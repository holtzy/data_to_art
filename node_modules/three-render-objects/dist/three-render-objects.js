// Version 1.40.4 three-render-objects - https://github.com/vasturiano/three-render-objects
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('three')) :
  typeof define === 'function' && define.amd ? define(['three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ThreeRenderObjects = factory(global.THREE));
})(this, (function (three$1) { 'use strict';

  function styleInject$1(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$1 = ".scene-nav-info {\n  position: absolute;\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n  font-family: sans-serif;\n  pointer-events: none;\n  user-select: none;\n}\n\n.scene-container canvas:focus {\n  outline: none;\n}";
  styleInject$1(css_248z$1);

  function _arrayLikeToArray$2(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles$2(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray$2(r);
  }
  function _defineProperty$1(e, r, t) {
    return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit$2(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = true,
        o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = true, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray$2(r, e) {
    return _arrayWithHoles$2(r) || _iterableToArrayLimit$2(r, e) || _unsupportedIterableToArray$2(r, e) || _nonIterableRest$2();
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$2(r) || _nonIterableSpread();
  }
  function _toPrimitive$1(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey$1(t) {
    var i = _toPrimitive$1(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray$2(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$2(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0;
    }
  }

  /**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = '178';

  /**
   * Disables face culling.
   *
   * @type {number}
   * @constant
   */
  const CullFaceNone = 0;

  /**
   * Culls back faces.
   *
   * @type {number}
   * @constant
   */
  const CullFaceBack = 1;

  /**
   * Culls front faces.
   *
   * @type {number}
   * @constant
   */
  const CullFaceFront = 2;

  /**
   * Gives unfiltered shadow maps - fastest, but lowest quality.
   *
   * @type {number}
   * @constant
   */
  const BasicShadowMap = 0;

  /**
   * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
   *
   * @type {number}
   * @constant
   */
  const PCFShadowMap = 1;

  /**
   * Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
   * When using VSMShadowMap all shadow receivers will also cast shadows.
   *
   * @type {number}
   * @constant
   */
  const VSMShadowMap = 3;

  /**
   * Only front faces are rendered.
   *
   * @type {number}
   * @constant
   */
  const FrontSide = 0;

  /**
   * Only back faces are rendered.
   *
   * @type {number}
   * @constant
   */
  const BackSide = 1;

  /**
   * Both front and back faces are rendered.
   *
   * @type {number}
   * @constant
   */
  const DoubleSide = 2;

  /**
   * No blending is performed which effectively disables
   * alpha transparency.
   *
   * @type {number}
   * @constant
   */
  const NoBlending = 0;

  /**
   * The default blending.
   *
   * @type {number}
   * @constant
   */
  const NormalBlending = 1;

  /**
   * Represents additive blending.
   *
   * @type {number}
   * @constant
   */
  const AdditiveBlending = 2;

  /**
   * Represents subtractive blending.
   *
   * @type {number}
   * @constant
   */
  const SubtractiveBlending = 3;

  /**
   * Represents multiply blending.
   *
   * @type {number}
   * @constant
   */
  const MultiplyBlending = 4;

  /**
   * Represents custom blending.
   *
   * @type {number}
   * @constant
   */
  const CustomBlending = 5;

  /**
   * A `source + destination` blending equation.
   *
   * @type {number}
   * @constant
   */
  const AddEquation = 100;

  /**
   * A `source - destination` blending equation.
   *
   * @type {number}
   * @constant
   */
  const SubtractEquation = 101;

  /**
   * A `destination - source` blending equation.
   *
   * @type {number}
   * @constant
   */
  const ReverseSubtractEquation = 102;

  /**
   * A blend equation that uses the minimum of source and destination.
   *
   * @type {number}
   * @constant
   */
  const MinEquation = 103;

  /**
   * A blend equation that uses the maximum of source and destination.
   *
   * @type {number}
   * @constant
   */
  const MaxEquation = 104;

  /**
   * Multiplies all colors by `0`.
   *
   * @type {number}
   * @constant
   */
  const ZeroFactor = 200;

  /**
   * Multiplies all colors by `1`.
   *
   * @type {number}
   * @constant
   */
  const OneFactor = 201;

  /**
   * Multiplies all colors by the source colors.
   *
   * @type {number}
   * @constant
   */
  const SrcColorFactor = 202;

  /**
   * Multiplies all colors by `1` minus each source color.
   *
   * @type {number}
   * @constant
   */
  const OneMinusSrcColorFactor = 203;

  /**
   * Multiplies all colors by the source alpha value.
   *
   * @type {number}
   * @constant
   */
  const SrcAlphaFactor = 204;

  /**
   * Multiplies all colors by 1 minus the source alpha value.
   *
   * @type {number}
   * @constant
   */
  const OneMinusSrcAlphaFactor = 205;

  /**
   * Multiplies all colors by the destination alpha value.
   *
   * @type {number}
   * @constant
   */
  const DstAlphaFactor = 206;

  /**
   * Multiplies all colors by `1` minus the destination alpha value.
   *
   * @type {number}
   * @constant
   */
  const OneMinusDstAlphaFactor = 207;

  /**
   * Multiplies all colors by the destination color.
   *
   * @type {number}
   * @constant
   */
  const DstColorFactor = 208;

  /**
   * Multiplies all colors by `1` minus each destination color.
   *
   * @type {number}
   * @constant
   */
  const OneMinusDstColorFactor = 209;

  /**
   * Multiplies the RGB colors by the smaller of either the source alpha
   * value or the value of `1` minus the destination alpha value. The alpha
   * value is multiplied by `1`.
   *
   * @type {number}
   * @constant
   */
  const SrcAlphaSaturateFactor = 210;

  /**
   * Never pass.
   *
   * @type {number}
   * @constant
   */
  const NeverDepth = 0;

  /**
   * Always pass.
   *
   * @type {number}
   * @constant
   */
  const AlwaysDepth = 1;

  /**
   * Pass if the incoming value is less than the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const LessDepth = 2;

  /**
   * Pass if the incoming value is less than or equal to the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const LessEqualDepth = 3;

  /**
   * Pass if the incoming value equals the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const EqualDepth = 4;

  /**
   * Pass if the incoming value is greater than or equal to the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const GreaterEqualDepth = 5;

  /**
   * Pass if the incoming value is greater than the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const GreaterDepth = 6;

  /**
   * Pass if the incoming value is not equal to the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const NotEqualDepth = 7;

  /**
   * Multiplies the environment map color with the surface color.
   *
   * @type {number}
   * @constant
   */
  const MultiplyOperation = 0;

  /**
   * Uses reflectivity to blend between the two colors.
   *
   * @type {number}
   * @constant
   */
  const MixOperation = 1;

  /**
   * Adds the two colors.
   *
   * @type {number}
   * @constant
   */
  const AddOperation = 2;

  /**
   * No tone mapping is applied.
   *
   * @type {number}
   * @constant
   */
  const NoToneMapping = 0;

  /**
   * Linear tone mapping.
   *
   * @type {number}
   * @constant
   */
  const LinearToneMapping = 1;

  /**
   * Reinhard tone mapping.
   *
   * @type {number}
   * @constant
   */
  const ReinhardToneMapping = 2;

  /**
   * Cineon tone mapping.
   *
   * @type {number}
   * @constant
   */
  const CineonToneMapping = 3;

  /**
   * ACES Filmic tone mapping.
   *
   * @type {number}
   * @constant
   */
  const ACESFilmicToneMapping = 4;

  /**
   * AgX tone mapping.
   *
   * @type {number}
   * @constant
   */
  const AgXToneMapping = 6;

  /**
   * Neutral tone mapping.
   *
   * Implementation based on the Khronos 3D Commerce Group standard tone mapping.
   *
   * @type {number}
   * @constant
   */
  const NeutralToneMapping = 7;

  /**
   * Maps textures using the geometry's UV coordinates.
   *
   * @type {number}
   * @constant
   */
  const UVMapping = 300;

  /**
   * Reflection mapping for cube textures.
   *
   * @type {number}
   * @constant
   */
  const CubeReflectionMapping = 301;

  /**
   * Refraction mapping for cube textures.
   *
   * @type {number}
   * @constant
   */
  const CubeRefractionMapping = 302;

  /**
   * Reflection mapping for equirectangular textures.
   *
   * @type {number}
   * @constant
   */
  const EquirectangularReflectionMapping = 303;

  /**
   * Refraction mapping for equirectangular textures.
   *
   * @type {number}
   * @constant
   */
  const EquirectangularRefractionMapping = 304;

  /**
   * Reflection mapping for PMREM textures.
   *
   * @type {number}
   * @constant
   */
  const CubeUVReflectionMapping = 306;

  /**
   * The texture will simply repeat to infinity.
   *
   * @type {number}
   * @constant
   */
  const RepeatWrapping = 1000;

  /**
   * The last pixel of the texture stretches to the edge of the mesh.
   *
   * @type {number}
   * @constant
   */
  const ClampToEdgeWrapping = 1001;

  /**
   * The texture will repeats to infinity, mirroring on each repeat.
   *
   * @type {number}
   * @constant
   */
  const MirroredRepeatWrapping = 1002;

  /**
   * Returns the value of the texture element that is nearest (in Manhattan distance)
   * to the specified texture coordinates.
   *
   * @type {number}
   * @constant
   */
  const NearestFilter = 1003;

  /**
   * Chooses the mipmap that most closely matches the size of the pixel being textured
   * and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
   * to produce a texture value.
   *
   * @type {number}
   * @constant
   */
  const NearestMipmapNearestFilter = 1004;

  /**
   * Chooses the two mipmaps that most closely match the size of the pixel being textured and
   * uses the `NearestFilter` criterion to produce a texture value from each mipmap.
   * The final texture value is a weighted average of those two values.
   *
   * @type {number}
   * @constant
   */
  const NearestMipmapLinearFilter = 1005;

  /**
   * Returns the weighted average of the four texture elements that are closest to the specified
   * texture coordinates, and can include items wrapped or repeated from other parts of a texture,
   * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
   *
   * @type {number}
   * @constant
   */
  const LinearFilter = 1006;

  /**
   * Chooses the mipmap that most closely matches the size of the pixel being textured and uses
   * the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
   * center of the pixel) to produce a texture value.
   *
   * @type {number}
   * @constant
   */
  const LinearMipmapNearestFilter = 1007;

  /**
   * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
   * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
   * is a weighted average of those two values.
   *
   * @type {number}
   * @constant
   */
  const LinearMipmapLinearFilter = 1008;

  /**
   * An unsigned byte data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedByteType = 1009;

  /**
   * A byte data type for textures.
   *
   * @type {number}
   * @constant
   */
  const ByteType = 1010;

  /**
   * A short data type for textures.
   *
   * @type {number}
   * @constant
   */
  const ShortType = 1011;

  /**
   * An unsigned short data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedShortType = 1012;

  /**
   * An int data type for textures.
   *
   * @type {number}
   * @constant
   */
  const IntType = 1013;

  /**
   * An unsigned int data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedIntType = 1014;

  /**
   * A float data type for textures.
   *
   * @type {number}
   * @constant
   */
  const FloatType = 1015;

  /**
   * A half float data type for textures.
   *
   * @type {number}
   * @constant
   */
  const HalfFloatType = 1016;

  /**
   * An unsigned short 4_4_4_4 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedShort4444Type = 1017;

  /**
   * An unsigned short 5_5_5_1 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedShort5551Type = 1018;

  /**
   * An unsigned int 24_8 data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedInt248Type = 1020;

  /**
   * An unsigned int 5_9_9_9 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedInt5999Type = 35902;

  /**
   * Discards the red, green and blue components and reads just the alpha component.
   *
   * @type {number}
   * @constant
   */
  const AlphaFormat = 1021;

  /**
   * Discards the alpha component and reads the red, green and blue component.
   *
   * @type {number}
   * @constant
   */
  const RGBFormat = 1022;

  /**
   * Reads the red, green, blue and alpha components.
   *
   * @type {number}
   * @constant
   */
  const RGBAFormat = 1023;

  /**
   * Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
   *
   * @type {number}
   * @constant
   */
  const DepthFormat = 1026;

  /**
   * Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
   * in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
   *
   * @type {number}
   * @constant
   */
  const DepthStencilFormat = 1027;

  /**
   * Discards the green, blue and alpha components and reads just the red component.
   *
   * @type {number}
   * @constant
   */
  const RedFormat = 1028;

  /**
   * Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RedIntegerFormat = 1029;

  /**
   * Discards the alpha, and blue components and reads the red, and green components.
   *
   * @type {number}
   * @constant
   */
  const RGFormat = 1030;

  /**
   * Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RGIntegerFormat = 1031;

  /**
   * Discards the alpha component and reads the red, green and blue component. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RGBIntegerFormat = 1032;

  /**
   * Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RGBAIntegerFormat = 1033;

  /**
   * A DXT1-compressed image in an RGB image format.
   *
   * @type {number}
   * @constant
   */
  const RGB_S3TC_DXT1_Format = 33776;

  /**
   * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
   *
   * @type {number}
   * @constant
   */
  const RGBA_S3TC_DXT1_Format = 33777;

  /**
   * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
   *
   * @type {number}
   * @constant
   */
  const RGBA_S3TC_DXT3_Format = 33778;

  /**
   * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
   * compression in how the alpha compression is done.
   *
   * @type {number}
   * @constant
   */
  const RGBA_S3TC_DXT5_Format = 33779;

  /**
   * PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGB_PVRTC_4BPPV1_Format = 35840;

  /**
   * PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGB_PVRTC_2BPPV1_Format = 35841;

  /**
   * PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGBA_PVRTC_4BPPV1_Format = 35842;

  /**
   * PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGBA_PVRTC_2BPPV1_Format = 35843;

  /**
   * ETC1 RGB format.
   *
   * @type {number}
   * @constant
   */
  const RGB_ETC1_Format = 36196;

  /**
   * ETC2 RGB format.
   *
   * @type {number}
   * @constant
   */
  const RGB_ETC2_Format = 37492;

  /**
   * ETC2 RGBA format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ETC2_EAC_Format = 37496;

  /**
   * ASTC RGBA 4x4 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_4x4_Format = 37808;

  /**
   * ASTC RGBA 5x4 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_5x4_Format = 37809;

  /**
   * ASTC RGBA 5x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_5x5_Format = 37810;

  /**
   * ASTC RGBA 6x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_6x5_Format = 37811;

  /**
   * ASTC RGBA 6x6 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_6x6_Format = 37812;

  /**
   * ASTC RGBA 8x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_8x5_Format = 37813;

  /**
   * ASTC RGBA 8x6 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_8x6_Format = 37814;

  /**
   * ASTC RGBA 8x8 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_8x8_Format = 37815;

  /**
   * ASTC RGBA 10x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x5_Format = 37816;

  /**
   * ASTC RGBA 10x6 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x6_Format = 37817;

  /**
   * ASTC RGBA 10x8 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x8_Format = 37818;

  /**
   * ASTC RGBA 10x10 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x10_Format = 37819;

  /**
   * ASTC RGBA 12x10 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_12x10_Format = 37820;

  /**
   * ASTC RGBA 12x12 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_12x12_Format = 37821;

  /**
   * BPTC RGBA format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_BPTC_Format = 36492;

  /**
   * RGTC1 Red format.
   *
   * @type {number}
   * @constant
   */
  const RED_RGTC1_Format = 36283;

  /**
   * RGTC1 Signed Red format.
   *
   * @type {number}
   * @constant
   */
  const SIGNED_RED_RGTC1_Format = 36284;

  /**
   * RGTC2 Red Green format.
   *
   * @type {number}
   * @constant
   */
  const RED_GREEN_RGTC2_Format = 36285;

  /**
   * RGTC2 Signed Red Green format.
   *
   * @type {number}
   * @constant
   */
  const SIGNED_RED_GREEN_RGTC2_Format = 36286;

  /**
   * Normal information is relative to the underlying surface.
   *
   * @type {number}
   * @constant
   */
  const TangentSpaceNormalMap = 0;

  /**
   * Normal information is relative to the object orientation.
   *
   * @type {number}
   * @constant
   */
  const ObjectSpaceNormalMap = 1;

  // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

  /**
   * No color space.
   *
   * @type {string}
   * @constant
   */
  const NoColorSpace = '';

  /**
   * sRGB color space.
   *
   * @type {string}
   * @constant
   */
  const SRGBColorSpace = 'srgb';

  /**
   * sRGB-linear color space.
   *
   * @type {string}
   * @constant
   */
  const LinearSRGBColorSpace = 'srgb-linear';

  /**
   * Linear transfer function.
   *
   * @type {string}
   * @constant
   */
  const LinearTransfer = 'linear';

  /**
   * sRGB transfer function.
   *
   * @type {string}
   * @constant
   */
  const SRGBTransfer = 'srgb';

  /**
   * Sets the stencil buffer value to `0`.
   *
   * @type {number}
   * @constant
   */
  const ZeroStencilOp = 0;

  /**
   * Keeps the current value.
   *
   * @type {number}
   * @constant
   */
  const KeepStencilOp = 7680;

  /**
   * Sets the stencil buffer value to the specified reference value.
   *
   * @type {number}
   * @constant
   */
  const ReplaceStencilOp = 7681;

  /**
   * Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
   *
   * @type {number}
   * @constant
   */
  const IncrementStencilOp = 7682;

  /**
   * Decrements the current stencil buffer value. Clamps to `0`.
   *
   * @type {number}
   * @constant
   */
  const DecrementStencilOp = 7683;

  /**
   * Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing
   * the maximum representable unsigned value.
   *
   * @type {number}
   * @constant
   */
  const IncrementWrapStencilOp = 34055;

  /**
   * Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable
   * unsigned value when decrementing a stencil buffer value of `0`.
   *
   * @type {number}
   * @constant
   */
  const DecrementWrapStencilOp = 34056;

  /**
   * Inverts the current stencil buffer value bitwise.
   *
   * @type {number}
   * @constant
   */
  const InvertStencilOp = 5386;

  /**
   * Will never return true.
   *
   * @type {number}
   * @constant
   */
  const NeverStencilFunc = 512;

  /**
   * Will return true if the stencil reference value is less than the current stencil value.
   *
   * @type {number}
   * @constant
   */
  const LessStencilFunc = 513;

  /**
   * Will return true if the stencil reference value is equal to the current stencil value.
   *
   * @type {number}
   * @constant
   */
  const EqualStencilFunc = 514;

  /**
   * Will return true if the stencil reference value is less than or equal to the current stencil value.
   *
   * @type {number}
   * @constant
   */
  const LessEqualStencilFunc = 515;

  /**
   * Will return true if the stencil reference value is greater than the current stencil value.
   *
   * @type {number}
   * @constant
   */
  const GreaterStencilFunc = 516;

  /**
   * Will return true if the stencil reference value is not equal to the current stencil value.
   *
   * @type {number}
   * @constant
   */
  const NotEqualStencilFunc = 517;

  /**
   * Will return true if the stencil reference value is greater than or equal to the current stencil value.
   *
   * @type {number}
   * @constant
   */
  const GreaterEqualStencilFunc = 518;

  /**
   * Will always return true.
   *
   * @type {number}
   * @constant
   */
  const AlwaysStencilFunc = 519;

  /**
   * Never pass.
   *
   * @type {number}
   * @constant
   */
  const NeverCompare = 512;

  /**
   * Pass if the incoming value is less than the texture value.
   *
   * @type {number}
   * @constant
   */
  const LessCompare = 513;

  /**
   * Pass if the incoming value equals the texture value.
   *
   * @type {number}
   * @constant
   */
  const EqualCompare = 514;

  /**
   * Pass if the incoming value is less than or equal to the texture value.
   *
   * @type {number}
   * @constant
   */
  const LessEqualCompare = 515;

  /**
   * Pass if the incoming value is greater than the texture value.
   *
   * @type {number}
   * @constant
   */
  const GreaterCompare = 516;

  /**
   * Pass if the incoming value is not equal to the texture value.
   *
   * @type {number}
   * @constant
   */
  const NotEqualCompare = 517;

  /**
   * Pass if the incoming value is greater than or equal to the texture value.
   *
   * @type {number}
   * @constant
   */
  const GreaterEqualCompare = 518;

  /**
   * Always pass.
   *
   * @type {number}
   * @constant
   */
  const AlwaysCompare = 519;

  /**
   * The contents are intended to be specified once by the application, and used many
   * times as the source for drawing and image specification commands.
   *
   * @type {number}
   * @constant
   */
  const StaticDrawUsage = 35044;

  /**
   * The contents are intended to be respecified repeatedly by the application, and
   * used many times as the source for drawing and image specification commands.
   *
   * @type {number}
   * @constant
   */
  const DynamicDrawUsage = 35048;

  /**
   * WebGL coordinate system.
   *
   * @type {number}
   * @constant
   */
  const WebGLCoordinateSystem = 2000;

  /**
   * WebGPU coordinate system.
   *
   * @type {number}
   * @constant
   */
  const WebGPUCoordinateSystem = 2001;

  /**
   * This type represents mouse buttons and interaction types in context of controls.
   *
   * @typedef {Object} ConstantsMouse
   * @property {number} MIDDLE - The left mouse button.
   * @property {number} LEFT - The middle mouse button.
   * @property {number} RIGHT - The right mouse button.
   * @property {number} ROTATE - A rotate interaction.
   * @property {number} DOLLY - A dolly interaction.
   * @property {number} PAN - A pan interaction.
   **/

  /**
   * This type represents touch interaction types in context of controls.
   *
   * @typedef {Object} ConstantsTouch
   * @property {number} ROTATE - A rotate interaction.
   * @property {number} PAN - A pan interaction.
   * @property {number} DOLLY_PAN - The dolly-pan interaction.
   * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
   **/

  /**
   * This type represents the different timestamp query types.
   *
   * @typedef {Object} ConstantsTimestampQuery
   * @property {string} COMPUTE - A `compute` timestamp query.
   * @property {string} RENDER - A `render` timestamp query.
   **/

  /**
   * Represents the different interpolation sampling types.
   *
   * @typedef {Object} ConstantsInterpolationSamplingType
   * @property {string} PERSPECTIVE - Perspective-correct interpolation.
   * @property {string} LINEAR - Linear interpolation.
   * @property {string} FLAT - Flat interpolation.
   */

  /**
   * Represents the different interpolation sampling modes.
   *
   * @typedef {Object} ConstantsInterpolationSamplingMode
   * @property {string} NORMAL - Normal sampling mode.
   * @property {string} CENTROID - Centroid sampling mode.
   * @property {string} SAMPLE - Sample-specific sampling mode.
   * @property {string} FLAT_FIRST - Flat interpolation using the first vertex.
   * @property {string} FLAT_EITHER - Flat interpolation using either vertex.
   */

  /**
   * This modules allows to dispatch event objects on custom JavaScript objects.
   *
   * Main repository: [eventdispatcher.js]{@link https://github.com/mrdoob/eventdispatcher.js/}
   *
   * Code Example:
   * ```js
   * class Car extends EventDispatcher {
   * 	start() {
   *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
   *	}
   *};
   *
   * // Using events with the custom object
   * const car = new Car();
   * car.addEventListener( 'start', function ( event ) {
   * 	alert( event.message );
   * } );
   *
   * car.start();
   * ```
   */
  class EventDispatcher {

  	/**
  	 * Adds the given event listener to the given event type.
  	 *
  	 * @param {string} type - The type of event to listen to.
  	 * @param {Function} listener - The function that gets called when the event is fired.
  	 */
  	addEventListener( type, listener ) {

  		if ( this._listeners === undefined ) this._listeners = {};

  		const listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === -1 ) {

  			listeners[ type ].push( listener );

  		}

  	}

  	/**
  	 * Returns `true` if the given event listener has been added to the given event type.
  	 *
  	 * @param {string} type - The type of event.
  	 * @param {Function} listener - The listener to check.
  	 * @return {boolean} Whether the given event listener has been added to the given event type.
  	 */
  	hasEventListener( type, listener ) {

  		const listeners = this._listeners;

  		if ( listeners === undefined ) return false;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;

  	}

  	/**
  	 * Removes the given event listener from the given event type.
  	 *
  	 * @param {string} type - The type of event.
  	 * @param {Function} listener - The listener to remove.
  	 */
  	removeEventListener( type, listener ) {

  		const listeners = this._listeners;

  		if ( listeners === undefined ) return;

  		const listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			const index = listenerArray.indexOf( listener );

  			if ( index !== -1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	}

  	/**
  	 * Dispatches an event object.
  	 *
  	 * @param {Object} event - The event that gets fired.
  	 */
  	dispatchEvent( event ) {

  		const listeners = this._listeners;

  		if ( listeners === undefined ) return;

  		const listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			// Make a copy, in case listeners are removed while iterating.
  			const array = listenerArray.slice( 0 );

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this, event );

  			}

  			event.target = null;

  		}

  	}

  }

  const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

  let _seed = 1234567;


  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @return {string} The UUID.
   */
  function generateUUID() {

  	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

  	const d0 = Math.random() * 0xffffffff | 0;
  	const d1 = Math.random() * 0xffffffff | 0;
  	const d2 = Math.random() * 0xffffffff | 0;
  	const d3 = Math.random() * 0xffffffff | 0;
  	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
  			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
  			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
  			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

  	// .toLowerCase() here flattens concatenated strings to save heap memory space.
  	return uuid.toLowerCase();

  }

  /**
   * Clamps the given value between min and max.
   *
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  function clamp$1( value, min, max ) {

  	return Math.max( min, Math.min( max, value ) );

  }

  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  function euclideanModulo( n, m ) {

  	// https://en.wikipedia.org/wiki/Modulo_operation

  	return ( ( n % m ) + m ) % m;

  }

  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  function mapLinear( x, a1, a2, b1, b2 ) {

  	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  }

  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  function inverseLerp( x, y, value ) {

  	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/

  	if ( x !== y ) {

  		return ( value - x ) / ( y - x );

  	} else {

  		return 0;

  	}

  }

  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  function lerp( x, y, t ) {

  	return ( 1 - t ) * x + t * y;

  }

  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  function damp( x, y, lambda, dt ) {

  	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

  }

  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  function pingpong( x, length = 1 ) {

  	// https://www.desmos.com/calculator/vcsjnyz7x4

  	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

  }

  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  function smoothstep$1( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * ( 3 - 2 * x );

  }

  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  function smootherstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  }

  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  function randInt( low, high ) {

  	return low + Math.floor( Math.random() * ( high - low + 1 ) );

  }

  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  function randFloat( low, high ) {

  	return low + Math.random() * ( high - low );

  }

  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  function randFloatSpread( range ) {

  	return range * ( 0.5 - Math.random() );

  }

  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  function seededRandom( s ) {

  	if ( s !== undefined ) _seed = s;

  	// Mulberry32 generator

  	let t = _seed += 0x6D2B79F5;

  	t = Math.imul( t ^ t >>> 15, t | 1 );

  	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

  	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

  }

  /**
   * Converts degrees to radians.
   *
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  function degToRad( degrees ) {

  	return degrees * DEG2RAD;

  }

  /**
   * Converts radians to degrees.
   *
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  function radToDeg( radians ) {

  	return radians * RAD2DEG;

  }

  /**
   * Returns `true` if the given number is a power of two.
   *
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  function isPowerOfTwo( value ) {

  	return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }

  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  function ceilPowerOfTwo( value ) {

  	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  }

  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  function floorPowerOfTwo( value ) {

  	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  }

  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  function setQuaternionFromProperEuler( q, a, b, c, order ) {

  	const cos = Math.cos;
  	const sin = Math.sin;

  	const c2 = cos( b / 2 );
  	const s2 = sin( b / 2 );

  	const c13 = cos( ( a + c ) / 2 );
  	const s13 = sin( ( a + c ) / 2 );

  	const c1_3 = cos( ( a - c ) / 2 );
  	const s1_3 = sin( ( a - c ) / 2 );

  	const c3_1 = cos( ( c - a ) / 2 );
  	const s3_1 = sin( ( c - a ) / 2 );

  	switch ( order ) {

  		case 'XYX':
  			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
  			break;

  		case 'YZY':
  			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
  			break;

  		case 'ZXZ':
  			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
  			break;

  		case 'XZX':
  			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
  			break;

  		case 'YXY':
  			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
  			break;

  		case 'ZYZ':
  			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
  			break;

  		default:
  			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

  	}

  }

  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  function denormalize( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return value / 4294967295.0;

  		case Uint16Array:

  			return value / 65535.0;

  		case Uint8Array:

  			return value / 255.0;

  		case Int32Array:

  			return Math.max( value / 2147483647.0, -1 );

  		case Int16Array:

  			return Math.max( value / 32767.0, -1 );

  		case Int8Array:

  			return Math.max( value / 127.0, -1 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  /**
   * Normalizes the given value according to the given typed array.
   *
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  function normalize$1( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return Math.round( value * 4294967295.0 );

  		case Uint16Array:

  			return Math.round( value * 65535.0 );

  		case Uint8Array:

  			return Math.round( value * 255.0 );

  		case Int32Array:

  			return Math.round( value * 2147483647.0 );

  		case Int16Array:

  			return Math.round( value * 32767.0 );

  		case Int8Array:

  			return Math.round( value * 127.0 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  /**
   * @class
   * @classdesc A collection of math utility functions.
   * @hideconstructor
   */
  const MathUtils = {
  	DEG2RAD: DEG2RAD,
  	RAD2DEG: RAD2DEG,
  	/**
  	 * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
  	 * (universally unique identifier).
  	 *
  	 * @static
  	 * @method
  	 * @return {string} The UUID.
  	 */
  	generateUUID: generateUUID,
  	/**
  	 * Clamps the given value between min and max.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to clamp.
  	 * @param {number} min - The min value.
  	 * @param {number} max - The max value.
  	 * @return {number} The clamped value.
  	 */
  	clamp: clamp$1,
  	/**
  	 * Computes the Euclidean modulo of the given parameters that
  	 * is `( ( n % m ) + m ) % m`.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} n - The first parameter.
  	 * @param {number} m - The second parameter.
  	 * @return {number} The Euclidean modulo.
  	 */
  	euclideanModulo: euclideanModulo,
  	/**
  	 * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
  	 * for the given value.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to be mapped.
  	 * @param {number} a1 - Minimum value for range A.
  	 * @param {number} a2 - Maximum value for range A.
  	 * @param {number} b1 - Minimum value for range B.
  	 * @param {number} b2 - Maximum value for range B.
  	 * @return {number} The mapped value.
  	 */
  	mapLinear: mapLinear,
  	/**
  	 * Returns the percentage in the closed interval `[0, 1]` of the given value
  	 * between the start and end point.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The start point
  	 * @param {number} y - The end point.
  	 * @param {number} value - A value between start and end.
  	 * @return {number} The interpolation factor.
  	 */
  	inverseLerp: inverseLerp,
  	/**
  	 * Returns a value linearly interpolated from two known points based on the given interval -
  	 * `t = 0` will return `x` and `t = 1` will return `y`.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The start point
  	 * @param {number} y - The end point.
  	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
  	 * @return {number} The interpolated value.
  	 */
  	lerp: lerp,
  	/**
  	 * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
  	 * time to maintain frame rate independent movement. For details, see
  	 * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The current point.
  	 * @param {number} y - The target point.
  	 * @param {number} lambda - A higher lambda value will make the movement more sudden,
  	 * and a lower value will make the movement more gradual.
  	 * @param {number} dt - Delta time in seconds.
  	 * @return {number} The interpolated value.
  	 */
  	damp: damp,
  	/**
  	 * Returns a value that alternates between `0` and the given `length` parameter.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to pingpong.
  	 * @param {number} [length=1] - The positive value the function will pingpong to.
  	 * @return {number} The alternated value.
  	 */
  	pingpong: pingpong,
  	/**
  	 * Returns a value in the range `[0,1]` that represents the percentage that `x` has
  	 * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
  	 * the `min` and `max`.
  	 *
  	 * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to evaluate based on its position between min and max.
  	 * @param {number} min - The min value. Any x value below min will be `0`.
  	 * @param {number} max - The max value. Any x value above max will be `1`.
  	 * @return {number} The alternated value.
  	 */
  	smoothstep: smoothstep$1,
  	/**
  	 * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
  	 * that has zero 1st and 2nd order derivatives at x=0 and x=1.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to evaluate based on its position between min and max.
  	 * @param {number} min - The min value. Any x value below min will be `0`.
  	 * @param {number} max - The max value. Any x value above max will be `1`.
  	 * @return {number} The alternated value.
  	 */
  	smootherstep: smootherstep,
  	/**
  	 * Returns a random integer from `<low, high>` interval.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} low - The lower value boundary.
  	 * @param {number} high - The upper value boundary
  	 * @return {number} A random integer.
  	 */
  	randInt: randInt,
  	/**
  	 * Returns a random float from `<low, high>` interval.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} low - The lower value boundary.
  	 * @param {number} high - The upper value boundary
  	 * @return {number} A random float.
  	 */
  	randFloat: randFloat,
  	/**
  	 * Returns a random integer from `<-range/2, range/2>` interval.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} range - Defines the value range.
  	 * @return {number} A random float.
  	 */
  	randFloatSpread: randFloatSpread,
  	/**
  	 * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} [s] - The integer seed.
  	 * @return {number} A random float.
  	 */
  	seededRandom: seededRandom,
  	/**
  	 * Converts degrees to radians.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} degrees - A value in degrees.
  	 * @return {number} The converted value in radians.
  	 */
  	degToRad: degToRad,
  	/**
  	 * Converts radians to degrees.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} radians - A value in radians.
  	 * @return {number} The converted value in degrees.
  	 */
  	radToDeg: radToDeg,
  	/**
  	 * Returns `true` if the given number is a power of two.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to check.
  	 * @return {boolean} Whether the given number is a power of two or not.
  	 */
  	isPowerOfTwo: isPowerOfTwo,
  	/**
  	 * Returns the smallest power of two that is greater than or equal to the given number.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to find a POT for.
  	 * @return {number} The smallest power of two that is greater than or equal to the given number.
  	 */
  	ceilPowerOfTwo: ceilPowerOfTwo,
  	/**
  	 * Returns the largest power of two that is less than or equal to the given number.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to find a POT for.
  	 * @return {number} The largest power of two that is less than or equal to the given number.
  	 */
  	floorPowerOfTwo: floorPowerOfTwo,
  	/**
  	 * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
  	 * defined by the given angles and order.
  	 *
  	 * Rotations are applied to the axes in the order specified by order:
  	 * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
  	 *
  	 * @static
  	 * @method
  	 * @param {Quaternion} q - The quaternion to set.
  	 * @param {number} a - The rotation applied to the first axis, in radians.
  	 * @param {number} b - The rotation applied to the second axis, in radians.
  	 * @param {number} c - The rotation applied to the third axis, in radians.
  	 * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
  	 */
  	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  	/**
  	 * Normalizes the given value according to the given typed array.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The float value in the range `[0,1]` to normalize.
  	 * @param {TypedArray} array - The typed array that defines the data type of the value.
  	 * @return {number} The normalize value.
  	 */
  	normalize: normalize$1,
  	/**
  	 * Denormalizes the given value according to the given typed array.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to denormalize.
  	 * @param {TypedArray} array - The typed array that defines the data type of the value.
  	 * @return {number} The denormalize (float) value in the range `[0,1]`.
  	 */
  	denormalize: denormalize
  };

  /**
   * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
   * (labeled x and y), which can be used to represent a number of things, such as:
   *
   * - A point in 2D space (i.e. a position on a plane).
   * - A direction and length across a plane. In three.js the length will
   * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
   * and the direction is also measured from `(0, 0)` towards `(x, y)`.
   * - Any arbitrary ordered pair of numbers.
   *
   * There are other things a 2D vector can be used to represent, such as
   * momentum vectors, complex numbers and so on, however these are the most
   * common uses in three.js.
   *
   * Iterating through a vector instance will yield its components `(x, y)` in
   * the corresponding order.
   * ```js
   * const a = new THREE.Vector2( 0, 1 );
   *
   * //no arguments; will be initialised to (0, 0)
   * const b = new THREE.Vector2( );
   *
   * const d = a.distanceTo( b );
   * ```
   */
  class Vector2 {

  	/**
  	 * Constructs a new 2D vector.
  	 *
  	 * @param {number} [x=0] - The x value of this vector.
  	 * @param {number} [y=0] - The y value of this vector.
  	 */
  	constructor( x = 0, y = 0 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Vector2.prototype.isVector2 = true;

  		/**
  		 * The x value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.x = x;

  		/**
  		 * The y value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.y = y;

  	}

  	/**
  	 * Alias for {@link Vector2#x}.
  	 *
  	 * @type {number}
  	 */
  	get width() {

  		return this.x;

  	}

  	set width( value ) {

  		this.x = value;

  	}

  	/**
  	 * Alias for {@link Vector2#y}.
  	 *
  	 * @type {number}
  	 */
  	get height() {

  		return this.y;

  	}

  	set height( value ) {

  		this.y = value;

  	}

  	/**
  	 * Sets the vector components.
  	 *
  	 * @param {number} x - The value of the x component.
  	 * @param {number} y - The value of the y component.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	set( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	}

  	/**
  	 * Sets the vector components to the same value.
  	 *
  	 * @param {number} scalar - The value to set for all vector components.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	}

  	/**
  	 * Sets the vector's x component to the given value
  	 *
  	 * @param {number} x - The value to set.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	/**
  	 * Sets the vector's y component to the given value
  	 *
  	 * @param {number} y - The value to set.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	/**
  	 * Allows to set a vector component with an index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
  	 * @param {number} value - The value to set.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	/**
  	 * Returns the value of the vector component which matches the given index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
  	 * @return {number} A vector component value.
  	 */
  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	/**
  	 * Returns a new vector with copied values from this instance.
  	 *
  	 * @return {Vector2} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.x, this.y );

  	}

  	/**
  	 * Copies the values of the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to copy.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	}

  	/**
  	 * Adds the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to add.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to all components of this instance.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	addScalar( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	}

  	/**
  	 * Adds the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector2} a - The first vector.
  	 * @param {Vector2} b - The second vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	}

  	/**
  	 * Adds the given vector scaled by the given factor to this instance.
  	 *
  	 * @param {Vector2} v - The vector.
  	 * @param {number} s - The factor that scales `v`.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vector from this instance.
  	 *
  	 * @param {Vector2} v - The vector to subtract.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	}

  	/**
  	 * Subtracts the given scalar value from all components of this instance.
  	 *
  	 * @param {number} s - The scalar to subtract.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector2} a - The first vector.
  	 * @param {Vector2} b - The second vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	}

  	/**
  	 * Multiplies the given vector with this instance.
  	 *
  	 * @param {Vector2} v - The vector to multiply.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with all components of this instance.
  	 *
  	 * @param {number} scalar - The scalar to multiply.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	}

  	/**
  	 * Divides this instance by the given vector.
  	 *
  	 * @param {Vector2} v - The vector to divide.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	}

  	/**
  	 * Divides this vector by the given scalar.
  	 *
  	 * @param {number} scalar - The scalar to divide.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	/**
  	 * Multiplies this vector (with an implicit 1 as the 3rd component) by
  	 * the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix to apply.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	applyMatrix3( m ) {

  		const x = this.x, y = this.y;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	}

  	/**
  	 * If this vector's x or y value is greater than the given vector's x or y
  	 * value, replace that value with the corresponding min value.
  	 *
  	 * @param {Vector2} v - The vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	}

  	/**
  	 * If this vector's x or y value is less than the given vector's x or y
  	 * value, replace that value with the corresponding max value.
  	 *
  	 * @param {Vector2} v - The vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	}

  	/**
  	 * If this vector's x or y value is greater than the max vector's x or y
  	 * value, it is replaced by the corresponding value.
  	 * If this vector's x or y value is less than the min vector's x or y value,
  	 * it is replaced by the corresponding value.
  	 *
  	 * @param {Vector2} min - The minimum x and y values.
  	 * @param {Vector2} max - The maximum x and y values in the desired range.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = clamp$1( this.x, min.x, max.x );
  		this.y = clamp$1( this.y, min.y, max.y );

  		return this;

  	}

  	/**
  	 * If this vector's x or y values are greater than the max value, they are
  	 * replaced by the max value.
  	 * If this vector's x or y values are less than the min value, they are
  	 * replaced by the min value.
  	 *
  	 * @param {number} minVal - The minimum value the components will be clamped to.
  	 * @param {number} maxVal - The maximum value the components will be clamped to.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	clampScalar( minVal, maxVal ) {

  		this.x = clamp$1( this.x, minVal, maxVal );
  		this.y = clamp$1( this.y, minVal, maxVal );

  		return this;

  	}

  	/**
  	 * If this vector's length is greater than the max value, it is replaced by
  	 * the max value.
  	 * If this vector's length is less than the min value, it is replaced by the
  	 * min value.
  	 *
  	 * @param {number} min - The minimum value the vector length will be clamped to.
  	 * @param {number} max - The maximum value the vector length will be clamped to.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( clamp$1( length, min, max ) );

  	}

  	/**
  	 * The components of this vector are rounded down to the nearest integer value.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded up to the nearest integer value.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded to the nearest integer value
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded towards zero (up if negative,
  	 * down if positive) to an integer value.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );

  		return this;

  	}

  	/**
  	 * Inverts this vector - i.e. sets x = -x and y = -y.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	}

  	/**
  	 * Calculates the dot product of the given vector with this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this.x * v.x + this.y * v.y;

  	}

  	/**
  	 * Calculates the cross product of the given vector with this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the cross product with.
  	 * @return {number} The result of the cross product.
  	 */
  	cross( v ) {

  		return this.x * v.y - this.y * v.x;

  	}

  	/**
  	 * Computes the square of the Euclidean length (straight-line length) from
  	 * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
  	 * compare the length squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @return {number} The square length of this vector.
  	 */
  	lengthSq() {

  		return this.x * this.x + this.y * this.y;

  	}

  	/**
  	 * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	}

  	/**
  	 * Computes the Manhattan length of this vector.
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	}

  	/**
  	 * Converts this vector to a unit vector - that is, sets it equal to a vector
  	 * with the same direction as this one, but with a vector length of `1`.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	/**
  	 * Computes the angle in radians of this vector with respect to the positive x-axis.
  	 *
  	 * @return {number} The angle in radians.
  	 */
  	angle() {

  		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

  		return angle;

  	}

  	/**
  	 * Returns the angle between the given vector and this instance in radians.
  	 *
  	 * @param {Vector2} v - The vector to compute the angle with.
  	 * @return {number} The angle in radians.
  	 */
  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp$1( theta, -1, 1 ) );

  	}

  	/**
  	 * Computes the distance from the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the distance to.
  	 * @return {number} The distance.
  	 */
  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	/**
  	 * Computes the squared distance from the given vector to this instance.
  	 * If you are just comparing the distance with another distance, you should compare
  	 * the distance squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @param {Vector2} v - The vector to compute the squared distance to.
  	 * @return {number} The squared distance.
  	 */
  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	}

  	/**
  	 * Computes the Manhattan distance from the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the Manhattan distance to.
  	 * @return {number} The Manhattan distance.
  	 */
  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	}

  	/**
  	 * Sets this vector to a vector with the same direction as this one, but
  	 * with the specified length.
  	 *
  	 * @param {number} length - The new length of this vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	/**
  	 * Linearly interpolates between the given vector and this instance, where
  	 * alpha is the percent distance along the line - alpha = 0 will be this
  	 * vector, and alpha = 1 will be the given one.
  	 *
  	 * @param {Vector2} v - The vector to interpolate towards.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given vectors, where alpha is the percent
  	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
  	 * be the second one. The result is stored in this instance.
  	 *
  	 * @param {Vector2} v1 - The first vector.
  	 * @param {Vector2} v2 - The second vector.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;

  		return this;

  	}

  	/**
  	 * Returns `true` if this vector is equal with the given one.
  	 *
  	 * @param {Vector2} v - The vector to test for equality.
  	 * @return {boolean} Whether this vector is equal with the given one.
  	 */
  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	}

  	/**
  	 * Sets this vector's x value to be `array[ offset ]` and y
  	 * value to be `array[ offset + 1 ]`.
  	 *
  	 * @param {Array<number>} array - An array holding the vector component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	}

  	/**
  	 * Writes the components of this vector to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The vector components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	}

  	/**
  	 * Sets the components of this vector from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	}

  	/**
  	 * Rotates this vector around the given center by the given angle.
  	 *
  	 * @param {Vector2} center - The point around which to rotate.
  	 * @param {number} angle - The angle to rotate, in radians.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	rotateAround( center, angle ) {

  		const c = Math.cos( angle ), s = Math.sin( angle );

  		const x = this.x - center.x;
  		const y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  	/**
  	 * Sets each component of this vector to a pseudo-random value between `0` and
  	 * `1`, excluding `1`.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	random() {

  		this.x = Math.random();
  		this.y = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;

  	}

  }

  /**
   * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
   *
   * Iterating through a vector instance will yield its components `(x, y, z, w)` in
   * the corresponding order.
   *
   * Note that three.js expects Quaternions to be normalized.
   * ```js
   * const quaternion = new THREE.Quaternion();
   * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
   *
   * const vector = new THREE.Vector3( 1, 0, 0 );
   * vector.applyQuaternion( quaternion );
   * ```
   */
  class Quaternion {

  	/**
  	 * Constructs a new quaternion.
  	 *
  	 * @param {number} [x=0] - The x value of this quaternion.
  	 * @param {number} [y=0] - The y value of this quaternion.
  	 * @param {number} [z=0] - The z value of this quaternion.
  	 * @param {number} [w=1] - The w value of this quaternion.
  	 */
  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isQuaternion = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  	}

  	/**
  	 * Interpolates between two quaternions via SLERP. This implementation assumes the
  	 * quaternion data are managed  in flat arrays.
  	 *
  	 * @param {Array<number>} dst - The destination array.
  	 * @param {number} dstOffset - An offset into the destination array.
  	 * @param {Array<number>} src0 - The source array of the first quaternion.
  	 * @param {number} srcOffset0 - An offset into the first source array.
  	 * @param {Array<number>} src1 -  The source array of the second quaternion.
  	 * @param {number} srcOffset1 - An offset into the second source array.
  	 * @param {number} t - The interpolation factor in the range `[0,1]`.
  	 * @see {@link Quaternion#slerp}
  	 */
  	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		let x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( t === 0 ) {

  			dst[ dstOffset + 0 ] = x0;
  			dst[ dstOffset + 1 ] = y0;
  			dst[ dstOffset + 2 ] = z0;
  			dst[ dstOffset + 3 ] = w0;
  			return;

  		}

  		if ( t === 1 ) {

  			dst[ dstOffset + 0 ] = x1;
  			dst[ dstOffset + 1 ] = y1;
  			dst[ dstOffset + 2 ] = z1;
  			dst[ dstOffset + 3 ] = w1;
  			return;

  		}

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			let s = 1 - t;
  			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
  				dir = ( cos >= 0 ? 1 : -1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				const sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			const tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  	/**
  	 * Multiplies two quaternions. This implementation assumes the quaternion data are managed
  	 * in flat arrays.
  	 *
  	 * @param {Array<number>} dst - The destination array.
  	 * @param {number} dstOffset - An offset into the destination array.
  	 * @param {Array<number>} src0 - The source array of the first quaternion.
  	 * @param {number} srcOffset0 - An offset into the first source array.
  	 * @param {Array<number>} src1 -  The source array of the second quaternion.
  	 * @param {number} srcOffset1 - An offset into the second source array.
  	 * @return {Array<number>} The destination array.
  	 * @see {@link Quaternion#multiplyQuaternions}.
  	 */
  	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

  		const x0 = src0[ srcOffset0 ];
  		const y0 = src0[ srcOffset0 + 1 ];
  		const z0 = src0[ srcOffset0 + 2 ];
  		const w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 ];
  		const y1 = src1[ srcOffset1 + 1 ];
  		const z1 = src1[ srcOffset1 + 2 ];
  		const w1 = src1[ srcOffset1 + 3 ];

  		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
  		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
  		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
  		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

  		return dst;

  	}

  	/**
  	 * The x value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The y value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The z value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The w value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 1
  	 */
  	get w() {

  		return this._w;

  	}

  	set w( value ) {

  		this._w = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * Sets the quaternion components.
  	 *
  	 * @param {number} x - The x value of this quaternion.
  	 * @param {number} y - The y value of this quaternion.
  	 * @param {number} z - The z value of this quaternion.
  	 * @param {number} w - The w value of this quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	set( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Returns a new quaternion with copied values from this instance.
  	 *
  	 * @return {Quaternion} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	}

  	/**
  	 * Copies the values of the given quaternion to this instance.
  	 *
  	 * @param {Quaternion} quaternion - The quaternion to copy.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	copy( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion from the rotation specified by the given
  	 * Euler angles.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromEuler( euler, update = true ) {

  		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		const cos = Math.cos;
  		const sin = Math.sin;

  		const c1 = cos( x / 2 );
  		const c2 = cos( y / 2 );
  		const c3 = cos( z / 2 );

  		const s1 = sin( x / 2 );
  		const s2 = sin( y / 2 );
  		const s3 = sin( z / 2 );

  		switch ( order ) {

  			case 'XYZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'YXZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'ZXY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'ZYX':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'YZX':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'XZY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			default:
  				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

  		}

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion from the given axis and angle.
  	 *
  	 * @param {Vector3} axis - The normalized axis.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromAxisAngle( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		const halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion from the given rotation matrix.
  	 *
  	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33;

  		if ( trace > 0 ) {

  			const s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion to the rotation required to rotate the direction vector
  	 * `vFrom` to the direction vector `vTo`.
  	 *
  	 * @param {Vector3} vFrom - The first (normalized) direction vector.
  	 * @param {Vector3} vTo - The second (normalized) direction vector.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromUnitVectors( vFrom, vTo ) {

  		// assumes direction vectors vFrom and vTo are normalized

  		let r = vFrom.dot( vTo ) + 1;

  		if ( r < 1e-8 ) { // the epsilon value has been discussed in #31286

  			// vFrom and vTo point in opposite directions

  			r = 0;

  			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  				this._x = - vFrom.y;
  				this._y = vFrom.x;
  				this._z = 0;
  				this._w = r;

  			} else {

  				this._x = 0;
  				this._y = - vFrom.z;
  				this._z = vFrom.y;
  				this._w = r;

  			}

  		} else {

  			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

  			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
  			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
  			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
  			this._w = r;

  		}

  		return this.normalize();

  	}

  	/**
  	 * Returns the angle between this quaternion and the given one in radians.
  	 *
  	 * @param {Quaternion} q - The quaternion to compute the angle with.
  	 * @return {number} The angle in radians.
  	 */
  	angleTo( q ) {

  		return 2 * Math.acos( Math.abs( clamp$1( this.dot( q ), -1, 1 ) ) );

  	}

  	/**
  	 * Rotates this quaternion by a given angular step to the given quaternion.
  	 * The method ensures that the final quaternion will not overshoot `q`.
  	 *
  	 * @param {Quaternion} q - The target quaternion.
  	 * @param {number} step - The angular step in radians.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	rotateTowards( q, step ) {

  		const angle = this.angleTo( q );

  		if ( angle === 0 ) return this;

  		const t = Math.min( 1, step / angle );

  		this.slerp( q, t );

  		return this;

  	}

  	/**
  	 * Sets this quaternion to the identity quaternion; that is, to the
  	 * quaternion that represents "no rotation".
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	identity() {

  		return this.set( 0, 0, 0, 1 );

  	}

  	/**
  	 * Inverts this quaternion via {@link Quaternion#conjugate}. The
  	 * quaternion is assumed to have unit length.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	invert() {

  		return this.conjugate();

  	}

  	/**
  	 * Returns the rotational conjugate of this quaternion. The conjugate of a
  	 * quaternion represents the same rotation in the opposite direction about
  	 * the rotational axis.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	conjugate() {

  		this._x *= -1;
  		this._y *= -1;
  		this._z *= -1;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Calculates the dot product of this quaternion and the given one.
  	 *
  	 * @param {Quaternion} v - The quaternion to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	}

  	/**
  	 * Computes the squared Euclidean length (straight-line length) of this quaternion,
  	 * considered as a 4 dimensional vector. This can be useful if you are comparing the
  	 * lengths of two quaternions, as this is a slightly more efficient calculation than
  	 * {@link Quaternion#length}.
  	 *
  	 * @return {number} The squared Euclidean length.
  	 */
  	lengthSq() {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	}

  	/**
  	 * Computes the Euclidean length (straight-line length) of this quaternion,
  	 * considered as a 4 dimensional vector.
  	 *
  	 * @return {number} The Euclidean length.
  	 */
  	length() {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	}

  	/**
  	 * Normalizes this quaternion - that is, calculated the quaternion that performs
  	 * the same rotation as this one, but has a length equal to `1`.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	normalize() {

  		let l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Multiplies this quaternion by the given one.
  	 *
  	 * @param {Quaternion} q - The quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	multiply( q ) {

  		return this.multiplyQuaternions( this, q );

  	}

  	/**
  	 * Pre-multiplies this quaternion by the given one.
  	 *
  	 * @param {Quaternion} q - The quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	premultiply( q ) {

  		return this.multiplyQuaternions( q, this );

  	}

  	/**
  	 * Multiplies the given quaternions and stores the result in this instance.
  	 *
  	 * @param {Quaternion} a - The first quaternion.
  	 * @param {Quaternion} b - The second quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	multiplyQuaternions( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Performs a spherical linear interpolation between quaternions.
  	 *
  	 * @param {Quaternion} qb - The target quaternion.
  	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	slerp( qb, t ) {

  		if ( t === 0 ) return this;
  		if ( t === 1 ) return this.copy( qb );

  		const x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  		if ( sqrSinHalfTheta <= Number.EPSILON ) {

  			const s = 1 - t;
  			this._w = s * w + t * this._w;
  			this._x = s * x + t * this._x;
  			this._y = s * y + t * this._y;
  			this._z = s * z + t * this._z;

  			this.normalize(); // normalize calls _onChangeCallback()

  			return this;

  		}

  		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Performs a spherical linear interpolation between the given quaternions
  	 * and stores the result in this quaternion.
  	 *
  	 * @param {Quaternion} qa - The source quaternion.
  	 * @param {Quaternion} qb - The target quaternion.
  	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	slerpQuaternions( qa, qb, t ) {

  		return this.copy( qa ).slerp( qb, t );

  	}

  	/**
  	 * Sets this quaternion to a uniformly random, normalized quaternion.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	random() {

  		// Ken Shoemake
  		// Uniform random rotations
  		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

  		const theta1 = 2 * Math.PI * Math.random();
  		const theta2 = 2 * Math.PI * Math.random();

  		const x0 = Math.random();
  		const r1 = Math.sqrt( 1 - x0 );
  		const r2 = Math.sqrt( x0 );

  		return this.set(
  			r1 * Math.sin( theta1 ),
  			r1 * Math.cos( theta1 ),
  			r2 * Math.sin( theta2 ),
  			r2 * Math.cos( theta2 ),
  		);

  	}

  	/**
  	 * Returns `true` if this quaternion is equal with the given one.
  	 *
  	 * @param {Quaternion} quaternion - The quaternion to test for equality.
  	 * @return {boolean} Whether this quaternion is equal with the given one.
  	 */
  	equals( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	}

  	/**
  	 * Sets this quaternion's components from the given array.
  	 *
  	 * @param {Array<number>} array - An array holding the quaternion component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	fromArray( array, offset = 0 ) {

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Writes the components of this quaternion to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The quaternion components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	}

  	/**
  	 * Sets the components of this quaternion from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this._x = attribute.getX( index );
  		this._y = attribute.getY( index );
  		this._z = attribute.getZ( index );
  		this._w = attribute.getW( index );

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * This methods defines the serialization result of this class. Returns the
  	 * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
  	 *
  	 * @return {Array<number>} The serialized quaternion.
  	 */
  	toJSON() {

  		return this.toArray();

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._w;

  	}

  }

  /**
   * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
   * (labeled x, y and z), which can be used to represent a number of things, such as:
   *
   * - A point in 3D space.
   * - A direction and length in 3D space. In three.js the length will
   * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
   * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
   * - Any arbitrary ordered triplet of numbers.
   *
   * There are other things a 3D vector can be used to represent, such as
   * momentum vectors and so on, however these are the most
   * common uses in three.js.
   *
   * Iterating through a vector instance will yield its components `(x, y, z)` in
   * the corresponding order.
   * ```js
   * const a = new THREE.Vector3( 0, 1, 0 );
   *
   * //no arguments; will be initialised to (0, 0, 0)
   * const b = new THREE.Vector3( );
   *
   * const d = a.distanceTo( b );
   * ```
   */
  class Vector3 {

  	/**
  	 * Constructs a new 3D vector.
  	 *
  	 * @param {number} [x=0] - The x value of this vector.
  	 * @param {number} [y=0] - The y value of this vector.
  	 * @param {number} [z=0] - The z value of this vector.
  	 */
  	constructor( x = 0, y = 0, z = 0 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Vector3.prototype.isVector3 = true;

  		/**
  		 * The x value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.x = x;

  		/**
  		 * The y value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.y = y;

  		/**
  		 * The z value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.z = z;

  	}

  	/**
  	 * Sets the vector components.
  	 *
  	 * @param {number} x - The value of the x component.
  	 * @param {number} y - The value of the y component.
  	 * @param {number} z - The value of the z component.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	set( x, y, z ) {

  		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	}

  	/**
  	 * Sets the vector components to the same value.
  	 *
  	 * @param {number} scalar - The value to set for all vector components.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	}

  	/**
  	 * Sets the vector's x component to the given value
  	 *
  	 * @param {number} x - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	/**
  	 * Sets the vector's y component to the given value
  	 *
  	 * @param {number} y - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	/**
  	 * Sets the vector's z component to the given value
  	 *
  	 * @param {number} z - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	/**
  	 * Allows to set a vector component with an index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
  	 * @param {number} value - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	/**
  	 * Returns the value of the vector component which matches the given index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
  	 * @return {number} A vector component value.
  	 */
  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	/**
  	 * Returns a new vector with copied values from this instance.
  	 *
  	 * @return {Vector3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.x, this.y, this.z );

  	}

  	/**
  	 * Copies the values of the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to copy.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	}

  	/**
  	 * Adds the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to add.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to all components of this instance.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	}

  	/**
  	 * Adds the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	}

  	/**
  	 * Adds the given vector scaled by the given factor to this instance.
  	 *
  	 * @param {Vector3|Vector4} v - The vector.
  	 * @param {number} s - The factor that scales `v`.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vector from this instance.
  	 *
  	 * @param {Vector3} v - The vector to subtract.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	}

  	/**
  	 * Subtracts the given scalar value from all components of this instance.
  	 *
  	 * @param {number} s - The scalar to subtract.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	}

  	/**
  	 * Multiplies the given vector with this instance.
  	 *
  	 * @param {Vector3} v - The vector to multiply.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with all components of this instance.
  	 *
  	 * @param {number} scalar - The scalar to multiply.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	}

  	/**
  	 * Multiplies the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	multiplyVectors( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	}

  	/**
  	 * Applies the given Euler rotation to this vector.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyEuler( euler ) {

  		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

  	}

  	/**
  	 * Applies a rotation specified by an axis and an angle to this vector.
  	 *
  	 * @param {Vector3} axis - A normalized vector representing the rotation axis.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyAxisAngle( axis, angle ) {

  		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

  	}

  	/**
  	 * Multiplies this vector with the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The 3x3 matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyMatrix3( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	}

  	/**
  	 * Multiplies this vector by the given normal matrix and normalizes
  	 * the result.
  	 *
  	 * @param {Matrix3} m - The normal matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyNormalMatrix( m ) {

  		return this.applyMatrix3( m ).normalize();

  	}

  	/**
  	 * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
  	 * divides by perspective.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	}

  	/**
  	 * Applies the given Quaternion to this vector.
  	 *
  	 * @param {Quaternion} q - The Quaternion.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyQuaternion( q ) {

  		// quaternion q is assumed to have unit length

  		const vx = this.x, vy = this.y, vz = this.z;
  		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// t = 2 * cross( q.xyz, v );
  		const tx = 2 * ( qy * vz - qz * vy );
  		const ty = 2 * ( qz * vx - qx * vz );
  		const tz = 2 * ( qx * vy - qy * vx );

  		// v + q.w * t + cross( q.xyz, t );
  		this.x = vx + qw * tx + qy * tz - qz * ty;
  		this.y = vy + qw * ty + qz * tx - qx * tz;
  		this.z = vz + qw * tz + qx * ty - qy * tx;

  		return this;

  	}

  	/**
  	 * Projects this vector from world space into the camera's normalized
  	 * device coordinate (NDC) space.
  	 *
  	 * @param {Camera} camera - The camera.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	project( camera ) {

  		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  	}

  	/**
  	 * Unprojects this vector from the camera's normalized device coordinate (NDC)
  	 * space into world space.
  	 *
  	 * @param {Camera} camera - The camera.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	unproject( camera ) {

  		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

  	}

  	/**
  	 * Transforms the direction of this vector by a matrix (the upper left 3 x 3
  	 * subset of the given 4x4 matrix and then normalizes the result.
  	 *
  	 * @param {Matrix4} m - The matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	transformDirection( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	}

  	/**
  	 * Divides this instance by the given vector.
  	 *
  	 * @param {Vector3} v - The vector to divide.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	}

  	/**
  	 * Divides this vector by the given scalar.
  	 *
  	 * @param {number} scalar - The scalar to divide.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	/**
  	 * If this vector's x, y or z value is greater than the given vector's x, y or z
  	 * value, replace that value with the corresponding min value.
  	 *
  	 * @param {Vector3} v - The vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	}

  	/**
  	 * If this vector's x, y or z value is less than the given vector's x, y or z
  	 * value, replace that value with the corresponding max value.
  	 *
  	 * @param {Vector3} v - The vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	}

  	/**
  	 * If this vector's x, y or z value is greater than the max vector's x, y or z
  	 * value, it is replaced by the corresponding value.
  	 * If this vector's x, y or z value is less than the min vector's x, y or z value,
  	 * it is replaced by the corresponding value.
  	 *
  	 * @param {Vector3} min - The minimum x, y and z values.
  	 * @param {Vector3} max - The maximum x, y and z values in the desired range.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = clamp$1( this.x, min.x, max.x );
  		this.y = clamp$1( this.y, min.y, max.y );
  		this.z = clamp$1( this.z, min.z, max.z );

  		return this;

  	}

  	/**
  	 * If this vector's x, y or z values are greater than the max value, they are
  	 * replaced by the max value.
  	 * If this vector's x, y or z values are less than the min value, they are
  	 * replaced by the min value.
  	 *
  	 * @param {number} minVal - The minimum value the components will be clamped to.
  	 * @param {number} maxVal - The maximum value the components will be clamped to.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	clampScalar( minVal, maxVal ) {

  		this.x = clamp$1( this.x, minVal, maxVal );
  		this.y = clamp$1( this.y, minVal, maxVal );
  		this.z = clamp$1( this.z, minVal, maxVal );

  		return this;

  	}

  	/**
  	 * If this vector's length is greater than the max value, it is replaced by
  	 * the max value.
  	 * If this vector's length is less than the min value, it is replaced by the
  	 * min value.
  	 *
  	 * @param {number} min - The minimum value the vector length will be clamped to.
  	 * @param {number} max - The maximum value the vector length will be clamped to.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( clamp$1( length, min, max ) );

  	}

  	/**
  	 * The components of this vector are rounded down to the nearest integer value.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded up to the nearest integer value.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded to the nearest integer value
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded towards zero (up if negative,
  	 * down if positive) to an integer value.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );

  		return this;

  	}

  	/**
  	 * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	}

  	/**
  	 * Calculates the dot product of the given vector with this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	}

  	// TODO lengthSquared?

  	/**
  	 * Computes the square of the Euclidean length (straight-line length) from
  	 * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
  	 * compare the length squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @return {number} The square length of this vector.
  	 */
  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	}

  	/**
  	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	}

  	/**
  	 * Computes the Manhattan length of this vector.
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	}

  	/**
  	 * Converts this vector to a unit vector - that is, sets it equal to a vector
  	 * with the same direction as this one, but with a vector length of `1`.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	/**
  	 * Sets this vector to a vector with the same direction as this one, but
  	 * with the specified length.
  	 *
  	 * @param {number} length - The new length of this vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	/**
  	 * Linearly interpolates between the given vector and this instance, where
  	 * alpha is the percent distance along the line - alpha = 0 will be this
  	 * vector, and alpha = 1 will be the given one.
  	 *
  	 * @param {Vector3} v - The vector to interpolate towards.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given vectors, where alpha is the percent
  	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
  	 * be the second one. The result is stored in this instance.
  	 *
  	 * @param {Vector3} v1 - The first vector.
  	 * @param {Vector3} v2 - The second vector.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;

  		return this;

  	}

  	/**
  	 * Calculates the cross product of the given vector with this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the cross product with.
  	 * @return {Vector3} The result of the cross product.
  	 */
  	cross( v ) {

  		return this.crossVectors( this, v );

  	}

  	/**
  	 * Calculates the cross product of the given vectors and stores the result
  	 * in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	crossVectors( a, b ) {

  		const ax = a.x, ay = a.y, az = a.z;
  		const bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	}

  	/**
  	 * Projects this vector onto the given one.
  	 *
  	 * @param {Vector3} v - The vector to project to.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	projectOnVector( v ) {

  		const denominator = v.lengthSq();

  		if ( denominator === 0 ) return this.set( 0, 0, 0 );

  		const scalar = v.dot( this ) / denominator;

  		return this.copy( v ).multiplyScalar( scalar );

  	}

  	/**
  	 * Projects this vector onto a plane by subtracting this
  	 * vector projected onto the plane's normal from this vector.
  	 *
  	 * @param {Vector3} planeNormal - The plane normal.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	projectOnPlane( planeNormal ) {

  		_vector$c.copy( this ).projectOnVector( planeNormal );

  		return this.sub( _vector$c );

  	}

  	/**
  	 * Reflects this vector off a plane orthogonal to the given normal vector.
  	 *
  	 * @param {Vector3} normal - The (normalized) normal vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	reflect( normal ) {

  		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  	}
  	/**
  	 * Returns the angle between the given vector and this instance in radians.
  	 *
  	 * @param {Vector3} v - The vector to compute the angle with.
  	 * @return {number} The angle in radians.
  	 */
  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp$1( theta, -1, 1 ) );

  	}

  	/**
  	 * Computes the distance from the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the distance to.
  	 * @return {number} The distance.
  	 */
  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	/**
  	 * Computes the squared distance from the given vector to this instance.
  	 * If you are just comparing the distance with another distance, you should compare
  	 * the distance squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @param {Vector3} v - The vector to compute the squared distance to.
  	 * @return {number} The squared distance.
  	 */
  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	}

  	/**
  	 * Computes the Manhattan distance from the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the Manhattan distance to.
  	 * @return {number} The Manhattan distance.
  	 */
  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	}

  	/**
  	 * Sets the vector components from the given spherical coordinates.
  	 *
  	 * @param {Spherical} s - The spherical coordinates.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromSpherical( s ) {

  		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  	}

  	/**
  	 * Sets the vector components from the given spherical coordinates.
  	 *
  	 * @param {number} radius - The radius.
  	 * @param {number} phi - The phi angle in radians.
  	 * @param {number} theta - The theta angle in radians.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromSphericalCoords( radius, phi, theta ) {

  		const sinPhiRadius = Math.sin( phi ) * radius;

  		this.x = sinPhiRadius * Math.sin( theta );
  		this.y = Math.cos( phi ) * radius;
  		this.z = sinPhiRadius * Math.cos( theta );

  		return this;

  	}

  	/**
  	 * Sets the vector components from the given cylindrical coordinates.
  	 *
  	 * @param {Cylindrical} c - The cylindrical coordinates.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromCylindrical( c ) {

  		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  	}

  	/**
  	 * Sets the vector components from the given cylindrical coordinates.
  	 *
  	 * @param {number} radius - The radius.
  	 * @param {number} theta - The theta angle in radians.
  	 * @param {number} y - The y value.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromCylindricalCoords( radius, theta, y ) {

  		this.x = radius * Math.sin( theta );
  		this.y = y;
  		this.z = radius * Math.cos( theta );

  		return this;

  	}

  	/**
  	 * Sets the vector components to the position elements of the
  	 * given transformation matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	}

  	/**
  	 * Sets the vector components to the scale elements of the
  	 * given transformation matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrixScale( m ) {

  		const sx = this.setFromMatrixColumn( m, 0 ).length();
  		const sy = this.setFromMatrixColumn( m, 1 ).length();
  		const sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	}

  	/**
  	 * Sets the vector components from the specified matrix column.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @param {number} index - The column index.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrixColumn( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	}

  	/**
  	 * Sets the vector components from the specified matrix column.
  	 *
  	 * @param {Matrix3} m - The 3x3 matrix.
  	 * @param {number} index - The column index.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrix3Column( m, index ) {

  		return this.fromArray( m.elements, index * 3 );

  	}

  	/**
  	 * Sets the vector components from the given Euler angles.
  	 *
  	 * @param {Euler} e - The Euler angles to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromEuler( e ) {

  		this.x = e._x;
  		this.y = e._y;
  		this.z = e._z;

  		return this;

  	}

  	/**
  	 * Sets the vector components from the RGB components of the
  	 * given color.
  	 *
  	 * @param {Color} c - The color to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromColor( c ) {

  		this.x = c.r;
  		this.y = c.g;
  		this.z = c.b;

  		return this;

  	}

  	/**
  	 * Returns `true` if this vector is equal with the given one.
  	 *
  	 * @param {Vector3} v - The vector to test for equality.
  	 * @return {boolean} Whether this vector is equal with the given one.
  	 */
  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	}

  	/**
  	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
  	 * and z value to be `array[ offset + 2 ]`.
  	 *
  	 * @param {Array<number>} array - An array holding the vector component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	}

  	/**
  	 * Writes the components of this vector to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The vector components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	}

  	/**
  	 * Sets the components of this vector from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  	/**
  	 * Sets each component of this vector to a pseudo-random value between `0` and
  	 * `1`, excluding `1`.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();

  		return this;

  	}

  	/**
  	 * Sets this vector to a uniformly random point on a unit sphere.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	randomDirection() {

  		// https://mathworld.wolfram.com/SpherePointPicking.html

  		const theta = Math.random() * Math.PI * 2;
  		const u = Math.random() * 2 - 1;
  		const c = Math.sqrt( 1 - u * u );

  		this.x = c * Math.cos( theta );
  		this.y = u;
  		this.z = c * Math.sin( theta );

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;

  	}

  }

  const _vector$c = /*@__PURE__*/ new Vector3();
  const _quaternion$4 = /*@__PURE__*/ new Quaternion();

  /**
   * Represents a 3x3 matrix.
   *
   * A Note on Row-Major and Column-Major Ordering:
   *
   * The constructor and {@link Matrix3#set} method take arguments in
   * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
   * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
   * This means that calling:
   * ```js
   * const m = new THREE.Matrix();
   * m.set( 11, 12, 13,
   *        21, 22, 23,
   *        31, 32, 33 );
   * ```
   * will result in the elements array containing:
   * ```js
   * m.elements = [ 11, 21, 31,
   *                12, 22, 32,
   *                13, 23, 33 ];
   * ```
   * and internally all calculations are performed using column-major ordering.
   * However, as the actual ordering makes no difference mathematically and
   * most people are used to thinking about matrices in row-major order, the
   * three.js documentation shows matrices in row-major order. Just bear in
   * mind that if you are reading the source code, you'll have to take the
   * transpose of any matrices outlined here to make sense of the calculations.
   */
  class Matrix3 {

  	/**
  	 * Constructs a new 3x3 matrix. The arguments are supposed to be
  	 * in row-major order. If no arguments are provided, the constructor
  	 * initializes the matrix as an identity matrix.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 */
  	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Matrix3.prototype.isMatrix3 = true;

  		/**
  		 * A column-major list of matrix values.
  		 *
  		 * @type {Array<number>}
  		 */
  		this.elements = [

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

  		}

  	}

  	/**
  	 * Sets the elements of the matrix.The arguments are supposed to be
  	 * in row-major order.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	}

  	/**
  	 * Sets this matrix to the 3x3 identity matrix.
  	 *
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	identity() {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Copies the values of the given matrix to this instance.
  	 *
  	 * @param {Matrix3} m - The matrix to copy.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	}

  	/**
  	 * Extracts the basis of this matrix into the three axis vectors provided.
  	 *
  	 * @param {Vector3} xAxis - The basis's x axis.
  	 * @param {Vector3} yAxis - The basis's y axis.
  	 * @param {Vector3} zAxis - The basis's z axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrix3Column( this, 0 );
  		yAxis.setFromMatrix3Column( this, 1 );
  		zAxis.setFromMatrix3Column( this, 2 );

  		return this;

  	}

  	/**
  	 * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	setFromMatrix4( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	}

  	/**
  	 * Post-multiplies this matrix by the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix to multiply with.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	/**
  	 * Pre-multiplies this matrix by the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix to multiply with.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	/**
  	 * Multiples the given 3x3 matrices and stores the result
  	 * in this matrix.
  	 *
  	 * @param {Matrix3} a - The first matrix.
  	 * @param {Matrix3} b - The second matrix.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	}

  	/**
  	 * Multiplies every component of the matrix by the given scalar.
  	 *
  	 * @param {number} s - The scalar.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	}

  	/**
  	 * Computes and returns the determinant of this matrix.
  	 *
  	 * @return {number} The determinant.
  	 */
  	determinant() {

  		const te = this.elements;

  		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	}

  	/**
  	 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
  	 * You can not invert with a determinant of zero. If you attempt this, the method produces
  	 * a zero matrix instead.
  	 *
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	invert() {

  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
  			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
  			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	}

  	/**
  	 * Transposes this matrix in place.
  	 *
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	transpose() {

  		let tmp;
  		const m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	}

  	/**
  	 * Computes the normal matrix which is the inverse transpose of the upper
  	 * left 3x3 portion of the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} matrix4 - The 4x4 matrix.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	getNormalMatrix( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).invert().transpose();

  	}

  	/**
  	 * Transposes this matrix into the supplied array, and returns itself unchanged.
  	 *
  	 * @param {Array<number>} r - An array to store the transposed matrix elements.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	transposeIntoArray( r ) {

  		const m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	}

  	/**
  	 * Sets the UV transform matrix from offset, repeat, rotation, and center.
  	 *
  	 * @param {number} tx - Offset x.
  	 * @param {number} ty - Offset y.
  	 * @param {number} sx - Repeat x.
  	 * @param {number} sy - Repeat y.
  	 * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
  	 * @param {number} cx - Center x of rotation.
  	 * @param {number} cy - Center y of rotation
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

  		const c = Math.cos( rotation );
  		const s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  		return this;

  	}

  	/**
  	 * Scales this matrix with the given scalar values.
  	 *
  	 * @param {number} sx - The amount to scale in the X axis.
  	 * @param {number} sy - The amount to scale in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	scale( sx, sy ) {

  		this.premultiply( _m3.makeScale( sx, sy ) );

  		return this;

  	}

  	/**
  	 * Rotates this matrix by the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	rotate( theta ) {

  		this.premultiply( _m3.makeRotation( - theta ) );

  		return this;

  	}

  	/**
  	 * Translates this matrix by the given scalar values.
  	 *
  	 * @param {number} tx - The amount to translate in the X axis.
  	 * @param {number} ty - The amount to translate in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	translate( tx, ty ) {

  		this.premultiply( _m3.makeTranslation( tx, ty ) );

  		return this;

  	}

  	// for 2D Transforms

  	/**
  	 * Sets this matrix as a 2D translation transform.
  	 *
  	 * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
  	 * @param {number} y - The amount to translate in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	makeTranslation( x, y ) {

  		if ( x.isVector2 ) {

  			this.set(

  				1, 0, x.x,
  				0, 1, x.y,
  				0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, x,
  				0, 1, y,
  				0, 0, 1

  			);

  		}

  		return this;

  	}

  	/**
  	 * Sets this matrix as a 2D rotational transformation.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	makeRotation( theta ) {

  		// counterclockwise

  		const c = Math.cos( theta );
  		const s = Math.sin( theta );

  		this.set(

  			c, - s, 0,
  			s, c, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a 2D scale transform.
  	 *
  	 * @param {number} x - The amount to scale in the X axis.
  	 * @param {number} y - The amount to scale in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	makeScale( x, y ) {

  		this.set(

  			x, 0, 0,
  			0, y, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Returns `true` if this matrix is equal with the given one.
  	 *
  	 * @param {Matrix3} matrix - The matrix to test for equality.
  	 * @return {boolean} Whether this matrix is equal with the given one.
  	 */
  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	/**
  	 * Sets the elements of the matrix from the given array.
  	 *
  	 * @param {Array<number>} array - The matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	/**
  	 * Writes the elements of this matrix to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The matrix elements in column-major order.
  	 */
  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  	/**
  	 * Returns a matrix with copied values from this instance.
  	 *
  	 * @return {Matrix3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().fromArray( this.elements );

  	}

  }

  const _m3 = /*@__PURE__*/ new Matrix3();

  function arrayNeedsUint32( array ) {

  	// assumes larger values usually on last

  	for ( let i = array.length - 1; i >= 0; -- i ) {

  		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

  	}

  	return false;

  }

  function createElementNS( name ) {

  	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

  }

  function createCanvasElement() {

  	const canvas = createElementNS( 'canvas' );
  	canvas.style.display = 'block';
  	return canvas;

  }

  const _cache$2 = {};

  function warnOnce( message ) {

  	if ( message in _cache$2 ) return;

  	_cache$2[ message ] = true;

  	console.warn( message );

  }

  const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
  	0.4123908, 0.3575843, 0.1804808,
  	0.2126390, 0.7151687, 0.0721923,
  	0.0193308, 0.1191948, 0.9505322
  );

  const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
  	3.2409699, -1.5373832, -0.4986108,
  	-0.9692436, 1.8759675, 0.0415551,
  	0.0556301, -0.203977, 1.0569715
  );

  function createColorManagement() {

  	const ColorManagement = {

  		enabled: true,

  		workingColorSpace: LinearSRGBColorSpace,

  		/**
  		 * Implementations of supported color spaces.
  		 *
  		 * Required:
  		 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
  		 *	- whitePoint: reference white [ x y ]
  		 *	- transfer: transfer function (pre-defined)
  		 *	- toXYZ: Matrix3 RGB to XYZ transform
  		 *	- fromXYZ: Matrix3 XYZ to RGB transform
  		 *	- luminanceCoefficients: RGB luminance coefficients
  		 *
  		 * Optional:
  		 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
  		 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
  		 *
  		 * Reference:
  		 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
  		 */
  		spaces: {},

  		convert: function ( color, sourceColorSpace, targetColorSpace ) {

  			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

  				return color;

  			}

  			if ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {

  				color.r = SRGBToLinear( color.r );
  				color.g = SRGBToLinear( color.g );
  				color.b = SRGBToLinear( color.b );

  			}

  			if ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {

  				color.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );
  				color.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );

  			}

  			if ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {

  				color.r = LinearToSRGB( color.r );
  				color.g = LinearToSRGB( color.g );
  				color.b = LinearToSRGB( color.b );

  			}

  			return color;

  		},

  		workingToColorSpace: function ( color, targetColorSpace ) {

  			return this.convert( color, this.workingColorSpace, targetColorSpace );

  		},

  		colorSpaceToWorking: function ( color, sourceColorSpace ) {

  			return this.convert( color, sourceColorSpace, this.workingColorSpace );

  		},

  		getPrimaries: function ( colorSpace ) {

  			return this.spaces[ colorSpace ].primaries;

  		},

  		getTransfer: function ( colorSpace ) {

  			if ( colorSpace === NoColorSpace ) return LinearTransfer;

  			return this.spaces[ colorSpace ].transfer;

  		},

  		getLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {

  			return target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );

  		},

  		define: function ( colorSpaces ) {

  			Object.assign( this.spaces, colorSpaces );

  		},

  		// Internal APIs

  		_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {

  			return targetMatrix
  				.copy( this.spaces[ sourceColorSpace ].toXYZ )
  				.multiply( this.spaces[ targetColorSpace ].fromXYZ );

  		},

  		_getDrawingBufferColorSpace: function ( colorSpace ) {

  			return this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;

  		},

  		_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {

  			return this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;

  		},

  		// Deprecated

  		fromWorkingColorSpace: function ( color, targetColorSpace ) {

  			warnOnce( 'THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().' ); // @deprecated, r177

  			return ColorManagement.workingToColorSpace( color, targetColorSpace );

  		},

  		toWorkingColorSpace: function ( color, sourceColorSpace ) {

  			warnOnce( 'THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().' ); // @deprecated, r177

  			return ColorManagement.colorSpaceToWorking( color, sourceColorSpace );

  		},

  	};

  	/******************************************************************************
  	 * sRGB definitions
  	 */

  	const REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];
  	const REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];
  	const D65 = [ 0.3127, 0.3290 ];

  	ColorManagement.define( {

  		[ LinearSRGBColorSpace ]: {
  			primaries: REC709_PRIMARIES,
  			whitePoint: D65,
  			transfer: LinearTransfer,
  			toXYZ: LINEAR_REC709_TO_XYZ,
  			fromXYZ: XYZ_TO_LINEAR_REC709,
  			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
  			workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
  			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  		},

  		[ SRGBColorSpace ]: {
  			primaries: REC709_PRIMARIES,
  			whitePoint: D65,
  			transfer: SRGBTransfer,
  			toXYZ: LINEAR_REC709_TO_XYZ,
  			fromXYZ: XYZ_TO_LINEAR_REC709,
  			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
  			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  		},

  	} );

  	return ColorManagement;

  }

  const ColorManagement = /*@__PURE__*/ createColorManagement();

  function SRGBToLinear( c ) {

  	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  }

  function LinearToSRGB( c ) {

  	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  }

  let _canvas;

  /**
   * A class containing utility functions for images.
   *
   * @hideconstructor
   */
  class ImageUtils {

  	/**
  	 * Returns a data URI containing a representation of the given image.
  	 *
  	 * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
  	 * @param {string} [type='image/png'] - Indicates the image format.
  	 * @return {string} The data URI.
  	 */
  	static getDataURL( image, type = 'image/png' ) {

  		if ( /^data:/i.test( image.src ) ) {

  			return image.src;

  		}

  		if ( typeof HTMLCanvasElement === 'undefined' ) {

  			return image.src;

  		}

  		let canvas;

  		if ( image instanceof HTMLCanvasElement ) {

  			canvas = image;

  		} else {

  			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

  			_canvas.width = image.width;
  			_canvas.height = image.height;

  			const context = _canvas.getContext( '2d' );

  			if ( image instanceof ImageData ) {

  				context.putImageData( image, 0, 0 );

  			} else {

  				context.drawImage( image, 0, 0, image.width, image.height );

  			}

  			canvas = _canvas;

  		}

  		return canvas.toDataURL( type );

  	}

  	/**
  	 * Converts the given sRGB image data to linear color space.
  	 *
  	 * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
  	 * @return {HTMLCanvasElement|Object} The converted image.
  	 */
  	static sRGBToLinear( image ) {

  		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  			const canvas = createElementNS( 'canvas' );

  			canvas.width = image.width;
  			canvas.height = image.height;

  			const context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, image.width, image.height );

  			const imageData = context.getImageData( 0, 0, image.width, image.height );
  			const data = imageData.data;

  			for ( let i = 0; i < data.length; i ++ ) {

  				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

  			}

  			context.putImageData( imageData, 0, 0 );

  			return canvas;

  		} else if ( image.data ) {

  			const data = image.data.slice( 0 );

  			for ( let i = 0; i < data.length; i ++ ) {

  				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

  					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

  				} else {

  					// assuming float

  					data[ i ] = SRGBToLinear( data[ i ] );

  				}

  			}

  			return {
  				data: data,
  				width: image.width,
  				height: image.height
  			};

  		} else {

  			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
  			return image;

  		}

  	}

  }

  let _sourceId = 0;

  /**
   * Represents the data source of a texture.
   *
   * The main purpose of this class is to decouple the data definition from the texture
   * definition so the same data can be used with multiple texture instances.
   */
  class Source {

  	/**
  	 * Constructs a new video texture.
  	 *
  	 * @param {any} [data=null] - The data definition of a texture.
  	 */
  	constructor( data = null ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSource = true;

  		/**
  		 * The ID of the source.
  		 *
  		 * @name Source#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

  		/**
  		 * The UUID of the source.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The data definition of a texture.
  		 *
  		 * @type {any}
  		 */
  		this.data = data;

  		/**
  		 * This property is only relevant when {@link Source#needsUpdate} is set to `true` and
  		 * provides more control on how texture data should be processed. When `dataReady` is set
  		 * to `false`, the engine performs the memory allocation (if necessary) but does not transfer
  		 * the data into the GPU memory.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.dataReady = true;

  		/**
  		 * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  	}

  	getSize( target ) {

  		const data = this.data;

  		if ( data instanceof HTMLVideoElement ) {

  			target.set( data.videoWidth, data.videoHeight );

  		} else if ( data !== null ) {

  			target.set( data.width, data.height, data.depth || 0 );

  		} else {

  			target.set( 0, 0, 0 );

  		}

  		return target;

  	}

  	/**
  	 * When the property is set to `true`, the engine allocates the memory
  	 * for the texture (if necessary) and triggers the actual texture upload
  	 * to the GPU next time the source is used.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	/**
  	 * Serializes the source into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized source.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

  			return meta.images[ this.uuid ];

  		}

  		const output = {
  			uuid: this.uuid,
  			url: ''
  		};

  		const data = this.data;

  		if ( data !== null ) {

  			let url;

  			if ( Array.isArray( data ) ) {

  				// cube texture

  				url = [];

  				for ( let i = 0, l = data.length; i < l; i ++ ) {

  					if ( data[ i ].isDataTexture ) {

  						url.push( serializeImage( data[ i ].image ) );

  					} else {

  						url.push( serializeImage( data[ i ] ) );

  					}

  				}

  			} else {

  				// texture

  				url = serializeImage( data );

  			}

  			output.url = url;

  		}

  		if ( ! isRootObject ) {

  			meta.images[ this.uuid ] = output;

  		}

  		return output;

  	}

  }

  function serializeImage( image ) {

  	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  		// default images

  		return ImageUtils.getDataURL( image );

  	} else {

  		if ( image.data ) {

  			// images of DataTexture

  			return {
  				data: Array.from( image.data ),
  				width: image.width,
  				height: image.height,
  				type: image.data.constructor.name
  			};

  		} else {

  			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
  			return {};

  		}

  	}

  }

  let _textureId = 0;

  const _tempVec3 = /*@__PURE__*/ new Vector3();

  /**
   * Base class for all textures.
   *
   * Note: After the initial use of a texture, its dimensions, format, and type
   * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
   *
   * @augments EventDispatcher
   */
  class Texture extends EventDispatcher {

  	/**
  	 * Constructs a new texture.
  	 *
  	 * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
  	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
  	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
  	 * @param {number} [format=RGBAFormat] - The texture format.
  	 * @param {number} [type=UnsignedByteType] - The texture type.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space.
  	 */
  	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isTexture = true;

  		/**
  		 * The ID of the texture.
  		 *
  		 * @name Texture#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _textureId ++ } );

  		/**
  		 * The UUID of the material.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the material.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The data definition of a texture. A reference to the data source can be
  		 * shared across textures. This is often useful in context of spritesheets
  		 * where multiple textures render the same data but with different texture
  		 * transformations.
  		 *
  		 * @type {Source}
  		 */
  		this.source = new Source( image );

  		/**
  		 * An array holding user-defined mipmaps.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.mipmaps = [];

  		/**
  		 * How the texture is applied to the object. The value `UVMapping`
  		 * is the default, where texture or uv coordinates are used to apply the map.
  		 *
  		 * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
  		 * @default UVMapping
  		*/
  		this.mapping = mapping;

  		/**
  		 * Lets you select the uv attribute to map the texture to. `0` for `uv`,
  		 * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.channel = 0;

  		/**
  		 * This defines how the texture is wrapped horizontally and corresponds to
  		 * *U* in UV mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapS = wrapS;

  		/**
  		 * This defines how the texture is wrapped horizontally and corresponds to
  		 * *V* in UV mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapT = wrapT;

  		/**
  		 * How the texture is sampled when a texel covers more than one pixel.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default LinearFilter
  		 */
  		this.magFilter = magFilter;

  		/**
  		 * How the texture is sampled when a texel covers less than one pixel.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default LinearMipmapLinearFilter
  		 */
  		this.minFilter = minFilter;

  		/**
  		 * The number of samples taken along the axis through the pixel that has the
  		 * highest density of texels. By default, this value is `1`. A higher value
  		 * gives a less blurry result than a basic mipmap, at the cost of more
  		 * texture samples being used.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.anisotropy = anisotropy;

  		/**
  		 * The format of the texture.
  		 *
  		 * @type {number}
  		 * @default RGBAFormat
  		 */
  		this.format = format;

  		/**
  		 * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
  		 * defines how the texture data is going to be stored on the GPU.
  		 *
  		 * This property allows to overwrite the default format.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.internalFormat = null;

  		/**
  		 * The data type of the texture.
  		 *
  		 * @type {number}
  		 * @default UnsignedByteType
  		 */
  		this.type = type;

  		/**
  		 * How much a single repetition of the texture is offset from the beginning,
  		 * in each direction U and V. Typical range is `0.0` to `1.0`.
  		 *
  		 * @type {Vector2}
  		 * @default (0,0)
  		 */
  		this.offset = new Vector2( 0, 0 );

  		/**
  		 * How many times the texture is repeated across the surface, in each
  		 * direction U and V. If repeat is set greater than `1` in either direction,
  		 * the corresponding wrap parameter should also be set to `RepeatWrapping`
  		 * or `MirroredRepeatWrapping` to achieve the desired tiling effect.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.repeat = new Vector2( 1, 1 );

  		/**
  		 * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
  		 * to the center of the texture. Default is `(0, 0)`, the lower left.
  		 *
  		 * @type {Vector2}
  		 * @default (0,0)
  		 */
  		this.center = new Vector2( 0, 0 );

  		/**
  		 * How much the texture is rotated around the center point, in radians.
  		 * Positive values are counter-clockwise.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.rotation = 0;

  		/**
  		 * Whether to update the texture's uv-transformation {@link Texture#matrix}
  		 * from the properties {@link Texture#offset}, {@link Texture#repeat},
  		 * {@link Texture#rotation}, and {@link Texture#center}.
  		 *
  		 * Set this to `false` if you are specifying the uv-transform matrix directly.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.matrixAutoUpdate = true;

  		/**
  		 * The uv-transformation matrix of the texture.
  		 *
  		 * @type {Matrix3}
  		 */
  		this.matrix = new Matrix3();

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Set this to `false` if you are creating mipmaps manually.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.generateMipmaps = true;

  		/**
  		 * If set to `true`, the alpha channel, if present, is multiplied into the
  		 * color channels when the texture is uploaded to the GPU.
  		 *
  		 * Note that this property has no effect when using `ImageBitmap`. You need to
  		 * configure premultiply alpha on bitmap creation instead.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.premultiplyAlpha = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Note that this property has no effect when using `ImageBitmap`. You need to
  		 * configure the flip on bitmap creation instead.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.flipY = true;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
  		 * `4` (word-alignment), and `8` (rows start on double-word boundaries).
  		 *
  		 * @type {number}
  		 * @default 4
  		 */
  		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  		/**
  		 * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
  		 *
  		 * @type {string}
  		 * @default NoColorSpace
  		 */
  		this.colorSpace = colorSpace;

  		/**
  		 * An object that can be used to store custom data about the texture. It
  		 * should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  		/**
  		 * This can be used to only update a subregion or specific rows of the texture (for example, just the
  		 * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.updateRanges = [];

  		/**
  		 * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  		/**
  		 * A callback function, called when the texture is updated (e.g., when
  		 * {@link Texture#needsUpdate} has been set to true and then the texture is used).
  		 *
  		 * @type {?Function}
  		 * @default null
  		 */
  		this.onUpdate = null;

  		/**
  		 * An optional back reference to the textures render target.
  		 *
  		 * @type {?(RenderTarget|WebGLRenderTarget)}
  		 * @default null
  		 */
  		this.renderTarget = null;

  		/**
  		 * Indicates whether a texture belongs to a render target or not.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isRenderTargetTexture = false;

  		/**
  		 * Indicates if a texture should be handled like a texture array.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;

  		/**
  		 * Indicates whether this texture should be processed by `PMREMGenerator` or not
  		 * (only relevant for render target textures).
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.pmremVersion = 0;

  	}

  	/**
  	 * The width of the texture in pixels.
  	 */
  	get width() {

  		return this.source.getSize( _tempVec3 ).x;

  	}

  	/**
  	 * The height of the texture in pixels.
  	 */
  	get height() {

  		return this.source.getSize( _tempVec3 ).y;

  	}

  	/**
  	 * The depth of the texture in pixels.
  	 */
  	get depth() {

  		return this.source.getSize( _tempVec3 ).z;

  	}

  	/**
  	 * The image object holding the texture data.
  	 *
  	 * @type {?Object}
  	 */
  	get image() {

  		return this.source.data;

  	}

  	set image( value = null ) {

  		this.source.data = value;

  	}

  	/**
  	 * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
  	 * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
  	 */
  	updateMatrix() {

  		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  	}

  	/**
  	 * Adds a range of data in the data texture to be updated on the GPU.
  	 *
  	 * @param {number} start - Position at which to start update.
  	 * @param {number} count - The number of components to update.
  	 */
  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	/**
  	 * Clears the update ranges.
  	 */
  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	/**
  	 * Returns a new texture with copied values from this instance.
  	 *
  	 * @return {Texture} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given texture to this instance.
  	 *
  	 * @param {Texture} source - The texture to copy.
  	 * @return {Texture} A reference to this instance.
  	 */
  	copy( source ) {

  		this.name = source.name;

  		this.source = source.source;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;
  		this.channel = source.channel;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.internalFormat = source.internalFormat;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.colorSpace = source.colorSpace;

  		this.renderTarget = source.renderTarget;
  		this.isRenderTargetTexture = source.isRenderTargetTexture;
  		this.isArrayTexture = source.isArrayTexture;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.needsUpdate = true;

  		return this;

  	}

  	/**
  	 * Sets this texture's properties based on `values`.
  	 * @param {Object} values - A container with texture parameters.
  	 */
  	setValues( values ) {

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( `THREE.Texture.setValues(): parameter '${ key }' has value of undefined.` );
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( `THREE.Texture.setValues(): property '${ key }' does not exist.` );
  				continue;

  			}

  			if ( ( currentValue && newValue ) && ( currentValue.isVector2 && newValue.isVector2 ) ) {

  				currentValue.copy( newValue );

  			} else if ( ( currentValue && newValue ) && ( currentValue.isVector3 && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else if ( ( currentValue && newValue ) && ( currentValue.isMatrix3 && newValue.isMatrix3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	/**
  	 * Serializes the texture into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized texture.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		const output = {

  			metadata: {
  				version: 4.7,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			image: this.source.toJSON( meta ).uuid,

  			mapping: this.mapping,
  			channel: this.channel,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			format: this.format,
  			internalFormat: this.internalFormat,
  			type: this.type,
  			colorSpace: this.colorSpace,

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY,

  			generateMipmaps: this.generateMipmaps,
  			premultiplyAlpha: this.premultiplyAlpha,
  			unpackAlignment: this.unpackAlignment

  		};

  		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

  		if ( ! isRootObject ) {

  			meta.textures[ this.uuid ] = output;

  		}

  		return output;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires Texture#dispose
  	 */
  	dispose() {

  		/**
  		 * Fires when the texture has been disposed of.
  		 *
  		 * @event Texture#dispose
  		 * @type {Object}
  		 */
  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	/**
  	 * Transforms the given uv vector with the textures uv transformation matrix.
  	 *
  	 * @param {Vector2} uv - The uv vector.
  	 * @return {Vector2} The transformed uv vector.
  	 */
  	transformUv( uv ) {

  		if ( this.mapping !== UVMapping ) return uv;

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}

  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}

  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  		return uv;

  	}

  	/**
  	 * Setting this property to `true` indicates the engine the texture
  	 * must be updated in the next render. This triggers a texture upload
  	 * to the GPU and ensures correct texture parameter configuration.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) {

  			this.version ++;
  			this.source.needsUpdate = true;

  		}

  	}

  	/**
  	 * Setting this property to `true` indicates the engine the PMREM
  	 * must be regenerated.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsPMREMUpdate( value ) {

  		if ( value === true ) {

  			this.pmremVersion ++;

  		}

  	}

  }

  /**
   * The default image for all textures.
   *
   * @static
   * @type {?Image}
   * @default null
   */
  Texture.DEFAULT_IMAGE = null;

  /**
   * The default mapping for all textures.
   *
   * @static
   * @type {number}
   * @default UVMapping
   */
  Texture.DEFAULT_MAPPING = UVMapping;

  /**
   * The default anisotropy value for all textures.
   *
   * @static
   * @type {number}
   * @default 1
   */
  Texture.DEFAULT_ANISOTROPY = 1;

  /**
   * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
   * (labeled x, y, z and w), which can be used to represent a number of things, such as:
   *
   * - A point in 4D space.
   * - A direction and length in 4D space. In three.js the length will
   * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
   * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
   * - Any arbitrary ordered quadruplet of numbers.
   *
   * There are other things a 4D vector can be used to represent, however these
   * are the most common uses in *three.js*.
   *
   * Iterating through a vector instance will yield its components `(x, y, z, w)` in
   * the corresponding order.
   * ```js
   * const a = new THREE.Vector4( 0, 1, 0, 0 );
   *
   * //no arguments; will be initialised to (0, 0, 0, 1)
   * const b = new THREE.Vector4( );
   *
   * const d = a.dot( b );
   * ```
   */
  class Vector4 {

  	/**
  	 * Constructs a new 4D vector.
  	 *
  	 * @param {number} [x=0] - The x value of this vector.
  	 * @param {number} [y=0] - The y value of this vector.
  	 * @param {number} [z=0] - The z value of this vector.
  	 * @param {number} [w=1] - The w value of this vector.
  	 */
  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Vector4.prototype.isVector4 = true;

  		/**
  		 * The x value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.x = x;

  		/**
  		 * The y value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.y = y;

  		/**
  		 * The z value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.z = z;

  		/**
  		 * The w value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.w = w;

  	}

  	/**
  	 * Alias for {@link Vector4#z}.
  	 *
  	 * @type {number}
  	 */
  	get width() {

  		return this.z;

  	}

  	set width( value ) {

  		this.z = value;

  	}

  	/**
  	 * Alias for {@link Vector4#w}.
  	 *
  	 * @type {number}
  	 */
  	get height() {

  		return this.w;

  	}

  	set height( value ) {

  		this.w = value;

  	}

  	/**
  	 * Sets the vector components.
  	 *
  	 * @param {number} x - The value of the x component.
  	 * @param {number} y - The value of the y component.
  	 * @param {number} z - The value of the z component.
  	 * @param {number} w - The value of the w component.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	set( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	}

  	/**
  	 * Sets the vector components to the same value.
  	 *
  	 * @param {number} scalar - The value to set for all vector components.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	}

  	/**
  	 * Sets the vector's x component to the given value
  	 *
  	 * @param {number} x - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	/**
  	 * Sets the vector's y component to the given value
  	 *
  	 * @param {number} y - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	/**
  	 * Sets the vector's z component to the given value
  	 *
  	 * @param {number} z - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	/**
  	 * Sets the vector's w component to the given value
  	 *
  	 * @param {number} w - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setW( w ) {

  		this.w = w;

  		return this;

  	}

  	/**
  	 * Allows to set a vector component with an index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
  	 * `2` equals to z, `3` equals to w.
  	 * @param {number} value - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	/**
  	 * Returns the value of the vector component which matches the given index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
  	 * `2` equals to z, `3` equals to w.
  	 * @return {number} A vector component value.
  	 */
  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	/**
  	 * Returns a new vector with copied values from this instance.
  	 *
  	 * @return {Vector4} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	}

  	/**
  	 * Copies the values of the given vector to this instance.
  	 *
  	 * @param {Vector3|Vector4} v - The vector to copy.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	}

  	/**
  	 * Adds the given vector to this instance.
  	 *
  	 * @param {Vector4} v - The vector to add.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to all components of this instance.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	}

  	/**
  	 * Adds the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector4} a - The first vector.
  	 * @param {Vector4} b - The second vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	}

  	/**
  	 * Adds the given vector scaled by the given factor to this instance.
  	 *
  	 * @param {Vector4} v - The vector.
  	 * @param {number} s - The factor that scales `v`.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vector from this instance.
  	 *
  	 * @param {Vector4} v - The vector to subtract.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	}

  	/**
  	 * Subtracts the given scalar value from all components of this instance.
  	 *
  	 * @param {number} s - The scalar to subtract.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector4} a - The first vector.
  	 * @param {Vector4} b - The second vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	}

  	/**
  	 * Multiplies the given vector with this instance.
  	 *
  	 * @param {Vector4} v - The vector to multiply.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;
  		this.w *= v.w;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with all components of this instance.
  	 *
  	 * @param {number} scalar - The scalar to multiply.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	}

  	/**
  	 * Multiplies this vector with the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z, w = this.w;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	}

  	/**
  	 * Divides this instance by the given vector.
  	 *
  	 * @param {Vector4} v - The vector to divide.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;
  		this.w /= v.w;

  		return this;

  	}

  	/**
  	 * Divides this vector by the given scalar.
  	 *
  	 * @param {number} scalar - The scalar to divide.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	/**
  	 * Sets the x, y and z components of this
  	 * vector to the quaternion's axis and w to the angle.
  	 *
  	 * @param {Quaternion} q - The Quaternion to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setAxisAngleFromQuaternion( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		const s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	}

  	/**
  	 * Sets the x, y and z components of this
  	 * vector to the axis of rotation and w to the angle.
  	 *
  	 * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setAxisAngleFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		let angle, x, y, z; // variables for result
  		const epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			const xx = ( m11 + 1 ) / 2;
  			const yy = ( m22 + 1 ) / 2;
  			const zz = ( m33 + 1 ) / 2;
  			const xy = ( m12 + m21 ) / 4;
  			const xz = ( m13 + m31 ) / 4;
  			const yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  			( m13 - m31 ) * ( m13 - m31 ) +
  			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) s = 1;

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	}

  	/**
  	 * Sets the vector components to the position elements of the
  	 * given transformation matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];
  		this.w = e[ 15 ];

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
  	 * value, replace that value with the corresponding min value.
  	 *
  	 * @param {Vector4} v - The vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
  	 * value, replace that value with the corresponding max value.
  	 *
  	 * @param {Vector4} v - The vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
  	 * value, it is replaced by the corresponding value.
  	 * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
  	 * it is replaced by the corresponding value.
  	 *
  	 * @param {Vector4} min - The minimum x, y and z values.
  	 * @param {Vector4} max - The maximum x, y and z values in the desired range.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = clamp$1( this.x, min.x, max.x );
  		this.y = clamp$1( this.y, min.y, max.y );
  		this.z = clamp$1( this.z, min.z, max.z );
  		this.w = clamp$1( this.w, min.w, max.w );

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w values are greater than the max value, they are
  	 * replaced by the max value.
  	 * If this vector's x, y, z or w values are less than the min value, they are
  	 * replaced by the min value.
  	 *
  	 * @param {number} minVal - The minimum value the components will be clamped to.
  	 * @param {number} maxVal - The maximum value the components will be clamped to.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	clampScalar( minVal, maxVal ) {

  		this.x = clamp$1( this.x, minVal, maxVal );
  		this.y = clamp$1( this.y, minVal, maxVal );
  		this.z = clamp$1( this.z, minVal, maxVal );
  		this.w = clamp$1( this.w, minVal, maxVal );

  		return this;

  	}

  	/**
  	 * If this vector's length is greater than the max value, it is replaced by
  	 * the max value.
  	 * If this vector's length is less than the min value, it is replaced by the
  	 * min value.
  	 *
  	 * @param {number} min - The minimum value the vector length will be clamped to.
  	 * @param {number} max - The maximum value the vector length will be clamped to.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( clamp$1( length, min, max ) );

  	}

  	/**
  	 * The components of this vector are rounded down to the nearest integer value.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded up to the nearest integer value.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded to the nearest integer value
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded towards zero (up if negative,
  	 * down if positive) to an integer value.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );
  		this.w = Math.trunc( this.w );

  		return this;

  	}

  	/**
  	 * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	}

  	/**
  	 * Calculates the dot product of the given vector with this instance.
  	 *
  	 * @param {Vector4} v - The vector to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	}

  	/**
  	 * Computes the square of the Euclidean length (straight-line length) from
  	 * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
  	 * compare the length squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @return {number} The square length of this vector.
  	 */
  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	}

  	/**
  	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	}

  	/**
  	 * Computes the Manhattan length of this vector.
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	}

  	/**
  	 * Converts this vector to a unit vector - that is, sets it equal to a vector
  	 * with the same direction as this one, but with a vector length of `1`.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	/**
  	 * Sets this vector to a vector with the same direction as this one, but
  	 * with the specified length.
  	 *
  	 * @param {number} length - The new length of this vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	/**
  	 * Linearly interpolates between the given vector and this instance, where
  	 * alpha is the percent distance along the line - alpha = 0 will be this
  	 * vector, and alpha = 1 will be the given one.
  	 *
  	 * @param {Vector4} v - The vector to interpolate towards.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given vectors, where alpha is the percent
  	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
  	 * be the second one. The result is stored in this instance.
  	 *
  	 * @param {Vector4} v1 - The first vector.
  	 * @param {Vector4} v2 - The second vector.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;
  		this.w = v1.w + ( v2.w - v1.w ) * alpha;

  		return this;

  	}

  	/**
  	 * Returns `true` if this vector is equal with the given one.
  	 *
  	 * @param {Vector4} v - The vector to test for equality.
  	 * @return {boolean} Whether this vector is equal with the given one.
  	 */
  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	}

  	/**
  	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
  	 * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
  	 *
  	 * @param {Array<number>} array - An array holding the vector component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	}

  	/**
  	 * Writes the components of this vector to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The vector components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	}

  	/**
  	 * Sets the components of this vector from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  	/**
  	 * Sets each component of this vector to a pseudo-random value between `0` and
  	 * `1`, excluding `1`.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();
  		this.w = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;
  		yield this.w;

  	}

  }

  /**
   * A render target is a buffer where the video card draws pixels for a scene
   * that is being rendered in the background. It is used in different effects,
   * such as applying postprocessing to a rendered image before displaying it
   * on the screen.
   *
   * @augments EventDispatcher
   */
  class RenderTarget extends EventDispatcher {

  	/**
  	 * Render target options.
  	 *
  	 * @typedef {Object} RenderTarget~Options
  	 * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
  	 * @property {number} [magFilter=LinearFilter] - The mag filter.
  	 * @property {number} [minFilter=LinearFilter] - The min filter.
  	 * @property {number} [format=RGBAFormat] - The texture format.
  	 * @property {number} [type=UnsignedByteType] - The texture type.
  	 * @property {?string} [internalFormat=null] - The texture's internal format.
  	 * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
  	 * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
  	 * @property {number} [anisotropy=1] - The texture's anisotropy value.
  	 * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
  	 * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
  	 * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
  	 * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
  	 * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
  	 * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
  	 * @property {number} [samples=0] - The MSAA samples count.
  	 * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
  	 * @property {number} [depth=1] - The texture depth.
  	 * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
  	 */

  	/**
  	 * Constructs a new render target.
  	 *
  	 * @param {number} [width=1] - The width of the render target.
  	 * @param {number} [height=1] - The height of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( width = 1, height = 1, options = {} ) {

  		super();

  		options = Object.assign( {
  			generateMipmaps: false,
  			internalFormat: null,
  			minFilter: LinearFilter,
  			depthBuffer: true,
  			stencilBuffer: false,
  			resolveDepthBuffer: true,
  			resolveStencilBuffer: true,
  			depthTexture: null,
  			samples: 0,
  			count: 1,
  			depth: 1,
  			multiview: false
  		}, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRenderTarget = true;

  		/**
  		 * The width of the render target.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.width = width;

  		/**
  		 * The height of the render target.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.height = height;

  		/**
  		 * The depth of the render target.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.depth = options.depth;

  		/**
  		 * A rectangular area inside the render target's viewport. Fragments that are
  		 * outside the area will be discarded.
  		 *
  		 * @type {Vector4}
  		 * @default (0,0,width,height)
  		 */
  		this.scissor = new Vector4( 0, 0, width, height );

  		/**
  		 * Indicates whether the scissor test should be enabled when rendering into
  		 * this render target or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.scissorTest = false;

  		/**
  		 * A rectangular area representing the render target's viewport.
  		 *
  		 * @type {Vector4}
  		 * @default (0,0,width,height)
  		 */
  		this.viewport = new Vector4( 0, 0, width, height );

  		const image = { width: width, height: height, depth: options.depth };

  		const texture = new Texture( image );

  		/**
  		 * An array of textures. Each color attachment is represented as a separate texture.
  		 * Has at least a single entry for the default color attachment.
  		 *
  		 * @type {Array<Texture>}
  		 */
  		this.textures = [];

  		const count = options.count;
  		for ( let i = 0; i < count; i ++ ) {

  			this.textures[ i ] = texture.clone();
  			this.textures[ i ].isRenderTargetTexture = true;
  			this.textures[ i ].renderTarget = this;

  		}

  		this._setTextureOptions( options );

  		/**
  		 * Whether to allocate a depth buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depthBuffer = options.depthBuffer;

  		/**
  		 * Whether to allocate a stencil buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.stencilBuffer = options.stencilBuffer;

  		/**
  		 * Whether to resolve the depth buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.resolveDepthBuffer = options.resolveDepthBuffer;

  		/**
  		 * Whether to resolve the stencil buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.resolveStencilBuffer = options.resolveStencilBuffer;

  		this._depthTexture = null;
  		this.depthTexture = options.depthTexture;

  		/**
  		 * The number of MSAA samples.
  		 *
  		 * A value of `0` disables MSAA.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.samples = options.samples;

  		/**
  		 * Whether to this target is used in multiview rendering.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.multiview = options.multiview;

  	}

  	_setTextureOptions( options = {} ) {

  		const values = {
  			minFilter: LinearFilter,
  			generateMipmaps: false,
  			flipY: false,
  			internalFormat: null
  		};

  		if ( options.mapping !== undefined ) values.mapping = options.mapping;
  		if ( options.wrapS !== undefined ) values.wrapS = options.wrapS;
  		if ( options.wrapT !== undefined ) values.wrapT = options.wrapT;
  		if ( options.wrapR !== undefined ) values.wrapR = options.wrapR;
  		if ( options.magFilter !== undefined ) values.magFilter = options.magFilter;
  		if ( options.minFilter !== undefined ) values.minFilter = options.minFilter;
  		if ( options.format !== undefined ) values.format = options.format;
  		if ( options.type !== undefined ) values.type = options.type;
  		if ( options.anisotropy !== undefined ) values.anisotropy = options.anisotropy;
  		if ( options.colorSpace !== undefined ) values.colorSpace = options.colorSpace;
  		if ( options.flipY !== undefined ) values.flipY = options.flipY;
  		if ( options.generateMipmaps !== undefined ) values.generateMipmaps = options.generateMipmaps;
  		if ( options.internalFormat !== undefined ) values.internalFormat = options.internalFormat;

  		for ( let i = 0; i < this.textures.length; i ++ ) {

  			const texture = this.textures[ i ];
  			texture.setValues( values );

  		}

  	}

  	/**
  	 * The texture representing the default color attachment.
  	 *
  	 * @type {Texture}
  	 */
  	get texture() {

  		return this.textures[ 0 ];

  	}

  	set texture( value ) {

  		this.textures[ 0 ] = value;

  	}

  	set depthTexture( current ) {

  		if ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;
  		if ( current !== null ) current.renderTarget = this;

  		this._depthTexture = current;

  	}

  	/**
  	 * Instead of saving the depth in a renderbuffer, a texture
  	 * can be used instead which is useful for further processing
  	 * e.g. in context of post-processing.
  	 *
  	 * @type {?DepthTexture}
  	 * @default null
  	 */
  	get depthTexture() {

  		return this._depthTexture;

  	}

  	/**
  	 * Sets the size of this render target.
  	 *
  	 * @param {number} width - The width.
  	 * @param {number} height - The height.
  	 * @param {number} [depth=1] - The depth.
  	 */
  	setSize( width, height, depth = 1 ) {

  		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

  			this.width = width;
  			this.height = height;
  			this.depth = depth;

  			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

  				this.textures[ i ].image.width = width;
  				this.textures[ i ].image.height = height;
  				this.textures[ i ].image.depth = depth;
  				this.textures[ i ].isArrayTexture = this.textures[ i ].image.depth > 1;

  			}

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	}

  	/**
  	 * Returns a new render target with copied values from this instance.
  	 *
  	 * @return {RenderTarget} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the settings of the given render target. This is a structural copy so
  	 * no resources are shared between render targets after the copy. That includes
  	 * all MRT textures and the depth texture.
  	 *
  	 * @param {RenderTarget} source - The render target to copy.
  	 * @return {RenderTarget} A reference to this instance.
  	 */
  	copy( source ) {

  		this.width = source.width;
  		this.height = source.height;
  		this.depth = source.depth;

  		this.scissor.copy( source.scissor );
  		this.scissorTest = source.scissorTest;

  		this.viewport.copy( source.viewport );

  		this.textures.length = 0;

  		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

  			this.textures[ i ] = source.textures[ i ].clone();
  			this.textures[ i ].isRenderTargetTexture = true;
  			this.textures[ i ].renderTarget = this;

  			// ensure image object is not shared, see #20328

  			const image = Object.assign( {}, source.textures[ i ].image );
  			this.textures[ i ].source = new Source( image );

  		}

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;

  		this.resolveDepthBuffer = source.resolveDepthBuffer;
  		this.resolveStencilBuffer = source.resolveStencilBuffer;

  		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

  		this.samples = source.samples;

  		return this;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires RenderTarget#dispose
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  /**
   * A render target used in context of {@link WebGLRenderer}.
   *
   * @augments RenderTarget
   */
  class WebGLRenderTarget extends RenderTarget {

  	/**
  	 * Constructs a new 3D render target.
  	 *
  	 * @param {number} [width=1] - The width of the render target.
  	 * @param {number} [height=1] - The height of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( width = 1, height = 1, options = {} ) {

  		super( width, height, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGLRenderTarget = true;

  	}

  }

  /**
   * Creates an array of textures directly from raw buffer data.
   *
   * @augments Texture
   */
  class DataArrayTexture extends Texture {

  	/**
  	 * Constructs a new data array texture.
  	 *
  	 * @param {?TypedArray} [data=null] - The buffer data.
  	 * @param {number} [width=1] - The width of the texture.
  	 * @param {number} [height=1] - The height of the texture.
  	 * @param {number} [depth=1] - The depth of the texture.
  	 */
  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		super( null );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDataArrayTexture = true;

  		/**
  		 * The image definition of a data texture.
  		 *
  		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
  		 */
  		this.image = { data, width, height, depth };

  		/**
  		 * How the texture is sampled when a texel covers more than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.magFilter = NearestFilter;

  		/**
  		 * How the texture is sampled when a texel covers less than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.minFilter = NearestFilter;

  		/**
  		 * This defines how the texture is wrapped in the depth and corresponds to
  		 * *W* in UVW mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapR = ClampToEdgeWrapping;

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 *
  		 * Overwritten and set to `1` by default.
  		 *
  		 * @type {boolean}
  		 * @default 1
  		 */
  		this.unpackAlignment = 1;

  		/**
  		 * A set of all layers which need to be updated in the texture.
  		 *
  		 * @type {Set<number>}
  		 */
  		this.layerUpdates = new Set();

  	}

  	/**
  	 * Describes that a specific layer of the texture needs to be updated.
  	 * Normally when {@link Texture#needsUpdate} is set to `true`, the
  	 * entire data texture array is sent to the GPU. Marking specific
  	 * layers will only transmit subsets of all mipmaps associated with a
  	 * specific depth in the array which is often much more performant.
  	 *
  	 * @param {number} layerIndex - The layer index that should be updated.
  	 */
  	addLayerUpdate( layerIndex ) {

  		this.layerUpdates.add( layerIndex );

  	}

  	/**
  	 * Resets the layer updates registry.
  	 */
  	clearLayerUpdates() {

  		this.layerUpdates.clear();

  	}

  }

  /**
   * Represents an axis-aligned bounding box (AABB) in 3D space.
   */
  class Box3 {

  	/**
  	 * Constructs a new bounding box.
  	 *
  	 * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
  	 * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
  	 */
  	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBox3 = true;

  		/**
  		 * The lower boundary of the box.
  		 *
  		 * @type {Vector3}
  		 */
  		this.min = min;

  		/**
  		 * The upper boundary of the box.
  		 *
  		 * @type {Vector3}
  		 */
  		this.max = max;

  	}

  	/**
  	 * Sets the lower and upper boundaries of this box.
  	 * Please note that this method only copies the values from the given objects.
  	 *
  	 * @param {Vector3} min - The lower boundary of the box.
  	 * @param {Vector3} max - The upper boundary of the box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	set( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	}

  	/**
  	 * Sets the upper and lower bounds of this box so it encloses the position data
  	 * in the given array.
  	 *
  	 * @param {Array<number>} array - An array holding 3D position data.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromArray( array ) {

  		this.makeEmpty();

  		for ( let i = 0, il = array.length; i < il; i += 3 ) {

  			this.expandByPoint( _vector$b.fromArray( array, i ) );

  		}

  		return this;

  	}

  	/**
  	 * Sets the upper and lower bounds of this box so it encloses the position data
  	 * in the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromBufferAttribute( attribute ) {

  		this.makeEmpty();

  		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

  			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

  		}

  		return this;

  	}

  	/**
  	 * Sets the upper and lower bounds of this box so it encloses the position data
  	 * in the given array.
  	 *
  	 * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromPoints( points ) {

  		this.makeEmpty();

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	}

  	/**
  	 * Centers this box on the given center vector and sets this box's width, height and
  	 * depth to the given size values.
  	 *
  	 * @param {Vector3} center - The center of the box.
  	 * @param {Vector3} size - The x, y and z dimensions of the box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromCenterAndSize( center, size ) {

  		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

  		this.min.copy( center ).sub( halfSize );
  		this.max.copy( center ).add( halfSize );

  		return this;

  	}

  	/**
  	 * Computes the world-axis-aligned bounding box for the given 3D object
  	 * (including its children), accounting for the object's, and children's,
  	 * world transforms. The function may result in a larger box than strictly necessary.
  	 *
  	 * @param {Object3D} object - The 3D object to compute the bounding box for.
  	 * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
  	 * world-axis-aligned bounding box at the expense of more computation.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromObject( object, precise = false ) {

  		this.makeEmpty();

  		return this.expandByObject( object, precise );

  	}

  	/**
  	 * Returns a new box with copied values from this instance.
  	 *
  	 * @return {Box3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given box to this instance.
  	 *
  	 * @param {Box3} box - The box to copy.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	copy( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	}

  	/**
  	 * Makes this box empty which means in encloses a zero space in 3D.
  	 *
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	makeEmpty() {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	}

  	/**
  	 * Returns true if this box includes zero points within its bounds.
  	 * Note that a box with equal lower and upper bounds still includes one
  	 * point, the one both bounds share.
  	 *
  	 * @return {boolean} Whether this box is empty or not.
  	 */
  	isEmpty() {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	}

  	/**
  	 * Returns the center point of this box.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The center point.
  	 */
  	getCenter( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	}

  	/**
  	 * Returns the dimensions of this box.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The size.
  	 */
  	getSize( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  	}

  	/**
  	 * Expands the boundaries of this box to include the given point.
  	 *
  	 * @param {Vector3} point - The point that should be included by the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByPoint( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	}

  	/**
  	 * Expands this box equilaterally by the given vector. The width of this
  	 * box will be expanded by the x component of the vector in both
  	 * directions. The height of this box will be expanded by the y component of
  	 * the vector in both directions. The depth of this box will be
  	 * expanded by the z component of the vector in both directions.
  	 *
  	 * @param {Vector3} vector - The vector that should expand the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByVector( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	}

  	/**
  	 * Expands each dimension of the box by the given scalar. If negative, the
  	 * dimensions of the box will be contracted.
  	 *
  	 * @param {number} scalar - The scalar value that should expand the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByScalar( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	}

  	/**
  	 * Expands the boundaries of this box to include the given 3D object and
  	 * its children, accounting for the object's, and children's, world
  	 * transforms. The function may result in a larger box than strictly
  	 * necessary (unless the precise parameter is set to true).
  	 *
  	 * @param {Object3D} object - The 3D object that should expand the bounding box.
  	 * @param {boolean} precise - If set to `true`, the method expands the bounding box
  	 * as little as necessary at the expense of more computation.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByObject( object, precise = false ) {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		object.updateWorldMatrix( false, false );

  		const geometry = object.geometry;

  		if ( geometry !== undefined ) {

  			const positionAttribute = geometry.getAttribute( 'position' );

  			// precise AABB computation based on vertex data requires at least a position attribute.
  			// instancing isn't supported so far and uses the normal (conservative) code path.

  			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

  				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

  					if ( object.isMesh === true ) {

  						object.getVertexPosition( i, _vector$b );

  					} else {

  						_vector$b.fromBufferAttribute( positionAttribute, i );

  					}

  					_vector$b.applyMatrix4( object.matrixWorld );
  					this.expandByPoint( _vector$b );

  				}

  			} else {

  				if ( object.boundingBox !== undefined ) {

  					// object-level bounding box

  					if ( object.boundingBox === null ) {

  						object.computeBoundingBox();

  					}

  					_box$4.copy( object.boundingBox );


  				} else {

  					// geometry-level bounding box

  					if ( geometry.boundingBox === null ) {

  						geometry.computeBoundingBox();

  					}

  					_box$4.copy( geometry.boundingBox );

  				}

  				_box$4.applyMatrix4( object.matrixWorld );

  				this.union( _box$4 );

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this.expandByObject( children[ i ], precise );

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if the given point lies within or on the boundaries of this box.
  	 *
  	 * @param {Vector3} point - The point to test.
  	 * @return {boolean} Whether the bounding box contains the given point or not.
  	 */
  	containsPoint( point ) {

  		return point.x >= this.min.x && point.x <= this.max.x &&
  			point.y >= this.min.y && point.y <= this.max.y &&
  			point.z >= this.min.z && point.z <= this.max.z;

  	}

  	/**
  	 * Returns `true` if this bounding box includes the entirety of the given bounding box.
  	 * If this box and the given one are identical, this function also returns `true`.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the bounding box contains the given bounding box or not.
  	 */
  	containsBox( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	}

  	/**
  	 * Returns a point as a proportion of this box's width, height and depth.
  	 *
  	 * @param {Vector3} point - A point in 3D space.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} A point as a proportion of this box's width, height and depth.
  	 */
  	getParameter( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	}

  	/**
  	 * Returns `true` if the given bounding box intersects with this bounding box.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the given bounding box intersects with this bounding box.
  	 */
  	intersectsBox( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
  			box.max.y >= this.min.y && box.min.y <= this.max.y &&
  			box.max.z >= this.min.z && box.min.z <= this.max.z;

  	}

  	/**
  	 * Returns `true` if the given bounding sphere intersects with this bounding box.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
  	 */
  	intersectsSphere( sphere ) {

  		// Find the point on the AABB closest to the sphere center.
  		this.clampPoint( sphere.center, _vector$b );

  		// If that point is inside the sphere, the AABB and sphere intersect.
  		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	/**
  	 * Returns `true` if the given plane intersects with this bounding box.
  	 *
  	 * @param {Plane} plane - The plane to test.
  	 * @return {boolean} Whether the given plane intersects with this bounding box.
  	 */
  	intersectsPlane( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		let min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= - plane.constant && max >= - plane.constant );

  	}

  	/**
  	 * Returns `true` if the given triangle intersects with this bounding box.
  	 *
  	 * @param {Triangle} triangle - The triangle to test.
  	 * @return {boolean} Whether the given triangle intersects with this bounding box.
  	 */
  	intersectsTriangle( triangle ) {

  		if ( this.isEmpty() ) {

  			return false;

  		}

  		// compute box center and extents
  		this.getCenter( _center );
  		_extents.subVectors( this.max, _center );

  		// translate triangle to aabb origin
  		_v0$2.subVectors( triangle.a, _center );
  		_v1$7.subVectors( triangle.b, _center );
  		_v2$4.subVectors( triangle.c, _center );

  		// compute edge vectors for triangle
  		_f0.subVectors( _v1$7, _v0$2 );
  		_f1.subVectors( _v2$4, _v1$7 );
  		_f2.subVectors( _v0$2, _v2$4 );

  		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  		let axes = [
  			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
  			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
  			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
  		];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// test 3 face normals from the aabb
  		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// finally testing the face normal of the triangle
  		// use already existing triangle edge vectors here
  		_triangleNormal.crossVectors( _f0, _f1 );
  		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

  		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

  	}

  	/**
  	 * Clamps the given point within the bounds of this box.
  	 *
  	 * @param {Vector3} point - The point to clamp.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The clamped point.
  	 */
  	clampPoint( point, target ) {

  		return target.copy( point ).clamp( this.min, this.max );

  	}

  	/**
  	 * Returns the euclidean distance from any edge of this box to the specified point. If
  	 * the given point lies inside of this box, the distance will be `0`.
  	 *
  	 * @param {Vector3} point - The point to compute the distance to.
  	 * @return {number} The euclidean distance.
  	 */
  	distanceToPoint( point ) {

  		return this.clampPoint( point, _vector$b ).distanceTo( point );

  	}

  	/**
  	 * Returns a bounding sphere that encloses this bounding box.
  	 *
  	 * @param {Sphere} target - The target sphere that is used to store the method's result.
  	 * @return {Sphere} The bounding sphere that encloses this bounding box.
  	 */
  	getBoundingSphere( target ) {

  		if ( this.isEmpty() ) {

  			target.makeEmpty();

  		} else {

  			this.getCenter( target.center );

  			target.radius = this.getSize( _vector$b ).length() * 0.5;

  		}

  		return target;

  	}

  	/**
  	 * Computes the intersection of this bounding box and the given one, setting the upper
  	 * bound of this box to the lesser of the two boxes' upper bounds and the
  	 * lower bound of this box to the greater of the two boxes' lower bounds. If
  	 * there's no overlap, makes this box empty.
  	 *
  	 * @param {Box3} box - The bounding box to intersect with.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	intersect( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) this.makeEmpty();

  		return this;

  	}

  	/**
  	 * Computes the union of this box and another and the given one, setting the upper
  	 * bound of this box to the greater of the two boxes' upper bounds and the
  	 * lower bound of this box to the lesser of the two boxes' lower bounds.
  	 *
  	 * @param {Box3} box - The bounding box that will be unioned with this instance.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	union( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	}

  	/**
  	 * Transforms this bounding box by the given 4x4 transformation matrix.
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	applyMatrix4( matrix ) {

  		// transform of empty box is an empty box.
  		if ( this.isEmpty() ) return this;

  		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  		this.setFromPoints( _points );

  		return this;

  	}

  	/**
  	 * Adds the given offset to both the upper and lower bounds of this bounding box,
  	 * effectively moving it in 3D space.
  	 *
  	 * @param {Vector3} offset - The offset that should be used to translate the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	translate( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	}

  	/**
  	 * Returns `true` if this bounding box is equal with the given one.
  	 *
  	 * @param {Box3} box - The box to test for equality.
  	 * @return {boolean} Whether this bounding box is equal with the given one.
  	 */
  	equals( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  	/**
  	 * Returns a serialized structure of the bounding box.
  	 *
  	 * @return {Object} Serialized structure with fields representing the object state.
  	 */
  	toJSON() {

  		return {
  			min: this.min.toArray(),
  			max: this.max.toArray()
  		};

  	}

  	/**
  	 * Returns a serialized structure of the bounding box.
  	 *
  	 * @param {Object} json - The serialized json to set the box from.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	fromJSON( json ) {

  		this.min.fromArray( json.min );
  		this.max.fromArray( json.max );
  		return this;

  	}

  }

  const _points = [
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3()
  ];

  const _vector$b = /*@__PURE__*/ new Vector3();

  const _box$4 = /*@__PURE__*/ new Box3();

  // triangle centered vertices

  const _v0$2 = /*@__PURE__*/ new Vector3();
  const _v1$7 = /*@__PURE__*/ new Vector3();
  const _v2$4 = /*@__PURE__*/ new Vector3();

  // triangle edge vectors

  const _f0 = /*@__PURE__*/ new Vector3();
  const _f1 = /*@__PURE__*/ new Vector3();
  const _f2 = /*@__PURE__*/ new Vector3();

  const _center = /*@__PURE__*/ new Vector3();
  const _extents = /*@__PURE__*/ new Vector3();
  const _triangleNormal = /*@__PURE__*/ new Vector3();
  const _testAxis = /*@__PURE__*/ new Vector3();

  function satForAxes( axes, v0, v1, v2, extents ) {

  	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  		_testAxis.fromArray( axes, i );
  		// project the aabb onto the separating axis
  		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
  		// project all 3 vertices of the triangle onto the separating axis
  		const p0 = v0.dot( _testAxis );
  		const p1 = v1.dot( _testAxis );
  		const p2 = v2.dot( _testAxis );
  		// actual test, basically see if either of the most extreme of the triangle points intersects r
  		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  			// points of the projected triangle are outside the projected half-length of the aabb
  			// the axis is separating and we can exit
  			return false;

  		}

  	}

  	return true;

  }

  const _box$3 = /*@__PURE__*/ new Box3();
  const _v1$6 = /*@__PURE__*/ new Vector3();
  const _v2$3 = /*@__PURE__*/ new Vector3();

  /**
   * An analytical 3D sphere defined by a center and radius. This class is mainly
   * used as a Bounding Sphere for 3D objects.
   */
  class Sphere {

  	/**
  	 * Constructs a new sphere.
  	 *
  	 * @param {Vector3} [center=(0,0,0)] - The center of the sphere
  	 * @param {number} [radius=-1] - The radius of the sphere.
  	 */
  	constructor( center = new Vector3(), radius = -1 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSphere = true;

  		/**
  		 * The center of the sphere
  		 *
  		 * @type {Vector3}
  		 */
  		this.center = center;

  		/**
  		 * The radius of the sphere.
  		 *
  		 * @type {number}
  		 */
  		this.radius = radius;

  	}

  	/**
  	 * Sets the sphere's components by copying the given values.
  	 *
  	 * @param {Vector3} center - The center.
  	 * @param {number} radius - The radius.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	set( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	}

  	/**
  	 * Computes the minimum bounding sphere for list of points.
  	 * If the optional center point is given, it is used as the sphere's
  	 * center. Otherwise, the center of the axis-aligned bounding box
  	 * encompassing the points is calculated.
  	 *
  	 * @param {Array<Vector3>} points - A list of points in 3D space.
  	 * @param {Vector3} [optionalCenter] - The center of the sphere.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	setFromPoints( points, optionalCenter ) {

  		const center = this.center;

  		if ( optionalCenter !== undefined ) {

  			center.copy( optionalCenter );

  		} else {

  			_box$3.setFromPoints( points ).getCenter( center );

  		}

  		let maxRadiusSq = 0;

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  		}

  		this.radius = Math.sqrt( maxRadiusSq );

  		return this;

  	}

  	/**
  	 * Copies the values of the given sphere to this instance.
  	 *
  	 * @param {Sphere} sphere - The sphere to copy.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	copy( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	}

  	/**
  	 * Returns `true` if the sphere is empty (the radius set to a negative number).
  	 *
  	 * Spheres with a radius of `0` contain only their center point and are not
  	 * considered to be empty.
  	 *
  	 * @return {boolean} Whether this sphere is empty or not.
  	 */
  	isEmpty() {

  		return ( this.radius < 0 );

  	}

  	/**
  	 * Makes this sphere empty which means in encloses a zero space in 3D.
  	 *
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	makeEmpty() {

  		this.center.set( 0, 0, 0 );
  		this.radius = -1;

  		return this;

  	}

  	/**
  	 * Returns `true` if this sphere contains the given point inclusive of
  	 * the surface of the sphere.
  	 *
  	 * @param {Vector3} point - The point to check.
  	 * @return {boolean} Whether this sphere contains the given point or not.
  	 */
  	containsPoint( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	}

  	/**
  	 * Returns the closest distance from the boundary of the sphere to the
  	 * given point. If the sphere contains the point, the distance will
  	 * be negative.
  	 *
  	 * @param {Vector3} point - The point to compute the distance to.
  	 * @return {number} The distance to the point.
  	 */
  	distanceToPoint( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	}

  	/**
  	 * Returns `true` if this sphere intersects with the given one.
  	 *
  	 * @param {Sphere} sphere - The sphere to test.
  	 * @return {boolean} Whether this sphere intersects with the given one or not.
  	 */
  	intersectsSphere( sphere ) {

  		const radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	}

  	/**
  	 * Returns `true` if this sphere intersects with the given box.
  	 *
  	 * @param {Box3} box - The box to test.
  	 * @return {boolean} Whether this sphere intersects with the given box or not.
  	 */
  	intersectsBox( box ) {

  		return box.intersectsSphere( this );

  	}

  	/**
  	 * Returns `true` if this sphere intersects with the given plane.
  	 *
  	 * @param {Plane} plane - The plane to test.
  	 * @return {boolean} Whether this sphere intersects with the given plane or not.
  	 */
  	intersectsPlane( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	}

  	/**
  	 * Clamps a point within the sphere. If the point is outside the sphere, it
  	 * will clamp it to the closest point on the edge of the sphere. Points
  	 * already inside the sphere will not be affected.
  	 *
  	 * @param {Vector3} point - The plane to clamp.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The clamped point.
  	 */
  	clampPoint( point, target ) {

  		const deltaLengthSq = this.center.distanceToSquared( point );

  		target.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			target.sub( this.center ).normalize();
  			target.multiplyScalar( this.radius ).add( this.center );

  		}

  		return target;

  	}

  	/**
  	 * Returns a bounding box that encloses this sphere.
  	 *
  	 * @param {Box3} target - The target box that is used to store the method's result.
  	 * @return {Box3} The bounding box that encloses this sphere.
  	 */
  	getBoundingBox( target ) {

  		if ( this.isEmpty() ) {

  			// Empty sphere produces empty bounding box
  			target.makeEmpty();
  			return target;

  		}

  		target.set( this.center, this.center );
  		target.expandByScalar( this.radius );

  		return target;

  	}

  	/**
  	 * Transforms this sphere with the given 4x4 transformation matrix.
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	applyMatrix4( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	}

  	/**
  	 * Translates the sphere's center by the given offset.
  	 *
  	 * @param {Vector3} offset - The offset.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	translate( offset ) {

  		this.center.add( offset );

  		return this;

  	}

  	/**
  	 * Expands the boundaries of this sphere to include the given point.
  	 *
  	 * @param {Vector3} point - The point to include.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	expandByPoint( point ) {

  		if ( this.isEmpty() ) {

  			this.center.copy( point );

  			this.radius = 0;

  			return this;

  		}

  		_v1$6.subVectors( point, this.center );

  		const lengthSq = _v1$6.lengthSq();

  		if ( lengthSq > ( this.radius * this.radius ) ) {

  			// calculate the minimal sphere

  			const length = Math.sqrt( lengthSq );

  			const delta = ( length - this.radius ) * 0.5;

  			this.center.addScaledVector( _v1$6, delta / length );

  			this.radius += delta;

  		}

  		return this;

  	}

  	/**
  	 * Expands this sphere to enclose both the original sphere and the given sphere.
  	 *
  	 * @param {Sphere} sphere - The sphere to include.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	union( sphere ) {

  		if ( sphere.isEmpty() ) {

  			return this;

  		}

  		if ( this.isEmpty() ) {

  			this.copy( sphere );

  			return this;

  		}

  		if ( this.center.equals( sphere.center ) === true ) {

  			 this.radius = Math.max( this.radius, sphere.radius );

  		} else {

  			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

  			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

  			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if this sphere is equal with the given one.
  	 *
  	 * @param {Sphere} sphere - The sphere to test for equality.
  	 * @return {boolean} Whether this bounding sphere is equal with the given one.
  	 */
  	equals( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  	/**
  	 * Returns a new sphere with copied values from this instance.
  	 *
  	 * @return {Sphere} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Returns a serialized structure of the bounding sphere.
  	 *
  	 * @return {Object} Serialized structure with fields representing the object state.
  	 */
  	toJSON() {

  		return {
  			radius: this.radius,
  			center: this.center.toArray()
  		};

  	}

  	/**
  	 * Returns a serialized structure of the bounding sphere.
  	 *
  	 * @param {Object} json - The serialized json to set the sphere from.
  	 * @return {Box3} A reference to this bounding sphere.
  	 */
  	fromJSON( json ) {

  		this.radius = json.radius;
  		this.center.fromArray( json.center );
  		return this;

  	}

  }

  const _vector$a = /*@__PURE__*/ new Vector3();
  const _segCenter = /*@__PURE__*/ new Vector3();
  const _segDir = /*@__PURE__*/ new Vector3();
  const _diff = /*@__PURE__*/ new Vector3();

  const _edge1 = /*@__PURE__*/ new Vector3();
  const _edge2 = /*@__PURE__*/ new Vector3();
  const _normal$1 = /*@__PURE__*/ new Vector3();

  /**
   * A ray that emits from an origin in a certain direction. The class is used by
   * {@link Raycaster} to assist with raycasting. Raycasting is used for
   * mouse picking (working out what objects in the 3D space the mouse is over)
   * amongst other things.
   */
  class Ray {

  	/**
  	 * Constructs a new ray.
  	 *
  	 * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
  	 * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
  	 */
  	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {

  		/**
  		 * The origin of the ray.
  		 *
  		 * @type {Vector3}
  		 */
  		this.origin = origin;

  		/**
  		 * The (normalized) direction of the ray.
  		 *
  		 * @type {Vector3}
  		 */
  		this.direction = direction;

  	}

  	/**
  	 * Sets the ray's components by copying the given values.
  	 *
  	 * @param {Vector3} origin - The origin.
  	 * @param {Vector3} direction - The direction.
  	 * @return {Ray} A reference to this ray.
  	 */
  	set( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	}

  	/**
  	 * Copies the values of the given ray to this instance.
  	 *
  	 * @param {Ray} ray - The ray to copy.
  	 * @return {Ray} A reference to this ray.
  	 */
  	copy( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	}

  	/**
  	 * Returns a vector that is located at a given distance along this ray.
  	 *
  	 * @param {number} t - The distance along the ray to retrieve a position for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} A position on the ray.
  	 */
  	at( t, target ) {

  		return target.copy( this.origin ).addScaledVector( this.direction, t );

  	}

  	/**
  	 * Adjusts the direction of the ray to point at the given vector in world space.
  	 *
  	 * @param {Vector3} v - The target position.
  	 * @return {Ray} A reference to this ray.
  	 */
  	lookAt( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	}

  	/**
  	 * Shift the origin of this ray along its direction by the given distance.
  	 *
  	 * @param {number} t - The distance along the ray to interpolate.
  	 * @return {Ray} A reference to this ray.
  	 */
  	recast( t ) {

  		this.origin.copy( this.at( t, _vector$a ) );

  		return this;

  	}

  	/**
  	 * Returns the point along this ray that is closest to the given point.
  	 *
  	 * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The closest point on this ray.
  	 */
  	closestPointToPoint( point, target ) {

  		target.subVectors( point, this.origin );

  		const directionDistance = target.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return target.copy( this.origin );

  		}

  		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  	}

  	/**
  	 * Returns the distance of the closest approach between this ray and the given point.
  	 *
  	 * @param {Vector3} point - A point in 3D space to compute the distance to.
  	 * @return {number} The distance.
  	 */
  	distanceToPoint( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	}

  	/**
  	 * Returns the squared distance of the closest approach between this ray and the given point.
  	 *
  	 * @param {Vector3} point - A point in 3D space to compute the distance to.
  	 * @return {number} The squared distance.
  	 */
  	distanceSqToPoint( point ) {

  		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

  		// point behind the ray

  		if ( directionDistance < 0 ) {

  			return this.origin.distanceToSquared( point );

  		}

  		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  		return _vector$a.distanceToSquared( point );

  	}

  	/**
  	 * Returns the squared distance between this ray and the given line segment.
  	 *
  	 * @param {Vector3} v0 - The start point of the line segment.
  	 * @param {Vector3} v1 - The end point of the line segment.
  	 * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
  	 * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
  	 * @return {number} The squared distance.
  	 */
  	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
  		// It returns the min distance between the ray and the segment
  		// defined by v0 and v1
  		// It can also set two optional targets :
  		// - The closest point on the ray
  		// - The closest point on the segment

  		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  		_segDir.copy( v1 ).sub( v0 ).normalize();
  		_diff.copy( this.origin ).sub( _segCenter );

  		const segExtent = v0.distanceTo( v1 ) * 0.5;
  		const a01 = - this.direction.dot( _segDir );
  		const b0 = _diff.dot( this.direction );
  		const b1 = - _diff.dot( _segDir );
  		const c = _diff.lengthSq();
  		const det = Math.abs( 1 - a01 * a01 );
  		let s0, s1, sqrDist, extDet;

  		if ( det > 0 ) {

  			// The ray and segment are not parallel.

  			s0 = a01 * b1 - b0;
  			s1 = a01 * b0 - b1;
  			extDet = segExtent * det;

  			if ( s0 >= 0 ) {

  				if ( s1 >= - extDet ) {

  					if ( s1 <= extDet ) {

  						// region 0
  						// Minimum at interior points of ray and segment.

  						const invDet = 1 / det;
  						s0 *= invDet;
  						s1 *= invDet;
  						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  					} else {

  						// region 1

  						s1 = segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					// region 5

  					s1 = - segExtent;
  					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			} else {

  				if ( s1 <= - extDet ) {

  					// region 4

  					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				} else if ( s1 <= extDet ) {

  					// region 3

  					s0 = 0;
  					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  				} else {

  					// region 2

  					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			}

  		} else {

  			// Ray and segment are parallel.

  			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  		}

  		if ( optionalPointOnRay ) {

  			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

  		}

  		if ( optionalPointOnSegment ) {

  			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

  		}

  		return sqrDist;

  	}

  	/**
  	 * Intersects this ray with the given sphere, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Sphere} sphere - The sphere to intersect.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectSphere( sphere, target ) {

  		_vector$a.subVectors( sphere.center, this.origin );
  		const tca = _vector$a.dot( this.direction );
  		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
  		const radius2 = sphere.radius * sphere.radius;

  		if ( d2 > radius2 ) return null;

  		const thc = Math.sqrt( radius2 - d2 );

  		// t0 = first intersect point - entrance on front of sphere
  		const t0 = tca - thc;

  		// t1 = second intersect point - exit point on back of sphere
  		const t1 = tca + thc;

  		// test to see if t1 is behind the ray - if so, return null
  		if ( t1 < 0 ) return null;

  		// test to see if t0 is behind the ray:
  		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  		// in order to always return an intersect point that is in front of the ray.
  		if ( t0 < 0 ) return this.at( t1, target );

  		// else t0 is in front of the ray, so return the first collision point scaled by t0
  		return this.at( t0, target );

  	}

  	/**
  	 * Returns `true` if this ray intersects with the given sphere.
  	 *
  	 * @param {Sphere} sphere - The sphere to intersect.
  	 * @return {boolean} Whether this ray intersects with the given sphere or not.
  	 */
  	intersectsSphere( sphere ) {

  		if ( sphere.radius < 0 ) return false; // handle empty spheres, see #31187

  		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	/**
  	 * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
  	 * does not intersect with the plane.
  	 *
  	 * @param {Plane} plane - The plane to compute the distance to.
  	 * @return {?number} Whether this ray intersects with the given sphere or not.
  	 */
  	distanceToPlane( plane ) {

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	}

  	/**
  	 * Intersects this ray with the given plane, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Plane} plane - The plane to intersect.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectPlane( plane, target ) {

  		const t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, target );

  	}

  	/**
  	 * Returns `true` if this ray intersects with the given plane.
  	 *
  	 * @param {Plane} plane - The plane to intersect.
  	 * @return {boolean} Whether this ray intersects with the given plane or not.
  	 */
  	intersectsPlane( plane ) {

  		// check if the ray lies on the plane first

  		const distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	}

  	/**
  	 * Intersects this ray with the given bounding box, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Box3} box - The box to intersect.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectBox( box, target ) {

  		let tmin, tmax, tymin, tymax, tzmin, tzmax;

  		const invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		const origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

  		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) return null;

  		return this.at( tmin >= 0 ? tmin : tmax, target );

  	}

  	/**
  	 * Returns `true` if this ray intersects with the given box.
  	 *
  	 * @param {Box3} box - The box to intersect.
  	 * @return {boolean} Whether this ray intersects with the given box or not.
  	 */
  	intersectsBox( box ) {

  		return this.intersectBox( box, _vector$a ) !== null;

  	}

  	/**
  	 * Intersects this ray with the given triangle, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Vector3} a - The first vertex of the triangle.
  	 * @param {Vector3} b - The second vertex of the triangle.
  	 * @param {Vector3} c - The third vertex of the triangle.
  	 * @param {boolean} backfaceCulling - Whether to use backface culling or not.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectTriangle( a, b, c, backfaceCulling, target ) {

  		// Compute the offset origin, edges, and normal.

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  		_edge1.subVectors( b, a );
  		_edge2.subVectors( c, a );
  		_normal$1.crossVectors( _edge1, _edge2 );

  		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  		let DdN = this.direction.dot( _normal$1 );
  		let sign;

  		if ( DdN > 0 ) {

  			if ( backfaceCulling ) return null;
  			sign = 1;

  		} else if ( DdN < 0 ) {

  			sign = -1;
  			DdN = - DdN;

  		} else {

  			return null;

  		}

  		_diff.subVectors( this.origin, a );
  		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

  		// b1 < 0, no intersection
  		if ( DdQxE2 < 0 ) {

  			return null;

  		}

  		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

  		// b2 < 0, no intersection
  		if ( DdE1xQ < 0 ) {

  			return null;

  		}

  		// b1+b2 > 1, no intersection
  		if ( DdQxE2 + DdE1xQ > DdN ) {

  			return null;

  		}

  		// Line intersects triangle, check if ray does.
  		const QdN = - sign * _diff.dot( _normal$1 );

  		// t < 0, no intersection
  		if ( QdN < 0 ) {

  			return null;

  		}

  		// Ray intersects triangle.
  		return this.at( QdN / DdN, target );

  	}

  	/**
  	 * Transforms this ray with the given 4x4 transformation matrix.
  	 *
  	 * @param {Matrix4} matrix4 - The transformation matrix.
  	 * @return {Ray} A reference to this ray.
  	 */
  	applyMatrix4( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	}

  	/**
  	 * Returns `true` if this ray is equal with the given one.
  	 *
  	 * @param {Ray} ray - The ray to test for equality.
  	 * @return {boolean} Whether this ray is equal with the given one.
  	 */
  	equals( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  	/**
  	 * Returns a new ray with copied values from this instance.
  	 *
  	 * @return {Ray} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  /**
   * Represents a 4x4 matrix.
   *
   * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
   * For an introduction to transformation matrices as used in WebGL, check out [this tutorial]{@link https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices}
   *
   * This allows a 3D vector representing a point in 3D space to undergo
   * transformations such as translation, rotation, shear, scale, reflection,
   * orthogonal or perspective projection and so on, by being multiplied by the
   * matrix. This is known as `applying` the matrix to the vector.
   *
   * A Note on Row-Major and Column-Major Ordering:
   *
   * The constructor and {@link Matrix3#set} method take arguments in
   * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
   * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
   * This means that calling:
   * ```js
   * const m = new THREE.Matrix4();
   * m.set( 11, 12, 13, 14,
   *        21, 22, 23, 24,
   *        31, 32, 33, 34,
   *        41, 42, 43, 44 );
   * ```
   * will result in the elements array containing:
   * ```js
   * m.elements = [ 11, 21, 31, 41,
   *                12, 22, 32, 42,
   *                13, 23, 33, 43,
   *                14, 24, 34, 44 ];
   * ```
   * and internally all calculations are performed using column-major ordering.
   * However, as the actual ordering makes no difference mathematically and
   * most people are used to thinking about matrices in row-major order, the
   * three.js documentation shows matrices in row-major order. Just bear in
   * mind that if you are reading the source code, you'll have to take the
   * transpose of any matrices outlined here to make sense of the calculations.
   */
  class Matrix4 {

  	/**
  	 * Constructs a new 4x4 matrix. The arguments are supposed to be
  	 * in row-major order. If no arguments are provided, the constructor
  	 * initializes the matrix as an identity matrix.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n14] - 1-4 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n24] - 2-4 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 * @param {number} [n34] - 3-4 matrix element.
  	 * @param {number} [n41] - 4-1 matrix element.
  	 * @param {number} [n42] - 4-2 matrix element.
  	 * @param {number} [n43] - 4-3 matrix element.
  	 * @param {number} [n44] - 4-4 matrix element.
  	 */
  	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Matrix4.prototype.isMatrix4 = true;

  		/**
  		 * A column-major list of matrix values.
  		 *
  		 * @type {Array<number>}
  		 */
  		this.elements = [

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

  		}

  	}

  	/**
  	 * Sets the elements of the matrix.The arguments are supposed to be
  	 * in row-major order.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n14] - 1-4 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n24] - 2-4 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 * @param {number} [n34] - 3-4 matrix element.
  	 * @param {number} [n41] - 4-1 matrix element.
  	 * @param {number} [n42] - 4-2 matrix element.
  	 * @param {number} [n43] - 4-3 matrix element.
  	 * @param {number} [n44] - 4-4 matrix element.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	}

  	/**
  	 * Sets this matrix to the 4x4 identity matrix.
  	 *
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	identity() {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Returns a matrix with copied values from this instance.
  	 *
  	 * @return {Matrix4} A clone of this instance.
  	 */
  	clone() {

  		return new Matrix4().fromArray( this.elements );

  	}

  	/**
  	 * Copies the values of the given matrix to this instance.
  	 *
  	 * @param {Matrix4} m - The matrix to copy.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	}

  	/**
  	 * Copies the translation component of the given matrix
  	 * into this matrix's translation component.
  	 *
  	 * @param {Matrix4} m - The matrix to copy the translation component.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	copyPosition( m ) {

  		const te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	}

  	/**
  	 * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The 3x3 matrix.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	setFromMatrix3( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 3 ], me[ 6 ], 0,
  			me[ 1 ], me[ 4 ], me[ 7 ], 0,
  			me[ 2 ], me[ 5 ], me[ 8 ], 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Extracts the basis of this matrix into the three axis vectors provided.
  	 *
  	 * @param {Vector3} xAxis - The basis's x axis.
  	 * @param {Vector3} yAxis - The basis's y axis.
  	 * @param {Vector3} zAxis - The basis's z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	}

  	/**
  	 * Sets the given basis vectors to this matrix.
  	 *
  	 * @param {Vector3} xAxis - The basis's x axis.
  	 * @param {Vector3} yAxis - The basis's y axis.
  	 * @param {Vector3} zAxis - The basis's z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeBasis( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	}

  	/**
  	 * Extracts the rotation component of the given matrix
  	 * into this matrix's rotation component.
  	 *
  	 * Note: This method does not support reflection matrices.
  	 *
  	 * @param {Matrix4} m - The matrix.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	extractRotation( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
  		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
  		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

  		te[ 0 ] = me[ 0 ] * scaleX;
  		te[ 1 ] = me[ 1 ] * scaleX;
  		te[ 2 ] = me[ 2 ] * scaleX;
  		te[ 3 ] = 0;

  		te[ 4 ] = me[ 4 ] * scaleY;
  		te[ 5 ] = me[ 5 ] * scaleY;
  		te[ 6 ] = me[ 6 ] * scaleY;
  		te[ 7 ] = 0;

  		te[ 8 ] = me[ 8 ] * scaleZ;
  		te[ 9 ] = me[ 9 ] * scaleZ;
  		te[ 10 ] = me[ 10 ] * scaleZ;
  		te[ 11 ] = 0;

  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
  	 * the rotation specified by the given Euler angles. The rest of
  	 * the matrix is set to the identity. Depending on the {@link Euler#order},
  	 * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
  	 * for a complete list.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationFromEuler( euler ) {

  		const te = this.elements;

  		const x = euler.x, y = euler.y, z = euler.z;
  		const a = Math.cos( x ), b = Math.sin( x );
  		const c = Math.cos( y ), d = Math.sin( y );
  		const e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// bottom row
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// last column
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Sets the rotation component of this matrix to the rotation specified by
  	 * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
  	 * The rest of the matrix is set to the identity.
  	 *
  	 * @param {Quaternion} q - The Quaternion.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationFromQuaternion( q ) {

  		return this.compose( _zero, q, _one );

  	}

  	/**
  	 * Sets the rotation component of the transformation matrix, looking from `eye` towards
  	 * `target`, and oriented by the up-direction.
  	 *
  	 * @param {Vector3} eye - The eye vector.
  	 * @param {Vector3} target - The target vector.
  	 * @param {Vector3} up - The up vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	lookAt( eye, target, up ) {

  		const te = this.elements;

  		_z.subVectors( eye, target );

  		if ( _z.lengthSq() === 0 ) {

  			// eye and target are in the same position

  			_z.z = 1;

  		}

  		_z.normalize();
  		_x.crossVectors( up, _z );

  		if ( _x.lengthSq() === 0 ) {

  			// up and z are parallel

  			if ( Math.abs( up.z ) === 1 ) {

  				_z.x += 0.0001;

  			} else {

  				_z.z += 0.0001;

  			}

  			_z.normalize();
  			_x.crossVectors( up, _z );

  		}

  		_x.normalize();
  		_y.crossVectors( _z, _x );

  		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
  		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
  		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

  		return this;

  	}

  	/**
  	 * Post-multiplies this matrix by the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The matrix to multiply with.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	/**
  	 * Pre-multiplies this matrix by the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The matrix to multiply with.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	/**
  	 * Multiples the given 4x4 matrices and stores the result
  	 * in this matrix.
  	 *
  	 * @param {Matrix4} a - The first matrix.
  	 * @param {Matrix4} b - The second matrix.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	}

  	/**
  	 * Multiplies every component of the matrix by the given scalar.
  	 *
  	 * @param {number} s - The scalar.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	}

  	/**
  	 * Computes and returns the determinant of this matrix.
  	 *
  	 * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
  	 *
  	 * @return {number} The determinant.
  	 */
  	determinant() {

  		const te = this.elements;

  		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	}

  	/**
  	 * Transposes this matrix in place.
  	 *
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	transpose() {

  		const te = this.elements;
  		let tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	}

  	/**
  	 * Sets the position component for this matrix from the given vector,
  	 * without affecting the rest of the matrix.
  	 *
  	 * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
  	 * @param {number} y - The y component of the vector.
  	 * @param {number} z - The z component of the vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	setPosition( x, y, z ) {

  		const te = this.elements;

  		if ( x.isVector3 ) {

  			te[ 12 ] = x.x;
  			te[ 13 ] = x.y;
  			te[ 14 ] = x.z;

  		} else {

  			te[ 12 ] = x;
  			te[ 13 ] = y;
  			te[ 14 ] = z;

  		}

  		return this;

  	}

  	/**
  	 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
  	 * You can not invert with a determinant of zero. If you attempt this, the method produces
  	 * a zero matrix instead.
  	 *
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	invert() {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
  			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
  			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
  			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	}

  	/**
  	 * Multiplies the columns of this matrix by the given vector.
  	 *
  	 * @param {Vector3} v - The scale vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	scale( v ) {

  		const te = this.elements;
  		const x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	}

  	/**
  	 * Gets the maximum scale value of the three axes.
  	 *
  	 * @return {number} The maximum scale.
  	 */
  	getMaxScaleOnAxis() {

  		const te = this.elements;

  		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	}

  	/**
  	 * Sets this matrix as a translation transform from the given vector.
  	 *
  	 * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
  	 * @param {number} y - The amount to translate in the Y axis.
  	 * @param {number} z - The amount to translate in the z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeTranslation( x, y, z ) {

  		if ( x.isVector3 ) {

  			this.set(

  				1, 0, 0, x.x,
  				0, 1, 0, x.y,
  				0, 0, 1, x.z,
  				0, 0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, 0, x,
  				0, 1, 0, y,
  				0, 0, 1, z,
  				0, 0, 0, 1

  			);

  		}

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the X axis by
  	 * the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationX( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the Y axis by
  	 * the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationY( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the Z axis by
  	 * the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationZ( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the given axis by
  	 * the given angle.
  	 *
  	 * This is a somewhat controversial but mathematically sound alternative to
  	 * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
  	 *
  	 * @param {Vector3} axis - The normalized rotation axis.
  	 * @param {number} angle - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationAxis( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		const c = Math.cos( angle );
  		const s = Math.sin( angle );
  		const t = 1 - c;
  		const x = axis.x, y = axis.y, z = axis.z;
  		const tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a scale transformation.
  	 *
  	 * @param {number} x - The amount to scale in the X axis.
  	 * @param {number} y - The amount to scale in the Y axis.
  	 * @param {number} z - The amount to scale in the Z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeScale( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a shear transformation.
  	 *
  	 * @param {number} xy - The amount to shear X by Y.
  	 * @param {number} xz - The amount to shear X by Z.
  	 * @param {number} yx - The amount to shear Y by X.
  	 * @param {number} yz - The amount to shear Y by Z.
  	 * @param {number} zx - The amount to shear Z by X.
  	 * @param {number} zy - The amount to shear Z by Y.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeShear( xy, xz, yx, yz, zx, zy ) {

  		this.set(

  			1, yx, zx, 0,
  			xy, 1, zy, 0,
  			xz, yz, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix to the transformation composed of the given position,
  	 * rotation (Quaternion) and scale.
  	 *
  	 * @param {Vector3} position - The position vector.
  	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
  	 * @param {Vector3} scale - The scale vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	compose( position, quaternion, scale ) {

  		const te = this.elements;

  		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  		const x2 = x + x,	y2 = y + y, z2 = z + z;
  		const xx = x * x2, xy = x * y2, xz = x * z2;
  		const yy = y * y2, yz = y * z2, zz = z * z2;
  		const wx = w * x2, wy = w * y2, wz = w * z2;

  		const sx = scale.x, sy = scale.y, sz = scale.z;

  		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  		te[ 1 ] = ( xy + wz ) * sx;
  		te[ 2 ] = ( xz - wy ) * sx;
  		te[ 3 ] = 0;

  		te[ 4 ] = ( xy - wz ) * sy;
  		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  		te[ 6 ] = ( yz + wx ) * sy;
  		te[ 7 ] = 0;

  		te[ 8 ] = ( xz + wy ) * sz;
  		te[ 9 ] = ( yz - wx ) * sz;
  		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  		te[ 11 ] = 0;

  		te[ 12 ] = position.x;
  		te[ 13 ] = position.y;
  		te[ 14 ] = position.z;
  		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Decomposes this matrix into its position, rotation and scale components
  	 * and provides the result in the given objects.
  	 *
  	 * Note: Not all matrices are decomposable in this way. For example, if an
  	 * object has a non-uniformly scaled parent, then the object's world matrix
  	 * may not be decomposable, and this method may not be appropriate.
  	 *
  	 * @param {Vector3} position - The position vector.
  	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
  	 * @param {Vector3} scale - The scale vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	decompose( position, quaternion, scale ) {

  		const te = this.elements;

  		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  		// if determine is negative, we need to invert one scale
  		const det = this.determinant();
  		if ( det < 0 ) sx = - sx;

  		position.x = te[ 12 ];
  		position.y = te[ 13 ];
  		position.z = te[ 14 ];

  		// scale the rotation part
  		_m1$2.copy( this );

  		const invSX = 1 / sx;
  		const invSY = 1 / sy;
  		const invSZ = 1 / sz;

  		_m1$2.elements[ 0 ] *= invSX;
  		_m1$2.elements[ 1 ] *= invSX;
  		_m1$2.elements[ 2 ] *= invSX;

  		_m1$2.elements[ 4 ] *= invSY;
  		_m1$2.elements[ 5 ] *= invSY;
  		_m1$2.elements[ 6 ] *= invSY;

  		_m1$2.elements[ 8 ] *= invSZ;
  		_m1$2.elements[ 9 ] *= invSZ;
  		_m1$2.elements[ 10 ] *= invSZ;

  		quaternion.setFromRotationMatrix( _m1$2 );

  		scale.x = sx;
  		scale.y = sy;
  		scale.z = sz;

  		return this;

  	}

  	/**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.

  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

  		const te = this.elements;
  		const x = 2 * near / ( right - left );
  		const y = 2 * near / ( top - bottom );

  		const a = ( right + left ) / ( right - left );
  		const b = ( top + bottom ) / ( top - bottom );

  		let c, d;

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			c = - ( far + near ) / ( far - near );
  			d = ( -2 * far * near ) / ( far - near );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			c = - far / ( far - near );
  			d = ( - far * near ) / ( far - near );

  		} else {

  			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = -1;	te[ 15 ] = 0;

  		return this;

  	}

  	/**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.

  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

  		const te = this.elements;
  		const w = 1.0 / ( right - left );
  		const h = 1.0 / ( top - bottom );
  		const p = 1.0 / ( far - near );

  		const x = ( right + left ) * w;
  		const y = ( top + bottom ) * h;

  		let z, zInv;

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			z = ( far + near ) * p;
  			zInv = -2 * p;

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			z = near * p;
  			zInv = -1 * p;

  		} else {

  			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
  		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
  		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
  		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Returns `true` if this matrix is equal with the given one.
  	 *
  	 * @param {Matrix4} matrix - The matrix to test for equality.
  	 * @return {boolean} Whether this matrix is equal with the given one.
  	 */
  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	/**
  	 * Sets the elements of the matrix from the given array.
  	 *
  	 * @param {Array<number>} array - The matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 16; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	/**
  	 * Writes the elements of this matrix to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The matrix elements in column-major order.
  	 */
  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  }

  const _v1$5 = /*@__PURE__*/ new Vector3();
  const _m1$2 = /*@__PURE__*/ new Matrix4();
  const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
  const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
  const _x = /*@__PURE__*/ new Vector3();
  const _y = /*@__PURE__*/ new Vector3();
  const _z = /*@__PURE__*/ new Vector3();

  const _matrix$2 = /*@__PURE__*/ new Matrix4();
  const _quaternion$3 = /*@__PURE__*/ new Quaternion();

  /**
   * A class representing Euler angles.
   *
   * Euler angles describe a rotational transformation by rotating an object on
   * its various axes in specified amounts per axis, and a specified axis
   * order.
   *
   * Iterating through an instance will yield its components (x, y, z,
   * order) in the corresponding order.
   *
   * ```js
   * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
   * const b = new THREE.Vector3( 1, 0, 1 );
   * b.applyEuler(a);
   * ```
   */
  class Euler {

  	/**
  	 * Constructs a new euler instance.
  	 *
  	 * @param {number} [x=0] - The angle of the x axis in radians.
  	 * @param {number} [y=0] - The angle of the y axis in radians.
  	 * @param {number} [z=0] - The angle of the z axis in radians.
  	 * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
  	 */
  	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isEuler = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  	}

  	/**
  	 * The angle of the x axis in radians.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The angle of the y axis in radians.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The angle of the z axis in radians.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * A string representing the order that the rotations are applied.
  	 *
  	 * @type {string}
  	 * @default 'XYZ'
  	 */
  	get order() {

  		return this._order;

  	}

  	set order( value ) {

  		this._order = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * Sets the Euler components.
  	 *
  	 * @param {number} x - The angle of the x axis in radians.
  	 * @param {number} y - The angle of the y axis in radians.
  	 * @param {number} z - The angle of the z axis in radians.
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	set( x, y, z, order = this._order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Returns a new Euler instance with copied values from this instance.
  	 *
  	 * @return {Euler} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	}

  	/**
  	 * Copies the values of the given Euler instance to this instance.
  	 *
  	 * @param {Euler} euler - The Euler instance to copy.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	copy( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets the angles of this Euler instance from a pure rotation matrix.
  	 *
  	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	setFromRotationMatrix( m, order = this._order, update = true ) {

  		const te = m.elements;
  		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		switch ( order ) {

  			case 'XYZ':

  				this._y = Math.asin( clamp$1( m13, -1, 1 ) );

  				if ( Math.abs( m13 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m33 );
  					this._z = Math.atan2( - m12, m11 );

  				} else {

  					this._x = Math.atan2( m32, m22 );
  					this._z = 0;

  				}

  				break;

  			case 'YXZ':

  				this._x = Math.asin( - clamp$1( m23, -1, 1 ) );

  				if ( Math.abs( m23 ) < 0.9999999 ) {

  					this._y = Math.atan2( m13, m33 );
  					this._z = Math.atan2( m21, m22 );

  				} else {

  					this._y = Math.atan2( - m31, m11 );
  					this._z = 0;

  				}

  				break;

  			case 'ZXY':

  				this._x = Math.asin( clamp$1( m32, -1, 1 ) );

  				if ( Math.abs( m32 ) < 0.9999999 ) {

  					this._y = Math.atan2( - m31, m33 );
  					this._z = Math.atan2( - m12, m22 );

  				} else {

  					this._y = 0;
  					this._z = Math.atan2( m21, m11 );

  				}

  				break;

  			case 'ZYX':

  				this._y = Math.asin( - clamp$1( m31, -1, 1 ) );

  				if ( Math.abs( m31 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m33 );
  					this._z = Math.atan2( m21, m11 );

  				} else {

  					this._x = 0;
  					this._z = Math.atan2( - m12, m22 );

  				}

  				break;

  			case 'YZX':

  				this._z = Math.asin( clamp$1( m21, -1, 1 ) );

  				if ( Math.abs( m21 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m22 );
  					this._y = Math.atan2( - m31, m11 );

  				} else {

  					this._x = 0;
  					this._y = Math.atan2( m13, m33 );

  				}

  				break;

  			case 'XZY':

  				this._z = Math.asin( - clamp$1( m12, -1, 1 ) );

  				if ( Math.abs( m12 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m22 );
  					this._y = Math.atan2( m13, m11 );

  				} else {

  					this._x = Math.atan2( - m23, m33 );
  					this._y = 0;

  				}

  				break;

  			default:

  				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

  		}

  		this._order = order;

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets the angles of this Euler instance from a normalized quaternion.
  	 *
  	 * @param {Quaternion} q - A normalized Quaternion.
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	setFromQuaternion( q, order, update ) {

  		_matrix$2.makeRotationFromQuaternion( q );

  		return this.setFromRotationMatrix( _matrix$2, order, update );

  	}

  	/**
  	 * Sets the angles of this Euler instance from the given vector.
  	 *
  	 * @param {Vector3} v - The vector.
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	setFromVector3( v, order = this._order ) {

  		return this.set( v.x, v.y, v.z, order );

  	}

  	/**
  	 * Resets the euler angle with a new order by creating a quaternion from this
  	 * euler angle and then setting this euler angle with the quaternion and the
  	 * new order.
  	 *
  	 * Warning: This discards revolution information.
  	 *
  	 * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	reorder( newOrder ) {

  		_quaternion$3.setFromEuler( this );

  		return this.setFromQuaternion( _quaternion$3, newOrder );

  	}

  	/**
  	 * Returns `true` if this Euler instance is equal with the given one.
  	 *
  	 * @param {Euler} euler - The Euler instance to test for equality.
  	 * @return {boolean} Whether this Euler instance is equal with the given one.
  	 */
  	equals( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	}

  	/**
  	 * Sets this Euler instance's components to values from the given array. The first three
  	 * entries of the array are assign to the x,y and z components. An optional fourth entry
  	 * defines the Euler order.
  	 *
  	 * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	fromArray( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Writes the components of this Euler instance to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number,number,number,string>} The Euler components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._order;

  	}

  }

  /**
   * The default Euler angle order.
   *
   * @static
   * @type {string}
   * @default 'XYZ'
   */
  Euler.DEFAULT_ORDER = 'XYZ';

  /**
   * A layers object assigns an 3D object to 1 or more of 32
   * layers numbered `0` to `31` - internally the layers are stored as a
   * bit mask], and by default all 3D objects are a member of layer `0`.
   *
   * This can be used to control visibility - an object must share a layer with
   * a camera to be visible when that camera's view is
   * rendered.
   *
   * All classes that inherit from {@link Object3D} have an `layers` property which
   * is an instance of this class.
   */
  class Layers {

  	/**
  	 * Constructs a new layers instance, with membership
  	 * initially set to layer `0`.
  	 */
  	constructor() {

  		/**
  		 * A bit mask storing which of the 32 layers this layers object is currently
  		 * a member of.
  		 *
  		 * @type {number}
  		 */
  		this.mask = 1 | 0;

  	}

  	/**
  	 * Sets membership to the given layer, and remove membership all other layers.
  	 *
  	 * @param {number} layer - The layer to set.
  	 */
  	set( layer ) {

  		this.mask = ( 1 << layer | 0 ) >>> 0;

  	}

  	/**
  	 * Adds membership of the given layer.
  	 *
  	 * @param {number} layer - The layer to enable.
  	 */
  	enable( layer ) {

  		this.mask |= 1 << layer | 0;

  	}

  	/**
  	 * Adds membership to all layers.
  	 */
  	enableAll() {

  		this.mask = 0xffffffff | 0;

  	}

  	/**
  	 * Toggles the membership of the given layer.
  	 *
  	 * @param {number} layer - The layer to toggle.
  	 */
  	toggle( layer ) {

  		this.mask ^= 1 << layer | 0;

  	}

  	/**
  	 * Removes membership of the given layer.
  	 *
  	 * @param {number} layer - The layer to enable.
  	 */
  	disable( layer ) {

  		this.mask &= ~ ( 1 << layer | 0 );

  	}

  	/**
  	 * Removes the membership from all layers.
  	 */
  	disableAll() {

  		this.mask = 0;

  	}

  	/**
  	 * Returns `true` if this and the given layers object have at least one
  	 * layer in common.
  	 *
  	 * @param {Layers} layers - The layers to test.
  	 * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
  	 */
  	test( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  	/**
  	 * Returns `true` if the given layer is enabled.
  	 *
  	 * @param {number} layer - The layer to test.
  	 * @return {boolean } Whether the given layer is enabled or not.
  	 */
  	isEnabled( layer ) {

  		return ( this.mask & ( 1 << layer | 0 ) ) !== 0;

  	}

  }

  let _object3DId = 0;

  const _v1$4 = /*@__PURE__*/ new Vector3();
  const _q1 = /*@__PURE__*/ new Quaternion();
  const _m1$1$1 = /*@__PURE__*/ new Matrix4();
  const _target = /*@__PURE__*/ new Vector3();

  const _position$3 = /*@__PURE__*/ new Vector3();
  const _scale$2 = /*@__PURE__*/ new Vector3();
  const _quaternion$2 = /*@__PURE__*/ new Quaternion();

  const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
  const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

  /**
   * Fires when the object has been added to its parent object.
   *
   * @event Object3D#added
   * @type {Object}
   */
  const _addedEvent = { type: 'added' };

  /**
   * Fires when the object has been removed from its parent object.
   *
   * @event Object3D#removed
   * @type {Object}
   */
  const _removedEvent = { type: 'removed' };

  /**
   * Fires when a new child object has been added.
   *
   * @event Object3D#childadded
   * @type {Object}
   */
  const _childaddedEvent = { type: 'childadded', child: null };

  /**
   * Fires when a child object has been removed.
   *
   * @event Object3D#childremoved
   * @type {Object}
   */
  const _childremovedEvent = { type: 'childremoved', child: null };

  /**
   * This is the base class for most objects in three.js and provides a set of
   * properties and methods for manipulating objects in 3D space.
   *
   * @augments EventDispatcher
   */
  class Object3D extends EventDispatcher {

  	/**
  	 * Constructs a new 3D object.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isObject3D = true;

  		/**
  		 * The ID of the 3D object.
  		 *
  		 * @name Object3D#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

  		/**
  		 * The UUID of the 3D object.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the 3D object.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The type property is used for detecting the object type
  		 * in context of serialization/deserialization.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.type = 'Object3D';

  		/**
  		 * A reference to the parent object.
  		 *
  		 * @type {?Object3D}
  		 * @default null
  		 */
  		this.parent = null;

  		/**
  		 * An array holding the child 3D objects of this instance.
  		 *
  		 * @type {Array<Object3D>}
  		 */
  		this.children = [];

  		/**
  		 * Defines the `up` direction of the 3D object which influences
  		 * the orientation via methods like {@link Object3D#lookAt}.
  		 *
  		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.up = Object3D.DEFAULT_UP.clone();

  		const position = new Vector3();
  		const rotation = new Euler();
  		const quaternion = new Quaternion();
  		const scale = new Vector3( 1, 1, 1 );

  		function onRotationChange() {

  			quaternion.setFromEuler( rotation, false );

  		}

  		function onQuaternionChange() {

  			rotation.setFromQuaternion( quaternion, undefined, false );

  		}

  		rotation._onChange( onRotationChange );
  		quaternion._onChange( onQuaternionChange );

  		Object.defineProperties( this, {
  			/**
  			 * Represents the object's local position.
  			 *
  			 * @name Object3D#position
  			 * @type {Vector3}
  			 * @default (0,0,0)
  			 */
  			position: {
  				configurable: true,
  				enumerable: true,
  				value: position
  			},
  			/**
  			 * Represents the object's local rotation as Euler angles, in radians.
  			 *
  			 * @name Object3D#rotation
  			 * @type {Euler}
  			 * @default (0,0,0)
  			 */
  			rotation: {
  				configurable: true,
  				enumerable: true,
  				value: rotation
  			},
  			/**
  			 * Represents the object's local rotation as Quaternions.
  			 *
  			 * @name Object3D#quaternion
  			 * @type {Quaternion}
  			 */
  			quaternion: {
  				configurable: true,
  				enumerable: true,
  				value: quaternion
  			},
  			/**
  			 * Represents the object's local scale.
  			 *
  			 * @name Object3D#scale
  			 * @type {Vector3}
  			 * @default (1,1,1)
  			 */
  			scale: {
  				configurable: true,
  				enumerable: true,
  				value: scale
  			},
  			/**
  			 * Represents the object's model-view matrix.
  			 *
  			 * @name Object3D#modelViewMatrix
  			 * @type {Matrix4}
  			 */
  			modelViewMatrix: {
  				value: new Matrix4()
  			},
  			/**
  			 * Represents the object's normal matrix.
  			 *
  			 * @name Object3D#normalMatrix
  			 * @type {Matrix3}
  			 */
  			normalMatrix: {
  				value: new Matrix3()
  			}
  		} );

  		/**
  		 * Represents the object's transformation matrix in local space.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrix = new Matrix4();

  		/**
  		 * Represents the object's transformation matrix in world space.
  		 * If the 3D object has no parent, then it's identical to the local transformation matrix
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrixWorld = new Matrix4();

  		/**
  		 * When set to `true`, the engine automatically computes the local matrix from position,
  		 * rotation and scale every frame.
  		 *
  		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

  		/**
  		 * When set to `true`, the engine automatically computes the world matrix from the current local
  		 * matrix and the object's transformation hierarchy.
  		 *
  		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

  		/**
  		 * When set to `true`, it calculates the world matrix in that frame and resets this property
  		 * to `false`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.matrixWorldNeedsUpdate = false;

  		/**
  		 * The layer membership of the 3D object. The 3D object is only visible if it has
  		 * at least one layer in common with the camera in use. This property can also be
  		 * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
  		 *
  		 * @type {Layers}
  		 */
  		this.layers = new Layers();

  		/**
  		 * When set to `true`, the 3D object gets rendered.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.visible = true;

  		/**
  		 * When set to `true`, the 3D object gets rendered into shadow maps.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.castShadow = false;

  		/**
  		 * When set to `true`, the 3D object is affected by shadows in the scene.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.receiveShadow = false;

  		/**
  		 * When set to `true`, the 3D object is honored by view frustum culling.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.frustumCulled = true;

  		/**
  		 * This value allows the default rendering order of scene graph objects to be
  		 * overridden although opaque and transparent objects remain sorted independently.
  		 * When this property is set for an instance of {@link Group},all descendants
  		 * objects will be sorted and rendered together. Sorting is from lowest to highest
  		 * render order.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.renderOrder = 0;

  		/**
  		 * An array holding the animation clips of the 3D object.
  		 *
  		 * @type {Array<AnimationClip>}
  		 */
  		this.animations = [];

  		/**
  		 * Custom depth material to be used when rendering to the depth map. Can only be used
  		 * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
  		 * if you are modifying vertex positions in the vertex shader you must specify a custom depth
  		 * material for proper shadows.
  		 *
  		 * Only relevant in context of {@link WebGLRenderer}.
  		 *
  		 * @type {(Material|undefined)}
  		 * @default undefined
  		 */
  		this.customDepthMaterial = undefined;

  		/**
  		 * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
  		 *
  		 * Only relevant in context of {@link WebGLRenderer}.
  		 *
  		 * @type {(Material|undefined)}
  		 * @default undefined
  		 */
  		this.customDistanceMaterial = undefined;

  		/**
  		 * An object that can be used to store custom data about the 3D object. It
  		 * should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  	}

  	/**
  	 * A callback that is executed immediately before a 3D object is rendered to a shadow map.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {Camera} shadowCamera - The shadow camera.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} depthMaterial - The depth material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	/**
  	 * A callback that is executed immediately after a 3D object is rendered to a shadow map.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {Camera} shadowCamera - The shadow camera.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} depthMaterial - The depth material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	/**
  	 * A callback that is executed immediately before a 3D object is rendered.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	/**
  	 * A callback that is executed immediately after a 3D object is rendered.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	/**
  	 * Applies the given transformation matrix to the object and updates the object's position,
  	 * rotation and scale.
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 */
  	applyMatrix4( matrix ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		this.matrix.premultiply( matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	}

  	/**
  	 * Applies a rotation represented by given the quaternion to the 3D object.
  	 *
  	 * @param {Quaternion} q - The quaternion.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	applyQuaternion( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	}

  	/**
  	 * Sets the given rotation represented as an axis/angle couple to the 3D object.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} angle - The angle in radians.
  	 */
  	setRotationFromAxisAngle( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	}

  	/**
  	 * Sets the given rotation represented as Euler angles to the 3D object.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 */
  	setRotationFromEuler( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	}

  	/**
  	 * Sets the given rotation represented as rotation matrix to the 3D object.
  	 *
  	 * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
  	 * a pure rotation matrix (i.e, unscaled).
  	 */
  	setRotationFromMatrix( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	}

  	/**
  	 * Sets the given rotation represented as a Quaternion to the 3D object.
  	 *
  	 * @param {Quaternion} q - The Quaternion
  	 */
  	setRotationFromQuaternion( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	}

  	/**
  	 * Rotates the 3D object along an axis in local space.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateOnAxis( axis, angle ) {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.multiply( _q1 );

  		return this;

  	}

  	/**
  	 * Rotates the 3D object along an axis in world space.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateOnWorldAxis( axis, angle ) {

  		// rotate object on axis in world space
  		// axis is assumed to be normalized
  		// method assumes no rotated parent

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.premultiply( _q1 );

  		return this;

  	}

  	/**
  	 * Rotates the 3D object around its X axis in local space.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateX( angle ) {

  		return this.rotateOnAxis( _xAxis, angle );

  	}

  	/**
  	 * Rotates the 3D object around its Y axis in local space.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateY( angle ) {

  		return this.rotateOnAxis( _yAxis, angle );

  	}

  	/**
  	 * Rotates the 3D object around its Z axis in local space.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateZ( angle ) {

  		return this.rotateOnAxis( _zAxis, angle );

  	}

  	/**
  	 * Translate the 3D object by a distance along the given axis in local space.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateOnAxis( axis, distance ) {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

  		this.position.add( _v1$4.multiplyScalar( distance ) );

  		return this;

  	}

  	/**
  	 * Translate the 3D object by a distance along its X-axis in local space.
  	 *
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateX( distance ) {

  		return this.translateOnAxis( _xAxis, distance );

  	}

  	/**
  	 * Translate the 3D object by a distance along its Y-axis in local space.
  	 *
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateY( distance ) {

  		return this.translateOnAxis( _yAxis, distance );

  	}

  	/**
  	 * Translate the 3D object by a distance along its Z-axis in local space.
  	 *
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateZ( distance ) {

  		return this.translateOnAxis( _zAxis, distance );

  	}

  	/**
  	 * Converts the given vector from this 3D object's local space to world space.
  	 *
  	 * @param {Vector3} vector - The vector to convert.
  	 * @return {Vector3} The converted vector.
  	 */
  	localToWorld( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( this.matrixWorld );

  	}

  	/**
  	 * Converts the given vector from this 3D object's word space to local space.
  	 *
  	 * @param {Vector3} vector - The vector to convert.
  	 * @return {Vector3} The converted vector.
  	 */
  	worldToLocal( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( _m1$1$1.copy( this.matrixWorld ).invert() );

  	}

  	/**
  	 * Rotates the object to face a point in world space.
  	 *
  	 * This method does not support objects having non-uniformly-scaled parent(s).
  	 *
  	 * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
  	 * @param {number} [y] - The y coordinate in world space.
  	 * @param {number} [z] - The z coordinate in world space.
  	 */
  	lookAt( x, y, z ) {

  		// This method does not support objects having non-uniformly-scaled parent(s)

  		if ( x.isVector3 ) {

  			_target.copy( x );

  		} else {

  			_target.set( x, y, z );

  		}

  		const parent = this.parent;

  		this.updateWorldMatrix( true, false );

  		_position$3.setFromMatrixPosition( this.matrixWorld );

  		if ( this.isCamera || this.isLight ) {

  			_m1$1$1.lookAt( _position$3, _target, this.up );

  		} else {

  			_m1$1$1.lookAt( _target, _position$3, this.up );

  		}

  		this.quaternion.setFromRotationMatrix( _m1$1$1 );

  		if ( parent ) {

  			_m1$1$1.extractRotation( parent.matrixWorld );
  			_q1.setFromRotationMatrix( _m1$1$1 );
  			this.quaternion.premultiply( _q1.invert() );

  		}

  	}

  	/**
  	 * Adds the given 3D object as a child to this 3D object. An arbitrary number of
  	 * objects may be added. Any current parent on an object passed in here will be
  	 * removed, since an object can have at most one parent.
  	 *
  	 * @fires Object3D#added
  	 * @fires Object3D#childadded
  	 * @param {Object3D} object - The 3D object to add.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	add( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.add( arguments[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
  			return this;

  		}

  		if ( object && object.isObject3D ) {

  			object.removeFromParent();
  			object.parent = this;
  			this.children.push( object );

  			object.dispatchEvent( _addedEvent );

  			_childaddedEvent.child = object;
  			this.dispatchEvent( _childaddedEvent );
  			_childaddedEvent.child = null;

  		} else {

  			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

  		}

  		return this;

  	}

  	/**
  	 * Removes the given 3D object as child from this 3D object.
  	 * An arbitrary number of objects may be removed.
  	 *
  	 * @fires Object3D#removed
  	 * @fires Object3D#childremoved
  	 * @param {Object3D} object - The 3D object to remove.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	remove( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.remove( arguments[ i ] );

  			}

  			return this;

  		}

  		const index = this.children.indexOf( object );

  		if ( index !== -1 ) {

  			object.parent = null;
  			this.children.splice( index, 1 );

  			object.dispatchEvent( _removedEvent );

  			_childremovedEvent.child = object;
  			this.dispatchEvent( _childremovedEvent );
  			_childremovedEvent.child = null;

  		}

  		return this;

  	}

  	/**
  	 * Removes this 3D object from its current parent.
  	 *
  	 * @fires Object3D#removed
  	 * @fires Object3D#childremoved
  	 * @return {Object3D} A reference to this instance.
  	 */
  	removeFromParent() {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			parent.remove( this );

  		}

  		return this;

  	}

  	/**
  	 * Removes all child objects.
  	 *
  	 * @fires Object3D#removed
  	 * @fires Object3D#childremoved
  	 * @return {Object3D} A reference to this instance.
  	 */
  	clear() {

  		return this.remove( ... this.children );

  	}

  	/**
  	 * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
  	 * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
  	 *
  	 * @fires Object3D#added
  	 * @fires Object3D#childadded
  	 * @param {Object3D} object - The 3D object to attach.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	attach( object ) {

  		// adds object as a child of this, while maintaining the object's world transform

  		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

  		this.updateWorldMatrix( true, false );

  		_m1$1$1.copy( this.matrixWorld ).invert();

  		if ( object.parent !== null ) {

  			object.parent.updateWorldMatrix( true, false );

  			_m1$1$1.multiply( object.parent.matrixWorld );

  		}

  		object.applyMatrix4( _m1$1$1 );

  		object.removeFromParent();
  		object.parent = this;
  		this.children.push( object );

  		object.updateWorldMatrix( false, true );

  		object.dispatchEvent( _addedEvent );

  		_childaddedEvent.child = object;
  		this.dispatchEvent( _childaddedEvent );
  		_childaddedEvent.child = null;

  		return this;

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns the first with a matching ID.
  	 *
  	 * @param {number} id - The id.
  	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
  	 */
  	getObjectById( id ) {

  		return this.getObjectByProperty( 'id', id );

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns the first with a matching name.
  	 *
  	 * @param {string} name - The name.
  	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
  	 */
  	getObjectByName( name ) {

  		return this.getObjectByProperty( 'name', name );

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns the first with a matching property value.
  	 *
  	 * @param {string} name - The name of the property.
  	 * @param {any} value - The value.
  	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
  	 */
  	getObjectByProperty( name, value ) {

  		if ( this[ name ] === value ) return this;

  		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

  			const child = this.children[ i ];
  			const object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns all 3D objects with a matching property value.
  	 *
  	 * @param {string} name - The name of the property.
  	 * @param {any} value - The value.
  	 * @param {Array<Object3D>} result - The method stores the result in this array.
  	 * @return {Array<Object3D>} The found 3D objects.
  	 */
  	getObjectsByProperty( name, value, result = [] ) {

  		if ( this[ name ] === value ) result.push( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].getObjectsByProperty( name, value, result );

  		}

  		return result;

  	}

  	/**
  	 * Returns a vector representing the position of the 3D object in world space.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's position in world space.
  	 */
  	getWorldPosition( target ) {

  		this.updateWorldMatrix( true, false );

  		return target.setFromMatrixPosition( this.matrixWorld );

  	}

  	/**
  	 * Returns a Quaternion representing the position of the 3D object in world space.
  	 *
  	 * @param {Quaternion} target - The target Quaternion the result is stored to.
  	 * @return {Quaternion} The 3D object's rotation in world space.
  	 */
  	getWorldQuaternion( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, target, _scale$2 );

  		return target;

  	}

  	/**
  	 * Returns a vector representing the scale of the 3D object in world space.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's scale in world space.
  	 */
  	getWorldScale( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

  		return target;

  	}

  	/**
  	 * Returns a vector representing the ("look") direction of the 3D object in world space.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's direction in world space.
  	 */
  	getWorldDirection( target ) {

  		this.updateWorldMatrix( true, false );

  		const e = this.matrixWorld.elements;

  		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  	}

  	/**
  	 * Abstract method to get intersections between a casted ray and this
  	 * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
  	 * implement this method in order to use raycasting.
  	 *
  	 * @abstract
  	 * @param {Raycaster} raycaster - The raycaster.
  	 * @param {Array<Object>} intersects - An array holding the result of the method.
  	 */
  	raycast( /* raycaster, intersects */ ) {}

  	/**
  	 * Executes the callback on this 3D object and all descendants.
  	 *
  	 * Note: Modifying the scene graph inside the callback is discouraged.
  	 *
  	 * @param {Function} callback - A callback function that allows to process the current 3D object.
  	 */
  	traverse( callback ) {

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	}

  	/**
  	 * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
  	 * Descendants of invisible 3D objects are not traversed.
  	 *
  	 * Note: Modifying the scene graph inside the callback is discouraged.
  	 *
  	 * @param {Function} callback - A callback function that allows to process the current 3D object.
  	 */
  	traverseVisible( callback ) {

  		if ( this.visible === false ) return;

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	}

  	/**
  	 * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
  	 *
  	 * Note: Modifying the scene graph inside the callback is discouraged.
  	 *
  	 * @param {Function} callback - A callback function that allows to process the current 3D object.
  	 */
  	traverseAncestors( callback ) {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	}

  	/**
  	 * Updates the transformation matrix in local space by computing it from the current
  	 * position, rotation and scale values.
  	 */
  	updateMatrix() {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	}

  	/**
  	 * Updates the transformation matrix in world space of this 3D objects and its descendants.
  	 *
  	 * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
  	 * local space. The computation of the local and world matrix can be controlled with the
  	 * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
  	 * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
  	 *
  	 * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
  	 * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
  	 */
  	updateMatrixWorld( force ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.matrixWorldAutoUpdate === true ) {

  				if ( this.parent === null ) {

  					this.matrixWorld.copy( this.matrix );

  				} else {

  					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  				}

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// make sure descendants are updated if required

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			const child = children[ i ];

  			child.updateMatrixWorld( force );

  		}

  	}

  	/**
  	 * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
  	 * update of ancestor and descendant nodes.
  	 *
  	 * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
  	 * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
  	 */
  	updateWorldMatrix( updateParents, updateChildren ) {

  		const parent = this.parent;

  		if ( updateParents === true && parent !== null ) {

  			parent.updateWorldMatrix( true, false );

  		}

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldAutoUpdate === true ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  		}

  		// make sure descendants are updated

  		if ( updateChildren === true ) {

  			const children = this.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				const child = children[ i ];

  				child.updateWorldMatrix( false, true );

  			}

  		}

  	}

  	/**
  	 * Serializes the 3D object into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized 3D object.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		// meta is a string when called from JSON.stringify
  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		const output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {},
  				shapes: {},
  				skeletons: {},
  				animations: {},
  				nodes: {}
  			};

  			output.metadata = {
  				version: 4.7,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		const object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) object.name = this.name;
  		if ( this.castShadow === true ) object.castShadow = true;
  		if ( this.receiveShadow === true ) object.receiveShadow = true;
  		if ( this.visible === false ) object.visible = false;
  		if ( this.frustumCulled === false ) object.frustumCulled = false;
  		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
  		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

  		object.layers = this.layers.mask;
  		object.matrix = this.matrix.toArray();
  		object.up = this.up.toArray();

  		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

  		// object specific properties

  		if ( this.isInstancedMesh ) {

  			object.type = 'InstancedMesh';
  			object.count = this.count;
  			object.instanceMatrix = this.instanceMatrix.toJSON();
  			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

  		}

  		if ( this.isBatchedMesh ) {

  			object.type = 'BatchedMesh';
  			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
  			object.sortObjects = this.sortObjects;

  			object.drawRanges = this._drawRanges;
  			object.reservedRanges = this._reservedRanges;

  			object.geometryInfo = this._geometryInfo.map( info => ( {
  				...info,
  				boundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,
  				boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined
  			} ) );
  			object.instanceInfo = this._instanceInfo.map( info => ( { ...info } ) );

  			object.availableInstanceIds = this._availableInstanceIds.slice();
  			object.availableGeometryIds = this._availableGeometryIds.slice();

  			object.nextIndexStart = this._nextIndexStart;
  			object.nextVertexStart = this._nextVertexStart;
  			object.geometryCount = this._geometryCount;

  			object.maxInstanceCount = this._maxInstanceCount;
  			object.maxVertexCount = this._maxVertexCount;
  			object.maxIndexCount = this._maxIndexCount;

  			object.geometryInitialized = this._geometryInitialized;

  			object.matricesTexture = this._matricesTexture.toJSON( meta );

  			object.indirectTexture = this._indirectTexture.toJSON( meta );

  			if ( this._colorsTexture !== null ) {

  				object.colorsTexture = this._colorsTexture.toJSON( meta );

  			}

  			if ( this.boundingSphere !== null ) {

  				object.boundingSphere = this.boundingSphere.toJSON();

  			}

  			if ( this.boundingBox !== null ) {

  				object.boundingBox = this.boundingBox.toJSON();

  			}

  		}

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.isScene ) {

  			if ( this.background ) {

  				if ( this.background.isColor ) {

  					object.background = this.background.toJSON();

  				} else if ( this.background.isTexture ) {

  					object.background = this.background.toJSON( meta ).uuid;

  				}

  			}

  			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

  				object.environment = this.environment.toJSON( meta ).uuid;

  			}

  		} else if ( this.isMesh || this.isLine || this.isPoints ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  			const parameters = this.geometry.parameters;

  			if ( parameters !== undefined && parameters.shapes !== undefined ) {

  				const shapes = parameters.shapes;

  				if ( Array.isArray( shapes ) ) {

  					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  						const shape = shapes[ i ];

  						serialize( meta.shapes, shape );

  					}

  				} else {

  					serialize( meta.shapes, shapes );

  				}

  			}

  		}

  		if ( this.isSkinnedMesh ) {

  			object.bindMode = this.bindMode;
  			object.bindMatrix = this.bindMatrix.toArray();

  			if ( this.skeleton !== undefined ) {

  				serialize( meta.skeletons, this.skeleton );

  				object.skeleton = this.skeleton.uuid;

  			}

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				const uuids = [];

  				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( let i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this.children[ i ].toJSON( meta ).object );

  			}

  		}

  		//

  		if ( this.animations.length > 0 ) {

  			object.animations = [];

  			for ( let i = 0; i < this.animations.length; i ++ ) {

  				const animation = this.animations[ i ];

  				object.animations.push( serialize( meta.animations, animation ) );

  			}

  		}

  		if ( isRootObject ) {

  			const geometries = extractFromCache( meta.geometries );
  			const materials = extractFromCache( meta.materials );
  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const shapes = extractFromCache( meta.shapes );
  			const skeletons = extractFromCache( meta.skeletons );
  			const animations = extractFromCache( meta.animations );
  			const nodes = extractFromCache( meta.nodes );

  			if ( geometries.length > 0 ) output.geometries = geometries;
  			if ( materials.length > 0 ) output.materials = materials;
  			if ( textures.length > 0 ) output.textures = textures;
  			if ( images.length > 0 ) output.images = images;
  			if ( shapes.length > 0 ) output.shapes = shapes;
  			if ( skeletons.length > 0 ) output.skeletons = skeletons;
  			if ( animations.length > 0 ) output.animations = animations;
  			if ( nodes.length > 0 ) output.nodes = nodes;

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			const values = [];
  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  	}

  	/**
  	 * Returns a new 3D object with copied values from this instance.
  	 *
  	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
  	 * @return {Object3D} A clone of this instance.
  	 */
  	clone( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	}

  	/**
  	 * Copies the values of the given 3D object to this instance.
  	 *
  	 * @param {Object3D} source - The 3D object to copy.
  	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	copy( source, recursive = true ) {

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.rotation.order = source.rotation.order;
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.animations = source.animations.slice();

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( let i = 0; i < source.children.length; i ++ ) {

  				const child = source.children[ i ];
  				this.add( child.clone() );

  			}

  		}

  		return this;

  	}

  }

  /**
   * The default up direction for objects, also used as the default
   * position for {@link DirectionalLight} and {@link HemisphereLight}.
   *
   * @static
   * @type {Vector3}
   * @default (0,1,0)
   */
  Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );

  /**
   * The default setting for {@link Object3D#matrixAutoUpdate} for
   * newly created 3D objects.
   *
   * @static
   * @type {boolean}
   * @default true
   */
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;

  /**
   * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
   * newly created 3D objects.
   *
   * @static
   * @type {boolean}
   * @default true
   */
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

  const _v0$1 = /*@__PURE__*/ new Vector3();
  const _v1$3 = /*@__PURE__*/ new Vector3();
  const _v2$2 = /*@__PURE__*/ new Vector3();
  const _v3$2 = /*@__PURE__*/ new Vector3();

  const _vab = /*@__PURE__*/ new Vector3();
  const _vac = /*@__PURE__*/ new Vector3();
  const _vbc = /*@__PURE__*/ new Vector3();
  const _vap = /*@__PURE__*/ new Vector3();
  const _vbp = /*@__PURE__*/ new Vector3();
  const _vcp = /*@__PURE__*/ new Vector3();

  const _v40 = /*@__PURE__*/ new Vector4();
  const _v41 = /*@__PURE__*/ new Vector4();
  const _v42 = /*@__PURE__*/ new Vector4();

  /**
   * A geometric triangle as defined by three vectors representing its three corners.
   */
  class Triangle {

  	/**
  	 * Constructs a new triangle.
  	 *
  	 * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
  	 * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
  	 * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
  	 */
  	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

  		/**
  		 * The first corner of the triangle.
  		 *
  		 * @type {Vector3}
  		 */
  		this.a = a;

  		/**
  		 * The second corner of the triangle.
  		 *
  		 * @type {Vector3}
  		 */
  		this.b = b;

  		/**
  		 * The third corner of the triangle.
  		 *
  		 * @type {Vector3}
  		 */
  		this.c = c;

  	}

  	/**
  	 * Computes the normal vector of a triangle.
  	 *
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The triangle's normal.
  	 */
  	static getNormal( a, b, c, target ) {

  		target.subVectors( c, b );
  		_v0$1.subVectors( a, b );
  		target.cross( _v0$1 );

  		const targetLengthSq = target.lengthSq();
  		if ( targetLengthSq > 0 ) {

  			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  		}

  		return target.set( 0, 0, 0 );

  	}

  	/**
  	 * Computes a barycentric coordinates from the given vector.
  	 * Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - A point in 3D space.
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The barycentric coordinates for the given point
  	 */
  	static getBarycoord( point, a, b, c, target ) {

  		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html

  		_v0$1.subVectors( c, a );
  		_v1$3.subVectors( b, a );
  		_v2$2.subVectors( point, a );

  		const dot00 = _v0$1.dot( _v0$1 );
  		const dot01 = _v0$1.dot( _v1$3 );
  		const dot02 = _v0$1.dot( _v2$2 );
  		const dot11 = _v1$3.dot( _v1$3 );
  		const dot12 = _v1$3.dot( _v2$2 );

  		const denom = ( dot00 * dot11 - dot01 * dot01 );

  		// collinear or singular triangle
  		if ( denom === 0 ) {

  			target.set( 0, 0, 0 );
  			return null;

  		}

  		const invDenom = 1 / denom;
  		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  		// barycentric coordinates must always sum to 1
  		return target.set( 1 - u - v, v, u );

  	}

  	/**
  	 * Returns `true` if the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle.
  	 *
  	 * @param {Vector3} point - The point in 3D space to test.
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @return {boolean} Whether the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle or not.
  	 */
  	static containsPoint( point, a, b, c ) {

  		// if the triangle is degenerate then we can't contain a point
  		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

  			return false;

  		}

  		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

  	}

  	/**
  	 * Computes the value barycentrically interpolated for the given point on the
  	 * triangle. Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - Position of interpolated point.
  	 * @param {Vector3} p1 - The first corner of the triangle.
  	 * @param {Vector3} p2 - The second corner of the triangle.
  	 * @param {Vector3} p3 - The third corner of the triangle.
  	 * @param {Vector3} v1 - Value to interpolate of first vertex.
  	 * @param {Vector3} v2 - Value to interpolate of second vertex.
  	 * @param {Vector3} v3 - Value to interpolate of third vertex.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The interpolated value.
  	 */
  	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

  		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

  			target.x = 0;
  			target.y = 0;
  			if ( 'z' in target ) target.z = 0;
  			if ( 'w' in target ) target.w = 0;
  			return null;

  		}

  		target.setScalar( 0 );
  		target.addScaledVector( v1, _v3$2.x );
  		target.addScaledVector( v2, _v3$2.y );
  		target.addScaledVector( v3, _v3$2.z );

  		return target;

  	}

  	/**
  	 * Computes the value barycentrically interpolated for the given attribute and indices.
  	 *
  	 * @param {BufferAttribute} attr - The attribute to interpolate.
  	 * @param {number} i1 - Index of first vertex.
  	 * @param {number} i2 - Index of second vertex.
  	 * @param {number} i3 - Index of third vertex.
  	 * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The interpolated attribute value.
  	 */
  	static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

  		_v40.setScalar( 0 );
  		_v41.setScalar( 0 );
  		_v42.setScalar( 0 );

  		_v40.fromBufferAttribute( attr, i1 );
  		_v41.fromBufferAttribute( attr, i2 );
  		_v42.fromBufferAttribute( attr, i3 );

  		target.setScalar( 0 );
  		target.addScaledVector( _v40, barycoord.x );
  		target.addScaledVector( _v41, barycoord.y );
  		target.addScaledVector( _v42, barycoord.z );

  		return target;

  	}

  	/**
  	 * Returns `true` if the triangle is oriented towards the given direction.
  	 *
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @param {Vector3} direction - The (normalized) direction vector.
  	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
  	 */
  	static isFrontFacing( a, b, c, direction ) {

  		_v0$1.subVectors( c, b );
  		_v1$3.subVectors( a, b );

  		// strictly front facing
  		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

  	}

  	/**
  	 * Sets the triangle's vertices by copying the given values.
  	 *
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	set( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	}

  	/**
  	 * Sets the triangle's vertices by copying the given array values.
  	 *
  	 * @param {Array<Vector3>} points - An array with 3D points.
  	 * @param {number} i0 - The array index representing the first corner of the triangle.
  	 * @param {number} i1 - The array index representing the second corner of the triangle.
  	 * @param {number} i2 - The array index representing the third corner of the triangle.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	setFromPointsAndIndices( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	}

  	/**
  	 * Sets the triangle's vertices by copying the given attribute values.
  	 *
  	 * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
  	 * @param {number} i0 - The attribute index representing the first corner of the triangle.
  	 * @param {number} i1 - The attribute index representing the second corner of the triangle.
  	 * @param {number} i2 - The attribute index representing the third corner of the triangle.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

  		this.a.fromBufferAttribute( attribute, i0 );
  		this.b.fromBufferAttribute( attribute, i1 );
  		this.c.fromBufferAttribute( attribute, i2 );

  		return this;

  	}

  	/**
  	 * Returns a new triangle with copied values from this instance.
  	 *
  	 * @return {Triangle} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given triangle to this instance.
  	 *
  	 * @param {Triangle} triangle - The triangle to copy.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	copy( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	}

  	/**
  	 * Computes the area of the triangle.
  	 *
  	 * @return {number} The triangle's area.
  	 */
  	getArea() {

  		_v0$1.subVectors( this.c, this.b );
  		_v1$3.subVectors( this.a, this.b );

  		return _v0$1.cross( _v1$3 ).length() * 0.5;

  	}

  	/**
  	 * Computes the midpoint of the triangle.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The triangle's midpoint.
  	 */
  	getMidpoint( target ) {

  		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	}

  	/**
  	 * Computes the normal of the triangle.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The triangle's normal.
  	 */
  	getNormal( target ) {

  		return Triangle.getNormal( this.a, this.b, this.c, target );

  	}

  	/**
  	 * Computes a plane the triangle lies within.
  	 *
  	 * @param {Plane} target - The target vector that is used to store the method's result.
  	 * @return {Plane} The plane the triangle lies within.
  	 */
  	getPlane( target ) {

  		return target.setFromCoplanarPoints( this.a, this.b, this.c );

  	}

  	/**
  	 * Computes a barycentric coordinates from the given vector.
  	 * Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - A point in 3D space.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The barycentric coordinates for the given point
  	 */
  	getBarycoord( point, target ) {

  		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  	}

  	/**
  	 * Computes the value barycentrically interpolated for the given point on the
  	 * triangle. Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - Position of interpolated point.
  	 * @param {Vector3} v1 - Value to interpolate of first vertex.
  	 * @param {Vector3} v2 - Value to interpolate of second vertex.
  	 * @param {Vector3} v3 - Value to interpolate of third vertex.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The interpolated value.
  	 */
  	getInterpolation( point, v1, v2, v3, target ) {

  		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

  	}

  	/**
  	 * Returns `true` if the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle.
  	 *
  	 * @param {Vector3} point - The point in 3D space to test.
  	 * @return {boolean} Whether the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle or not.
  	 */
  	containsPoint( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	}

  	/**
  	 * Returns `true` if the triangle is oriented towards the given direction.
  	 *
  	 * @param {Vector3} direction - The (normalized) direction vector.
  	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
  	 */
  	isFrontFacing( direction ) {

  		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

  	}

  	/**
  	 * Returns `true` if this triangle intersects with the given box.
  	 *
  	 * @param {Box3} box - The box to intersect.
  	 * @return {boolean} Whether this triangle intersects with the given box or not.
  	 */
  	intersectsBox( box ) {

  		return box.intersectsTriangle( this );

  	}

  	/**
  	 * Returns the closest point on the triangle to the given point.
  	 *
  	 * @param {Vector3} p - The point to compute the closest point for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The closest point on the triangle.
  	 */
  	closestPointToPoint( p, target ) {

  		const a = this.a, b = this.b, c = this.c;
  		let v, w;

  		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  		// basically, we're distinguishing which of the voronoi regions of the triangle
  		// the point lies in with the minimum amount of redundant computation.

  		_vab.subVectors( b, a );
  		_vac.subVectors( c, a );
  		_vap.subVectors( p, a );
  		const d1 = _vab.dot( _vap );
  		const d2 = _vac.dot( _vap );
  		if ( d1 <= 0 && d2 <= 0 ) {

  			// vertex region of A; barycentric coords (1, 0, 0)
  			return target.copy( a );

  		}

  		_vbp.subVectors( p, b );
  		const d3 = _vab.dot( _vbp );
  		const d4 = _vac.dot( _vbp );
  		if ( d3 >= 0 && d4 <= d3 ) {

  			// vertex region of B; barycentric coords (0, 1, 0)
  			return target.copy( b );

  		}

  		const vc = d1 * d4 - d3 * d2;
  		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  			v = d1 / ( d1 - d3 );
  			// edge region of AB; barycentric coords (1-v, v, 0)
  			return target.copy( a ).addScaledVector( _vab, v );

  		}

  		_vcp.subVectors( p, c );
  		const d5 = _vab.dot( _vcp );
  		const d6 = _vac.dot( _vcp );
  		if ( d6 >= 0 && d5 <= d6 ) {

  			// vertex region of C; barycentric coords (0, 0, 1)
  			return target.copy( c );

  		}

  		const vb = d5 * d2 - d1 * d6;
  		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  			w = d2 / ( d2 - d6 );
  			// edge region of AC; barycentric coords (1-w, 0, w)
  			return target.copy( a ).addScaledVector( _vac, w );

  		}

  		const va = d3 * d6 - d5 * d4;
  		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  			_vbc.subVectors( c, b );
  			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  			// edge region of BC; barycentric coords (0, 1-w, w)
  			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

  		}

  		// face region
  		const denom = 1 / ( va + vb + vc );
  		// u = va * denom
  		v = vb * denom;
  		w = vc * denom;

  		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

  	}

  	/**
  	 * Returns `true` if this triangle is equal with the given one.
  	 *
  	 * @param {Triangle} triangle - The triangle to test for equality.
  	 * @return {boolean} Whether this triangle is equal with the given one.
  	 */
  	equals( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  }

  const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };

  function hue2rgb( p, q, t ) {

  	if ( t < 0 ) t += 1;
  	if ( t > 1 ) t -= 1;
  	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  	if ( t < 1 / 2 ) return q;
  	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  	return p;

  }

  /**
   * A Color instance is represented by RGB components in the linear <i>working
   * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
   * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
   * strings) are converted to the working color space automatically.
   *
   * ```js
   * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
   * const color = new THREE.Color().setHex( 0x112233 );
   * ```
   * Source color spaces may be specified explicitly, to ensure correct conversions.
   * ```js
   * // assumed already LinearSRGBColorSpace; no conversion
   * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
   *
   * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
   * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
   * ```
   * If THREE.ColorManagement is disabled, no conversions occur. For details,
   * see <i>Color management</i>. Iterating through a Color instance will yield
   * its components (r, g, b) in the corresponding order. A Color can be initialised
   * in any of the following ways:
   * ```js
   * //empty constructor - will default white
   * const color1 = new THREE.Color();
   *
   * //Hexadecimal color (recommended)
   * const color2 = new THREE.Color( 0xff0000 );
   *
   * //RGB string
   * const color3 = new THREE.Color("rgb(255, 0, 0)");
   * const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
   *
   * //X11 color name - all 140 color names are supported.
   * //Note the lack of CamelCase in the name
   * const color5 = new THREE.Color( 'skyblue' );
   * //HSL string
   * const color6 = new THREE.Color("hsl(0, 100%, 50%)");
   *
   * //Separate RGB values between 0 and 1
   * const color7 = new THREE.Color( 1, 0, 0 );
   * ```
   */
  class Color {

  	/**
  	 * Constructs a new color.
  	 *
  	 * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
  	 * and that method is used throughout the rest of the documentation.
  	 *
  	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
  	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
  	 * @param {number} [g] - The green component.
  	 * @param {number} [b] - The blue component.
  	 */
  	constructor( r, g, b ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isColor = true;

  		/**
  		 * The red component.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.r = 1;

  		/**
  		 * The green component.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.g = 1;

  		/**
  		 * The blue component.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.b = 1;

  		return this.set( r, g, b );

  	}

  	/**
  	 * Sets the colors's components from the given values.
  	 *
  	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
  	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
  	 * @param {number} [g] - The green component.
  	 * @param {number} [b] - The blue component.
  	 * @return {Color} A reference to this color.
  	 */
  	set( r, g, b ) {

  		if ( g === undefined && b === undefined ) {

  			// r is THREE.Color, hex or string

  			const value = r;

  			if ( value && value.isColor ) {

  				this.copy( value );

  			} else if ( typeof value === 'number' ) {

  				this.setHex( value );

  			} else if ( typeof value === 'string' ) {

  				this.setStyle( value );

  			}

  		} else {

  			this.setRGB( r, g, b );

  		}

  		return this;

  	}

  	/**
  	 * Sets the colors's components to the given scalar value.
  	 *
  	 * @param {number} scalar - The scalar value.
  	 * @return {Color} A reference to this color.
  	 */
  	setScalar( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	}

  	/**
  	 * Sets this color from a hexadecimal value.
  	 *
  	 * @param {number} hex - The hexadecimal value.
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setHex( hex, colorSpace = SRGBColorSpace ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		ColorManagement.colorSpaceToWorking( this, colorSpace );

  		return this;

  	}

  	/**
  	 * Sets this color from RGB values.
  	 *
  	 * @param {number} r - Red channel value between `0.0` and `1.0`.
  	 * @param {number} g - Green channel value between `0.0` and `1.0`.
  	 * @param {number} b - Blue channel value between `0.0` and `1.0`.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		ColorManagement.colorSpaceToWorking( this, colorSpace );

  		return this;

  	}

  	/**
  	 * Sets this color from RGB values.
  	 *
  	 * @param {number} h - Hue value between `0.0` and `1.0`.
  	 * @param {number} s - Saturation value between `0.0` and `1.0`.
  	 * @param {number} l - Lightness value between `0.0` and `1.0`.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0
  		h = euclideanModulo( h, 1 );
  		s = clamp$1( s, 0, 1 );
  		l = clamp$1( l, 0, 1 );

  		if ( s === 0 ) {

  			this.r = this.g = this.b = l;

  		} else {

  			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  			const q = ( 2 * l ) - p;

  			this.r = hue2rgb( q, p, h + 1 / 3 );
  			this.g = hue2rgb( q, p, h );
  			this.b = hue2rgb( q, p, h - 1 / 3 );

  		}

  		ColorManagement.colorSpaceToWorking( this, colorSpace );

  		return this;

  	}

  	/**
  	 * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
  	 * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
  	 * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
  	 * all 140 color names are supported).
  	 *
  	 * @param {string} style - Color as a CSS-style string.
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setStyle( style, colorSpace = SRGBColorSpace ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) return;

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		let m;

  		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			let color;
  			const name = m[ 1 ];
  			const components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
  							colorSpace
  						);

  					}

  					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setHSL(
  							parseFloat( color[ 1 ] ) / 360,
  							parseFloat( color[ 2 ] ) / 100,
  							parseFloat( color[ 3 ] ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				default:

  					console.warn( 'THREE.Color: Unknown color model ' + style );

  			}

  		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

  			// hex color

  			const hex = m[ 1 ];
  			const size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				return this.setRGB(
  					parseInt( hex.charAt( 0 ), 16 ) / 15,
  					parseInt( hex.charAt( 1 ), 16 ) / 15,
  					parseInt( hex.charAt( 2 ), 16 ) / 15,
  					colorSpace
  				);

  			} else if ( size === 6 ) {

  				// #ff0000
  				return this.setHex( parseInt( hex, 16 ), colorSpace );

  			} else {

  				console.warn( 'THREE.Color: Invalid hex color ' + style );

  			}

  		} else if ( style && style.length > 0 ) {

  			return this.setColorName( style, colorSpace );

  		}

  		return this;

  	}

  	/**
  	 * Sets this color from a color name. Faster than {@link Color#setStyle} if
  	 * you don't need the other CSS-style formats.
  	 *
  	 * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
  	 * ```js
  	 * Color.NAMES.aliceblue // returns 0xF0F8FF
  	 * ```
  	 *
  	 * @param {string} style - The color name.
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setColorName( style, colorSpace = SRGBColorSpace ) {

  		// color keywords
  		const hex = _colorKeywords[ style.toLowerCase() ];

  		if ( hex !== undefined ) {

  			// red
  			this.setHex( hex, colorSpace );

  		} else {

  			// unknown color
  			console.warn( 'THREE.Color: Unknown color ' + style );

  		}

  		return this;

  	}

  	/**
  	 * Returns a new color with copied values from this instance.
  	 *
  	 * @return {Color} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.r, this.g, this.b );

  	}

  	/**
  	 * Copies the values of the given color to this instance.
  	 *
  	 * @param {Color} color - The color to copy.
  	 * @return {Color} A reference to this color.
  	 */
  	copy( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	}

  	/**
  	 * Copies the given color into this color, and then converts this color from
  	 * `SRGBColorSpace` to `LinearSRGBColorSpace`.
  	 *
  	 * @param {Color} color - The color to copy/convert.
  	 * @return {Color} A reference to this color.
  	 */
  	copySRGBToLinear( color ) {

  		this.r = SRGBToLinear( color.r );
  		this.g = SRGBToLinear( color.g );
  		this.b = SRGBToLinear( color.b );

  		return this;

  	}

  	/**
  	 * Copies the given color into this color, and then converts this color from
  	 * `LinearSRGBColorSpace` to `SRGBColorSpace`.
  	 *
  	 * @param {Color} color - The color to copy/convert.
  	 * @return {Color} A reference to this color.
  	 */
  	copyLinearToSRGB( color ) {

  		this.r = LinearToSRGB( color.r );
  		this.g = LinearToSRGB( color.g );
  		this.b = LinearToSRGB( color.b );

  		return this;

  	}

  	/**
  	 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
  	 *
  	 * @return {Color} A reference to this color.
  	 */
  	convertSRGBToLinear() {

  		this.copySRGBToLinear( this );

  		return this;

  	}

  	/**
  	 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
  	 *
  	 * @return {Color} A reference to this color.
  	 */
  	convertLinearToSRGB() {

  		this.copyLinearToSRGB( this );

  		return this;

  	}

  	/**
  	 * Returns the hexadecimal value of this color.
  	 *
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {number} The hexadecimal value.
  	 */
  	getHex( colorSpace = SRGBColorSpace ) {

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		return Math.round( clamp$1( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp$1( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp$1( _color.b * 255, 0, 255 ) );

  	}

  	/**
  	 * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
  	 *
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {string} The hexadecimal value as a string.
  	 */
  	getHexString( colorSpace = SRGBColorSpace ) {

  		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );

  	}

  	/**
  	 * Converts the colors RGB values into the HSL format and stores them into the
  	 * given target object.
  	 *
  	 * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {{h:number,s:number,l:number}} The HSL representation of this color.
  	 */
  	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		const r = _color.r, g = _color.g, b = _color.b;

  		const max = Math.max( r, g, b );
  		const min = Math.min( r, g, b );

  		let hue, saturation;
  		const lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			const delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		target.h = hue;
  		target.s = saturation;
  		target.l = lightness;

  		return target;

  	}

  	/**
  	 * Returns the RGB values of this color and stores them into the given target object.
  	 *
  	 * @param {Color} target - The target color that is used to store the method's result.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {Color} The RGB representation of this color.
  	 */
  	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		target.r = _color.r;
  		target.g = _color.g;
  		target.b = _color.b;

  		return target;

  	}

  	/**
  	 * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
  	 *
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {string} The CSS representation of this color.
  	 */
  	getStyle( colorSpace = SRGBColorSpace ) {

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		const r = _color.r, g = _color.g, b = _color.b;

  		if ( colorSpace !== SRGBColorSpace ) {

  			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
  			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

  		}

  		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

  	}

  	/**
  	 * Adds the given HSL values to this color's values.
  	 * Internally, this converts the color's RGB values to HSL, adds HSL
  	 * and then converts the color back to RGB.
  	 *
  	 * @param {number} h - Hue value between `0.0` and `1.0`.
  	 * @param {number} s - Saturation value between `0.0` and `1.0`.
  	 * @param {number} l - Lightness value between `0.0` and `1.0`.
  	 * @return {Color} A reference to this color.
  	 */
  	offsetHSL( h, s, l ) {

  		this.getHSL( _hslA );

  		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

  	}

  	/**
  	 * Adds the RGB values of the given color to the RGB values of this color.
  	 *
  	 * @param {Color} color - The color to add.
  	 * @return {Color} A reference to this color.
  	 */
  	add( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	}

  	/**
  	 * Adds the RGB values of the given colors and stores the result in this instance.
  	 *
  	 * @param {Color} color1 - The first color.
  	 * @param {Color} color2 - The second color.
  	 * @return {Color} A reference to this color.
  	 */
  	addColors( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to the RGB values of this color.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Color} A reference to this color.
  	 */
  	addScalar( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	}

  	/**
  	 * Subtracts the RGB values of the given color from the RGB values of this color.
  	 *
  	 * @param {Color} color - The color to subtract.
  	 * @return {Color} A reference to this color.
  	 */
  	sub( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	}

  	/**
  	 * Multiplies the RGB values of the given color with the RGB values of this color.
  	 *
  	 * @param {Color} color - The color to multiply.
  	 * @return {Color} A reference to this color.
  	 */
  	multiply( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with the RGB values of this color.
  	 *
  	 * @param {number} s - The scalar to multiply.
  	 * @return {Color} A reference to this color.
  	 */
  	multiplyScalar( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	}

  	/**
  	 * Linearly interpolates this color's RGB values toward the RGB values of the
  	 * given color. The alpha argument can be thought of as the ratio between
  	 * the two colors, where `0.0` is this color and `1.0` is the first argument.
  	 *
  	 * @param {Color} color - The color to converge on.
  	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
  	 * @return {Color} A reference to this color.
  	 */
  	lerp( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given colors and stores the result in this instance.
  	 * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
  	 * is the first and `1.0` is the second color.
  	 *
  	 * @param {Color} color1 - The first color.
  	 * @param {Color} color2 - The second color.
  	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
  	 * @return {Color} A reference to this color.
  	 */
  	lerpColors( color1, color2, alpha ) {

  		this.r = color1.r + ( color2.r - color1.r ) * alpha;
  		this.g = color1.g + ( color2.g - color1.g ) * alpha;
  		this.b = color1.b + ( color2.b - color1.b ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates this color's HSL values toward the HSL values of the
  	 * given color. It differs from {@link Color#lerp} by not interpolating straight
  	 * from one color to the other, but instead going through all the hues in between
  	 * those two colors. The alpha argument can be thought of as the ratio between
  	 * the two colors, where 0.0 is this color and 1.0 is the first argument.
  	 *
  	 * @param {Color} color - The color to converge on.
  	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
  	 * @return {Color} A reference to this color.
  	 */
  	lerpHSL( color, alpha ) {

  		this.getHSL( _hslA );
  		color.getHSL( _hslB );

  		const h = lerp( _hslA.h, _hslB.h, alpha );
  		const s = lerp( _hslA.s, _hslB.s, alpha );
  		const l = lerp( _hslA.l, _hslB.l, alpha );

  		this.setHSL( h, s, l );

  		return this;

  	}

  	/**
  	 * Sets the color's RGB components from the given 3D vector.
  	 *
  	 * @param {Vector3} v - The vector to set.
  	 * @return {Color} A reference to this color.
  	 */
  	setFromVector3( v ) {

  		this.r = v.x;
  		this.g = v.y;
  		this.b = v.z;

  		return this;

  	}

  	/**
  	 * Transforms this color with the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix.
  	 * @return {Color} A reference to this color.
  	 */
  	applyMatrix3( m ) {

  		const r = this.r, g = this.g, b = this.b;
  		const e = m.elements;

  		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
  		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
  		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

  		return this;

  	}

  	/**
  	 * Returns `true` if this color is equal with the given one.
  	 *
  	 * @param {Color} c - The color to test for equality.
  	 * @return {boolean} Whether this bounding color is equal with the given one.
  	 */
  	equals( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	}

  	/**
  	 * Sets this color's RGB components from the given array.
  	 *
  	 * @param {Array<number>} array - An array holding the RGB values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Color} A reference to this color.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	}

  	/**
  	 * Writes the RGB components of this color to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the color components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The color components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	}

  	/**
  	 * Sets the components of this color from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding color data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Color} A reference to this color.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.r = attribute.getX( index );
  		this.g = attribute.getY( index );
  		this.b = attribute.getZ( index );

  		return this;

  	}

  	/**
  	 * This methods defines the serialization result of this class. Returns the color
  	 * as a hexadecimal value.
  	 *
  	 * @return {number} The hexadecimal value.
  	 */
  	toJSON() {

  		return this.getHex();

  	}

  	*[ Symbol.iterator ]() {

  		yield this.r;
  		yield this.g;
  		yield this.b;

  	}

  }

  const _color = /*@__PURE__*/ new Color();

  /**
   * A dictionary with X11 color names.
   *
   * Note that multiple words such as Dark Orange become the string 'darkorange'.
   *
   * @static
   * @type {Object}
   */
  Color.NAMES = _colorKeywords;

  let _materialId = 0;

  /**
   * Abstract base class for materials.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * @abstract
   * @augments EventDispatcher
   */
  class Material extends EventDispatcher {

  	/**
  	 * Constructs a new material.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMaterial = true;

  		/**
  		 * The ID of the material.
  		 *
  		 * @name Material#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _materialId ++ } );

  		/**
  		 * The UUID of the material.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the material.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The type property is used for detecting the object type
  		 * in context of serialization/deserialization.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.type = 'Material';

  		/**
  		 * Defines the blending type of the material.
  		 *
  		 * It must be set to `CustomBlending` if custom blending properties like
  		 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
  		 * should have any effect.
  		 *
  		 * @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
  		 * @default NormalBlending
  		 */
  		this.blending = NormalBlending;

  		/**
  		 * Defines which side of faces will be rendered - front, back or both.
  		 *
  		 * @type {(FrontSide|BackSide|DoubleSide)}
  		 * @default FrontSide
  		 */
  		this.side = FrontSide;

  		/**
  		 * If set to `true`, vertex colors should be used.
  		 *
  		 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
  		 * four (RGBA) component color buffer attribute is used.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.vertexColors = false;

  		/**
  		 * Defines how transparent the material is.
  		 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
  		 *
  		 * If the {@link Material#transparent} is not set to `true`,
  		 * the material will remain fully opaque and this value will only affect its color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.opacity = 1;

  		/**
  		 * Defines whether this material is transparent. This has an effect on
  		 * rendering as transparent objects need special treatment and are rendered
  		 * after non-transparent objects.
  		 *
  		 * When set to true, the extent to which the material is transparent is
  		 * controlled by {@link Material#opacity}.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.transparent = false;

  		/**
  		 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
  		 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
  		 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
  		 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.alphaHash = false;

  		/**
  		 * Defines the blending source factor.
  		 *
  		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default SrcAlphaFactor
  		 */
  		this.blendSrc = SrcAlphaFactor;

  		/**
  		 * Defines the blending destination factor.
  		 *
  		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default OneMinusSrcAlphaFactor
  		 */
  		this.blendDst = OneMinusSrcAlphaFactor;

  		/**
  		 * Defines the blending equation.
  		 *
  		 * @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
  		 * @default AddEquation
  		 */
  		this.blendEquation = AddEquation;

  		/**
  		 * Defines the blending source alpha factor.
  		 *
  		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default null
  		 */
  		this.blendSrcAlpha = null;

  		/**
  		 * Defines the blending destination alpha factor.
  		 *
  		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default null
  		 */
  		this.blendDstAlpha = null;

  		/**
  		 * Defines the blending equation of the alpha channel.
  		 *
  		 * @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
  		 * @default null
  		 */
  		this.blendEquationAlpha = null;

  		/**
  		 * Represents the RGB values of the constant blend color.
  		 *
  		 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.blendColor = new Color( 0, 0, 0 );

  		/**
  		 * Represents the alpha value of the constant blend color.
  		 *
  		 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.blendAlpha = 0;

  		/**
  		 * Defines the depth function.
  		 *
  		 * @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
  		 * @default LessEqualDepth
  		 */
  		this.depthFunc = LessEqualDepth;

  		/**
  		 * Whether to have depth test enabled when rendering this material.
  		 * When the depth test is disabled, the depth write will also be implicitly disabled.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depthTest = true;

  		/**
  		 * Whether rendering this material has any effect on the depth buffer.
  		 *
  		 * When drawing 2D overlays it can be useful to disable the depth writing in
  		 * order to layer several things together without creating z-index artifacts.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depthWrite = true;

  		/**
  		 * The bit mask to use when writing to the stencil buffer.
  		 *
  		 * @type {number}
  		 * @default 0xff
  		 */
  		this.stencilWriteMask = 0xff;

  		/**
  		 * The stencil comparison function to use.
  		 *
  		 * @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
  		 * @default AlwaysStencilFunc
  		 */
  		this.stencilFunc = AlwaysStencilFunc;

  		/**
  		 * The value to use when performing stencil comparisons or stencil operations.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.stencilRef = 0;

  		/**
  		 * The bit mask to use when comparing against the stencil buffer.
  		 *
  		 * @type {number}
  		 * @default 0xff
  		 */
  		this.stencilFuncMask = 0xff;

  		/**
  		 * Which stencil operation to perform when the comparison function returns `false`.
  		 *
  		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
  		 * @default KeepStencilOp
  		 */
  		this.stencilFail = KeepStencilOp;

  		/**
  		 * Which stencil operation to perform when the comparison function returns
  		 * `true` but the depth test fails.
  		 *
  		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
  		 * @default KeepStencilOp
  		 */
  		this.stencilZFail = KeepStencilOp;

  		/**
  		 * Which stencil operation to perform when the comparison function returns
  		 * `true` and the depth test passes.
  		 *
  		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
  		 * @default KeepStencilOp
  		 */
  		this.stencilZPass = KeepStencilOp;

  		/**
  		 * Whether stencil operations are performed against the stencil buffer. In
  		 * order to perform writes or comparisons against the stencil buffer this
  		 * value must be `true`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.stencilWrite = false;

  		/**
  		 * User-defined clipping planes specified as THREE.Plane objects in world
  		 * space. These planes apply to the objects this material is attached to.
  		 * Points in space whose signed distance to the plane is negative are clipped
  		 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
  		 * be `true`.
  		 *
  		 * @type {?Array<Plane>}
  		 * @default null
  		 */
  		this.clippingPlanes = null;

  		/**
  		 * Changes the behavior of clipping planes so that only their intersection is
  		 * clipped, rather than their union.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clipIntersection = false;

  		/**
  		 * Defines whether to clip shadows according to the clipping planes specified
  		 * on this material.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clipShadows = false;

  		/**
  		 * Defines which side of faces cast shadows. If `null`, the side casting shadows
  		 * is determined as follows:
  		 *
  		 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
  		 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
  		 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
  		 *
  		 * @type {?(FrontSide|BackSide|DoubleSide)}
  		 * @default null
  		 */
  		this.shadowSide = null;

  		/**
  		 * Whether to render the material's color.
  		 *
  		 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
  		 * objects that occlude other objects.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.colorWrite = true;

  		/**
  		 * Override the renderer's default precision for this material.
  		 *
  		 * @type {?('highp'|'mediump'|'lowp')}
  		 * @default null
  		 */
  		this.precision = null;

  		/**
  		 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
  		 * be offset after it is interpolated from the depth values of the appropriate vertices.
  		 * The offset is added before the depth test is performed and before the value is written
  		 * into the depth buffer.
  		 *
  		 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
  		 * rendering solids with highlighted edges.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.polygonOffset = false;

  		/**
  		 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.polygonOffsetFactor = 0;

  		/**
  		 * Is multiplied by an implementation-specific value to create a constant depth offset.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.polygonOffsetUnits = 0;

  		/**
  		 * Whether to apply dithering to the color to remove the appearance of banding.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.dithering = false;

  		/**
  		 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
  		 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
  		 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.alphaToCoverage = false;

  		/**
  		 * Whether to premultiply the alpha (transparency) value.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.premultipliedAlpha = false;

  		/**
  		 * Whether double-sided, transparent objects should be rendered with a single pass or not.
  		 *
  		 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
  		 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
  		 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
  		 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
  		 * disable the two pass rendering to avoid performance issues.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.forceSinglePass = false;

  		/**
  		 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.allowOverride = true;

  		/**
  		 * Defines whether 3D objects using this material are visible.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.visible = true;

  		/**
  		 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
  		 *
  		 * It is ignored when rendering to a render target or using post processing or when using
  		 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.toneMapped = true;

  		/**
  		 * An object that can be used to store custom data about the Material. It
  		 * should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  		/**
  		 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  		this._alphaTest = 0;

  	}

  	/**
  	 * Sets the alpha value to be used when running an alpha test. The material
  	 * will not be rendered if the opacity is lower than this value.
  	 *
  	 * @type {number}
  	 * @readonly
  	 * @default 0
  	 */
  	get alphaTest() {

  		return this._alphaTest;

  	}

  	set alphaTest( value ) {

  		if ( this._alphaTest > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._alphaTest = value;

  	}

  	/**
  	 * An optional callback that is executed immediately before the material is used to render a 3D object.
  	 *
  	 * This method can only be used when rendering with {@link WebGLRenderer}.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

  	/**
  	 * An optional callback that is executed immediately before the shader
  	 * program is compiled. This function is called with the shader source code
  	 * as a parameter. Useful for the modification of built-in materials.
  	 *
  	 * This method can only be used when rendering with {@link WebGLRenderer}. The
  	 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
  	 * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
  	 *
  	 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
  	 * @param {WebGLRenderer} renderer - A reference to the renderer.
  	 */
  	onBeforeCompile( /* shaderobject, renderer */ ) {}

  	/**
  	 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
  	 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
  	 * shader or recompile the shader for this material as needed.
  	 *
  	 * This method can only be used when rendering with {@link WebGLRenderer}.
  	 *
  	 * @return {string} The custom program cache key.
  	 */
  	customProgramCacheKey() {

  		return this.onBeforeCompile.toString();

  	}

  	/**
  	 * This method can be used to set default values from parameter objects.
  	 * It is a generic implementation so it can be used with different types
  	 * of materials.
  	 *
  	 * @param {Object} [values] - The material values to set.
  	 */
  	setValues( values ) {

  		if ( values === undefined ) return;

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	/**
  	 * Serializes the material into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized material.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( isRootObject ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		const data = {
  			metadata: {
  				version: 4.7,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  		if ( this.roughness !== undefined ) data.roughness = this.roughness;
  		if ( this.metalness !== undefined ) data.metalness = this.metalness;

  		if ( this.sheen !== undefined ) data.sheen = this.sheen;
  		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
  		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
  		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

  		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
  		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
  		if ( this.shininess !== undefined ) data.shininess = this.shininess;
  		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
  		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

  		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

  			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

  			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

  			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
  			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

  		}

  		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

  		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
  		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
  		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

  		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

  			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

  		}

  		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

  			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

  		}

  		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
  		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

  		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

  			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

  		}

  		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
  		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

  		if ( this.lightMap && this.lightMap.isTexture ) {

  			data.lightMap = this.lightMap.toJSON( meta ).uuid;
  			data.lightMapIntensity = this.lightMapIntensity;

  		}

  		if ( this.aoMap && this.aoMap.isTexture ) {

  			data.aoMap = this.aoMap.toJSON( meta ).uuid;
  			data.aoMapIntensity = this.aoMapIntensity;

  		}

  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}

  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalMapType = this.normalMapType;
  			data.normalScale = this.normalScale.toArray();

  		}

  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}

  		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
  		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
  		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;

  			if ( this.combine !== undefined ) data.combine = this.combine;

  		}

  		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
  		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
  		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
  		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.transmission !== undefined ) data.transmission = this.transmission;
  		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
  		if ( this.thickness !== undefined ) data.thickness = this.thickness;
  		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
  		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
  		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

  		if ( this.size !== undefined ) data.size = this.size;
  		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
  		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  		if ( this.blending !== NormalBlending ) data.blending = this.blending;
  		if ( this.side !== FrontSide ) data.side = this.side;
  		if ( this.vertexColors === true ) data.vertexColors = true;

  		if ( this.opacity < 1 ) data.opacity = this.opacity;
  		if ( this.transparent === true ) data.transparent = true;

  		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
  		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
  		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
  		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
  		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
  		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
  		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
  		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

  		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
  		if ( this.depthTest === false ) data.depthTest = this.depthTest;
  		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
  		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

  		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
  		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
  		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
  		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
  		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
  		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
  		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
  		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

  		// rotation (SpriteMaterial)
  		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

  		if ( this.polygonOffset === true ) data.polygonOffset = true;
  		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
  		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

  		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
  		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
  		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
  		if ( this.scale !== undefined ) data.scale = this.scale;

  		if ( this.dithering === true ) data.dithering = true;

  		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  		if ( this.alphaHash === true ) data.alphaHash = true;
  		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
  		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
  		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

  		if ( this.wireframe === true ) data.wireframe = true;
  		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  		if ( this.flatShading === true ) data.flatShading = true;

  		if ( this.visible === false ) data.visible = false;

  		if ( this.toneMapped === false ) data.toneMapped = false;

  		if ( this.fog === false ) data.fog = false;

  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRootObject ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;

  		}

  		return data;

  	}

  	/**
  	 * Returns a new material with copied values from this instance.
  	 *
  	 * @return {Material} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given material to this instance.
  	 *
  	 * @param {Material} source - The material to copy.
  	 * @return {Material} A reference to this instance.
  	 */
  	copy( source ) {

  		this.name = source.name;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;
  		this.blendColor.copy( source.blendColor );
  		this.blendAlpha = source.blendAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.stencilWriteMask = source.stencilWriteMask;
  		this.stencilFunc = source.stencilFunc;
  		this.stencilRef = source.stencilRef;
  		this.stencilFuncMask = source.stencilFuncMask;
  		this.stencilFail = source.stencilFail;
  		this.stencilZFail = source.stencilZFail;
  		this.stencilZPass = source.stencilZPass;
  		this.stencilWrite = source.stencilWrite;

  		const srcPlanes = source.clippingPlanes;
  		let dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			const n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( let i = 0; i !== n; ++ i ) {

  				dstPlanes[ i ] = srcPlanes[ i ].clone();

  			}

  		}

  		this.clippingPlanes = dstPlanes;
  		this.clipIntersection = source.clipIntersection;
  		this.clipShadows = source.clipShadows;

  		this.shadowSide = source.shadowSide;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.alphaHash = source.alphaHash;
  		this.alphaToCoverage = source.alphaToCoverage;
  		this.premultipliedAlpha = source.premultipliedAlpha;
  		this.forceSinglePass = source.forceSinglePass;

  		this.visible = source.visible;

  		this.toneMapped = source.toneMapped;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		return this;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires Material#dispose
  	 */
  	dispose() {

  		/**
  		 * Fires when the material has been disposed of.
  		 *
  		 * @event Material#dispose
  		 * @type {Object}
  		 */
  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	/**
  	 * Setting this property to `true` indicates the engine the material
  	 * needs to be recompiled.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  }

  /**
   * A material for drawing geometries in a simple shaded (flat or wireframe) way.
   *
   * This material is not affected by lights.
   *
   * @augments Material
   */
  class MeshBasicMaterial extends Material {

  	/**
  	 * Constructs a new mesh basic material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshBasicMaterial = true;

  		this.type = 'MeshBasicMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // emissive

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Specular map used by the material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularMap = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The environment map.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.envMap = null;

  		/**
  		 * The rotation of the environment map in radians.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.envMapRotation = new Euler();

  		/**
  		 * How to combine the result of the surface's color with the environment map, if any.
  		 *
  		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
  		 * blend between the two colors.
  		 *
  		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
  		 * @default MultiplyOperation
  		 */
  		this.combine = MultiplyOperation;

  		/**
  		 * How much the environment map affects the surface.
  		 * The valid range is between `0` (no reflections) and `1` (full reflections).
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.reflectivity = 1;

  		/**
  		 * The index of refraction (IOR) of air (approximately 1) divided by the
  		 * index of refraction of the material. It is used with environment mapping
  		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
  		 * The refraction ratio should not exceed `1`.
  		 *
  		 * @type {number}
  		 * @default 0.98
  		 */
  		this.refractionRatio = 0.98;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

  const _tables = /*@__PURE__*/ _generateTables();

  function _generateTables() {

  	// float32 to float16 helpers

  	const buffer = new ArrayBuffer( 4 );
  	const floatView = new Float32Array( buffer );
  	const uint32View = new Uint32Array( buffer );

  	const baseTable = new Uint32Array( 512 );
  	const shiftTable = new Uint32Array( 512 );

  	for ( let i = 0; i < 256; ++ i ) {

  		const e = i - 127;

  		// very small number (0, -0)

  		if ( e < -27 ) {

  			baseTable[ i ] = 0x0000;
  			baseTable[ i | 0x100 ] = 0x8000;
  			shiftTable[ i ] = 24;
  			shiftTable[ i | 0x100 ] = 24;

  			// small number (denorm)

  		} else if ( e < -14 ) {

  			baseTable[ i ] = 0x0400 >> ( - e - 14 );
  			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
  			shiftTable[ i ] = - e - 1;
  			shiftTable[ i | 0x100 ] = - e - 1;

  			// normal number

  		} else if ( e <= 15 ) {

  			baseTable[ i ] = ( e + 15 ) << 10;
  			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
  			shiftTable[ i ] = 13;
  			shiftTable[ i | 0x100 ] = 13;

  			// large number (Infinity, -Infinity)

  		} else if ( e < 128 ) {

  			baseTable[ i ] = 0x7c00;
  			baseTable[ i | 0x100 ] = 0xfc00;
  			shiftTable[ i ] = 24;
  			shiftTable[ i | 0x100 ] = 24;

  			// stay (NaN, Infinity, -Infinity)

  		} else {

  			baseTable[ i ] = 0x7c00;
  			baseTable[ i | 0x100 ] = 0xfc00;
  			shiftTable[ i ] = 13;
  			shiftTable[ i | 0x100 ] = 13;

  		}

  	}

  	// float16 to float32 helpers

  	const mantissaTable = new Uint32Array( 2048 );
  	const exponentTable = new Uint32Array( 64 );
  	const offsetTable = new Uint32Array( 64 );

  	for ( let i = 1; i < 1024; ++ i ) {

  		let m = i << 13; // zero pad mantissa bits
  		let e = 0; // zero exponent

  		// normalized
  		while ( ( m & 0x00800000 ) === 0 ) {

  			m <<= 1;
  			e -= 0x00800000; // decrement exponent

  		}

  		m &= -8388609; // clear leading 1 bit
  		e += 0x38800000; // adjust bias

  		mantissaTable[ i ] = m | e;

  	}

  	for ( let i = 1024; i < 2048; ++ i ) {

  		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

  	}

  	for ( let i = 1; i < 31; ++ i ) {

  		exponentTable[ i ] = i << 23;

  	}

  	exponentTable[ 31 ] = 0x47800000;
  	exponentTable[ 32 ] = 0x80000000;

  	for ( let i = 33; i < 63; ++ i ) {

  		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

  	}

  	exponentTable[ 63 ] = 0xc7800000;

  	for ( let i = 1; i < 64; ++ i ) {

  		if ( i !== 32 ) {

  			offsetTable[ i ] = 1024;

  		}

  	}

  	return {
  		floatView: floatView,
  		uint32View: uint32View,
  		baseTable: baseTable,
  		shiftTable: shiftTable,
  		mantissaTable: mantissaTable,
  		exponentTable: exponentTable,
  		offsetTable: offsetTable
  	};

  }

  /**
   * Returns a half precision floating point value (FP16) from the given single
   * precision floating point value (FP32).
   *
   * @param {number} val - A single precision floating point value.
   * @return {number} The FP16 value.
   */
  function toHalfFloat( val ) {

  	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

  	val = clamp$1( val, -65504, 65504 );

  	_tables.floatView[ 0 ] = val;
  	const f = _tables.uint32View[ 0 ];
  	const e = ( f >> 23 ) & 0x1ff;
  	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

  }

  /**
   * Returns a single precision floating point value (FP32) from the given half
   * precision floating point value (FP16).
   *
   * @param {number} val - A half precision floating point value.
   * @return {number} The FP32 value.
   */
  function fromHalfFloat( val ) {

  	const m = val >> 10;
  	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
  	return _tables.floatView[ 0 ];

  }

  const _vector$9 = /*@__PURE__*/ new Vector3();
  const _vector2$1 = /*@__PURE__*/ new Vector2();

  let _id$2$1 = 0;

  /**
   * This class stores data for an attribute (such as vertex positions, face
   * indices, normals, colors, UVs, and any custom attributes ) associated with
   * a geometry, which allows for more efficient passing of data to the GPU.
   *
   * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
   * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
   */
  class BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {TypedArray} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized = false ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBufferAttribute = true;

  		/**
  		 * The ID of the buffer attribute.
  		 *
  		 * @name BufferAttribute#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _id$2$1 ++ } );

  		/**
  		 * The name of the buffer attribute.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The array holding the attribute data. It should have `itemSize * numVertices`
  		 * elements, where `numVertices` is the number of vertices in the associated geometry.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.array = array;

  		/**
  		 * The number of values of the array that should be associated with a particular vertex.
  		 * For instance, if this attribute is storing a 3-component vector (such as a position,
  		 * normal, or color), then the value should be `3`.
  		 *
  		 * @type {number}
  		 */
  		this.itemSize = itemSize;

  		/**
  		 * Represents the number of items this buffer attribute stores. It is internally computed
  		 * by dividing the `array` length by the `itemSize`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 */
  		this.count = array !== undefined ? array.length / itemSize : 0;

  		/**
  		 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
  		 * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
  		 * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
  		 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
  		 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
  		 *
  		 * @type {boolean}
  		 */
  		this.normalized = normalized;

  		/**
  		 * Defines the intended usage pattern of the data store for optimization purposes.
  		 *
  		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
  		 * instantiate a new one and set the desired usage before the next render.
  		 *
  		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
  		 * @default StaticDrawUsage
  		 */
  		this.usage = StaticDrawUsage;

  		/**
  		 * This can be used to only update some components of stored vectors (for example, just the
  		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.updateRanges = [];

  		/**
  		 * Configures the bound GPU type for use in shaders.
  		 *
  		 * Note: this only has an effect for integer arrays and is not configurable for float arrays.
  		 * For lower precision float types, use `Float16BufferAttribute`.
  		 *
  		 * @type {(FloatType|IntType)}
  		 * @default FloatType
  		 */
  		this.gpuType = FloatType;

  		/**
  		 * A version number, incremented every time the `needsUpdate` is set to `true`.
  		 *
  		 * @type {number}
  		 */
  		this.version = 0;

  	}

  	/**
  	 * A callback function that is executed after the renderer has transferred the attribute
  	 * array data to the GPU.
  	 */
  	onUploadCallback() {}

  	/**
  	 * Flag to indicate that this attribute has changed and should be re-sent to
  	 * the GPU. Set this to `true` when you modify the value of the array.
  	 *
  	 * @type {number}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	/**
  	 * Sets the usage of this buffer attribute.
  	 *
  	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
  	 * @return {BufferAttribute} A reference to this buffer attribute.
  	 */
  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	/**
  	 * Adds a range of data in the data array to be updated on the GPU.
  	 *
  	 * @param {number} start - Position at which to start update.
  	 * @param {number} count - The number of components to update.
  	 */
  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	/**
  	 * Clears the update ranges.
  	 */
  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	/**
  	 * Copies the values of the given buffer attribute to this instance.
  	 *
  	 * @param {BufferAttribute} source - The buffer attribute to copy.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	copy( source ) {

  		this.name = source.name;
  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.usage = source.usage;
  		this.gpuType = source.gpuType;

  		return this;

  	}

  	/**
  	 * Copies a vector from the given buffer attribute to this one. The start
  	 * and destination position in the attribute buffers are represented by the
  	 * given indices.
  	 *
  	 * @param {number} index1 - The destination index into this buffer attribute.
  	 * @param {BufferAttribute} attribute - The buffer attribute to copy from.
  	 * @param {number} index2 - The source index into the given buffer attribute.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	/**
  	 * Copies the given array data into this buffer attribute.
  	 *
  	 * @param {(TypedArray|Array)} array - The array to copy.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	copyArray( array ) {

  		this.array.set( array );

  		return this;

  	}

  	/**
  	 * Applies the given 3x3 matrix to the given attribute. Works with
  	 * item size `2` and `3`.
  	 *
  	 * @param {Matrix3} m - The matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	applyMatrix3( m ) {

  		if ( this.itemSize === 2 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector2$1.fromBufferAttribute( this, i );
  				_vector2$1.applyMatrix3( m );

  				this.setXY( i, _vector2$1.x, _vector2$1.y );

  			}

  		} else if ( this.itemSize === 3 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector$9.fromBufferAttribute( this, i );
  				_vector$9.applyMatrix3( m );

  				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  			}

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyMatrix4( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix3} m - The normal matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3` and with direction vectors.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.transformDirection( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	/**
  	 * Sets the given array data in the buffer attribute.
  	 *
  	 * @param {(TypedArray|Array)} value - The array data to set.
  	 * @param {number} [offset=0] - The offset in this buffer attribute's array.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	set( value, offset = 0 ) {

  		// Matching BufferAttribute constructor, do not normalize the array.
  		this.array.set( value, offset );

  		return this;

  	}

  	/**
  	 * Returns the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @return {number} The returned value.
  	 */
  	getComponent( index, component ) {

  		let value = this.array[ index * this.itemSize + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	/**
  	 * Sets the given value to the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @param {number} value - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize$1( value, this.array );

  		this.array[ index * this.itemSize + component ] = value;

  		return this;

  	}

  	/**
  	 * Returns the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The x component.
  	 */
  	getX( index ) {

  		let x = this.array[ index * this.itemSize ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	/**
  	 * Sets the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setX( index, x ) {

  		if ( this.normalized ) x = normalize$1( x, this.array );

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	}

  	/**
  	 * Returns the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The y component.
  	 */
  	getY( index ) {

  		let y = this.array[ index * this.itemSize + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	/**
  	 * Sets the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} y - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setY( index, y ) {

  		if ( this.normalized ) y = normalize$1( y, this.array );

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Returns the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The z component.
  	 */
  	getZ( index ) {

  		let z = this.array[ index * this.itemSize + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	/**
  	 * Sets the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} z - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize$1( z, this.array );

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Returns the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The w component.
  	 */
  	getW( index ) {

  		let w = this.array[ index * this.itemSize + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	/**
  	 * Sets the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} w - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setW( index, w ) {

  		if ( this.normalized ) w = normalize$1( w, this.array );

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Sets the x and y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Sets the x, y and z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Sets the x, y, z and w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @param {number} w - The value for the w component to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );
  			w = normalize$1( w, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Sets the given callback function that is executed after the Renderer has transferred
  	 * the attribute array data to the GPU. Can be used to perform clean-up operations after
  	 * the upload when attribute data are not needed anymore on the CPU side.
  	 *
  	 * @param {Function} callback - The `onUpload()` callback.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	/**
  	 * Returns a new buffer attribute with copied values from this instance.
  	 *
  	 * @return {BufferAttribute} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  	/**
  	 * Serializes the buffer attribute into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized buffer attribute.
  	 */
  	toJSON() {

  		const data = {
  			itemSize: this.itemSize,
  			type: this.array.constructor.name,
  			array: Array.from( this.array ),
  			normalized: this.normalized
  		};

  		if ( this.name !== '' ) data.name = this.name;
  		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

  		return data;

  	}

  }

  /**
   * Convenient class that can be used when creating a `UInt16` buffer attribute with
   * a plain `Array` instance.
   *
   * @augments BufferAttribute
   */
  class Uint16BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  	}

  }

  /**
   * Convenient class that can be used when creating a `UInt32` buffer attribute with
   * a plain `Array` instance.
   *
   * @augments BufferAttribute
   */
  class Uint32BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Uint32Array( array ), itemSize, normalized );

  	}

  }

  /**
   * Convenient class that can be used when creating a `Float16` buffer attribute with
   * a plain `Array` instance.
   *
   * This class automatically converts to and from FP16 via `Uint16Array` since `Float16Array`
   * browser support is still problematic.
   *
   * @augments BufferAttribute
   */
  class Float16BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  		this.isFloat16BufferAttribute = true;

  	}

  	getX( index ) {

  		let x = fromHalfFloat( this.array[ index * this.itemSize ] );

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	setX( index, x ) {

  		if ( this.normalized ) x = normalize$1( x, this.array );

  		this.array[ index * this.itemSize ] = toHalfFloat( x );

  		return this;

  	}

  	getY( index ) {

  		let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	setY( index, y ) {

  		if ( this.normalized ) y = normalize$1( y, this.array );

  		this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

  		return this;

  	}

  	getZ( index ) {

  		let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize$1( z, this.array );

  		this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

  		return this;

  	}

  	getW( index ) {

  		let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	setW( index, w ) {

  		if ( this.normalized ) w = normalize$1( w, this.array );

  		this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

  		return this;

  	}

  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );

  		}

  		this.array[ index + 0 ] = toHalfFloat( x );
  		this.array[ index + 1 ] = toHalfFloat( y );

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );

  		}

  		this.array[ index + 0 ] = toHalfFloat( x );
  		this.array[ index + 1 ] = toHalfFloat( y );
  		this.array[ index + 2 ] = toHalfFloat( z );

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );
  			w = normalize$1( w, this.array );

  		}

  		this.array[ index + 0 ] = toHalfFloat( x );
  		this.array[ index + 1 ] = toHalfFloat( y );
  		this.array[ index + 2 ] = toHalfFloat( z );
  		this.array[ index + 3 ] = toHalfFloat( w );

  		return this;

  	}

  }

  /**
   * Convenient class that can be used when creating a `Float32` buffer attribute with
   * a plain `Array` instance.
   *
   * @augments BufferAttribute
   */
  class Float32BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Float32Array( array ), itemSize, normalized );

  	}

  }

  let _id$1$1 = 0;

  const _m1$3 = /*@__PURE__*/ new Matrix4();
  const _obj = /*@__PURE__*/ new Object3D();
  const _offset = /*@__PURE__*/ new Vector3();
  const _box$2 = /*@__PURE__*/ new Box3();
  const _boxMorphTargets = /*@__PURE__*/ new Box3();
  const _vector$8 = /*@__PURE__*/ new Vector3();

  /**
   * A representation of mesh, line, or point geometry. Includes vertex
   * positions, face indices, normals, colors, UVs, and custom attributes
   * within buffers, reducing the cost of passing all this data to the GPU.
   *
   * ```js
   * const geometry = new THREE.BufferGeometry();
   * // create a simple square shape. We duplicate the top left and bottom right
   * // vertices because each vertex needs to appear once per triangle.
   * const vertices = new Float32Array( [
   * 	-1.0, -1.0,  1.0, // v0
   * 	 1.0, -1.0,  1.0, // v1
   * 	 1.0,  1.0,  1.0, // v2
   *
   * 	 1.0,  1.0,  1.0, // v3
   * 	-1.0,  1.0,  1.0, // v4
   * 	-1.0, -1.0,  1.0  // v5
   * ] );
   * // itemSize = 3 because there are 3 values (components) per vertex
   * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
   * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
   * const mesh = new THREE.Mesh( geometry, material );
   * ```
   *
   * @augments EventDispatcher
   */
  class BufferGeometry extends EventDispatcher {

  	/**
  	 * Constructs a new geometry.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBufferGeometry = true;

  		/**
  		 * The ID of the geometry.
  		 *
  		 * @name BufferGeometry#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _id$1$1 ++ } );

  		/**
  		 * The UUID of the geometry.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the geometry.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';
  		this.type = 'BufferGeometry';

  		/**
  		 * Allows for vertices to be re-used across multiple triangles; this is
  		 * called using "indexed triangles". Each triangle is associated with the
  		 * indices of three vertices. This attribute therefore stores the index of
  		 * each vertex for each triangular face. If this attribute is not set, the
  		 * renderer assumes that each three contiguous positions represent a single triangle.
  		 *
  		 * @type {?BufferAttribute}
  		 * @default null
  		 */
  		this.index = null;

  		/**
  		 * A (storage) buffer attribute which was generated with a compute shader and
  		 * now defines indirect draw calls.
  		 *
  		 * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
  		 *
  		 * @type {?BufferAttribute}
  		 * @default null
  		 */
  		this.indirect = null;

  		/**
  		 * This dictionary has as id the name of the attribute to be set and as value
  		 * the buffer attribute to set it to. Rather than accessing this property directly,
  		 * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
  		 *
  		 * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
  		 */
  		this.attributes = {};

  		/**
  		 * This dictionary holds the morph targets of the geometry.
  		 *
  		 * Note: Once the geometry has been rendered, the morph attribute data cannot
  		 * be changed. You will have to call `dispose()?, and create a new geometry instance.
  		 *
  		 * @type {Object}
  		 */
  		this.morphAttributes = {};

  		/**
  		 * Used to control the morph target behavior; when set to `true`, the morph
  		 * target data is treated as relative offsets, rather than as absolute
  		 * positions/normals.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.morphTargetsRelative = false;

  		/**
  		 * Split the geometry into groups, each of which will be rendered in a
  		 * separate draw call. This allows an array of materials to be used with the geometry.
  		 *
  		 * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
  		 *
  		 * Every vertex and index must belong to exactly one group — groups must not share vertices or
  		 * indices, and must not leave vertices or indices unused.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.groups = [];

  		/**
  		 * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
  		 *
  		 * @type {Box3}
  		 * @default null
  		 */
  		this.boundingBox = null;

  		/**
  		 * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
  		 *
  		 * @type {Sphere}
  		 * @default null
  		 */
  		this.boundingSphere = null;

  		/**
  		 * Determines the part of the geometry to render. This should not be set directly,
  		 * instead use `setDrawRange()`.
  		 *
  		 * @type {{start:number,count:number}}
  		 */
  		this.drawRange = { start: 0, count: Infinity };

  		/**
  		 * An object that can be used to store custom data about the geometry.
  		 * It should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  	}

  	/**
  	 * Returns the index of this geometry.
  	 *
  	 * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
  	 */
  	getIndex() {

  		return this.index;

  	}

  	/**
  	 * Sets the given index to this geometry.
  	 *
  	 * @param {Array<number>|BufferAttribute} index - The index to set.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setIndex( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  		return this;

  	}

  	/**
  	 * Sets the given indirect attribute to this geometry.
  	 *
  	 * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setIndirect( indirect ) {

  		this.indirect = indirect;

  		return this;

  	}

  	/**
  	 * Returns the indirect attribute of this geometry.
  	 *
  	 * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
  	 */
  	getIndirect() {

  		return this.indirect;

  	}

  	/**
  	 * Returns the buffer attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
  	 * Returns `undefined` if not attribute has been found.
  	 */
  	getAttribute( name ) {

  		return this.attributes[ name ];

  	}

  	/**
  	 * Sets the given attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setAttribute( name, attribute ) {

  		this.attributes[ name ] = attribute;

  		return this;

  	}

  	/**
  	 * Deletes the attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name to delete.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	deleteAttribute( name ) {

  		delete this.attributes[ name ];

  		return this;

  	}

  	/**
  	 * Returns `true` if this geometry has an attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @return {boolean} Whether this geometry has an attribute for the given name or not.
  	 */
  	hasAttribute( name ) {

  		return this.attributes[ name ] !== undefined;

  	}

  	/**
  	 * Adds a group to this geometry.
  	 *
  	 * @param {number} start - The first element in this draw call. That is the first
  	 * vertex for non-indexed geometry, otherwise the first triangle index.
  	 * @param {number} count - Specifies how many vertices (or indices) are part of this group.
  	 * @param {number} [materialIndex=0] - The material array index to use.
  	 */
  	addGroup( start, count, materialIndex = 0 ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex

  		} );

  	}

  	/**
  	 * Clears all groups.
  	 */
  	clearGroups() {

  		this.groups = [];

  	}

  	/**
  	 * Sets the draw range for this geometry.
  	 *
  	 * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
  	 * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
  	 * For indexed BufferGeometry, `count` is the number of indices to render.
  	 */
  	setDrawRange( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	}

  	/**
  	 * Applies the given 4x4 transformation matrix to the geometry.
  	 *
  	 * @param {Matrix4} matrix - The matrix to apply.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	applyMatrix4( matrix ) {

  		const position = this.attributes.position;

  		if ( position !== undefined ) {

  			position.applyMatrix4( matrix );

  			position.needsUpdate = true;

  		}

  		const normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normal.applyNormalMatrix( normalMatrix );

  			normal.needsUpdate = true;

  		}

  		const tangent = this.attributes.tangent;

  		if ( tangent !== undefined ) {

  			tangent.transformDirection( matrix );

  			tangent.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	}

  	/**
  	 * Applies the rotation represented by the Quaternion to the geometry.
  	 *
  	 * @param {Quaternion} q - The Quaternion to apply.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	applyQuaternion( q ) {

  		_m1$3.makeRotationFromQuaternion( q );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry about the X axis. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	rotateX( angle ) {

  		// rotate geometry around world x-axis

  		_m1$3.makeRotationX( angle );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry about the Y axis. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	rotateY( angle ) {

  		// rotate geometry around world y-axis

  		_m1$3.makeRotationY( angle );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry about the Z axis. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	rotateZ( angle ) {

  		// rotate geometry around world z-axis

  		_m1$3.makeRotationZ( angle );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Translates the geometry. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#position} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} x - The x offset.
  	 * @param {number} y - The y offset.
  	 * @param {number} z - The z offset.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	translate( x, y, z ) {

  		// translate geometry

  		_m1$3.makeTranslation( x, y, z );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Scales the geometry. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#scale} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} x - The x scale.
  	 * @param {number} y - The y scale.
  	 * @param {number} z - The z scale.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	scale( x, y, z ) {

  		// scale geometry

  		_m1$3.makeScale( x, y, z );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry to face a point in 3D space. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {Vector3} vector - The target point.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	lookAt( vector ) {

  		_obj.lookAt( vector );

  		_obj.updateMatrix();

  		this.applyMatrix4( _obj.matrix );

  		return this;

  	}

  	/**
  	 * Center the geometry based on its bounding box.
  	 *
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	center() {

  		this.computeBoundingBox();

  		this.boundingBox.getCenter( _offset ).negate();

  		this.translate( _offset.x, _offset.y, _offset.z );

  		return this;

  	}

  	/**
  	 * Defines a geometry by creating a `position` attribute based on the given array of points. The array
  	 * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
  	 * set to `0`.
  	 *
  	 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
  	 * data from the array. The length of the array must match the vertex count.
  	 *
  	 * @param {Array<Vector2>|Array<Vector3>} points - The points.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setFromPoints( points ) {

  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute === undefined ) {

  			const position = [];

  			for ( let i = 0, l = points.length; i < l; i ++ ) {

  				const point = points[ i ];
  				position.push( point.x, point.y, point.z || 0 );

  			}

  			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  		} else {

  			const l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size

  			for ( let i = 0; i < l; i ++ ) {

  				const point = points[ i ];
  				positionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );

  			}

  			if ( points.length > positionAttribute.count ) {

  				console.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );

  			}

  			positionAttribute.needsUpdate = true;

  		}

  		return this;

  	}

  	/**
  	 * Computes the bounding box of the geometry, and updates the `boundingBox` member.
  	 * The bounding box is not computed by the engine; it must be computed by your app.
  	 * You may need to recompute the bounding box if the geometry vertices are modified.
  	 */
  	computeBoundingBox() {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

  			this.boundingBox.set(
  				new Vector3( - Infinity, - Infinity, - Infinity ),
  				new Vector3( + Infinity, + Infinity, + Infinity )
  			);

  			return;

  		}

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_box$2.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
  						this.boundingBox.expandByPoint( _vector$8 );

  						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
  						this.boundingBox.expandByPoint( _vector$8 );

  					} else {

  						this.boundingBox.expandByPoint( _box$2.min );
  						this.boundingBox.expandByPoint( _box$2.max );

  					}

  				}

  			}

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	}

  	/**
  	 * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
  	 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
  	 * You may need to recompute the bounding sphere if the geometry vertices are modified.
  	 */
  	computeBoundingSphere() {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

  			this.boundingSphere.set( new Vector3(), Infinity );

  			return;

  		}

  		if ( position ) {

  			// first, find the center of the bounding sphere

  			const center = this.boundingSphere.center;

  			_box$2.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
  						_box$2.expandByPoint( _vector$8 );

  						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
  						_box$2.expandByPoint( _vector$8 );

  					} else {

  						_box$2.expandByPoint( _boxMorphTargets.min );
  						_box$2.expandByPoint( _boxMorphTargets.max );

  					}

  				}

  			}

  			_box$2.getCenter( center );

  			// second, try to find a boundingSphere with a radius smaller than the
  			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  			let maxRadiusSq = 0;

  			for ( let i = 0, il = position.count; i < il; i ++ ) {

  				_vector$8.fromBufferAttribute( position, i );

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  			}

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					const morphTargetsRelative = this.morphTargetsRelative;

  					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

  						_vector$8.fromBufferAttribute( morphAttribute, j );

  						if ( morphTargetsRelative ) {

  							_offset.fromBufferAttribute( position, j );
  							_vector$8.add( _offset );

  						}

  						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  					}

  				}

  			}

  			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  			if ( isNaN( this.boundingSphere.radius ) ) {

  				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  			}

  		}

  	}

  	/**
  	 * Calculates and adds a tangent attribute to this geometry.
  	 *
  	 * The computation is only supported for indexed geometries and if position, normal, and uv attributes
  	 * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
  	 * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
  	 */
  	computeTangents() {

  		const index = this.index;
  		const attributes = this.attributes;

  		// based on http://www.terathon.com/code/tangent.html
  		// (per vertex tangents)

  		if ( index === null ||
  			 attributes.position === undefined ||
  			 attributes.normal === undefined ||
  			 attributes.uv === undefined ) {

  			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
  			return;

  		}

  		const positionAttribute = attributes.position;
  		const normalAttribute = attributes.normal;
  		const uvAttribute = attributes.uv;

  		if ( this.hasAttribute( 'tangent' ) === false ) {

  			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

  		}

  		const tangentAttribute = this.getAttribute( 'tangent' );

  		const tan1 = [], tan2 = [];

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			tan1[ i ] = new Vector3();
  			tan2[ i ] = new Vector3();

  		}

  		const vA = new Vector3(),
  			vB = new Vector3(),
  			vC = new Vector3(),

  			uvA = new Vector2(),
  			uvB = new Vector2(),
  			uvC = new Vector2(),

  			sdir = new Vector3(),
  			tdir = new Vector3();

  		function handleTriangle( a, b, c ) {

  			vA.fromBufferAttribute( positionAttribute, a );
  			vB.fromBufferAttribute( positionAttribute, b );
  			vC.fromBufferAttribute( positionAttribute, c );

  			uvA.fromBufferAttribute( uvAttribute, a );
  			uvB.fromBufferAttribute( uvAttribute, b );
  			uvC.fromBufferAttribute( uvAttribute, c );

  			vB.sub( vA );
  			vC.sub( vA );

  			uvB.sub( uvA );
  			uvC.sub( uvA );

  			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

  			// silently ignore degenerate uv triangles having coincident or colinear vertices

  			if ( ! isFinite( r ) ) return;

  			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
  			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

  			tan1[ a ].add( sdir );
  			tan1[ b ].add( sdir );
  			tan1[ c ].add( sdir );

  			tan2[ a ].add( tdir );
  			tan2[ b ].add( tdir );
  			tan2[ c ].add( tdir );

  		}

  		let groups = this.groups;

  		if ( groups.length === 0 ) {

  			groups = [ {
  				start: 0,
  				count: index.count
  			} ];

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleTriangle(
  					index.getX( j + 0 ),
  					index.getX( j + 1 ),
  					index.getX( j + 2 )
  				);

  			}

  		}

  		const tmp = new Vector3(), tmp2 = new Vector3();
  		const n = new Vector3(), n2 = new Vector3();

  		function handleVertex( v ) {

  			n.fromBufferAttribute( normalAttribute, v );
  			n2.copy( n );

  			const t = tan1[ v ];

  			// Gram-Schmidt orthogonalize

  			tmp.copy( t );
  			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

  			// Calculate handedness

  			tmp2.crossVectors( n2, t );
  			const test = tmp2.dot( tan2[ v ] );
  			const w = ( test < 0.0 ) ? -1 : 1.0;

  			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleVertex( index.getX( j + 0 ) );
  				handleVertex( index.getX( j + 1 ) );
  				handleVertex( index.getX( j + 2 ) );

  			}

  		}

  	}

  	/**
  	 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
  	 * each vertex normal to be the average of the face normals of the faces that share that vertex.
  	 * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
  	 * to be the same as the face normal.
  	 */
  	computeVertexNormals() {

  		const index = this.index;
  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute !== undefined ) {

  			let normalAttribute = this.getAttribute( 'normal' );

  			if ( normalAttribute === undefined ) {

  				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
  				this.setAttribute( 'normal', normalAttribute );

  			} else {

  				// reset existing normals to zero

  				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

  					normalAttribute.setXYZ( i, 0, 0, 0 );

  				}

  			}

  			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
  			const cb = new Vector3(), ab = new Vector3();

  			// indexed elements

  			if ( index ) {

  				for ( let i = 0, il = index.count; i < il; i += 3 ) {

  					const vA = index.getX( i + 0 );
  					const vB = index.getX( i + 1 );
  					const vC = index.getX( i + 2 );

  					pA.fromBufferAttribute( positionAttribute, vA );
  					pB.fromBufferAttribute( positionAttribute, vB );
  					pC.fromBufferAttribute( positionAttribute, vC );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					nA.fromBufferAttribute( normalAttribute, vA );
  					nB.fromBufferAttribute( normalAttribute, vB );
  					nC.fromBufferAttribute( normalAttribute, vC );

  					nA.add( cb );
  					nB.add( cb );
  					nC.add( cb );

  					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
  					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
  					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

  					pA.fromBufferAttribute( positionAttribute, i + 0 );
  					pB.fromBufferAttribute( positionAttribute, i + 1 );
  					pC.fromBufferAttribute( positionAttribute, i + 2 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

  				}

  			}

  			this.normalizeNormals();

  			normalAttribute.needsUpdate = true;

  		}

  	}

  	/**
  	 * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
  	 * correct lighting on the geometry surfaces.
  	 */
  	normalizeNormals() {

  		const normals = this.attributes.normal;

  		for ( let i = 0, il = normals.count; i < il; i ++ ) {

  			_vector$8.fromBufferAttribute( normals, i );

  			_vector$8.normalize();

  			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

  		}

  	}

  	/**
  	 * Return a new non-index version of this indexed geometry. If the geometry
  	 * is already non-indexed, the method is a NOOP.
  	 *
  	 * @return {BufferGeometry} The non-indexed version of this indexed geometry.
  	 */
  	toNonIndexed() {

  		function convertBufferAttribute( attribute, indices ) {

  			const array = attribute.array;
  			const itemSize = attribute.itemSize;
  			const normalized = attribute.normalized;

  			const array2 = new array.constructor( indices.length * itemSize );

  			let index = 0, index2 = 0;

  			for ( let i = 0, l = indices.length; i < l; i ++ ) {

  				if ( attribute.isInterleavedBufferAttribute ) {

  					index = indices[ i ] * attribute.data.stride + attribute.offset;

  				} else {

  					index = indices[ i ] * itemSize;

  				}

  				for ( let j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			return new BufferAttribute( array2, itemSize, normalized );

  		}

  		//

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
  			return this;

  		}

  		const geometry2 = new BufferGeometry();

  		const indices = this.index.array;
  		const attributes = this.attributes;

  		// attributes

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];

  			const newAttribute = convertBufferAttribute( attribute, indices );

  			geometry2.setAttribute( name, newAttribute );

  		}

  		// morph attributes

  		const morphAttributes = this.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const morphArray = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

  				const attribute = morphAttribute[ i ];

  				const newAttribute = convertBufferAttribute( attribute, indices );

  				morphArray.push( newAttribute );

  			}

  			geometry2.morphAttributes[ name ] = morphArray;

  		}

  		geometry2.morphTargetsRelative = this.morphTargetsRelative;

  		// groups

  		const groups = this.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			geometry2.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return geometry2;

  	}

  	/**
  	 * Serializes the geometry into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized geometry.
  	 */
  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.7,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;
  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		if ( this.parameters !== undefined ) {

  			const parameters = this.parameters;

  			for ( const key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		// for simplicity the code assumes attributes are not shared across geometries, see #15811

  		data.data = { attributes: {} };

  		const index = this.index;

  		if ( index !== null ) {

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: Array.prototype.slice.call( index.array )
  			};

  		}

  		const attributes = this.attributes;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];

  			data.data.attributes[ key ] = attribute.toJSON( data.data );

  		}

  		const morphAttributes = {};
  		let hasMorphAttributes = false;

  		for ( const key in this.morphAttributes ) {

  			const attributeArray = this.morphAttributes[ key ];

  			const array = [];

  			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

  				const attribute = attributeArray[ i ];

  				array.push( attribute.toJSON( data.data ) );

  			}

  			if ( array.length > 0 ) {

  				morphAttributes[ key ] = array;

  				hasMorphAttributes = true;

  			}

  		}

  		if ( hasMorphAttributes ) {

  			data.data.morphAttributes = morphAttributes;
  			data.data.morphTargetsRelative = this.morphTargetsRelative;

  		}

  		const groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		const boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = boundingSphere.toJSON();

  		}

  		return data;

  	}

  	/**
  	 * Returns a new geometry with copied values from this instance.
  	 *
  	 * @return {BufferGeometry} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given geometry to this instance.
  	 *
  	 * @param {BufferGeometry} source - The geometry to copy.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	copy( source ) {

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// used for storing cloned, shared data

  		const data = {};

  		// name

  		this.name = source.name;

  		// index

  		const index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		// attributes

  		const attributes = source.attributes;

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];
  			this.setAttribute( name, attribute.clone( data ) );

  		}

  		// morph attributes

  		const morphAttributes = source.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone( data ) );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		this.morphTargetsRelative = source.morphTargetsRelative;

  		// groups

  		const groups = source.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		const boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		const boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		// user data

  		this.userData = source.userData;

  		return this;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires BufferGeometry#dispose
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
  const _ray$3 = /*@__PURE__*/ new Ray();
  const _sphere$6 = /*@__PURE__*/ new Sphere();
  const _sphereHitAt = /*@__PURE__*/ new Vector3();

  const _vA$1 = /*@__PURE__*/ new Vector3();
  const _vB$1 = /*@__PURE__*/ new Vector3();
  const _vC$1 = /*@__PURE__*/ new Vector3();

  const _tempA = /*@__PURE__*/ new Vector3();
  const _morphA = /*@__PURE__*/ new Vector3();

  const _intersectionPoint = /*@__PURE__*/ new Vector3();
  const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

  /**
   * Class representing triangular polygon mesh based objects.
   *
   * ```js
   * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
   * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
   * const mesh = new THREE.Mesh( geometry, material );
   * scene.add( mesh );
   * ```
   *
   * @augments Object3D
   */
  class Mesh extends Object3D {

  	/**
  	 * Constructs a new mesh.
  	 *
  	 * @param {BufferGeometry} [geometry] - The mesh geometry.
  	 * @param {Material|Array<Material>} [material] - The mesh material.
  	 */
  	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMesh = true;

  		this.type = 'Mesh';

  		/**
  		 * The mesh geometry.
  		 *
  		 * @type {BufferGeometry}
  		 */
  		this.geometry = geometry;

  		/**
  		 * The mesh material.
  		 *
  		 * @type {Material|Array<Material>}
  		 * @default MeshBasicMaterial
  		 */
  		this.material = material;

  		/**
  		 * A dictionary representing the morph targets in the geometry. The key is the
  		 * morph targets name, the value its attribute index. This member is `undefined`
  		 * by default and only set when morph targets are detected in the geometry.
  		 *
  		 * @type {Object<String,number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetDictionary = undefined;

  		/**
  		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
  		 * is applied. This member is `undefined` by default and only set when morph targets are
  		 * detected in the geometry.
  		 *
  		 * @type {Array<number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetInfluences = undefined;

  		/**
  		 * The number of instances of this mesh.
  		 * Can only be used with {@link WebGPURenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.count = 1;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.morphTargetInfluences !== undefined ) {

  			this.morphTargetInfluences = source.morphTargetInfluences.slice();

  		}

  		if ( source.morphTargetDictionary !== undefined ) {

  			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  		}

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	/**
  	 * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
  	 * to make sure existing morph targets can influence this 3D object.
  	 */
  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  	/**
  	 * Returns the local-space position of the vertex at the given index, taking into
  	 * account the current animation state of both morph targets and skinning.
  	 *
  	 * @param {number} index - The vertex index.
  	 * @param {Vector3} target - The target object that is used to store the method's result.
  	 * @return {Vector3} The vertex position in local space.
  	 */
  	getVertexPosition( index, target ) {

  		const geometry = this.geometry;
  		const position = geometry.attributes.position;
  		const morphPosition = geometry.morphAttributes.position;
  		const morphTargetsRelative = geometry.morphTargetsRelative;

  		target.fromBufferAttribute( position, index );

  		const morphInfluences = this.morphTargetInfluences;

  		if ( morphPosition && morphInfluences ) {

  			_morphA.set( 0, 0, 0 );

  			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

  				const influence = morphInfluences[ i ];
  				const morphAttribute = morphPosition[ i ];

  				if ( influence === 0 ) continue;

  				_tempA.fromBufferAttribute( morphAttribute, index );

  				if ( morphTargetsRelative ) {

  					_morphA.addScaledVector( _tempA, influence );

  				} else {

  					_morphA.addScaledVector( _tempA.sub( target ), influence );

  				}

  			}

  			target.add( _morphA );

  		}

  		return target;

  	}

  	/**
  	 * Computes intersection points between a casted ray and this line.
  	 *
  	 * @param {Raycaster} raycaster - The raycaster.
  	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
  	 */
  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// test with bounding sphere in world space

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$6.copy( geometry.boundingSphere );
  		_sphere$6.applyMatrix4( matrixWorld );

  		// check distance from ray origin to bounding sphere

  		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

  		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

  			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

  			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

  		}

  		// convert ray to local space of mesh

  		_inverseMatrix$3.copy( matrixWorld ).invert();
  		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

  		// test with bounding box in local space

  		if ( geometry.boundingBox !== null ) {

  			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

  		}

  		// test for intersections with geometry

  		this._computeIntersections( raycaster, intersects, _ray$3 );

  	}

  	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

  		let intersection;

  		const geometry = this.geometry;
  		const material = this.material;

  		const index = geometry.index;
  		const position = geometry.attributes.position;
  		const uv = geometry.attributes.uv;
  		const uv1 = geometry.attributes.uv1;
  		const normal = geometry.attributes.normal;
  		const groups = geometry.groups;
  		const drawRange = geometry.drawRange;

  		if ( index !== null ) {

  			// indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = index.getX( j );
  						const b = index.getX( j + 1 );
  						const c = index.getX( j + 2 );

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = index.getX( i );
  					const b = index.getX( i + 1 );
  					const c = index.getX( i + 2 );

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		} else if ( position !== undefined ) {

  			// non-indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = j;
  						const b = j + 1;
  						const c = j + 2;

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = i;
  					const b = i + 1;
  					const c = i + 2;

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		}

  	}

  }

  function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

  	let intersect;

  	if ( material.side === BackSide ) {

  		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  	} else {

  		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

  	}

  	if ( intersect === null ) return null;

  	_intersectionPointWorld.copy( point );
  	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

  	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

  	if ( distance < raycaster.near || distance > raycaster.far ) return null;

  	return {
  		distance: distance,
  		point: _intersectionPointWorld.clone(),
  		object: object
  	};

  }

  function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

  	object.getVertexPosition( a, _vA$1 );
  	object.getVertexPosition( b, _vB$1 );
  	object.getVertexPosition( c, _vC$1 );

  	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

  	if ( intersection ) {

  		const barycoord = new Vector3();
  		Triangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );

  		if ( uv ) {

  			intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

  		}

  		if ( uv1 ) {

  			intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

  		}

  		if ( normal ) {

  			intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

  			if ( intersection.normal.dot( ray.direction ) > 0 ) {

  				intersection.normal.multiplyScalar( -1 );

  			}

  		}

  		const face = {
  			a: a,
  			b: b,
  			c: c,
  			normal: new Vector3(),
  			materialIndex: 0
  		};

  		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

  		intersection.face = face;
  		intersection.barycoord = barycoord;

  	}

  	return intersection;

  }

  /**
   * A geometry class for a rectangular cuboid with a given width, height, and depth.
   * On creation, the cuboid is centred on the origin, with each edge parallel to one
   * of the axes.
   *
   * ```js
   * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
   * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
   * const cube = new THREE.Mesh( geometry, material );
   * scene.add( cube );
   * ```
   *
   * @augments BufferGeometry
   */
  class BoxGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new box geometry.
  	 *
  	 * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
  	 * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
  	 * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
  	 * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
  	 * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
  	 * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
  	 */
  	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

  		super();

  		this.type = 'BoxGeometry';

  		/**
  		 * Holds the constructor parameters that have been
  		 * used to generate the geometry. Any modification
  		 * after instantiation does not change the geometry.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		const scope = this;

  		// segments

  		widthSegments = Math.floor( widthSegments );
  		heightSegments = Math.floor( heightSegments );
  		depthSegments = Math.floor( depthSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let numberOfVertices = 0;
  		let groupStart = 0;

  		// build each side of the box geometry

  		buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  		buildPlane( 'z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  		buildPlane( 'x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  		buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  		buildPlane( 'x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  			const segmentWidth = width / gridX;
  			const segmentHeight = height / gridY;

  			const widthHalf = width / 2;
  			const heightHalf = height / 2;
  			const depthHalf = depth / 2;

  			const gridX1 = gridX + 1;
  			const gridY1 = gridY + 1;

  			let vertexCounter = 0;
  			let groupCount = 0;

  			const vector = new Vector3();

  			// generate vertices, normals and uvs

  			for ( let iy = 0; iy < gridY1; iy ++ ) {

  				const y = iy * segmentHeight - heightHalf;

  				for ( let ix = 0; ix < gridX1; ix ++ ) {

  					const x = ix * segmentWidth - widthHalf;

  					// set values to correct vector component

  					vector[ u ] = x * udir;
  					vector[ v ] = y * vdir;
  					vector[ w ] = depthHalf;

  					// now apply vector to vertex buffer

  					vertices.push( vector.x, vector.y, vector.z );

  					// set values to correct vector component

  					vector[ u ] = 0;
  					vector[ v ] = 0;
  					vector[ w ] = depth > 0 ? 1 : -1;

  					// now apply vector to normal buffer

  					normals.push( vector.x, vector.y, vector.z );

  					// uvs

  					uvs.push( ix / gridX );
  					uvs.push( 1 - ( iy / gridY ) );

  					// counters

  					vertexCounter += 1;

  				}

  			}

  			// indices

  			// 1. you need three indices to draw a single face
  			// 2. a single segment consists of two faces
  			// 3. so we need to generate six (2*3) indices per segment

  			for ( let iy = 0; iy < gridY; iy ++ ) {

  				for ( let ix = 0; ix < gridX; ix ++ ) {

  					const a = numberOfVertices + ix + gridX1 * iy;
  					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// increase counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, materialIndex );

  			// calculate new start value for groups

  			groupStart += groupCount;

  			// update total number of vertices

  			numberOfVertices += vertexCounter;

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	/**
  	 * Factory method for creating an instance of this class from the given
  	 * JSON object.
  	 *
  	 * @param {Object} data - A JSON object representing the serialized geometry.
  	 * @return {BoxGeometry} A new instance.
  	 */
  	static fromJSON( data ) {

  		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

  	}

  }

  // Uniform Utilities

  function cloneUniforms( src ) {

  	const dst = {};

  	for ( const u in src ) {

  		dst[ u ] = {};

  		for ( const p in src[ u ] ) {

  			const property = src[ u ][ p ];

  			if ( property && ( property.isColor ||
  				property.isMatrix3 || property.isMatrix4 ||
  				property.isVector2 || property.isVector3 || property.isVector4 ||
  				property.isTexture || property.isQuaternion ) ) {

  				if ( property.isRenderTargetTexture ) {

  					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
  					dst[ u ][ p ] = null;

  				} else {

  					dst[ u ][ p ] = property.clone();

  				}

  			} else if ( Array.isArray( property ) ) {

  				dst[ u ][ p ] = property.slice();

  			} else {

  				dst[ u ][ p ] = property;

  			}

  		}

  	}

  	return dst;

  }

  function cloneUniformsGroups( src ) {

  	const dst = [];

  	for ( let u = 0; u < src.length; u ++ ) {

  		dst.push( src[ u ].clone() );

  	}

  	return dst;

  }

  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  /**
   * A material rendered with custom shaders. A shader is a small program written in GLSL.
   * that runs on the GPU. You may want to use a custom shader if you need to implement an
   * effect not included with any of the built-in materials.
   *
   * There are the following notes to bear in mind when using a `ShaderMaterial`:
   *
   * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
   * - Built in attributes and uniforms are passed to the shaders along with your code. If
   * you don't want that, use {@link RawShaderMaterial} instead.
   * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
   * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
   * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
   *   - The loop has to be [normalized]{@link https://en.wikipedia.org/wiki/Normalized_loop}.
   *   - The loop variable has to be *i*.
   *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
   * value of *i* for the given iteration and can be used in preprocessor
   * statements.
   *
   * ```js
   * const material = new THREE.ShaderMaterial( {
   * 	uniforms: {
   * 		time: { value: 1.0 },
   * 		resolution: { value: new THREE.Vector2() }
   * 	},
   * 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
   * 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
   * } );
   * ```
   *
   * @augments Material
   */
  class ShaderMaterial extends Material {

  	/**
  	 * Constructs a new shader material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isShaderMaterial = true;

  		this.type = 'ShaderMaterial';

  		/**
  		 * Defines custom constants using `#define` directives within the GLSL code
  		 * for both the vertex shader and the fragment shader; each key/value pair
  		 * yields another directive.
  		 * ```js
  		 * defines: {
  		 * 	FOO: 15,
  		 * 	BAR: true
  		 * }
  		 * ```
  		 * Yields the lines:
  		 * ```
  		 * #define FOO 15
  		 * #define BAR true
  		 * ```
  		 *
  		 * @type {Object}
  		 */
  		this.defines = {};

  		/**
  		 * An object of the form:
  		 * ```js
  		 * {
  		 * 	"uniform1": { value: 1.0 },
  		 * 	"uniform2": { value: 2 }
  		 * }
  		 * ```
  		 * specifying the uniforms to be passed to the shader code; keys are uniform
  		 * names, values are definitions of the form
  		 * ```
  		 * {
  		 * 	value: 1.0
  		 * }
  		 * ```
  		 * where `value` is the value of the uniform. Names must match the name of
  		 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
  		 * on every frame, so updating the value of the uniform will immediately
  		 * update the value available to the GLSL code.
  		 *
  		 * @type {Object}
  		 */
  		this.uniforms = {};

  		/**
  		 * An array holding uniforms groups for configuring UBOs.
  		 *
  		 * @type {Array<UniformsGroup>}
  		 */
  		this.uniformsGroups = [];

  		/**
  		 * Vertex shader GLSL code. This is the actual code for the shader.
  		 *
  		 * @type {string}
  		 */
  		this.vertexShader = default_vertex;

  		/**
  		 * Fragment shader GLSL code. This is the actual code for the shader.
  		 *
  		 * @type {string}
  		 */
  		this.fragmentShader = default_fragment;

  		/**
  		 * Controls line thickness or lines.
  		 *
  		 * WebGL and WebGPU ignore this setting and always render line primitives with a
  		 * width of one pixel.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.linewidth = 1;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * WebGL and WebGPU ignore this property and always render
  		 * 1 pixel wide lines.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Define whether the material color is affected by global fog settings; `true`
  		 * to pass fog uniforms to the shader.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.fog = false;

  		/**
  		 * Defines whether this material uses lighting; `true` to pass uniform data
  		 * related to lighting to this shader.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.lights = false;

  		/**
  		 * Defines whether this material supports clipping; `true` to let the renderer
  		 * pass the clippingPlanes uniform.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clipping = false;

  		/**
  		 * Overwritten and set to `true` by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.forceSinglePass = true;

  		/**
  		 * This object allows to enable certain WebGL 2 extensions.
  		 *
  		 * - clipCullDistance: set to `true` to use vertex shader clipping
  		 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
  		 *
  		 * @type {{clipCullDistance:false,multiDraw:false}}
  		 */
  		this.extensions = {
  			clipCullDistance: false, // set to use vertex shader clipping
  			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
  		};

  		/**
  		 * When the rendered geometry doesn't include these attributes but the
  		 * material does, these default values will be passed to the shaders. This
  		 * avoids errors when buffer data is missing.
  		 *
  		 * - color: [ 1, 1, 1 ]
  		 * - uv: [ 0, 0 ]
  		 * - uv1: [ 0, 0 ]
  		 *
  		 * @type {Object}
  		 */
  		this.defaultAttributeValues = {
  			'color': [ 1, 1, 1 ],
  			'uv': [ 0, 0 ],
  			'uv1': [ 0, 0 ]
  		};

  		/**
  		 * If set, this calls [gl.bindAttribLocation]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation}
  		 * to bind a generic vertex index to an attribute variable.
  		 *
  		 * @type {string|undefined}
  		 * @default undefined
  		 */
  		this.index0AttributeName = undefined;

  		/**
  		 * Can be used to force a uniform update while changing uniforms in
  		 * {@link Object3D#onBeforeRender}.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.uniformsNeedUpdate = false;

  		/**
  		 * Defines the GLSL version of custom shader code.
  		 *
  		 * @type {?(GLSL1|GLSL3)}
  		 * @default null
  		 */
  		this.glslVersion = null;

  		if ( parameters !== undefined ) {

  			this.setValues( parameters );

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.fragmentShader = source.fragmentShader;
  		this.vertexShader = source.vertexShader;

  		this.uniforms = cloneUniforms( source.uniforms );
  		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

  		this.defines = Object.assign( {}, source.defines );

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.fog = source.fog;
  		this.lights = source.lights;
  		this.clipping = source.clipping;

  		this.extensions = Object.assign( {}, source.extensions );

  		this.glslVersion = source.glslVersion;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.glslVersion = this.glslVersion;
  		data.uniforms = {};

  		for ( const name in this.uniforms ) {

  			const uniform = this.uniforms[ name ];
  			const value = uniform.value;

  			if ( value && value.isTexture ) {

  				data.uniforms[ name ] = {
  					type: 't',
  					value: value.toJSON( meta ).uuid
  				};

  			} else if ( value && value.isColor ) {

  				data.uniforms[ name ] = {
  					type: 'c',
  					value: value.getHex()
  				};

  			} else if ( value && value.isVector2 ) {

  				data.uniforms[ name ] = {
  					type: 'v2',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector3 ) {

  				data.uniforms[ name ] = {
  					type: 'v3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector4 ) {

  				data.uniforms[ name ] = {
  					type: 'v4',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix3 ) {

  				data.uniforms[ name ] = {
  					type: 'm3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix4 ) {

  				data.uniforms[ name ] = {
  					type: 'm4',
  					value: value.toArray()
  				};

  			} else {

  				data.uniforms[ name ] = {
  					value: value
  				};

  				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  			}

  		}

  		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

  		data.vertexShader = this.vertexShader;
  		data.fragmentShader = this.fragmentShader;

  		data.lights = this.lights;
  		data.clipping = this.clipping;

  		const extensions = {};

  		for ( const key in this.extensions ) {

  			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

  		}

  		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

  		return data;

  	}

  }

  /**
   * Abstract base class for cameras. This class should always be inherited
   * when you build a new camera.
   *
   * @abstract
   * @augments Object3D
   */
  class Camera extends Object3D {

  	/**
  	 * Constructs a new camera.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCamera = true;

  		this.type = 'Camera';

  		/**
  		 * The inverse of the camera's world matrix.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrixWorldInverse = new Matrix4();

  		/**
  		 * The camera's projection matrix.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.projectionMatrix = new Matrix4();

  		/**
  		 * The inverse of the camera's projection matrix.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.projectionMatrixInverse = new Matrix4();

  		/**
  		 * The coordinate system in which the camera is used.
  		 *
  		 * @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
  		 */
  		this.coordinateSystem = WebGLCoordinateSystem;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );

  		this.projectionMatrix.copy( source.projectionMatrix );
  		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  		this.coordinateSystem = source.coordinateSystem;

  		return this;

  	}

  	/**
  	 * Returns a vector representing the ("look") direction of the 3D object in world space.
  	 *
  	 * This method is overwritten since cameras have a different forward vector compared to other
  	 * 3D objects. A camera looks down its local, negative z-axis by default.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's direction in world space.
  	 */
  	getWorldDirection( target ) {

  		return super.getWorldDirection( target ).negate();

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		super.updateWorldMatrix( updateParents, updateChildren );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _v3$1 = /*@__PURE__*/ new Vector3();
  const _minTarget = /*@__PURE__*/ new Vector2();
  const _maxTarget = /*@__PURE__*/ new Vector2();

  /**
   * Camera that uses [perspective projection]{@link https://en.wikipedia.org/wiki/Perspective_(graphical)}.
   *
   * This projection mode is designed to mimic the way the human eye sees. It
   * is the most common projection mode used for rendering a 3D scene.
   *
   * ```js
   * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
   * scene.add( camera );
   * ```
   *
   * @augments Camera
   */
  class PerspectiveCamera extends Camera {

  	/**
  	 * Constructs a new perspective camera.
  	 *
  	 * @param {number} [fov=50] - The vertical field of view.
  	 * @param {number} [aspect=1] - The aspect ratio.
  	 * @param {number} [near=0.1] - The camera's near plane.
  	 * @param {number} [far=2000] - The camera's far plane.
  	 */
  	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPerspectiveCamera = true;

  		this.type = 'PerspectiveCamera';

  		/**
  		 * The vertical field of view, from bottom to top of view,
  		 * in degrees.
  		 *
  		 * @type {number}
  		 * @default 50
  		 */
  		this.fov = fov;

  		/**
  		 * The zoom factor of the camera.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.zoom = 1;

  		/**
  		 * The camera's near plane. The valid range is greater than `0`
  		 * and less than the current value of {@link PerspectiveCamera#far}.
  		 *
  		 * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
  		 * valid value for a perspective camera's near plane.
  		 *
  		 * @type {number}
  		 * @default 0.1
  		 */
  		this.near = near;

  		/**
  		 * The camera's far plane. Must be greater than the
  		 * current value of {@link PerspectiveCamera#near}.
  		 *
  		 * @type {number}
  		 * @default 2000
  		 */
  		this.far = far;

  		/**
  		 * Object distance used for stereoscopy and depth-of-field effects. This
  		 * parameter does not influence the projection matrix unless a
  		 * {@link StereoCamera} is being used.
  		 *
  		 * @type {number}
  		 * @default 10
  		 */
  		this.focus = 10;

  		/**
  		 * The aspect ratio, usually the canvas width / canvas height.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aspect = aspect;

  		/**
  		 * Represents the frustum window specification. This property should not be edited
  		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.view = null;

  		/**
  		 * Film size used for the larger axis. Default is `35` (millimeters). This
  		 * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
  		 * is set to a nonzero value.
  		 *
  		 * @type {number}
  		 * @default 35
  		 */
  		this.filmGauge = 35;

  		/**
  		 * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.filmOffset = 0;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	}

  	/**
  	 * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength( focalLength ) {

  		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
  		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Returns the focal length from the current {@link PerspectiveCamera#fov} and
  	 * {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * @return {number} The computed focal length.
  	 */
  	getFocalLength() {

  		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	}

  	/**
  	 * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
  	 *
  	 * @return {number} The effective FOV.
  	 */
  	getEffectiveFOV() {

  		return RAD2DEG * 2 * Math.atan(
  			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	}

  	/**
  	 * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
  	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * @return {number} The film width.
  	 */
  	getFilmWidth() {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	}

  	/**
  	 * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
  	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * @return {number} The film width.
  	 */
  	getFilmHeight() {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	}

  	/**
  	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
  	 * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
  	 *
  	 * @param {number} distance - The viewing distance.
  	 * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
  	 * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
  	 */
  	getViewBounds( distance, minTarget, maxTarget ) {

  		_v3$1.set( -1, -1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  	}

  	/**
  	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
  	 *
  	 * @param {number} distance - The viewing distance.
  	 * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
  	 * @returns {Vector2} The view size.
  	 */
  	getViewSize( distance, target ) {

  		this.getViewBounds( distance, _minTarget, _maxTarget );

  		return target.subVectors( _maxTarget, _minTarget );

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *```
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *```
  	 * then for each monitor you would call it like this:
  	 *```js
  	 * const w = 1920;
  	 * const h = 1080;
  	 * const fullWidth = w * 3;
  	 * const fullHeight = h * 2;
  	 *
  	 * // --A--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 * // --B--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 * // --C--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 * // --D--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 * // --E--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 * // --F--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 * ```
  	 *
  	 * Note there is no reason monitors have to be the same size or in a grid.
  	 *
  	 * @param {number} fullWidth - The full width of multiview setup.
  	 * @param {number} fullHeight - The full height of multiview setup.
  	 * @param {number} x - The horizontal offset of the subcamera.
  	 * @param {number} y - The vertical offset of the subcamera.
  	 * @param {number} width - The width of subcamera.
  	 * @param {number} height - The height of subcamera.
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Removes the view offset from the projection matrix.
  	 */
  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Updates the camera's projection matrix. Must be called after any change of
  	 * camera properties.
  	 */
  	updateProjectionMatrix() {

  		const near = this.near;
  		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
  		let height = 2 * top;
  		let width = this.aspect * height;
  		let left = -0.5 * width;
  		const view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			const fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		const skew = this.filmOffset;
  		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  }

  const fov = -90; // negative fov is not an error
  const aspect = 1;

  /**
   * A special type of camera that is positioned in 3D space to render its surroundings into a
   * cube render target. The render target can then be used as an environment map for rendering
   * realtime reflections in your scene.
   *
   * ```js
   * // Create cube render target
   * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
   *
   * // Create cube camera
   * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
   * scene.add( cubeCamera );
   *
   * // Create car
   * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
   * const car = new THREE.Mesh( carGeometry, chromeMaterial );
   * scene.add( car );
   *
   * // Update the render target cube
   * car.visible = false;
   * cubeCamera.position.copy( car.position );
   * cubeCamera.update( renderer, scene );
   *
   * // Render the scene
   * car.visible = true;
   * renderer.render( scene, camera );
   * ```
   *
   * @augments Object3D
   */
  class CubeCamera extends Object3D {

  	/**
  	 * Constructs a new cube camera.
  	 *
  	 * @param {number} near - The camera's near plane.
  	 * @param {number} far - The camera's far plane.
  	 * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
  	 */
  	constructor( near, far, renderTarget ) {

  		super();

  		this.type = 'CubeCamera';

  		/**
  		 * A reference to the cube render target.
  		 *
  		 * @type {WebGLCubeRenderTarget}
  		 */
  		this.renderTarget = renderTarget;

  		/**
  		 * The current active coordinate system.
  		 *
  		 * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
  		 * @default null
  		 */
  		this.coordinateSystem = null;

  		/**
  		 * The current active mipmap level
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.activeMipmapLevel = 0;

  		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPX.layers = this.layers;
  		this.add( cameraPX );

  		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNX.layers = this.layers;
  		this.add( cameraNX );

  		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPY.layers = this.layers;
  		this.add( cameraPY );

  		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNY.layers = this.layers;
  		this.add( cameraNY );

  		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPZ.layers = this.layers;
  		this.add( cameraPZ );

  		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNZ.layers = this.layers;
  		this.add( cameraNZ );

  	}

  	/**
  	 * Must be called when the coordinate system of the cube camera is changed.
  	 */
  	updateCoordinateSystem() {

  		const coordinateSystem = this.coordinateSystem;

  		const cameras = this.children.concat();

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

  		for ( const camera of cameras ) this.remove( camera );

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			cameraPX.up.set( 0, 1, 0 );
  			cameraPX.lookAt( 1, 0, 0 );

  			cameraNX.up.set( 0, 1, 0 );
  			cameraNX.lookAt( -1, 0, 0 );

  			cameraPY.up.set( 0, 0, -1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, 1 );
  			cameraNY.lookAt( 0, -1, 0 );

  			cameraPZ.up.set( 0, 1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, 1, 0 );
  			cameraNZ.lookAt( 0, 0, -1 );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			cameraPX.up.set( 0, -1, 0 );
  			cameraPX.lookAt( -1, 0, 0 );

  			cameraNX.up.set( 0, -1, 0 );
  			cameraNX.lookAt( 1, 0, 0 );

  			cameraPY.up.set( 0, 0, 1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, -1 );
  			cameraNY.lookAt( 0, -1, 0 );

  			cameraPZ.up.set( 0, -1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, -1, 0 );
  			cameraNZ.lookAt( 0, 0, -1 );

  		} else {

  			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		for ( const camera of cameras ) {

  			this.add( camera );

  			camera.updateMatrixWorld();

  		}

  	}

  	/**
  	 * Calling this method will render the given scene with the given renderer
  	 * into the cube render target of the camera.
  	 *
  	 * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
  	 * @param {Scene} scene - The scene to render.
  	 */
  	update( renderer, scene ) {

  		if ( this.parent === null ) this.updateMatrixWorld();

  		const { renderTarget, activeMipmapLevel } = this;

  		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

  			this.coordinateSystem = renderer.coordinateSystem;

  			this.updateCoordinateSystem();

  		}

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentActiveCubeFace = renderer.getActiveCubeFace();
  		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

  		const currentXrEnabled = renderer.xr.enabled;

  		renderer.xr.enabled = false;

  		const generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
  		renderer.render( scene, cameraPX );

  		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
  		renderer.render( scene, cameraNX );

  		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
  		renderer.render( scene, cameraPY );

  		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
  		renderer.render( scene, cameraNY );

  		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
  		renderer.render( scene, cameraPZ );

  		// mipmaps are generated during the last call of render()
  		// at this point, all sides of the cube render target are defined

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
  		renderer.render( scene, cameraNZ );

  		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

  		renderer.xr.enabled = currentXrEnabled;

  		renderTarget.texture.needsPMREMUpdate = true;

  	}

  }

  /**
   * Creates a cube texture made up of six images.
   *
   * ```js
   * const loader = new THREE.CubeTextureLoader();
   * loader.setPath( 'textures/cube/pisa/' );
   *
   * const textureCube = loader.load( [
   * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
   * ] );
   *
   * const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
   * ```
   *
   * @augments Texture
   */
  class CubeTexture extends Texture {

  	/**
  	 * Constructs a new cube texture.
  	 *
  	 * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
  	 * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
  	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
  	 * @param {number} [format=RGBAFormat] - The texture format.
  	 * @param {number} [type=UnsignedByteType] - The texture type.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space value.
  	 */
  	constructor( images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

  		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCubeTexture = true;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  	}

  	/**
  	 * Alias for {@link CubeTexture#image}.
  	 *
  	 * @type {Array<Image>}
  	 */
  	get images() {

  		return this.image;

  	}

  	set images( value ) {

  		this.image = value;

  	}

  }

  /**
   * A cube render target used in context of {@link WebGLRenderer}.
   *
   * @augments WebGLRenderTarget
   */
  class WebGLCubeRenderTarget extends WebGLRenderTarget {

  	/**
  	 * Constructs a new cube render target.
  	 *
  	 * @param {number} [size=1] - The size of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( size = 1, options = {} ) {

  		super( size, size, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGLCubeRenderTarget = true;

  		const image = { width: size, height: size, depth: 1 };
  		const images = [ image, image, image, image, image, image ];

  		/**
  		 * Overwritten with a different texture type.
  		 *
  		 * @type {DataArrayTexture}
  		 */
  		this.texture = new CubeTexture( images );
  		this._setTextureOptions( options );

  		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

  		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

  		this.texture.isRenderTargetTexture = true;

  	}

  	/**
  	 * Converts the given equirectangular texture to a cube map.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {Texture} texture - The equirectangular texture.
  	 * @return {WebGLCubeRenderTarget} A reference to this cube render target.
  	 */
  	fromEquirectangularTexture( renderer, texture ) {

  		this.texture.type = texture.type;
  		this.texture.colorSpace = texture.colorSpace;

  		this.texture.generateMipmaps = texture.generateMipmaps;
  		this.texture.minFilter = texture.minFilter;
  		this.texture.magFilter = texture.magFilter;

  		const shader = {

  			uniforms: {
  				tEquirect: { value: null },
  			},

  			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

  			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
  		};

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const material = new ShaderMaterial( {

  			name: 'CubemapFromEquirect',

  			uniforms: cloneUniforms( shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			side: BackSide,
  			blending: NoBlending

  		} );

  		material.uniforms.tEquirect.value = texture;

  		const mesh = new Mesh( geometry, material );

  		const currentMinFilter = texture.minFilter;

  		// Avoid blurred poles
  		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );
  		camera.update( renderer, mesh );

  		texture.minFilter = currentMinFilter;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  	/**
  	 * Clears this cube render target.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
  	 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
  	 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
  	 */
  	clear( renderer, color = true, depth = true, stencil = true ) {

  		const currentRenderTarget = renderer.getRenderTarget();

  		for ( let i = 0; i < 6; i ++ ) {

  			renderer.setRenderTarget( this, i );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  	}

  }

  /**
   * This is almost identical to an {@link Object3D}. Its purpose is to
   * make working with groups of objects syntactically clearer.
   *
   * ```js
   * // Create a group and add the two cubes.
   * // These cubes can now be rotated / scaled etc as a group.
   * const group = new THREE.Group();
   *
   * group.add( meshA );
   * group.add( meshB );
   *
   * scene.add( group );
   * ```
   *
   * @augments Object3D
   */
  let Group$1 = class Group extends Object3D {

  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isGroup = true;

  		this.type = 'Group';

  	}

  };

  const _moveEvent = { type: 'move' };

  /**
   * Class for representing a XR controller with its
   * different coordinate systems.
   *
   * @private
   */
  class WebXRController {

  	/**
  	 * Constructs a new XR controller.
  	 */
  	constructor() {

  		/**
  		 * A group representing the target ray space
  		 * of the XR controller.
  		 *
  		 * @private
  		 * @type {?Group}
  		 * @default null
  		 */
  		this._targetRay = null;

  		/**
  		 * A group representing the grip space
  		 * of the XR controller.
  		 *
  		 * @private
  		 * @type {?Group}
  		 * @default null
  		 */
  		this._grip = null;

  		/**
  		 * A group representing the hand space
  		 * of the XR controller.
  		 *
  		 * @private
  		 * @type {?Group}
  		 * @default null
  		 */
  		this._hand = null;

  	}

  	/**
  	 * Returns a group representing the hand space of the XR controller.
  	 *
  	 * @return {Group} A group representing the hand space of the XR controller.
  	 */
  	getHandSpace() {

  		if ( this._hand === null ) {

  			this._hand = new Group$1();
  			this._hand.matrixAutoUpdate = false;
  			this._hand.visible = false;

  			this._hand.joints = {};
  			this._hand.inputState = { pinching: false };

  		}

  		return this._hand;

  	}

  	/**
  	 * Returns a group representing the target ray space of the XR controller.
  	 *
  	 * @return {Group} A group representing the target ray space of the XR controller.
  	 */
  	getTargetRaySpace() {

  		if ( this._targetRay === null ) {

  			this._targetRay = new Group$1();
  			this._targetRay.matrixAutoUpdate = false;
  			this._targetRay.visible = false;
  			this._targetRay.hasLinearVelocity = false;
  			this._targetRay.linearVelocity = new Vector3();
  			this._targetRay.hasAngularVelocity = false;
  			this._targetRay.angularVelocity = new Vector3();

  		}

  		return this._targetRay;

  	}

  	/**
  	 * Returns a group representing the grip space of the XR controller.
  	 *
  	 * @return {Group} A group representing the grip space of the XR controller.
  	 */
  	getGripSpace() {

  		if ( this._grip === null ) {

  			this._grip = new Group$1();
  			this._grip.matrixAutoUpdate = false;
  			this._grip.visible = false;
  			this._grip.hasLinearVelocity = false;
  			this._grip.linearVelocity = new Vector3();
  			this._grip.hasAngularVelocity = false;
  			this._grip.angularVelocity = new Vector3();

  		}

  		return this._grip;

  	}

  	/**
  	 * Dispatches the given event to the groups representing
  	 * the different coordinate spaces of the XR controller.
  	 *
  	 * @param {Object} event - The event to dispatch.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	dispatchEvent( event ) {

  		if ( this._targetRay !== null ) {

  			this._targetRay.dispatchEvent( event );

  		}

  		if ( this._grip !== null ) {

  			this._grip.dispatchEvent( event );

  		}

  		if ( this._hand !== null ) {

  			this._hand.dispatchEvent( event );

  		}

  		return this;

  	}

  	/**
  	 * Connects the controller with the given XR input source.
  	 *
  	 * @param {XRInputSource} inputSource - The input source.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	connect( inputSource ) {

  		if ( inputSource && inputSource.hand ) {

  			const hand = this._hand;

  			if ( hand ) {

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Initialize hand with joints when connected
  					this._getHandJoint( hand, inputjoint );

  				}

  			}

  		}

  		this.dispatchEvent( { type: 'connected', data: inputSource } );

  		return this;

  	}

  	/**
  	 * Disconnects the controller from the given XR input source.
  	 *
  	 * @param {XRInputSource} inputSource - The input source.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	disconnect( inputSource ) {

  		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

  		if ( this._targetRay !== null ) {

  			this._targetRay.visible = false;

  		}

  		if ( this._grip !== null ) {

  			this._grip.visible = false;

  		}

  		if ( this._hand !== null ) {

  			this._hand.visible = false;

  		}

  		return this;

  	}

  	/**
  	 * Updates the controller with the given input source, XR frame and reference space.
  	 * This updates the transformations of the groups that represent the different
  	 * coordinate systems of the controller.
  	 *
  	 * @param {XRInputSource} inputSource - The input source.
  	 * @param {XRFrame} frame - The XR frame.
  	 * @param {XRReferenceSpace} referenceSpace - The reference space.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	update( inputSource, frame, referenceSpace ) {

  		let inputPose = null;
  		let gripPose = null;
  		let handPose = null;

  		const targetRay = this._targetRay;
  		const grip = this._grip;
  		const hand = this._hand;

  		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

  			if ( hand && inputSource.hand ) {

  				handPose = true;

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Update the joints groups with the XRJoint poses
  					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

  					// The transform of this joint will be updated with the joint pose on each frame
  					const joint = this._getHandJoint( hand, inputjoint );

  					if ( jointPose !== null ) {

  						joint.matrix.fromArray( jointPose.transform.matrix );
  						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
  						joint.matrixWorldNeedsUpdate = true;
  						joint.jointRadius = jointPose.radius;

  					}

  					joint.visible = jointPose !== null;

  				}

  				// Custom events

  				// Check pinchz
  				const indexTip = hand.joints[ 'index-finger-tip' ];
  				const thumbTip = hand.joints[ 'thumb-tip' ];
  				const distance = indexTip.position.distanceTo( thumbTip.position );

  				const distanceToPinch = 0.02;
  				const threshold = 0.005;

  				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

  					hand.inputState.pinching = false;
  					this.dispatchEvent( {
  						type: 'pinchend',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

  					hand.inputState.pinching = true;
  					this.dispatchEvent( {
  						type: 'pinchstart',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				}

  			} else {

  				if ( grip !== null && inputSource.gripSpace ) {

  					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

  					if ( gripPose !== null ) {

  						grip.matrix.fromArray( gripPose.transform.matrix );
  						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
  						grip.matrixWorldNeedsUpdate = true;

  						if ( gripPose.linearVelocity ) {

  							grip.hasLinearVelocity = true;
  							grip.linearVelocity.copy( gripPose.linearVelocity );

  						} else {

  							grip.hasLinearVelocity = false;

  						}

  						if ( gripPose.angularVelocity ) {

  							grip.hasAngularVelocity = true;
  							grip.angularVelocity.copy( gripPose.angularVelocity );

  						} else {

  							grip.hasAngularVelocity = false;

  						}

  					}

  				}

  			}

  			if ( targetRay !== null ) {

  				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

  				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
  				if ( inputPose === null && gripPose !== null ) {

  					inputPose = gripPose;

  				}

  				if ( inputPose !== null ) {

  					targetRay.matrix.fromArray( inputPose.transform.matrix );
  					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
  					targetRay.matrixWorldNeedsUpdate = true;

  					if ( inputPose.linearVelocity ) {

  						targetRay.hasLinearVelocity = true;
  						targetRay.linearVelocity.copy( inputPose.linearVelocity );

  					} else {

  						targetRay.hasLinearVelocity = false;

  					}

  					if ( inputPose.angularVelocity ) {

  						targetRay.hasAngularVelocity = true;
  						targetRay.angularVelocity.copy( inputPose.angularVelocity );

  					} else {

  						targetRay.hasAngularVelocity = false;

  					}

  					this.dispatchEvent( _moveEvent );

  				}

  			}


  		}

  		if ( targetRay !== null ) {

  			targetRay.visible = ( inputPose !== null );

  		}

  		if ( grip !== null ) {

  			grip.visible = ( gripPose !== null );

  		}

  		if ( hand !== null ) {

  			hand.visible = ( handPose !== null );

  		}

  		return this;

  	}

  	/**
  	 * Returns a group representing the hand joint for the given input joint.
  	 *
  	 * @private
  	 * @param {Group} hand - The group representing the hand space.
  	 * @param {XRJointSpace} inputjoint - The hand joint data.
  	 * @return {Group} A group representing the hand joint for the given input joint.
  	 */
  	_getHandJoint( hand, inputjoint ) {

  		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

  			const joint = new Group$1();
  			joint.matrixAutoUpdate = false;
  			joint.visible = false;
  			hand.joints[ inputjoint.jointName ] = joint;

  			hand.add( joint );

  		}

  		return hand.joints[ inputjoint.jointName ];

  	}

  }

  /**
   * Scenes allow you to set up what is to be rendered and where by three.js.
   * This is where you place 3D objects like meshes, lines or lights.
   *
   * @augments Object3D
   */
  class Scene extends Object3D {

  	/**
  	 * Constructs a new scene.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isScene = true;

  		this.type = 'Scene';

  		/**
  		 * Defines the background of the scene. Valid inputs are:
  		 *
  		 * - A color for defining a uniform colored background.
  		 * - A texture for defining a (flat) textured background.
  		 * - Cube textures or equirectangular textures for defining a skybox.
  		 *
  		 * @type {?(Color|Texture)}
  		 * @default null
  		 */
  		this.background = null;

  		/**
  		 * Sets the environment map for all physical materials in the scene. However,
  		 * it's not possible to overwrite an existing texture assigned to the `envMap`
  		 * material property.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.environment = null;

  		/**
  		 * A fog instance defining the type of fog that affects everything
  		 * rendered in the scene.
  		 *
  		 * @type {?(Fog|FogExp2)}
  		 * @default null
  		 */
  		this.fog = null;

  		/**
  		 * Sets the blurriness of the background. Only influences environment maps
  		 * assigned to {@link Scene#background}. Valid input is a float between `0`
  		 * and `1`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.backgroundBlurriness = 0;

  		/**
  		 * Attenuates the color of the background. Only applies to background textures.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.backgroundIntensity = 1;

  		/**
  		 * The rotation of the background in radians. Only influences environment maps
  		 * assigned to {@link Scene#background}.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.backgroundRotation = new Euler();

  		/**
  		 * Attenuates the color of the environment. Only influences environment maps
  		 * assigned to {@link Scene#environment}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.environmentIntensity = 1;

  		/**
  		 * The rotation of the environment map in radians. Only influences physical materials
  		 * in the scene when {@link Scene#environment} is used.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.environmentRotation = new Euler();

  		/**
  		 * Forces everything in the scene to be rendered with the defined material. It is possible
  		 * to exclude materials from override by setting {@link Material#allowOverride} to `false`.
  		 *
  		 * @type {?Material}
  		 * @default null
  		 */
  		this.overrideMaterial = null;

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.background !== null ) this.background = source.background.clone();
  		if ( source.environment !== null ) this.environment = source.environment.clone();
  		if ( source.fog !== null ) this.fog = source.fog.clone();

  		this.backgroundBlurriness = source.backgroundBlurriness;
  		this.backgroundIntensity = source.backgroundIntensity;
  		this.backgroundRotation.copy( source.backgroundRotation );

  		this.environmentIntensity = source.environmentIntensity;
  		this.environmentRotation.copy( source.environmentRotation );

  		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
  		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
  		data.object.backgroundRotation = this.backgroundRotation.toArray();

  		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
  		data.object.environmentRotation = this.environmentRotation.toArray();

  		return data;

  	}

  }

  /**
   * "Interleaved" means that multiple attributes, possibly of different types,
   * (e.g., position, normal, uv, color) are packed into a single array buffer.
   *
   * An introduction into interleaved arrays can be found here: [Interleaved array basics]{@link https://blog.tojicode.com/2011/05/interleaved-array-basics.html}
   */
  class InterleavedBuffer {

  	/**
  	 * Constructs a new interleaved buffer.
  	 *
  	 * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
  	 * @param {number} stride - The number of typed-array elements per vertex.
  	 */
  	constructor( array, stride ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInterleavedBuffer = true;

  		/**
  		 * A typed array with a shared buffer storing attribute data.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.array = array;

  		/**
  		 * The number of typed-array elements per vertex.
  		 *
  		 * @type {number}
  		 */
  		this.stride = stride;

  		/**
  		 * The total number of elements in the array
  		 *
  		 * @type {number}
  		 * @readonly
  		 */
  		this.count = array !== undefined ? array.length / stride : 0;

  		/**
  		 * Defines the intended usage pattern of the data store for optimization purposes.
  		 *
  		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
  		 * instantiate a new one and set the desired usage before the next render.
  		 *
  		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
  		 * @default StaticDrawUsage
  		 */
  		this.usage = StaticDrawUsage;

  		/**
  		 * This can be used to only update some components of stored vectors (for example, just the
  		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.updateRanges = [];

  		/**
  		 * A version number, incremented every time the `needsUpdate` is set to `true`.
  		 *
  		 * @type {number}
  		 */
  		this.version = 0;

  		/**
  		 * The UUID of the interleaved buffer.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  	}

  	/**
  	 * A callback function that is executed after the renderer has transferred the attribute array
  	 * data to the GPU.
  	 */
  	onUploadCallback() {}

  	/**
  	 * Flag to indicate that this attribute has changed and should be re-sent to
  	 * the GPU. Set this to `true` when you modify the value of the array.
  	 *
  	 * @type {number}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	/**
  	 * Sets the usage of this interleaved buffer.
  	 *
  	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
  	 * @return {InterleavedBuffer} A reference to this interleaved buffer.
  	 */
  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	/**
  	 * Adds a range of data in the data array to be updated on the GPU.
  	 *
  	 * @param {number} start - Position at which to start update.
  	 * @param {number} count - The number of components to update.
  	 */
  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	/**
  	 * Clears the update ranges.
  	 */
  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	/**
  	 * Copies the values of the given interleaved buffer to this instance.
  	 *
  	 * @param {InterleavedBuffer} source - The interleaved buffer to copy.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	copy( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.usage = source.usage;

  		return this;

  	}

  	/**
  	 * Copies a vector from the given interleaved buffer to this one. The start
  	 * and destination position in the attribute buffers are represented by the
  	 * given indices.
  	 *
  	 * @param {number} index1 - The destination index into this interleaved buffer.
  	 * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
  	 * @param {number} index2 - The source index into the given interleaved buffer.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	copyAt( index1, interleavedBuffer, index2 ) {

  		index1 *= this.stride;
  		index2 *= interleavedBuffer.stride;

  		for ( let i = 0, l = this.stride; i < l; i ++ ) {

  			this.array[ index1 + i ] = interleavedBuffer.array[ index2 + i ];

  		}

  		return this;

  	}

  	/**
  	 * Sets the given array data in the interleaved buffer.
  	 *
  	 * @param {(TypedArray|Array)} value - The array data to set.
  	 * @param {number} [offset=0] - The offset in this interleaved buffer's array.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	set( value, offset = 0 ) {

  		this.array.set( value, offset );

  		return this;

  	}

  	/**
  	 * Returns a new interleaved buffer with copied values from this instance.
  	 *
  	 * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
  	 * @return {InterleavedBuffer} A clone of this instance.
  	 */
  	clone( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

  		}

  		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

  		const ib = new this.constructor( array, this.stride );
  		ib.setUsage( this.usage );

  		return ib;

  	}

  	/**
  	 * Sets the given callback function that is executed after the Renderer has transferred
  	 * the array data to the GPU. Can be used to perform clean-up operations after
  	 * the upload when data are not needed anymore on the CPU side.
  	 *
  	 * @param {Function} callback - The `onUpload()` callback.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	/**
  	 * Serializes the interleaved buffer into JSON.
  	 *
  	 * @param {Object} [data] - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized interleaved buffer.
  	 */
  	toJSON( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		// generate UUID for array buffer if necessary

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

  		}

  		//

  		return {
  			uuid: this.uuid,
  			buffer: this.array.buffer._uuid,
  			type: this.array.constructor.name,
  			stride: this.stride
  		};

  	}

  }

  const _vector$7 = /*@__PURE__*/ new Vector3();

  /**
   * An alternative version of a buffer attribute with interleaved data. Interleaved
   * attributes share a common interleaved data storage ({@link InterleavedBuffer}) and refer with
   * different offsets into the buffer.
   */
  class InterleavedBufferAttribute {

  	/**
  	 * Constructs a new interleaved buffer attribute.
  	 *
  	 * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
  	 * @param {number} itemSize - The item size.
  	 * @param {number} offset - The attribute offset into the buffer.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInterleavedBufferAttribute = true;

  		/**
  		 * The name of the buffer attribute.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The buffer holding the interleaved data.
  		 *
  		 * @type {InterleavedBuffer}
  		 */
  		this.data = interleavedBuffer;

  		/**
  		 * The item size, see {@link BufferAttribute#itemSize}.
  		 *
  		 * @type {number}
  		 */
  		this.itemSize = itemSize;

  		/**
  		 * The attribute offset into the buffer.
  		 *
  		 * @type {number}
  		 */
  		this.offset = offset;

  		/**
  		 * Whether the data are normalized or not, see {@link BufferAttribute#normalized}
  		 *
  		 * @type {InterleavedBuffer}
  		 */
  		this.normalized = normalized;

  	}

  	/**
  	 * The item count of this buffer attribute.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get count() {

  		return this.data.count;

  	}

  	/**
  	 * The array holding the interleaved buffer attribute data.
  	 *
  	 * @type {TypedArray}
  	 */
  	get array() {

  		return this.data.array;

  	}

  	/**
  	 * Flag to indicate that this attribute has changed and should be re-sent to
  	 * the GPU. Set this to `true` when you modify the value of the array.
  	 *
  	 * @type {number}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		this.data.needsUpdate = value;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.applyMatrix4( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix3} m - The normal matrix to apply.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3` and with direction vectors.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.transformDirection( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	/**
  	 * Returns the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @return {number} The returned value.
  	 */
  	getComponent( index, component ) {

  		let value = this.array[ index * this.data.stride + this.offset + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	/**
  	 * Sets the given value to the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @param {number} value - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize$1( value, this.array );

  		this.data.array[ index * this.data.stride + this.offset + component ] = value;

  		return this;

  	}

  	/**
  	 * Sets the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setX( index, x ) {

  		if ( this.normalized ) x = normalize$1( x, this.array );

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	}

  	/**
  	 * Sets the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} y - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setY( index, y ) {

  		if ( this.normalized ) y = normalize$1( y, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Sets the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} z - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize$1( z, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Sets the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} w - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setW( index, w ) {

  		if ( this.normalized ) w = normalize$1( w, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Returns the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The x component.
  	 */
  	getX( index ) {

  		let x = this.data.array[ index * this.data.stride + this.offset ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	/**
  	 * Returns the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The y component.
  	 */
  	getY( index ) {

  		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	/**
  	 * Returns the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The z component.
  	 */
  	getZ( index ) {

  		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	/**
  	 * Returns the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The w component.
  	 */
  	getW( index ) {

  		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	/**
  	 * Sets the x and y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setXY( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Sets the x, y and z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setXYZ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Sets the x, y, z and w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @param {number} w - The value for the w component to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setXYZW( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );
  			w = normalize$1( w, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Returns a new buffer attribute with copied values from this instance.
  	 *
  	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
  	 *
  	 * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
  	 * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
  	 */
  	clone( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

  		} else {

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

  			}

  			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

  		}

  	}

  	/**
  	 * Serializes the buffer attribute into JSON.
  	 *
  	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
  	 *
  	 * @param {Object} [data] - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized buffer attribute.
  	 */
  	toJSON( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			// de-interleave data and save it as an ordinary buffer attribute for now

  			return {
  				itemSize: this.itemSize,
  				type: this.array.constructor.name,
  				array: array,
  				normalized: this.normalized
  			};

  		} else {

  			// save as true interleaved attribute

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

  			}

  			return {
  				isInterleavedBufferAttribute: true,
  				itemSize: this.itemSize,
  				data: this.data.uuid,
  				offset: this.offset,
  				normalized: this.normalized
  			};

  		}

  	}

  }

  /**
   * A material for rendering instances of {@link Sprite}.
   *
   * ```js
   * const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
   * const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );
   *
   * const sprite = new THREE.Sprite( material );
   * sprite.scale.set(200, 200, 1)
   * scene.add( sprite );
   * ```
   *
   * @augments Material
   */
  class SpriteMaterial extends Material {

  	/**
  	 * Constructs a new sprite material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSpriteMaterial = true;

  		this.type = 'SpriteMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff );

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The rotation of the sprite in radians.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.rotation = 0;

  		/**
  		 * Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.sizeAttenuation = true;

  		/**
  		 * Overwritten since sprite materials are transparent
  		 * by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.transparent = true;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.rotation = source.rotation;

  		this.sizeAttenuation = source.sizeAttenuation;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * Creates a texture directly from raw buffer data.
   *
   * The interpretation of the data depends on type and format: If the type is
   * `UnsignedByteType`, a `Uint8Array` will be useful for addressing the
   * texel data. If the format is `RGBAFormat`, data needs four values for
   * one texel; Red, Green, Blue and Alpha (typically the opacity).
   *
   * @augments Texture
   */
  class DataTexture extends Texture {

  	/**
  	 * Constructs a new data texture.
  	 *
  	 * @param {?TypedArray} [data=null] - The buffer data.
  	 * @param {number} [width=1] - The width of the texture.
  	 * @param {number} [height=1] - The height of the texture.
  	 * @param {number} [format=RGBAFormat] - The texture format.
  	 * @param {number} [type=UnsignedByteType] - The texture type.
  	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=NearestFilter] - The mag filter value.
  	 * @param {number} [minFilter=NearestFilter] - The min filter value.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space.
  	 */
  	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDataTexture = true;

  		/**
  		 * The image definition of a data texture.
  		 *
  		 * @type {{data:TypedArray,width:number,height:number}}
  		 */
  		this.image = { data: data, width: width, height: height };

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 *
  		 * Overwritten and set to `1` by default.
  		 *
  		 * @type {boolean}
  		 * @default 1
  		 */
  		this.unpackAlignment = 1;

  	}

  }

  /**
   * An instanced version of a buffer attribute.
   *
   * @augments BufferAttribute
   */
  class InstancedBufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new instanced buffer attribute.
  	 *
  	 * @param {TypedArray} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
  	 */
  	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

  		super( array, itemSize, normalized );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInstancedBufferAttribute = true;

  		/**
  		 * Defines how often a value of this buffer attribute should be repeated. A
  		 * value of one means that each value of the instanced attribute is used for
  		 * a single instance. A value of two means that each value is used for two
  		 * consecutive instances (and so on).
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.meshPerAttribute = meshPerAttribute;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.meshPerAttribute = this.meshPerAttribute;

  		data.isInstancedBufferAttribute = true;

  		return data;

  	}

  }

  const _vector1 = /*@__PURE__*/ new Vector3();
  const _vector2$2 = /*@__PURE__*/ new Vector3();
  const _normalMatrix = /*@__PURE__*/ new Matrix3();

  /**
   * A two dimensional surface that extends infinitely in 3D space, represented
   * in [Hessian normal form]{@link http://mathworld.wolfram.com/HessianNormalForm.html}
   * by a unit length normal vector and a constant.
   */
  class Plane {

  	/**
  	 * Constructs a new plane.
  	 *
  	 * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
  	 * @param {number} [constant=0] - The signed distance from the origin to the plane.
  	 */
  	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPlane = true;

  		/**
  		 * A unit length vector defining the normal of the plane.
  		 *
  		 * @type {Vector3}
  		 */
  		this.normal = normal;

  		/**
  		 * The signed distance from the origin to the plane.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.constant = constant;

  	}

  	/**
  	 * Sets the plane components by copying the given values.
  	 *
  	 * @param {Vector3} normal - The normal.
  	 * @param {number} constant - The constant.
  	 * @return {Plane} A reference to this plane.
  	 */
  	set( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	}

  	/**
  	 * Sets the plane components by defining `x`, `y`, `z` as the
  	 * plane normal and `w` as the constant.
  	 *
  	 * @param {number} x - The value for the normal's x component.
  	 * @param {number} y - The value for the normal's y component.
  	 * @param {number} z - The value for the normal's z component.
  	 * @param {number} w - The constant value.
  	 * @return {Plane} A reference to this plane.
  	 */
  	setComponents( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	}

  	/**
  	 * Sets the plane from the given normal and coplanar point (that is a point
  	 * that lies onto the plane).
  	 *
  	 * @param {Vector3} normal - The normal.
  	 * @param {Vector3} point - A coplanar point.
  	 * @return {Plane} A reference to this plane.
  	 */
  	setFromNormalAndCoplanarPoint( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	}

  	/**
  	 * Sets the plane from three coplanar points. The winding order is
  	 * assumed to be counter-clockwise, and determines the direction of
  	 * the plane normal.
  	 *
  	 * @param {Vector3} a - The first coplanar point.
  	 * @param {Vector3} b - The second coplanar point.
  	 * @param {Vector3} c - The third coplanar point.
  	 * @return {Plane} A reference to this plane.
  	 */
  	setFromCoplanarPoints( a, b, c ) {

  		const normal = _vector1.subVectors( c, b ).cross( _vector2$2.subVectors( a, b ) ).normalize();

  		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  		this.setFromNormalAndCoplanarPoint( normal, a );

  		return this;

  	}

  	/**
  	 * Copies the values of the given plane to this instance.
  	 *
  	 * @param {Plane} plane - The plane to copy.
  	 * @return {Plane} A reference to this plane.
  	 */
  	copy( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	}

  	/**
  	 * Normalizes the plane normal and adjusts the constant accordingly.
  	 *
  	 * @return {Plane} A reference to this plane.
  	 */
  	normalize() {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		const inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	}

  	/**
  	 * Negates both the plane normal and the constant.
  	 *
  	 * @return {Plane} A reference to this plane.
  	 */
  	negate() {

  		this.constant *= -1;
  		this.normal.negate();

  		return this;

  	}

  	/**
  	 * Returns the signed distance from the given point to this plane.
  	 *
  	 * @param {Vector3} point - The point to compute the distance for.
  	 * @return {number} The signed distance.
  	 */
  	distanceToPoint( point ) {

  		return this.normal.dot( point ) + this.constant;

  	}

  	/**
  	 * Returns the signed distance from the given sphere to this plane.
  	 *
  	 * @param {Sphere} sphere - The sphere to compute the distance for.
  	 * @return {number} The signed distance.
  	 */
  	distanceToSphere( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	}

  	/**
  	 * Projects a the given point onto the plane.
  	 *
  	 * @param {Vector3} point - The point to project.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The projected point on the plane.
  	 */
  	projectPoint( point, target ) {

  		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

  	}

  	/**
  	 * Returns the intersection point of the passed line and the plane. Returns
  	 * `null` if the line does not intersect. Returns the line's starting point if
  	 * the line is coplanar with the plane.
  	 *
  	 * @param {Line3} line - The line to compute the intersection for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectLine( line, target ) {

  		const direction = line.delta( _vector1 );

  		const denominator = this.normal.dot( direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( this.distanceToPoint( line.start ) === 0 ) {

  				return target.copy( line.start );

  			}

  			// Unsure if this is the correct method to handle this case.
  			return null;

  		}

  		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  		if ( t < 0 || t > 1 ) {

  			return null;

  		}

  		return target.copy( line.start ).addScaledVector( direction, t );

  	}

  	/**
  	 * Returns `true` if the given line segment intersects with (passes through) the plane.
  	 *
  	 * @param {Line3} line - The line to test.
  	 * @return {boolean} Whether the given line segment intersects with the plane or not.
  	 */
  	intersectsLine( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		const startSign = this.distanceToPoint( line.start );
  		const endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	}

  	/**
  	 * Returns `true` if the given bounding box intersects with the plane.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the given bounding box intersects with the plane or not.
  	 */
  	intersectsBox( box ) {

  		return box.intersectsPlane( this );

  	}

  	/**
  	 * Returns `true` if the given bounding sphere intersects with the plane.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
  	 */
  	intersectsSphere( sphere ) {

  		return sphere.intersectsPlane( this );

  	}

  	/**
  	 * Returns a coplanar vector to the plane, by calculating the
  	 * projection of the normal at the origin onto the plane.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The coplanar point.
  	 */
  	coplanarPoint( target ) {

  		return target.copy( this.normal ).multiplyScalar( - this.constant );

  	}

  	/**
  	 * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
  	 *
  	 * The optional normal matrix can be pre-computed like so:
  	 * ```js
  	 * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
  	 * ```
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
  	 * @return {Plane} A reference to this plane.
  	 */
  	applyMatrix4( matrix, optionalNormalMatrix ) {

  		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

  		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

  		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  		this.constant = - referencePoint.dot( normal );

  		return this;

  	}

  	/**
  	 * Translates the plane by the distance defined by the given offset vector.
  	 * Note that this only affects the plane constant and will not affect the normal vector.
  	 *
  	 * @param {Vector3} offset - The offset vector.
  	 * @return {Plane} A reference to this plane.
  	 */
  	translate( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	}

  	/**
  	 * Returns `true` if this plane is equal with the given one.
  	 *
  	 * @param {Plane} plane - The plane to test for equality.
  	 * @return {boolean} Whether this plane is equal with the given one.
  	 */
  	equals( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  	/**
  	 * Returns a new plane with copied values from this instance.
  	 *
  	 * @return {Plane} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _sphere$3 = /*@__PURE__*/ new Sphere();
  const _defaultSpriteCenter = /*@__PURE__*/ new Vector2( 0.5, 0.5 );
  const _vector$6 = /*@__PURE__*/ new Vector3();

  /**
   * Frustums are used to determine what is inside the camera's field of view.
   * They help speed up the rendering process - objects which lie outside a camera's
   * frustum can safely be excluded from rendering.
   *
   * This class is mainly intended for use internally by a renderer.
   */
  class Frustum {

  	/**
  	 * Constructs a new frustum.
  	 *
  	 * @param {Plane} [p0] - The first plane that encloses the frustum.
  	 * @param {Plane} [p1] - The second plane that encloses the frustum.
  	 * @param {Plane} [p2] - The third plane that encloses the frustum.
  	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
  	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
  	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
  	 */
  	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

  		/**
  		 * This array holds the planes that enclose the frustum.
  		 *
  		 * @type {Array<Plane>}
  		 */
  		this.planes = [ p0, p1, p2, p3, p4, p5 ];

  	}

  	/**
  	 * Sets the frustum planes by copying the given planes.
  	 *
  	 * @param {Plane} [p0] - The first plane that encloses the frustum.
  	 * @param {Plane} [p1] - The second plane that encloses the frustum.
  	 * @param {Plane} [p2] - The third plane that encloses the frustum.
  	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
  	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
  	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
  	 * @return {Frustum} A reference to this frustum.
  	 */
  	set( p0, p1, p2, p3, p4, p5 ) {

  		const planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	}

  	/**
  	 * Copies the values of the given frustum to this instance.
  	 *
  	 * @param {Frustum} frustum - The frustum to copy.
  	 * @return {Frustum} A reference to this frustum.
  	 */
  	copy( frustum ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	}

  	/**
  	 * Sets the frustum planes from the given projection matrix.
  	 *
  	 * @param {Matrix4} m - The projection matrix.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
  	 * @return {Frustum} A reference to this frustum.
  	 */
  	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

  		const planes = this.planes;
  		const me = m.elements;
  		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

  		} else {

  			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
  	 *
  	 * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
  	 *
  	 * @param {Object3D} object - The 3D object to test.
  	 * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
  	 */
  	intersectsObject( object ) {

  		if ( object.boundingSphere !== undefined ) {

  			if ( object.boundingSphere === null ) object.computeBoundingSphere();

  			_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

  		} else {

  			const geometry = object.geometry;

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

  		}

  		return this.intersectsSphere( _sphere$3 );

  	}

  	/**
  	 * Returns `true` if the given sprite is intersecting this frustum.
  	 *
  	 * @param {Sprite} sprite - The sprite to test.
  	 * @return {boolean} Whether the sprite is intersecting this frustum or not.
  	 */
  	intersectsSprite( sprite ) {

  		_sphere$3.center.set( 0, 0, 0 );

  		const offset = _defaultSpriteCenter.distanceTo( sprite.center );

  		_sphere$3.radius = 0.7071067811865476 + offset;
  		_sphere$3.applyMatrix4( sprite.matrixWorld );

  		return this.intersectsSphere( _sphere$3 );

  	}

  	/**
  	 * Returns `true` if the given bounding sphere is intersecting this frustum.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
  	 */
  	intersectsSphere( sphere ) {

  		const planes = this.planes;
  		const center = sphere.center;
  		const negRadius = - sphere.radius;

  		for ( let i = 0; i < 6; i ++ ) {

  			const distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Returns `true` if the given bounding box is intersecting this frustum.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the bounding box is intersecting this frustum or not.
  	 */
  	intersectsBox( box ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			const plane = planes[ i ];

  			// corner at max distance

  			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  			if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Returns `true` if the given point lies within the frustum.
  	 *
  	 * @param {Vector3} point - The point to test.
  	 * @return {boolean} Whether the point lies within this frustum or not.
  	 */
  	containsPoint( point ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Returns a new frustum with copied values from this instance.
  	 *
  	 * @return {Frustum} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
  const _frustum$1 = /*@__PURE__*/ new Frustum();

  /**
   * FrustumArray is used to determine if an object is visible in at least one camera
   * from an array of cameras. This is particularly useful for multi-view renderers.
  */
  class FrustumArray {

  	/**
  	 * Constructs a new frustum array.
  	 *
  	 */
  	constructor() {

  		/**
  		 * The coordinate system to use.
  		 *
  		 * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
  		 * @default WebGLCoordinateSystem
  		 */
  		this.coordinateSystem = WebGLCoordinateSystem;

  	}

  	/**
  	 * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
  	 * from the camera array.
  	 *
  	 * @param {Object3D} object - The 3D object to test.
  	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
  	 * @return {boolean} Whether the 3D object is visible in any camera.
  	 */
  	intersectsObject( object, cameraArray ) {

  		if ( ! cameraArray.isArrayCamera || cameraArray.cameras.length === 0 ) {

  			return false;

  		}

  		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

  			const camera = cameraArray.cameras[ i ];

  			_projScreenMatrix$2.multiplyMatrices(
  				camera.projectionMatrix,
  				camera.matrixWorldInverse
  			);

  			_frustum$1.setFromProjectionMatrix(
  				_projScreenMatrix$2,
  				this.coordinateSystem
  			);

  			if ( _frustum$1.intersectsObject( object ) ) {

  				return true; // Object is visible in at least one camera

  			}

  		}

  		return false; // Not visible in any camera

  	}

  	/**
  	 * Returns `true` if the given sprite is intersecting any frustum
  	 * from the camera array.
  	 *
  	 * @param {Sprite} sprite - The sprite to test.
  	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
  	 * @return {boolean} Whether the sprite is visible in any camera.
  	 */
  	intersectsSprite( sprite, cameraArray ) {

  		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

  			return false;

  		}

  		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

  			const camera = cameraArray.cameras[ i ];

  			_projScreenMatrix$2.multiplyMatrices(
  				camera.projectionMatrix,
  				camera.matrixWorldInverse
  			);

  			_frustum$1.setFromProjectionMatrix(
  				_projScreenMatrix$2,
  				this.coordinateSystem
  			);

  			if ( _frustum$1.intersectsSprite( sprite ) ) {

  				return true; // Sprite is visible in at least one camera

  			}

  		}

  		return false; // Not visible in any camera

  	}

  	/**
  	 * Returns `true` if the given bounding sphere is intersecting any frustum
  	 * from the camera array.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
  	 * @return {boolean} Whether the sphere is visible in any camera.
  	 */
  	intersectsSphere( sphere, cameraArray ) {

  		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

  			return false;

  		}

  		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

  			const camera = cameraArray.cameras[ i ];

  			_projScreenMatrix$2.multiplyMatrices(
  				camera.projectionMatrix,
  				camera.matrixWorldInverse
  			);

  			_frustum$1.setFromProjectionMatrix(
  				_projScreenMatrix$2,
  				this.coordinateSystem
  			);

  			if ( _frustum$1.intersectsSphere( sphere ) ) {

  				return true; // Sphere is visible in at least one camera

  			}

  		}

  		return false; // Not visible in any camera

  	}

  	/**
  	 * Returns `true` if the given bounding box is intersecting any frustum
  	 * from the camera array.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
  	 * @return {boolean} Whether the box is visible in any camera.
  	 */
  	intersectsBox( box, cameraArray ) {

  		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

  			return false;

  		}

  		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

  			const camera = cameraArray.cameras[ i ];

  			_projScreenMatrix$2.multiplyMatrices(
  				camera.projectionMatrix,
  				camera.matrixWorldInverse
  			);

  			_frustum$1.setFromProjectionMatrix(
  				_projScreenMatrix$2,
  				this.coordinateSystem
  			);

  			if ( _frustum$1.intersectsBox( box ) ) {

  				return true; // Box is visible in at least one camera

  			}

  		}

  		return false; // Not visible in any camera

  	}

  	/**
  	 * Returns `true` if the given point lies within any frustum
  	 * from the camera array.
  	 *
  	 * @param {Vector3} point - The point to test.
  	 * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
  	 * @return {boolean} Whether the point is visible in any camera.
  	 */
  	containsPoint( point, cameraArray ) {

  		if ( ! cameraArray || ! cameraArray.cameras || cameraArray.cameras.length === 0 ) {

  			return false;

  		}

  		for ( let i = 0; i < cameraArray.cameras.length; i ++ ) {

  			const camera = cameraArray.cameras[ i ];

  			_projScreenMatrix$2.multiplyMatrices(
  				camera.projectionMatrix,
  				camera.matrixWorldInverse
  			);

  			_frustum$1.setFromProjectionMatrix(
  				_projScreenMatrix$2,
  				this.coordinateSystem
  			);

  			if ( _frustum$1.containsPoint( point ) ) {

  				return true; // Point is visible in at least one camera

  			}

  		}

  		return false; // Not visible in any camera

  	}

  	/**
  	 * Returns a new frustum array with copied values from this instance.
  	 *
  	 * @return {FrustumArray} A clone of this instance.
  	 */
  	clone() {

  		return new FrustumArray();

  	}

  }

  /**
   * A material for rendering line primitives.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * ```js
   * const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
   * ```
   *
   * @augments Material
   */
  class LineBasicMaterial extends Material {

  	/**
  	 * Constructs a new line basic material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineBasicMaterial = true;

  		this.type = 'LineBasicMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff );

  		/**
  		 * Sets the color of the lines using data from a texture. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * Controls line thickness or lines.
  		 *
  		 * Can only be used with {@link SVGRenderer}. WebGL and WebGPU
  		 * ignore this setting and always render line primitives with a
  		 * width of one pixel.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.linewidth = 1;

  		/**
  		 * Defines appearance of line ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('butt'|'round'|'square')}
  		 * @default 'round'
  		 */
  		this.linecap = 'round';

  		/**
  		 * Defines appearance of line joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.linejoin = 'round';

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.linewidth = source.linewidth;
  		this.linecap = source.linecap;
  		this.linejoin = source.linejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * A material for rendering point primitives.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * ```js
   * const vertices = [];
   *
   * for ( let i = 0; i < 10000; i ++ ) {
   * 	const x = THREE.MathUtils.randFloatSpread( 2000 );
   * 	const y = THREE.MathUtils.randFloatSpread( 2000 );
   * 	const z = THREE.MathUtils.randFloatSpread( 2000 );
   *
   * 	vertices.push( x, y, z );
   * }
   *
   * const geometry = new THREE.BufferGeometry();
   * geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
   * const material = new THREE.PointsMaterial( { color: 0x888888 } );
   * const points = new THREE.Points( geometry, material );
   * scene.add( points );
   * ```
   *
   * @augments Material
   */
  class PointsMaterial extends Material {

  	/**
  	 * Constructs a new points material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointsMaterial = true;

  		this.type = 'PointsMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff );

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * Defines the size of the points in pixels.
  		 *
  		 * Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.size = 1;

  		/**
  		 * Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.sizeAttenuation = true;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.size = source.size;
  		this.sizeAttenuation = source.sizeAttenuation;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * This class can only be used in combination with `copyFramebufferToTexture()` methods
   * of renderers. It extracts the contents of the current bound framebuffer and provides it
   * as a texture for further usage.
   *
   * ```js
   * const pixelRatio = window.devicePixelRatio;
   * const textureSize = 128 * pixelRatio;
   *
   * const frameTexture = new FramebufferTexture( textureSize, textureSize );
   *
   * // calculate start position for copying part of the frame data
   * const vector = new Vector2();
   * vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );
   * vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );
   *
   * renderer.render( scene, camera );
   *
   * // copy part of the rendered frame into the framebuffer texture
   * renderer.copyFramebufferToTexture( frameTexture, vector );
   * ```
   *
   * @augments Texture
   */
  class FramebufferTexture extends Texture {

  	/**
  	 * Constructs a new framebuffer texture.
  	 *
  	 * @param {number} width - The width of the texture.
  	 * @param {number} height - The height of the texture.
  	 */
  	constructor( width, height ) {

  		super( { width, height } );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isFramebufferTexture = true;

  		/**
  		 * How the texture is sampled when a texel covers more than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default to disable filtering.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.magFilter = NearestFilter;

  		/**
  		 * How the texture is sampled when a texel covers less than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default to disable filtering.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.minFilter = NearestFilter;

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		this.needsUpdate = true;

  	}

  }

  /**
   * This class can be used to automatically save the depth information of a
   * rendering into a texture.
   *
   * @augments Texture
   */
  class DepthTexture extends Texture {

  	/**
  	 * Constructs a new depth texture.
  	 *
  	 * @param {number} width - The width of the texture.
  	 * @param {number} height - The height of the texture.
  	 * @param {number} [type=UnsignedIntType] - The texture type.
  	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
  	 * @param {number} [minFilter=LinearFilter] - The min filter value.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {number} [format=DepthFormat] - The texture format.
  	 * @param {number} [depth=1] - The depth of the texture.
  	 */
  	constructor( width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat, depth = 1 ) {

  		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  		}

  		const image = { width: width, height: height, depth: depth };

  		super( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDepthTexture = true;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * Code corresponding to the depth compare function.
  		 *
  		 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
  		 * @default null
  		 */
  		this.compareFunction = null;

  	}


  	copy( source ) {

  		super.copy( source );

  		this.source = new Source( Object.assign( {}, source.image ) ); // see #30540
  		this.compareFunction = source.compareFunction;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

  		return data;

  	}

  }

  /**
   * A geometry class for representing a cylinder.
   *
   * ```js
   * const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
   * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
   * const cylinder = new THREE.Mesh( geometry, material );
   * scene.add( cylinder );
   * ```
   *
   * @augments BufferGeometry
   */
  class CylinderGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new cylinder geometry.
  	 *
  	 * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
  	 * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
  	 * @param {number} [height=1] - Height of the cylinder.
  	 * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
  	 * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
  	 * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
  	 * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
  	 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
  	 * The default value results in a complete cylinder.
  	 */
  	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

  		super();

  		this.type = 'CylinderGeometry';

  		/**
  		 * Holds the constructor parameters that have been
  		 * used to generate the geometry. Any modification
  		 * after instantiation does not change the geometry.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = {
  			radiusTop: radiusTop,
  			radiusBottom: radiusBottom,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		const scope = this;

  		radialSegments = Math.floor( radialSegments );
  		heightSegments = Math.floor( heightSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let index = 0;
  		const indexArray = [];
  		const halfHeight = height / 2;
  		let groupStart = 0;

  		// generate geometry

  		generateTorso();

  		if ( openEnded === false ) {

  			if ( radiusTop > 0 ) generateCap( true );
  			if ( radiusBottom > 0 ) generateCap( false );

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function generateTorso() {

  			const normal = new Vector3();
  			const vertex = new Vector3();

  			let groupCount = 0;

  			// this will be used to calculate the normal
  			const slope = ( radiusBottom - radiusTop ) / height;

  			// generate vertices, normals and uvs

  			for ( let y = 0; y <= heightSegments; y ++ ) {

  				const indexRow = [];

  				const v = y / heightSegments;

  				// calculate the radius of the current row

  				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  				for ( let x = 0; x <= radialSegments; x ++ ) {

  					const u = x / radialSegments;

  					const theta = u * thetaLength + thetaStart;

  					const sinTheta = Math.sin( theta );
  					const cosTheta = Math.cos( theta );

  					// vertex

  					vertex.x = radius * sinTheta;
  					vertex.y = - v * height + halfHeight;
  					vertex.z = radius * cosTheta;
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					// normal

  					normal.set( sinTheta, slope, cosTheta ).normalize();
  					normals.push( normal.x, normal.y, normal.z );

  					// uv

  					uvs.push( u, 1 - v );

  					// save index of vertex in respective row

  					indexRow.push( index ++ );

  				}

  				// now save vertices of the row in our index array

  				indexArray.push( indexRow );

  			}

  			// generate indices

  			for ( let x = 0; x < radialSegments; x ++ ) {

  				for ( let y = 0; y < heightSegments; y ++ ) {

  					// we use the index array to access the correct indices

  					const a = indexArray[ y ][ x ];
  					const b = indexArray[ y + 1 ][ x ];
  					const c = indexArray[ y + 1 ][ x + 1 ];
  					const d = indexArray[ y ][ x + 1 ];

  					// faces

  					if ( radiusTop > 0 || y !== 0 ) {

  						indices.push( a, b, d );
  						groupCount += 3;

  					}

  					if ( radiusBottom > 0 || y !== heightSegments - 1 ) {

  						indices.push( b, c, d );
  						groupCount += 3;

  					}

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, 0 );

  			// calculate new start value for groups

  			groupStart += groupCount;

  		}

  		function generateCap( top ) {

  			// save the index of the first center vertex
  			const centerIndexStart = index;

  			const uv = new Vector2();
  			const vertex = new Vector3();

  			let groupCount = 0;

  			const radius = ( top === true ) ? radiusTop : radiusBottom;
  			const sign = ( top === true ) ? 1 : -1;

  			// first we generate the center vertex data of the cap.
  			// because the geometry needs one set of uvs per face,
  			// we must generate a center vertex per face/segment

  			for ( let x = 1; x <= radialSegments; x ++ ) {

  				// vertex

  				vertices.push( 0, halfHeight * sign, 0 );

  				// normal

  				normals.push( 0, sign, 0 );

  				// uv

  				uvs.push( 0.5, 0.5 );

  				// increase index

  				index ++;

  			}

  			// save the index of the last center vertex
  			const centerIndexEnd = index;

  			// now we generate the surrounding vertices, normals and uvs

  			for ( let x = 0; x <= radialSegments; x ++ ) {

  				const u = x / radialSegments;
  				const theta = u * thetaLength + thetaStart;

  				const cosTheta = Math.cos( theta );
  				const sinTheta = Math.sin( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = halfHeight * sign;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normals.push( 0, sign, 0 );

  				// uv

  				uv.x = ( cosTheta * 0.5 ) + 0.5;
  				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  				uvs.push( uv.x, uv.y );

  				// increase index

  				index ++;

  			}

  			// generate indices

  			for ( let x = 0; x < radialSegments; x ++ ) {

  				const c = centerIndexStart + x;
  				const i = centerIndexEnd + x;

  				if ( top === true ) {

  					// face top

  					indices.push( i, i + 1, c );

  				} else {

  					// face bottom

  					indices.push( i + 1, i, c );

  				}

  				groupCount += 3;

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  			// calculate new start value for groups

  			groupStart += groupCount;

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	/**
  	 * Factory method for creating an instance of this class from the given
  	 * JSON object.
  	 *
  	 * @param {Object} data - A JSON object representing the serialized geometry.
  	 * @return {CylinderGeometry} A new instance.
  	 */
  	static fromJSON( data ) {

  		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

  	}

  }

  /**
   * A geometry class for representing a plane.
   *
   * ```js
   * const geometry = new THREE.PlaneGeometry( 1, 1 );
   * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
   * const plane = new THREE.Mesh( geometry, material );
   * scene.add( plane );
   * ```
   *
   * @augments BufferGeometry
   */
  class PlaneGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new plane geometry.
  	 *
  	 * @param {number} [width=1] - The width along the X axis.
  	 * @param {number} [height=1] - The height along the Y axis
  	 * @param {number} [widthSegments=1] - The number of segments along the X axis.
  	 * @param {number} [heightSegments=1] - The number of segments along the Y axis.
  	 */
  	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

  		super();

  		this.type = 'PlaneGeometry';

  		/**
  		 * Holds the constructor parameters that have been
  		 * used to generate the geometry. Any modification
  		 * after instantiation does not change the geometry.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = {
  			width: width,
  			height: height,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments
  		};

  		const width_half = width / 2;
  		const height_half = height / 2;

  		const gridX = Math.floor( widthSegments );
  		const gridY = Math.floor( heightSegments );

  		const gridX1 = gridX + 1;
  		const gridY1 = gridY + 1;

  		const segment_width = width / gridX;
  		const segment_height = height / gridY;

  		//

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		for ( let iy = 0; iy < gridY1; iy ++ ) {

  			const y = iy * segment_height - height_half;

  			for ( let ix = 0; ix < gridX1; ix ++ ) {

  				const x = ix * segment_width - width_half;

  				vertices.push( x, - y, 0 );

  				normals.push( 0, 0, 1 );

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  			}

  		}

  		for ( let iy = 0; iy < gridY; iy ++ ) {

  			for ( let ix = 0; ix < gridX; ix ++ ) {

  				const a = ix + gridX1 * iy;
  				const b = ix + gridX1 * ( iy + 1 );
  				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  				const d = ( ix + 1 ) + gridX1 * iy;

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	/**
  	 * Factory method for creating an instance of this class from the given
  	 * JSON object.
  	 *
  	 * @param {Object} data - A JSON object representing the serialized geometry.
  	 * @return {PlaneGeometry} A new instance.
  	 */
  	static fromJSON( data ) {

  		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

  	}

  }

  /**
   * A class for generating a sphere geometry.
   *
   * ```js
   * const geometry = new THREE.SphereGeometry( 15, 32, 16 );
   * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
   * const sphere = new THREE.Mesh( geometry, material );
   * scene.add( sphere );
   * ```
   *
   * @augments BufferGeometry
   */
  class SphereGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new sphere geometry.
  	 *
  	 * @param {number} [radius=1] - The sphere radius.
  	 * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
  	 * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
  	 * @param {number} [phiStart=0] - The horizontal starting angle in radians.
  	 * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
  	 * @param {number} [thetaStart=0] - The vertical starting angle in radians.
  	 * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
  	 */
  	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

  		super();

  		this.type = 'SphereGeometry';

  		/**
  		 * Holds the constructor parameters that have been
  		 * used to generate the geometry. Any modification
  		 * after instantiation does not change the geometry.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = {
  			radius: radius,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			phiStart: phiStart,
  			phiLength: phiLength,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
  		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

  		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

  		let index = 0;
  		const grid = [];

  		const vertex = new Vector3();
  		const normal = new Vector3();

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// generate vertices, normals and uvs

  		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

  			const verticesRow = [];

  			const v = iy / heightSegments;

  			// special case for the poles

  			let uOffset = 0;

  			if ( iy === 0 && thetaStart === 0 ) {

  				uOffset = 0.5 / widthSegments;

  			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

  				uOffset = -0.5 / widthSegments;

  			}

  			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

  				const u = ix / widthSegments;

  				// vertex

  				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.copy( vertex ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u + uOffset, 1 - v );

  				verticesRow.push( index ++ );

  			}

  			grid.push( verticesRow );

  		}

  		// indices

  		for ( let iy = 0; iy < heightSegments; iy ++ ) {

  			for ( let ix = 0; ix < widthSegments; ix ++ ) {

  				const a = grid[ iy ][ ix + 1 ];
  				const b = grid[ iy ][ ix ];
  				const c = grid[ iy + 1 ][ ix ];
  				const d = grid[ iy + 1 ][ ix + 1 ];

  				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
  				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	/**
  	 * Factory method for creating an instance of this class from the given
  	 * JSON object.
  	 *
  	 * @param {Object} data - A JSON object representing the serialized geometry.
  	 * @return {SphereGeometry} A new instance.
  	 */
  	static fromJSON( data ) {

  		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

  	}

  }

  /**
   * This material can receive shadows, but otherwise is completely transparent.
   *
   * ```js
   * const geometry = new THREE.PlaneGeometry( 2000, 2000 );
   * geometry.rotateX( - Math.PI / 2 );
   *
   * const material = new THREE.ShadowMaterial();
   * material.opacity = 0.2;
   *
   * const plane = new THREE.Mesh( geometry, material );
   * plane.position.y = -200;
   * plane.receiveShadow = true;
   * scene.add( plane );
   * ```
   *
   * @augments Material
   */
  class ShadowMaterial extends Material {

  	/**
  	 * Constructs a new shadow material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isShadowMaterial = true;

  		this.type = 'ShadowMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.color = new Color( 0x000000 );

  		/**
  		 * Overwritten since shadow materials are transparent
  		 * by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.transparent = true;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * A standard physically based material, using Metallic-Roughness workflow.
   *
   * Physically based rendering (PBR) has recently become the standard in many
   * 3D applications, such as [Unity]{@link https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/},
   * [Unreal]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/} and
   * [3D Studio Max]{@link http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017}.
   *
   * This approach differs from older approaches in that instead of using
   * approximations for the way in which light interacts with a surface, a
   * physically correct model is used. The idea is that, instead of tweaking
   * materials to look good under specific lighting, a material can be created
   * that will react 'correctly' under all lighting scenarios.
   *
   * In practice this gives a more accurate and realistic looking result than
   * the {@link MeshLambertMaterial} or {@link MeshPhongMaterial}, at the cost of
   * being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
   * shading.
   *
   * Note that for best results you should always specify an environment map when using this material.
   *
   * For a non-technical introduction to the concept of PBR and how to set up a
   * PBR material, check out these articles by the people at [marmoset]{@link https://www.marmoset.co}:
   *
   * - [Basic Theory of Physically Based Rendering]{@link https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/}
   * - [Physically Based Rendering and You Can Too]{@link https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/}
   *
   * Technical details of the approach used in three.js (and most other PBR systems) can be found is this
   * [paper from Disney]{@link https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf}
   * (pdf), by Brent Burley.
   *
   * @augments Material
   */
  class MeshStandardMaterial extends Material {

  	/**
  	 * Constructs a new mesh standard material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshStandardMaterial = true;

  		this.type = 'MeshStandardMaterial';

  		this.defines = { 'STANDARD': '' };

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // diffuse

  		/**
  		 * How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
  		 * means fully diffuse. If `roughnessMap` is also provided,
  		 * both values are multiplied.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.roughness = 1.0;

  		/**
  		 * How much the material is like a metal. Non-metallic materials such as wood
  		 * or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
  		 * A value between `0.0` and `1.0` could be used for a rusty metal look.
  		 * If `metalnessMap` is also provided, both values are multiplied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.metalness = 0.0;

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Emissive (light) color of the material, essentially a solid color
  		 * unaffected by other lighting.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.emissive = new Color( 0x000000 );

  		/**
  		 * Intensity of the emissive light. Modulates the emissive color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.emissiveIntensity = 1.0;

  		/**
  		 * Set emissive (glow) map. The emissive map color is modulated by the
  		 * emissive color and the emissive intensity. If you have an emissive map,
  		 * be sure to set the emissive color to something other than black.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.emissiveMap = null;

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * The green channel of this texture is used to alter the roughness of the
  		 * material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.roughnessMap = null;

  		/**
  		 * The blue channel of this texture is used to alter the metalness of the
  		 * material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.metalnessMap = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The environment map. To ensure a physically correct rendering, environment maps
  		 * are internally pre-processed with {@link PMREMGenerator}.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.envMap = null;

  		/**
  		 * The rotation of the environment map in radians.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.envMapRotation = new Euler();

  		/**
  		 * Scales the effect of the environment map by multiplying its color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.envMapIntensity = 1.0;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is rendered with flat shading or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flatShading = false;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'STANDARD': '' };

  		this.color.copy( source.color );
  		this.roughness = source.roughness;
  		this.metalness = source.metalness;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.roughnessMap = source.roughnessMap;

  		this.metalnessMap = source.metalnessMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.envMapIntensity = source.envMapIntensity;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * An extension of the {@link MeshStandardMaterial}, providing more advanced
   * physically-based rendering properties:
   *
   * - Anisotropy: Ability to represent the anisotropic property of materials
   * as observable with brushed metals.
   * - Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require
   * a clear, reflective layer on top of another layer that may be irregular or rough.
   * Clearcoat approximates this effect, without the need for a separate transparent surface.
   * - Iridescence: Allows to render the effect where hue varies  depending on the viewing
   * angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
   * wings of many insects.
   * - Physically-based transparency: One limitation of {@link Material#opacity} is that highly
   * transparent materials are less reflective. Physically-based transmission provides a more
   * realistic option for thin, transparent surfaces like glass.
   * - Advanced reflectivity: More flexible reflectivity for non-metallic materials.
   * - Sheen: Can be used for representing cloth and fabric materials.
   *
   * As a result of these complex shading features, `MeshPhysicalMaterial` has a
   * higher performance cost, per pixel, than other three.js materials. Most
   * effects are disabled by default, and add cost as they are enabled. For
   * best results, always specify an environment map when using this material.
   *
   * @augments MeshStandardMaterial
   */
  class MeshPhysicalMaterial extends MeshStandardMaterial {

  	/**
  	 * Constructs a new mesh physical material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshPhysicalMaterial = true;

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.type = 'MeshPhysicalMaterial';

  		/**
  		 * The rotation of the anisotropy in tangent, bitangent space, measured in radians
  		 * counter-clockwise from the tangent. When `anisotropyMap` is present, this
  		 * property provides additional rotation to the vectors in the texture.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.anisotropyRotation = 0;

  		/**
  		 * Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
  		 * bitangent space, to be rotated by `anisotropyRotation`. The blue channel
  		 * contains strength as `[0, 1]` to be multiplied by `anisotropy`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.anisotropyMap = null;

  		/**
  		 * The red channel of this texture is multiplied against `clearcoat`,
  		 * for per-pixel control over a coating's intensity.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.clearcoatMap = null;

  		/**
  		 * Roughness of the clear coat layer, from `0.0` to `1.0`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.clearcoatRoughness = 0.0;

  		/**
  		 * The green channel of this texture is multiplied against
  		 * `clearcoatRoughness`, for per-pixel control over a coating's roughness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.clearcoatRoughnessMap = null;

  		/**
  		 * How much `clearcoatNormalMap` affects the clear coat layer, from
  		 * `(0,0)` to `(1,1)`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.clearcoatNormalScale = new Vector2( 1, 1 );

  		/**
  		 * Can be used to enable independent normals for the clear coat layer.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.clearcoatNormalMap = null;

  		/**
  		 * Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
  		 *
  		 * @type {number}
  		 * @default 1.5
  		 */
  		this.ior = 1.5;

  		/**
  		 * Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
  		 * corresponds to an index-of-refraction of `1.5`.
  		 *
  		 * This models the reflectivity of non-metallic materials. It has no effect
  		 * when `metalness` is `1.0`
  		 *
  		 * @name MeshPhysicalMaterial#reflectivity
  		 * @type {number}
  		 * @default 0.5
  		 */
  		Object.defineProperty( this, 'reflectivity', {
  			get: function () {

  				return ( clamp$1( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

  			},
  			set: function ( reflectivity ) {

  				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

  			}
  		} );

  		/**
  		 * The red channel of this texture is multiplied against `iridescence`, for per-pixel
  		 * control over iridescence.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.iridescenceMap = null;

  		/**
  		 * Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
  		 * Between `1.0` to `2.333`.
  		 *
  		 * @type {number}
  		 * @default 1.3
  		 */
  		this.iridescenceIOR = 1.3;

  		/**
  		 *Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
  		 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
  		 *
  		 * @type {Array<number,number>}
  		 * @default [100,400]
  		 */
  		this.iridescenceThicknessRange = [ 100, 400 ];

  		/**
  		 * A texture that defines the thickness of the iridescence layer, stored in the green channel.
  		 * Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
  		 * - `0.0` in the green channel will result in thickness equal to first element of the array.
  		 * - `1.0` in the green channel will result in thickness equal to second element of the array.
  		 * - Values in-between will linearly interpolate between the elements of the array.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.iridescenceThicknessMap = null;

  		/**
  		 * The sheen tint.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.sheenColor = new Color( 0x000000 );

  		/**
  		 * The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
  		 * over sheen tint.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.sheenColorMap = null;

  		/**
  		 * Roughness of the sheen layer, from `0.0` to `1.0`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.sheenRoughness = 1.0;

  		/**
  		 * The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
  		 * over sheen roughness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.sheenRoughnessMap = null;

  		/**
  		 * The red channel of this texture is multiplied against `transmission`, for per-pixel control over
  		 * optical transparency.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.transmissionMap = null;

  		/**
  		 * The thickness of the volume beneath the surface. The value is given in the
  		 * coordinate space of the mesh. If the value is `0` the material is
  		 * thin-walled. Otherwise the material is a volume boundary.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.thickness = 0;

  		/**
  		 * A texture that defines the thickness, stored in the green channel. This will
  		 * be multiplied by `thickness`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.thicknessMap = null;

  		/**
  		 * Density of the medium given as the average distance that light travels in
  		 * the medium before interacting with a particle. The value is given in world
  		 * space units, and must be greater than zero.
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.attenuationDistance = Infinity;

  		/**
  		 * The color that white light turns into due to absorption when reaching the
  		 * attenuation distance.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.attenuationColor = new Color( 1, 1, 1 );

  		/**
  		 * A float that scales the amount of specular reflection for non-metals only.
  		 * When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.specularIntensity = 1.0;

  		/**
  		 * The alpha channel of this texture is multiplied against `specularIntensity`,
  		 * for per-pixel control over specular intensity.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularIntensityMap = null;

  		/**
  		 * Tints the specular reflection at normal incidence for non-metals only.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.specularColor = new Color( 1, 1, 1 );

  		/**
  		 * The RGB channels of this texture are multiplied against `specularColor`,
  		 * for per-pixel control over specular color.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularColorMap = null;

  		this._anisotropy = 0;
  		this._clearcoat = 0;
  		this._dispersion = 0;
  		this._iridescence = 0;
  		this._sheen = 0.0;
  		this._transmission = 0;

  		this.setValues( parameters );

  	}

  	/**
  	 * The anisotropy strength.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get anisotropy() {

  		return this._anisotropy;

  	}

  	set anisotropy( value ) {

  		if ( this._anisotropy > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._anisotropy = value;

  	}

  	/**
  	 * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
  	 * clear coat related properties to enable multilayer materials that have a
  	 * thin translucent layer over the base layer.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get clearcoat() {

  		return this._clearcoat;

  	}

  	set clearcoat( value ) {

  		if ( this._clearcoat > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._clearcoat = value;

  	}
  	/**
  	 * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
  	 * the surface and the viewer, from `0.0` to `1.0`.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get iridescence() {

  		return this._iridescence;

  	}

  	set iridescence( value ) {

  		if ( this._iridescence > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._iridescence = value;

  	}

  	/**
  	 * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
  	 * through a relatively clear volume. Any value zero or larger is valid, the typical range of
  	 * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get dispersion() {

  		return this._dispersion;

  	}

  	set dispersion( value ) {

  		if ( this._dispersion > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._dispersion = value;

  	}

  	/**
  	 * The intensity of the sheen layer, from `0.0` to `1.0`.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get sheen() {

  		return this._sheen;

  	}

  	set sheen( value ) {

  		if ( this._sheen > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._sheen = value;

  	}

  	/**
  	 * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
  	 *
  	 * Thin, transparent or semitransparent, plastic or glass materials remain
  	 * largely reflective even if they are fully transmissive. The transmission
  	 * property can be used to model these materials.
  	 *
  	 * When transmission is non-zero, `opacity` should be  set to `1`.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get transmission() {

  		return this._transmission;

  	}

  	set transmission( value ) {

  		if ( this._transmission > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._transmission = value;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.anisotropy = source.anisotropy;
  		this.anisotropyRotation = source.anisotropyRotation;
  		this.anisotropyMap = source.anisotropyMap;

  		this.clearcoat = source.clearcoat;
  		this.clearcoatMap = source.clearcoatMap;
  		this.clearcoatRoughness = source.clearcoatRoughness;
  		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  		this.clearcoatNormalMap = source.clearcoatNormalMap;
  		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

  		this.dispersion = source.dispersion;
  		this.ior = source.ior;

  		this.iridescence = source.iridescence;
  		this.iridescenceMap = source.iridescenceMap;
  		this.iridescenceIOR = source.iridescenceIOR;
  		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
  		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

  		this.sheen = source.sheen;
  		this.sheenColor.copy( source.sheenColor );
  		this.sheenColorMap = source.sheenColorMap;
  		this.sheenRoughness = source.sheenRoughness;
  		this.sheenRoughnessMap = source.sheenRoughnessMap;

  		this.transmission = source.transmission;
  		this.transmissionMap = source.transmissionMap;

  		this.thickness = source.thickness;
  		this.thicknessMap = source.thicknessMap;
  		this.attenuationDistance = source.attenuationDistance;
  		this.attenuationColor.copy( source.attenuationColor );

  		this.specularIntensity = source.specularIntensity;
  		this.specularIntensityMap = source.specularIntensityMap;
  		this.specularColor.copy( source.specularColor );
  		this.specularColorMap = source.specularColorMap;

  		return this;

  	}

  }

  /**
   * A material for shiny surfaces with specular highlights.
   *
   * The material uses a non-physically based [Blinn-Phong]{@link https://en.wikipedia.org/wiki/Blinn-Phong_shading_model}
   * model for calculating reflectance. Unlike the Lambertian model used in the
   * {@link MeshLambertMaterial} this can simulate shiny surfaces with specular
   * highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.
   *
   * Performance will generally be greater when using this material over the
   * {@link MeshStandardMaterial} or {@link MeshPhysicalMaterial}, at the cost of
   * some graphical accuracy.
   *
   * @augments Material
   */
  class MeshPhongMaterial extends Material {

  	/**
  	 * Constructs a new mesh phong material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshPhongMaterial = true;

  		this.type = 'MeshPhongMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // diffuse

  		/**
  		 * Specular color of the material. The default color is set to `0x111111` (very dark grey)
  		 *
  		 * This defines how shiny the material is and the color of its shine.
  		 *
  		 * @type {Color}
  		 */
  		this.specular = new Color( 0x111111 );

  		/**
  		 * How shiny the specular highlight is; a higher value gives a sharper highlight.
  		 *
  		 * @type {number}
  		 * @default 30
  		 */
  		this.shininess = 30;

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Emissive (light) color of the material, essentially a solid color
  		 * unaffected by other lighting.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.emissive = new Color( 0x000000 );

  		/**
  		 * Intensity of the emissive light. Modulates the emissive color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.emissiveIntensity = 1.0;

  		/**
  		 * Set emissive (glow) map. The emissive map color is modulated by the
  		 * emissive color and the emissive intensity. If you have an emissive map,
  		 * be sure to set the emissive color to something other than black.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.emissiveMap = null;

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * The specular map value affects both how much the specular surface
  		 * highlight contributes and how much of the environment map affects the
  		 * surface.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularMap = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The environment map.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.envMap = null;

  		/**
  		 * The rotation of the environment map in radians.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.envMapRotation = new Euler();

  		/**
  		 * How to combine the result of the surface's color with the environment map, if any.
  		 *
  		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
  		 * blend between the two colors.
  		 *
  		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
  		 * @default MultiplyOperation
  		 */
  		this.combine = MultiplyOperation;

  		/**
  		 * How much the environment map affects the surface.
  		 * The valid range is between `0` (no reflections) and `1` (full reflections).
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.reflectivity = 1;

  		/**
  		 * The index of refraction (IOR) of air (approximately 1) divided by the
  		 * index of refraction of the material. It is used with environment mapping
  		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
  		 * The refraction ratio should not exceed `1`.
  		 *
  		 * @type {number}
  		 * @default 0.98
  		 */
  		this.refractionRatio = 0.98;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is rendered with flat shading or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flatShading = false;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );
  		this.specular.copy( source.specular );
  		this.shininess = source.shininess;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * A material implementing toon shading.
   *
   * @augments Material
   */
  class MeshToonMaterial extends Material {

  	/**
  	 * Constructs a new mesh toon material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshToonMaterial = true;

  		this.defines = { 'TOON': '' };

  		this.type = 'MeshToonMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff );

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * Gradient map for toon shading. It's required to set
  		 * {@link Texture#minFilter} and {@link Texture#magFilter} to {@linkNearestFilter}
  		 * when using this type of texture.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.gradientMap = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Emissive (light) color of the material, essentially a solid color
  		 * unaffected by other lighting.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.emissive = new Color( 0x000000 );

  		/**
  		 * Intensity of the emissive light. Modulates the emissive color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.emissiveIntensity = 1.0;

  		/**
  		 * Set emissive (glow) map. The emissive map color is modulated by the
  		 * emissive color and the emissive intensity. If you have an emissive map,
  		 * be sure to set the emissive color to something other than black.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.emissiveMap = null;

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;
  		this.gradientMap = source.gradientMap;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * A material that maps the normal vectors to RGB colors.
   *
   * @augments Material
   */
  class MeshNormalMaterial extends Material {

  	/**
  	 * Constructs a new mesh normal material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshNormalMaterial = true;

  		this.type = 'MeshNormalMaterial';

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * WebGL and WebGPU ignore this property and always render
  		 * 1 pixel wide lines.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Whether the material is rendered with flat shading or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flatShading = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.flatShading = source.flatShading;

  		return this;

  	}

  }

  /**
   * A material for non-shiny surfaces, without specular highlights.
   *
   * The material uses a non-physically based [Lambertian]{@link https://en.wikipedia.org/wiki/Lambertian_reflectance}
   * model for calculating reflectance. This can simulate some surfaces (such
   * as untreated wood or stone) well, but cannot simulate shiny surfaces with
   * specular highlights (such as varnished wood). `MeshLambertMaterial` uses per-fragment
   * shading.
   *
   * Due to the simplicity of the reflectance and illumination models,
   * performance will be greater when using this material over the
   * {@link MeshPhongMaterial}, {@link MeshStandardMaterial} or
   * {@link MeshPhysicalMaterial}, at the cost of some graphical accuracy.
   *
   * @augments Material
   */
  class MeshLambertMaterial extends Material {

  	/**
  	 * Constructs a new mesh lambert material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshLambertMaterial = true;

  		this.type = 'MeshLambertMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // diffuse

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Emissive (light) color of the material, essentially a solid color
  		 * unaffected by other lighting.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.emissive = new Color( 0x000000 );

  		/**
  		 * Intensity of the emissive light. Modulates the emissive color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.emissiveIntensity = 1.0;

  		/**
  		 * Set emissive (glow) map. The emissive map color is modulated by the
  		 * emissive color and the emissive intensity. If you have an emissive map,
  		 * be sure to set the emissive color to something other than black.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.emissiveMap = null;

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * Specular map used by the material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularMap = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The environment map.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.envMap = null;

  		/**
  		 * The rotation of the environment map in radians.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.envMapRotation = new Euler();

  		/**
  		 * How to combine the result of the surface's color with the environment map, if any.
  		 *
  		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
  		 * blend between the two colors.
  		 *
  		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
  		 * @default MultiplyOperation
  		 */
  		this.combine = MultiplyOperation;

  		/**
  		 * How much the environment map affects the surface.
  		 * The valid range is between `0` (no reflections) and `1` (full reflections).
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.reflectivity = 1;

  		/**
  		 * The index of refraction (IOR) of air (approximately 1) divided by the
  		 * index of refraction of the material. It is used with environment mapping
  		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
  		 * The refraction ratio should not exceed `1`.
  		 *
  		 * @type {number}
  		 * @default 0.98
  		 */
  		this.refractionRatio = 0.98;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is rendered with flat shading or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flatShading = false;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * This material is defined by a MatCap (or Lit Sphere) texture, which encodes the
   * material color and shading.
   *
   * `MeshMatcapMaterial` does not respond to lights since the matcap image file encodes
   * baked lighting. It will cast a shadow onto an object that receives shadows
   * (and shadow clipping works), but it will not self-shadow or receive
   * shadows.
   *
   * @augments Material
   */
  class MeshMatcapMaterial extends Material {

  	/**
  	 * Constructs a new mesh matcap material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshMatcapMaterial = true;

  		this.defines = { 'MATCAP': '' };

  		this.type = 'MeshMatcapMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // diffuse

  		/**
  		 * The matcap map.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.matcap = null;

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * Whether the material is rendered with flat shading or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flatShading = false;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}


  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'MATCAP': '' };

  		this.color.copy( source.color );

  		this.matcap = source.matcap;

  		this.map = source.map;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * A material for rendering line primitives.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * ```js
   * const material = new THREE.LineDashedMaterial( {
   * 	color: 0xffffff,
   * 	scale: 1,
   * 	dashSize: 3,
   * 	gapSize: 1,
   * } );
   * ```
   *
   * @augments LineBasicMaterial
   */
  class LineDashedMaterial extends LineBasicMaterial {

  	/**
  	 * Constructs a new line dashed material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineDashedMaterial = true;
  		this.type = 'LineDashedMaterial';

  		/**
  		 * The scale of the dashed part of a line.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.scale = 1;

  		/**
  		 * The size of the dash. This is both the gap with the stroke.
  		 *
  		 * @type {number}
  		 * @default 3
  		 */
  		this.dashSize = 3;

  		/**
  		 * The size of the gap.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.gapSize = 1;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.scale = source.scale;
  		this.dashSize = source.dashSize;
  		this.gapSize = source.gapSize;

  		return this;

  	}

  }

  /**
   * Abstract base class for lights - all other light types inherit the
   * properties and methods described here.
   *
   * @abstract
   * @augments Object3D
   */
  class Light extends Object3D {

  	/**
  	 * Constructs a new light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( color, intensity = 1 ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLight = true;

  		this.type = 'Light';

  		/**
  		 * The light's color.
  		 *
  		 * @type {Color}
  		 */
  		this.color = new Color( color );

  		/**
  		 * The light's intensity.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.intensity = intensity;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 */
  	dispose() {

  		// Empty here in base class; some subclasses override.

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  		if ( this.distance !== undefined ) data.object.distance = this.distance;
  		if ( this.angle !== undefined ) data.object.angle = this.angle;
  		if ( this.decay !== undefined ) data.object.decay = this.decay;
  		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
  		if ( this.target !== undefined ) data.object.target = this.target.uuid;

  		return data;

  	}

  }

  /**
   * A light source positioned directly above the scene, with color fading from
   * the sky color to the ground color.
   *
   * This light cannot be used to cast shadows.
   *
   * ```js
   * const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
   * scene.add( light );
   * ```
   *
   * @augments Light
   */
  class HemisphereLight extends Light {

  	/**
  	 * Constructs a new hemisphere light.
  	 *
  	 * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
  	 * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( skyColor, groundColor, intensity ) {

  		super( skyColor, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isHemisphereLight = true;

  		this.type = 'HemisphereLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		/**
  		 * The light's ground color.
  		 *
  		 * @type {Color}
  		 */
  		this.groundColor = new Color( groundColor );

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  }

  const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
  const _lookTarget$1 = /*@__PURE__*/ new Vector3();

  /**
   * Abstract base class for light shadow classes. These classes
   * represent the shadow configuration for different light types.
   *
   * @abstract
   */
  class LightShadow {

  	/**
  	 * Constructs a new light shadow.
  	 *
  	 * @param {Camera} camera - The light's view of the world.
  	 */
  	constructor( camera ) {

  		/**
  		 * The light's view of the world.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * The intensity of the shadow. The default is `1`.
  		 * Valid values are in the range `[0, 1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.intensity = 1;

  		/**
  		 * Shadow map bias, how much to add or subtract from the normalized depth
  		 * when deciding whether a surface is in shadow.
  		 *
  		 * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
  		 * may help reduce artifacts in shadows.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.bias = 0;

  		/**
  		 * Defines how much the position used to query the shadow map is offset along
  		 * the object normal. The default is `0`. Increasing this value can be used to
  		 * reduce shadow acne especially in large scenes where light shines onto
  		 * geometry at a shallow angle. The cost is that shadows may appear distorted.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.normalBias = 0;

  		/**
  		 * Setting this to values greater than 1 will blur the edges of the shadow.
  		 * High values will cause unwanted banding effects in the shadows - a greater
  		 * map size will allow for a higher value to be used here before these effects
  		 * become visible.
  		 *
  		 * The property has no effect when the shadow map type is `PCFSoftShadowMap` and
  		 * and it is recommended to increase softness by decreasing the shadow map size instead.
  		 *
  		 * The property has no effect when the shadow map type is `BasicShadowMap`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.radius = 1;

  		/**
  		 * The amount of samples to use when blurring a VSM shadow map.
  		 *
  		 * @type {number}
  		 * @default 8
  		 */
  		this.blurSamples = 8;

  		/**
  		 * Defines the width and height of the shadow map. Higher values give better quality
  		 * shadows at the cost of computation time. Values must be powers of two.
  		 *
  		 * @type {Vector2}
  		 * @default (512,512)
  		 */
  		this.mapSize = new Vector2( 512, 512 );

  		/**
  		 * The type of shadow texture. The default is `UnsignedByteType`.
  		 *
  		 * @type {number}
  		 * @default UnsignedByteType
  		 */
  		this.mapType = UnsignedByteType;

  		/**
  		 * The depth map generated using the internal camera; a location beyond a
  		 * pixel's depth is in shadow. Computed internally during rendering.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The distribution map generated using the internal camera; an occlusion is
  		 * calculated based on the distribution of depths. Computed internally during
  		 * rendering.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.mapPass = null;

  		/**
  		 * Model to shadow camera space, to compute location and depth in shadow map.
  		 * This is computed internally during rendering.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrix = new Matrix4();

  		/**
  		 * Enables automatic updates of the light's shadow. If you do not require dynamic
  		 * lighting / shadows, you may set this to `false`.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoUpdate = true;

  		/**
  		 * When set to `true`, shadow maps will be updated in the next `render` call.
  		 * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
  		 * set this property to `true` and then make a render call to update the light's shadow.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.needsUpdate = false;

  		this._frustum = new Frustum();
  		this._frameExtents = new Vector2( 1, 1 );

  		this._viewportCount = 1;

  		this._viewports = [

  			new Vector4( 0, 0, 1, 1 )

  		];

  	}

  	/**
  	 * Used internally by the renderer to get the number of viewports that need
  	 * to be rendered for this shadow.
  	 *
  	 * @return {number} The viewport count.
  	 */
  	getViewportCount() {

  		return this._viewportCount;

  	}

  	/**
  	 * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
  	 *
  	 * @return {Frustum} The shadow camera frustum.
  	 */
  	getFrustum() {

  		return this._frustum;

  	}

  	/**
  	 * Update the matrices for the camera and shadow, used internally by the renderer.
  	 *
  	 * @param {Light} light - The light for which the shadow is being rendered.
  	 */
  	updateMatrices( light ) {

  		const shadowCamera = this.camera;
  		const shadowMatrix = this.matrix;

  		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
  		shadowCamera.position.copy( _lightPositionWorld$1 );

  		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
  		shadowCamera.lookAt( _lookTarget$1 );
  		shadowCamera.updateMatrixWorld();

  		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

  		shadowMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);

  		shadowMatrix.multiply( _projScreenMatrix$1 );

  	}

  	/**
  	 * Returns a viewport definition for the given viewport index.
  	 *
  	 * @param {number} viewportIndex - The viewport index.
  	 * @return {Vector4} The viewport.
  	 */
  	getViewport( viewportIndex ) {

  		return this._viewports[ viewportIndex ];

  	}

  	/**
  	 * Returns the frame extends.
  	 *
  	 * @return {Vector2} The frame extends.
  	 */
  	getFrameExtents() {

  		return this._frameExtents;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 */
  	dispose() {

  		if ( this.map ) {

  			this.map.dispose();

  		}

  		if ( this.mapPass ) {

  			this.mapPass.dispose();

  		}

  	}

  	/**
  	 * Copies the values of the given light shadow instance to this instance.
  	 *
  	 * @param {LightShadow} source - The light shadow to copy.
  	 * @return {LightShadow} A reference to this light shadow instance.
  	 */
  	copy( source ) {

  		this.camera = source.camera.clone();

  		this.intensity = source.intensity;

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.autoUpdate = source.autoUpdate;
  		this.needsUpdate = source.needsUpdate;
  		this.normalBias = source.normalBias;
  		this.blurSamples = source.blurSamples;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	}

  	/**
  	 * Returns a new light shadow instance with copied values from this instance.
  	 *
  	 * @return {LightShadow} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Serializes the light shadow into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized light shadow.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON() {

  		const object = {};

  		if ( this.intensity !== 1 ) object.intensity = this.intensity;
  		if ( this.bias !== 0 ) object.bias = this.bias;
  		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
  		if ( this.radius !== 1 ) object.radius = this.radius;
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  }

  /**
   * Represents the shadow configuration of directional lights.
   *
   * @augments LightShadow
   */
  class SpotLightShadow extends LightShadow {

  	/**
  	 * Constructs a new spot light shadow.
  	 */
  	constructor() {

  		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSpotLightShadow = true;

  		/**
  		 * Used to focus the shadow camera. The camera's field of view is set as a
  		 * percentage of the spotlight's field-of-view. Range is `[0, 1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.focus = 1;

  		/**
  		 * Texture aspect ratio.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aspect = 1;

  	}

  	updateMatrices( light ) {

  		const camera = this.camera;

  		const fov = RAD2DEG * 2 * light.angle * this.focus;
  		const aspect = ( this.mapSize.width / this.mapSize.height ) * this.aspect;
  		const far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		super.updateMatrices( light );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.focus = source.focus;

  		return this;

  	}

  }

  /**
   * This light gets emitted from a single point in one direction, along a cone
   * that increases in size the further from the light it gets.
   *
   * This light can cast shadows - see the {@link SpotLightShadow} for details.
   *
   * ```js
   * // white spotlight shining from the side, modulated by a texture
   * const spotLight = new THREE.SpotLight( 0xffffff );
   * spotLight.position.set( 100, 1000, 100 );
   * spotLight.map = new THREE.TextureLoader().load( url );
   *
   * spotLight.castShadow = true;
   * spotLight.shadow.mapSize.width = 1024;
   * spotLight.shadow.mapSize.height = 1024;
   * spotLight.shadow.camera.near = 500;
   * spotLight.shadow.camera.far = 4000;
   * spotLight.shadow.camera.fov = 30;s
   * ```
   *
   * @augments Light
   */
  class SpotLight extends Light {

  	/**
  	 * Constructs a new spot light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
  	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
  	 * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
  	 * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
  	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
  	 */
  	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSpotLight = true;

  		this.type = 'SpotLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		/**
  		 * The spot light points from its position to the
  		 * target's position.
  		 *
  		 * For the target's position to be changed to anything other
  		 * than the default, it must be added to the scene.
  		 *
  		 * It is also possible to set the target to be another 3D object
  		 * in the scene. The light will now track the target object.
  		 *
  		 * @type {Object3D}
  		 */
  		this.target = new Object3D();

  		/**
  		 * Maximum range of the light. `0` means no limit.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.distance = distance;

  		/**
  		 * Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
  		 *
  		 * @type {number}
  		 * @default Math.PI/3
  		 */
  		this.angle = angle;

  		/**
  		 * Percent of the spotlight cone that is attenuated due to penumbra.
  		 * Value range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.penumbra = penumbra;

  		/**
  		 * The amount the light dims along the distance of the light. In context of
  		 * physically-correct rendering the default value should not be changed.
  		 *
  		 * @type {number}
  		 * @default 2
  		 */
  		this.decay = decay;

  		/**
  		 * A texture used to modulate the color of the light. The spot light
  		 * color is mixed with the RGB value of this texture, with a ratio
  		 * corresponding to its alpha value. The cookie-like masking effect is
  		 * reproduced using pixel values (0, 0, 0, 1-cookie_value).
  		 *
  		 * *Warning*: This property is disabled if {@link Object3D#castShadow} is set to `false`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * This property holds the light's shadow configuration.
  		 *
  		 * @type {SpotLightShadow}
  		 */
  		this.shadow = new SpotLightShadow();

  	}

  	/**
  	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
  	 *  Changing the power will also change the light's intensity.
  	 *
  	 * @type {number}
  	 */
  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
  		return this.intensity * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / Math.PI;

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  const _projScreenMatrix$3 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld = /*@__PURE__*/ new Vector3();
  const _lookTarget = /*@__PURE__*/ new Vector3();

  /**
   * Represents the shadow configuration of point lights.
   *
   * @augments LightShadow
   */
  class PointLightShadow extends LightShadow {

  	/**
  	 * Constructs a new point light shadow.
  	 */
  	constructor() {

  		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointLightShadow = true;

  		this._frameExtents = new Vector2( 4, 2 );

  		this._viewportCount = 6;

  		this._viewports = [
  			// These viewports map a cube-map onto a 2D texture with the
  			// following orientation:
  			//
  			//  xzXZ
  			//   y Y
  			//
  			// X - Positive x direction
  			// x - Negative x direction
  			// Y - Positive y direction
  			// y - Negative y direction
  			// Z - Positive z direction
  			// z - Negative z direction

  			// positive X
  			new Vector4( 2, 1, 1, 1 ),
  			// negative X
  			new Vector4( 0, 1, 1, 1 ),
  			// positive Z
  			new Vector4( 3, 1, 1, 1 ),
  			// negative Z
  			new Vector4( 1, 1, 1, 1 ),
  			// positive Y
  			new Vector4( 3, 0, 1, 1 ),
  			// negative Y
  			new Vector4( 1, 0, 1, 1 )
  		];

  		this._cubeDirections = [
  			new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ),
  			new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 )
  		];

  		this._cubeUps = [
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, -1 )
  		];

  	}

  	/**
  	 * Update the matrices for the camera and shadow, used internally by the renderer.
  	 *
  	 * @param {Light} light - The light for which the shadow is being rendered.
  	 * @param {number} [viewportIndex=0] - The viewport index.
  	 */
  	updateMatrices( light, viewportIndex = 0 ) {

  		const camera = this.camera;
  		const shadowMatrix = this.matrix;

  		const far = light.distance || camera.far;

  		if ( far !== camera.far ) {

  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  		camera.position.copy( _lightPositionWorld );

  		_lookTarget.copy( camera.position );
  		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
  		camera.up.copy( this._cubeUps[ viewportIndex ] );
  		camera.lookAt( _lookTarget );
  		camera.updateMatrixWorld();

  		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  		_projScreenMatrix$3.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$3 );

  	}

  }

  /**
   * A light that gets emitted from a single point in all directions. A common
   * use case for this is to replicate the light emitted from a bare
   * lightbulb.
   *
   * This light can cast shadows - see the {@link PointLightShadow} for details.
   *
   * ```js
   * const light = new THREE.PointLight( 0xff0000, 1, 100 );
   * light.position.set( 50, 50, 50 );
   * scene.add( light );
   * ```
   *
   * @augments Light
   */
  class PointLight extends Light {

  	/**
  	 * Constructs a new point light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
  	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
  	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
  	 */
  	constructor( color, intensity, distance = 0, decay = 2 ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointLight = true;

  		this.type = 'PointLight';

  		/**
  		 * When distance is zero, light will attenuate according to inverse-square
  		 * law to infinite distance. When distance is non-zero, light will attenuate
  		 * according to inverse-square law until near the distance cutoff, where it
  		 * will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
  		 * physically correct.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.distance = distance;

  		/**
  		 * The amount the light dims along the distance of the light. In context of
  		 * physically-correct rendering the default value should not be changed.
  		 *
  		 * @type {number}
  		 * @default 2
  		 */
  		this.decay = decay;

  		/**
  		 * This property holds the light's shadow configuration.
  		 *
  		 * @type {PointLightShadow}
  		 */
  		this.shadow = new PointLightShadow();

  	}

  	/**
  	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
  	 * Changing the power will also change the light's intensity.
  	 *
  	 * @type {number}
  	 */
  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
  		return this.intensity * 4 * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / ( 4 * Math.PI );

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  /**
   * Camera that uses [orthographic projection]{@link https://en.wikipedia.org/wiki/Orthographic_projection}.
   *
   * In this projection mode, an object's size in the rendered image stays
   * constant regardless of its distance from the camera. This can be useful
   * for rendering 2D scenes and UI elements, amongst other things.
   *
   * ```js
   * const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
   * scene.add( camera );
   * ```
   *
   * @augments Camera
   */
  class OrthographicCamera extends Camera {

  	/**
  	 * Constructs a new orthographic camera.
  	 *
  	 * @param {number} [left=-1] - The left plane of the camera's frustum.
  	 * @param {number} [right=1] - The right plane of the camera's frustum.
  	 * @param {number} [top=1] - The top plane of the camera's frustum.
  	 * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
  	 * @param {number} [near=0.1] - The camera's near plane.
  	 * @param {number} [far=2000] - The camera's far plane.
  	 */
  	constructor( left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000 ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isOrthographicCamera = true;

  		this.type = 'OrthographicCamera';

  		/**
  		 * The zoom factor of the camera.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.zoom = 1;

  		/**
  		 * Represents the frustum window specification. This property should not be edited
  		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.view = null;

  		/**
  		 * The left plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default -1
  		 */
  		this.left = left;

  		/**
  		 * The right plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.right = right;

  		/**
  		 * The top plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.top = top;

  		/**
  		 * The bottom plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default -1
  		 */
  		this.bottom = bottom;

  		/**
  		 * The camera's near plane. The valid range is greater than `0`
  		 * and less than the current value of {@link OrthographicCamera#far}.
  		 *
  		 * Note that, unlike for the {@link PerspectiveCamera}, `0` is a
  		 * valid value for an orthographic camera's near plane.
  		 *
  		 * @type {number}
  		 * @default 0.1
  		 */
  		this.near = near;

  		/**
  		 * The camera's far plane. Must be greater than the
  		 * current value of {@link OrthographicCamera#near}.
  		 *
  		 * @type {number}
  		 * @default 2000
  		 */
  		this.far = far;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * @param {number} fullWidth - The full width of multiview setup.
  	 * @param {number} fullHeight - The full height of multiview setup.
  	 * @param {number} x - The horizontal offset of the subcamera.
  	 * @param {number} y - The vertical offset of the subcamera.
  	 * @param {number} width - The width of subcamera.
  	 * @param {number} height - The height of subcamera.
  	 * @see {@link PerspectiveCamera#setViewOffset}
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Removes the view offset from the projection matrix.
  	 */
  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Updates the camera's projection matrix. Must be called after any change of
  	 * camera properties.
  	 */
  	updateProjectionMatrix() {

  		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		const cx = ( this.right + this.left ) / 2;
  		const cy = ( this.top + this.bottom ) / 2;

  		let left = cx - dx;
  		let right = cx + dx;
  		let top = cy + dy;
  		let bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
  			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

  			left += scaleW * this.view.offsetX;
  			right = left + scaleW * this.view.width;
  			top -= scaleH * this.view.offsetY;
  			bottom = top - scaleH * this.view.height;

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		return data;

  	}

  }

  /**
   * Represents the shadow configuration of directional lights.
   *
   * @augments LightShadow
   */
  class DirectionalLightShadow extends LightShadow {

  	/**
  	 * Constructs a new directional light shadow.
  	 */
  	constructor() {

  		super( new OrthographicCamera( -5, 5, 5, -5, 0.5, 500 ) );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDirectionalLightShadow = true;

  	}

  }

  /**
   * A light that gets emitted in a specific direction. This light will behave
   * as though it is infinitely far away and the rays produced from it are all
   * parallel. The common use case for this is to simulate daylight; the sun is
   * far enough away that its position can be considered to be infinite, and
   * all light rays coming from it are parallel.
   *
   * A common point of confusion for directional lights is that setting the
   * rotation has no effect. This is because three.js's DirectionalLight is the
   * equivalent to what is often called a 'Target Direct Light' in other
   * applications.
   *
   * This means that its direction is calculated as pointing from the light's
   * {@link Object3D#position} to the {@link DirectionalLight#target} position
   * (as opposed to a 'Free Direct Light' that just has a rotation
   * component).
   *
   * This light can cast shadows - see the {@link DirectionalLightShadow} for details.
   *
   * ```js
   * // White directional light at half intensity shining from the top.
   * const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
   * scene.add( directionalLight );
   * ```
   *
   * @augments Light
   */
  class DirectionalLight extends Light {

  	/**
  	 * Constructs a new directional light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( color, intensity ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDirectionalLight = true;

  		this.type = 'DirectionalLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		/**
  		 * The directional light points from its position to the
  		 * target's position.
  		 *
  		 * For the target's position to be changed to anything other
  		 * than the default, it must be added to the scene.
  		 *
  		 * It is also possible to set the target to be another 3D object
  		 * in the scene. The light will now track the target object.
  		 *
  		 * @type {Object3D}
  		 */
  		this.target = new Object3D();

  		/**
  		 * This property holds the light's shadow configuration.
  		 *
  		 * @type {DirectionalLightShadow}
  		 */
  		this.shadow = new DirectionalLightShadow();

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.target = source.target.clone();
  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  /**
   * This light globally illuminates all objects in the scene equally.
   *
   * It cannot be used to cast shadows as it does not have a direction.
   *
   * ```js
   * const light = new THREE.AmbientLight( 0x404040 ); // soft white light
   * scene.add( light );
   * ```
   *
   * @augments Light
   */
  class AmbientLight extends Light {

  	/**
  	 * Constructs a new ambient light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( color, intensity ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isAmbientLight = true;

  		this.type = 'AmbientLight';

  	}

  }

  /**
   * This class emits light uniformly across the face a rectangular plane.
   * This light type can be used to simulate light sources such as bright
   * windows or strip lighting.
   *
   * Important Notes:
   *
   * - There is no shadow support.
   * - Only PBR materials are supported.
   * - You have to include `RectAreaLightUniformsLib` (`WebGLRenderer`) or `RectAreaLightTexturesLib` (`WebGPURenderer`)
   * into your app and init the uniforms/textures.
   *
   * ```js
   * RectAreaLightUniformsLib.init(); // only relevant for WebGLRenderer
   * THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() ); //  only relevant for WebGPURenderer
   *
   * const intensity = 1; const width = 10; const height = 10;
   * const rectLight = new THREE.RectAreaLight( 0xffffff, intensity, width, height );
   * rectLight.position.set( 5, 5, 0 );
   * rectLight.lookAt( 0, 0, 0 );
   * scene.add( rectLight )
   * ```
   *
   * @augments Light
   */
  class RectAreaLight extends Light {

  	/**
  	 * Constructs a new area light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 * @param {number} [width=10] - The width of the light.
  	 * @param {number} [height=10] - The height of the light.
  	 */
  	constructor( color, intensity, width = 10, height = 10 ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRectAreaLight = true;

  		this.type = 'RectAreaLight';

  		/**
  		 * The width of the light.
  		 *
  		 * @type {number}
  		 * @default 10
  		 */
  		this.width = width;

  		/**
  		 * The height of the light.
  		 *
  		 * @type {number}
  		 * @default 10
  		 */
  		this.height = height;

  	}

  	/**
  	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
  	 * Changing the power will also change the light's intensity.
  	 *
  	 * @type {number}
  	 */
  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in nits)
  		return this.intensity * this.width * this.height * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in nits) from the desired luminous power (in lumens)
  		this.intensity = power / ( this.width * this.height * Math.PI );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  }

  /**
   * Represents a third-order spherical harmonics (SH). Light probes use this class
   * to encode lighting information.
   *
   * - Primary reference: {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf}
   * - Secondary reference: {@link https://www.ppsloan.org/publications/StupidSH36.pdf}
   */
  class SphericalHarmonics3 {

  	/**
  	 * Constructs a new spherical harmonics.
  	 */
  	constructor() {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSphericalHarmonics3 = true;

  		/**
  		 * An array holding the (9) SH coefficients.
  		 *
  		 * @type {Array<Vector3>}
  		 */
  		this.coefficients = [];

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients.push( new Vector3() );

  		}

  	}

  	/**
  	 * Sets the given SH coefficients to this instance by copying
  	 * the values.
  	 *
  	 * @param {Array<Vector3>} coefficients - The SH coefficients.
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	set( coefficients ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].copy( coefficients[ i ] );

  		}

  		return this;

  	}

  	/**
  	 * Sets all SH coefficients to `0`.
  	 *
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	zero() {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].set( 0, 0, 0 );

  		}

  		return this;

  	}

  	/**
  	 * Returns the radiance in the direction of the given normal.
  	 *
  	 * @param {Vector3} normal - The normal vector (assumed to be unit length)
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The radiance.
  	 */
  	getAt( normal, target ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		const coeff = this.coefficients;

  		// band 0
  		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

  		// band 1
  		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
  		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
  		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

  		// band 2
  		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
  		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
  		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
  		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
  		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

  		return target;

  	}

  	/**
  	 * Returns the irradiance (radiance convolved with cosine lobe) in the
  	 * direction of the given normal.
  	 *
  	 * @param {Vector3} normal - The normal vector (assumed to be unit length)
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The irradiance.
  	 */
  	getIrradianceAt( normal, target ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		const coeff = this.coefficients;

  		// band 0
  		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

  		// band 1
  		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
  		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
  		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

  		// band 2
  		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
  		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
  		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
  		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
  		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

  		return target;

  	}

  	/**
  	 * Adds the given SH to this instance.
  	 *
  	 * @param {SphericalHarmonics3} sh - The SH to add.
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	add( sh ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].add( sh.coefficients[ i ] );

  		}

  		return this;

  	}

  	/**
  	 * A convenience method for performing {@link SphericalHarmonics3#add} and
  	 * {@link SphericalHarmonics3#scale} at once.
  	 *
  	 * @param {SphericalHarmonics3} sh - The SH to add.
  	 * @param {number} s - The scale factor.
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	addScaledSH( sh, s ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

  		}

  		return this;

  	}

  	/**
  	 * Scales this SH by the given scale factor.
  	 *
  	 * @param {number} s - The scale factor.
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	scale( s ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].multiplyScalar( s );

  		}

  		return this;

  	}

  	/**
  	 * Linear interpolates between the given SH and this instance by the given
  	 * alpha factor.
  	 *
  	 * @param {SphericalHarmonics3} sh - The SH to interpolate with.
  	 * @param {number} alpha - The alpha factor.
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	lerp( sh, alpha ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if this spherical harmonics is equal with the given one.
  	 *
  	 * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
  	 * @return {boolean} Whether this spherical harmonics is equal with the given one.
  	 */
  	equals( sh ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Copies the values of the given spherical harmonics to this instance.
  	 *
  	 * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
  	 * @return {SphericalHarmonics3} A reference to this spherical harmonics.
  	 */
  	copy( sh ) {

  		return this.set( sh.coefficients );

  	}

  	/**
  	 * Returns a new spherical harmonics with copied values from this instance.
  	 *
  	 * @return {SphericalHarmonics3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Sets the SH coefficients of this instance from the given array.
  	 *
  	 * @param {Array<number>} array - An array holding the SH coefficients.
  	 * @param {number} [offset=0] - The array offset where to start copying.
  	 * @return {SphericalHarmonics3} A clone of this instance.
  	 */
  	fromArray( array, offset = 0 ) {

  		const coefficients = this.coefficients;

  		for ( let i = 0; i < 9; i ++ ) {

  			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

  		}

  		return this;

  	}

  	/**
  	 * Returns an array with the SH coefficients, or copies them into the provided
  	 * array. The coefficients are represented as numbers.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array.
  	 * @param {number} [offset=0] - The array offset where to start copying.
  	 * @return {Array<number>} An array with flat SH coefficients.
  	 */
  	toArray( array = [], offset = 0 ) {

  		const coefficients = this.coefficients;

  		for ( let i = 0; i < 9; i ++ ) {

  			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

  		}

  		return array;

  	}

  	/**
  	 * Computes the SH basis for the given normal vector.
  	 *
  	 * @param {Vector3} normal - The normal.
  	 * @param {Array<number>} shBasis - The target array holding the SH basis.
  	 */
  	static getBasisAt( normal, shBasis ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		// band 0
  		shBasis[ 0 ] = 0.282095;

  		// band 1
  		shBasis[ 1 ] = 0.488603 * y;
  		shBasis[ 2 ] = 0.488603 * z;
  		shBasis[ 3 ] = 0.488603 * x;

  		// band 2
  		shBasis[ 4 ] = 1.092548 * x * y;
  		shBasis[ 5 ] = 1.092548 * y * z;
  		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
  		shBasis[ 7 ] = 1.092548 * x * z;
  		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

  	}

  }

  /**
   * Light probes are an alternative way of adding light to a 3D scene. Unlike
   * classical light sources (e.g. directional, point or spot lights), light
   * probes do not emit light. Instead they store information about light
   * passing through 3D space. During rendering, the light that hits a 3D
   * object is approximated by using the data from the light probe.
   *
   * Light probes are usually created from (radiance) environment maps. The
   * class {@link LightProbeGenerator} can be used to create light probes from
   * cube textures or render targets. However, light estimation data could also
   * be provided in other forms e.g. by WebXR. This enables the rendering of
   * augmented reality content that reacts to real world lighting.
   *
   * The current probe implementation in three.js supports so-called diffuse
   * light probes. This type of light probe is functionally equivalent to an
   * irradiance environment map.
   *
   * @augments Light
   */
  class LightProbe extends Light {

  	/**
  	 * Constructs a new light probe.
  	 *
  	 * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

  		super( undefined, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLightProbe = true;

  		/**
  		 * A light probe uses spherical harmonics to encode lighting information.
  		 *
  		 * @type {SphericalHarmonics3}
  		 */
  		this.sh = sh;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.sh.copy( source.sh );

  		return this;

  	}

  	/**
  	 * Deserializes the light prove from the given JSON.
  	 *
  	 * @param {Object} json - The JSON holding the serialized light probe.
  	 * @return {LightProbe} A reference to this light probe.
  	 */
  	fromJSON( json ) {

  		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
  		this.sh.fromArray( json.sh );

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.sh = this.sh.toArray();

  		return data;

  	}

  }

  /**
   * This type of camera can be used in order to efficiently render a scene with a
   * predefined set of cameras. This is an important performance aspect for
   * rendering VR scenes.
   *
   * An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
   * to define for each sub camera the `viewport` property which determines the
   * part of the viewport that is rendered with this camera.
   *
   * @augments PerspectiveCamera
   */
  class ArrayCamera extends PerspectiveCamera {

  	/**
  	 * Constructs a new array camera.
  	 *
  	 * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
  	 */
  	constructor( array = [] ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isArrayCamera = true;

  		/**
  		 * Whether this camera is used with multiview rendering or not.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isMultiViewCamera = false;

  		/**
  		 * An array of perspective sub cameras.
  		 *
  		 * @type {Array<PerspectiveCamera>}
  		 */
  		this.cameras = array;

  	}

  }

  /**
   * An instanced version of an interleaved buffer.
   *
   * @augments InterleavedBuffer
   */
  class InstancedInterleavedBuffer extends InterleavedBuffer {

  	/**
  	 * Constructs a new instanced interleaved buffer.
  	 *
  	 * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
  	 * @param {number} stride - The number of typed-array elements per vertex.
  	 * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
  	 */
  	constructor( array, stride, meshPerAttribute = 1 ) {

  		super( array, stride );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInstancedInterleavedBuffer = true;

  		/**
  		 * Defines how often a value of this buffer attribute should be repeated,
  		 * see {@link InstancedBufferAttribute#meshPerAttribute}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.meshPerAttribute = meshPerAttribute;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	clone( data ) {

  		const ib = super.clone( data );

  		ib.meshPerAttribute = this.meshPerAttribute;

  		return ib;

  	}

  	toJSON( data ) {

  		const json = super.toJSON( data );

  		json.isInstancedInterleavedBuffer = true;
  		json.meshPerAttribute = this.meshPerAttribute;

  		return json;

  	}

  }

  /**
   * Represents a 2x2 matrix.
   *
   * A Note on Row-Major and Column-Major Ordering:
   *
   * The constructor and {@link Matrix2#set} method take arguments in
   * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
   * order, while internally they are stored in the {@link Matrix2#elements} array in column-major order.
   * This means that calling:
   * ```js
   * const m = new THREE.Matrix2();
   * m.set( 11, 12,
   *        21, 22 );
   * ```
   * will result in the elements array containing:
   * ```js
   * m.elements = [ 11, 21,
   *                12, 22 ];
   * ```
   * and internally all calculations are performed using column-major ordering.
   * However, as the actual ordering makes no difference mathematically and
   * most people are used to thinking about matrices in row-major order, the
   * three.js documentation shows matrices in row-major order. Just bear in
   * mind that if you are reading the source code, you'll have to take the
   * transpose of any matrices outlined here to make sense of the calculations.
   */
  class Matrix2 {

  	/**
  	 * Constructs a new 2x2 matrix. The arguments are supposed to be
  	 * in row-major order. If no arguments are provided, the constructor
  	 * initializes the matrix as an identity matrix.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 */
  	constructor( n11, n12, n21, n22 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Matrix2.prototype.isMatrix2 = true;

  		/**
  		 * A column-major list of matrix values.
  		 *
  		 * @type {Array<number>}
  		 */
  		this.elements = [
  			1, 0,
  			0, 1,
  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n21, n22 );

  		}

  	}

  	/**
  	 * Sets this matrix to the 2x2 identity matrix.
  	 *
  	 * @return {Matrix2} A reference to this matrix.
  	 */
  	identity() {

  		this.set(
  			1, 0,
  			0, 1,
  		);

  		return this;

  	}

  	/**
  	 * Sets the elements of the matrix from the given array.
  	 *
  	 * @param {Array<number>} array - The matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Matrix2} A reference to this matrix.
  	 */
  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 4; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	/**
  	 * Sets the elements of the matrix.The arguments are supposed to be
  	 * in row-major order.
  	 *
  	 * @param {number} n11 - 1-1 matrix element.
  	 * @param {number} n12 - 1-2 matrix element.
  	 * @param {number} n21 - 2-1 matrix element.
  	 * @param {number} n22 - 2-2 matrix element.
  	 * @return {Matrix2} A reference to this matrix.
  	 */
  	set( n11, n12, n21, n22 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 2 ] = n12;
  		te[ 1 ] = n21; te[ 3 ] = n22;

  		return this;

  	}

  }

  if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
  		revision: REVISION,
  	} } ) );

  }

  if ( typeof window !== 'undefined' ) {

  	if ( window.__THREE__ ) {

  		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

  	} else {

  		window.__THREE__ = REVISION;

  	}

  }

  /**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   */

  const refreshUniforms = [
  	'alphaMap',
  	'alphaTest',
  	'anisotropy',
  	'anisotropyMap',
  	'anisotropyRotation',
  	'aoMap',
  	'aoMapIntensity',
  	'attenuationColor',
  	'attenuationDistance',
  	'bumpMap',
  	'clearcoat',
  	'clearcoatMap',
  	'clearcoatNormalMap',
  	'clearcoatNormalScale',
  	'clearcoatRoughness',
  	'color',
  	'dispersion',
  	'displacementMap',
  	'emissive',
  	'emissiveIntensity',
  	'emissiveMap',
  	'envMap',
  	'envMapIntensity',
  	'gradientMap',
  	'ior',
  	'iridescence',
  	'iridescenceIOR',
  	'iridescenceMap',
  	'iridescenceThicknessMap',
  	'lightMap',
  	'lightMapIntensity',
  	'map',
  	'matcap',
  	'metalness',
  	'metalnessMap',
  	'normalMap',
  	'normalScale',
  	'opacity',
  	'roughness',
  	'roughnessMap',
  	'sheen',
  	'sheenColor',
  	'sheenColorMap',
  	'sheenRoughnessMap',
  	'shininess',
  	'specular',
  	'specularColor',
  	'specularColorMap',
  	'specularIntensity',
  	'specularIntensityMap',
  	'specularMap',
  	'thickness',
  	'transmission',
  	'transmissionMap'
  ];

  /**
   * This class is used by {@link WebGPURenderer} as management component.
   * It's primary purpose is to determine whether render objects require a
   * refresh right before they are going to be rendered or not.
   */
  class NodeMaterialObserver {

  	/**
  	 * Constructs a new node material observer.
  	 *
  	 * @param {NodeBuilder} builder - The node builder.
  	 */
  	constructor( builder ) {

  		/**
  		 * A node material can be used by more than one render object so the
  		 * monitor must maintain a list of render objects.
  		 *
  		 * @type {WeakMap<RenderObject,Object>}
  		 */
  		this.renderObjects = new WeakMap();

  		/**
  		 * Whether the material uses node objects or not.
  		 *
  		 * @type {boolean}
  		 */
  		this.hasNode = this.containsNode( builder );

  		/**
  		 * Whether the node builder's 3D object is animated or not.
  		 *
  		 * @type {boolean}
  		 */
  		this.hasAnimation = builder.object.isSkinnedMesh === true;

  		/**
  		 * A list of all possible material uniforms
  		 *
  		 * @type {Array<string>}
  		 */
  		this.refreshUniforms = refreshUniforms;

  		/**
  		 * Holds the current render ID from the node frame.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.renderId = 0;

  	}

  	/**
  	 * Returns `true` if the given render object is verified for the first time of this observer.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the given render object is verified for the first time of this observer.
  	 */
  	firstInitialization( renderObject ) {

  		const hasInitialized = this.renderObjects.has( renderObject );

  		if ( hasInitialized === false ) {

  			this.getRenderObjectData( renderObject );

  			return true;

  		}

  		return false;

  	}

  	/**
  	 * Returns `true` if the current rendering produces motion vectors.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {boolean} Whether the current rendering produces motion vectors or not.
  	 */
  	needsVelocity( renderer ) {

  		const mrt = renderer.getMRT();

  		return ( mrt !== null && mrt.has( 'velocity' ) );

  	}

  	/**
  	 * Returns monitoring data for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {Object} The monitoring data.
  	 */
  	getRenderObjectData( renderObject ) {

  		let data = this.renderObjects.get( renderObject );

  		if ( data === undefined ) {

  			const { geometry, material, object } = renderObject;

  			data = {
  				material: this.getMaterialData( material ),
  				geometry: {
  					id: geometry.id,
  					attributes: this.getAttributesData( geometry.attributes ),
  					indexVersion: geometry.index ? geometry.index.version : null,
  					drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
  				},
  				worldMatrix: object.matrixWorld.clone()
  			};

  			if ( object.center ) {

  				data.center = object.center.clone();

  			}

  			if ( object.morphTargetInfluences ) {

  				data.morphTargetInfluences = object.morphTargetInfluences.slice();

  			}

  			if ( renderObject.bundle !== null ) {

  				data.version = renderObject.bundle.version;

  			}

  			if ( data.material.transmission > 0 ) {

  				const { width, height } = renderObject.context;

  				data.bufferWidth = width;
  				data.bufferHeight = height;

  			}

  			this.renderObjects.set( renderObject, data );

  		}

  		return data;

  	}

  	/**
  	 * Returns an attribute data structure holding the attributes versions for
  	 * monitoring.
  	 *
  	 * @param {Object} attributes - The geometry attributes.
  	 * @return {Object} An object for monitoring the versions of attributes.
  	 */
  	getAttributesData( attributes ) {

  		const attributesData = {};

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];

  			attributesData[ name ] = {
  				version: attribute.version
  			};

  		}

  		return attributesData;

  	}

  	/**
  	 * Returns `true` if the node builder's material uses
  	 * node properties.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {boolean} Whether the node builder's material uses node properties or not.
  	 */
  	containsNode( builder ) {

  		const material = builder.material;

  		for ( const property in material ) {

  			if ( material[ property ] && material[ property ].isNode )
  				return true;

  		}

  		if ( builder.renderer.overrideNodes.modelViewMatrix !== null || builder.renderer.overrideNodes.modelNormalViewMatrix !== null )
  			return true;

  		return false;

  	}

  	/**
  	 * Returns a material data structure holding the material property values for
  	 * monitoring.
  	 *
  	 * @param {Material} material - The material.
  	 * @return {Object} An object for monitoring material properties.
  	 */
  	getMaterialData( material ) {

  		const data = {};

  		for ( const property of this.refreshUniforms ) {

  			const value = material[ property ];

  			if ( value === null || value === undefined ) continue;

  			if ( typeof value === 'object' && value.clone !== undefined ) {

  				if ( value.isTexture === true ) {

  					data[ property ] = { id: value.id, version: value.version };

  				} else {

  					data[ property ] = value.clone();

  				}

  			} else {

  				data[ property ] = value;

  			}

  		}

  		return data;

  	}

  	/**
  	 * Returns `true` if the given render object has not changed its state.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the given render object has changed its state or not.
  	 */
  	equals( renderObject ) {

  		const { object, material, geometry } = renderObject;

  		const renderObjectData = this.getRenderObjectData( renderObject );

  		// world matrix

  		if ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {

  			renderObjectData.worldMatrix.copy( object.matrixWorld );

  			return false;

  		}

  		// material

  		const materialData = renderObjectData.material;

  		for ( const property in materialData ) {

  			const value = materialData[ property ];
  			const mtlValue = material[ property ];

  			if ( value.equals !== undefined ) {

  				if ( value.equals( mtlValue ) === false ) {

  					value.copy( mtlValue );

  					return false;

  				}

  			} else if ( mtlValue.isTexture === true ) {

  				if ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {

  					value.id = mtlValue.id;
  					value.version = mtlValue.version;

  					return false;

  				}

  			} else if ( value !== mtlValue ) {

  				materialData[ property ] = mtlValue;

  				return false;

  			}

  		}

  		if ( materialData.transmission > 0 ) {

  			const { width, height } = renderObject.context;

  			if ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {

  				renderObjectData.bufferWidth = width;
  				renderObjectData.bufferHeight = height;

  				return false;

  			}

  		}

  		// geometry

  		const storedGeometryData = renderObjectData.geometry;
  		const attributes = geometry.attributes;
  		const storedAttributes = storedGeometryData.attributes;

  		const storedAttributeNames = Object.keys( storedAttributes );
  		const currentAttributeNames = Object.keys( attributes );

  		if ( storedGeometryData.id !== geometry.id ) {

  			storedGeometryData.id = geometry.id;
  			return false;

  		}

  		if ( storedAttributeNames.length !== currentAttributeNames.length ) {

  			renderObjectData.geometry.attributes = this.getAttributesData( attributes );
  			return false;

  		}

  		// compare each attribute

  		for ( const name of storedAttributeNames ) {

  			const storedAttributeData = storedAttributes[ name ];
  			const attribute = attributes[ name ];

  			if ( attribute === undefined ) {

  				// attribute was removed
  				delete storedAttributes[ name ];
  				return false;

  			}

  			if ( storedAttributeData.version !== attribute.version ) {

  				storedAttributeData.version = attribute.version;
  				return false;

  			}

  		}

  		// check index

  		const index = geometry.index;
  		const storedIndexVersion = storedGeometryData.indexVersion;
  		const currentIndexVersion = index ? index.version : null;

  		if ( storedIndexVersion !== currentIndexVersion ) {

  			storedGeometryData.indexVersion = currentIndexVersion;
  			return false;

  		}

  		// check drawRange

  		if ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {

  			storedGeometryData.drawRange.start = geometry.drawRange.start;
  			storedGeometryData.drawRange.count = geometry.drawRange.count;
  			return false;

  		}

  		// morph targets

  		if ( renderObjectData.morphTargetInfluences ) {

  			let morphChanged = false;

  			for ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {

  				if ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {

  					morphChanged = true;

  				}

  			}

  			if ( morphChanged ) return true;

  		}

  		// center

  		if ( renderObjectData.center ) {

  			if ( renderObjectData.center.equals( object.center ) === false ) {

  				renderObjectData.center.copy( object.center );

  				return true;

  			}

  		}

  		// bundle

  		if ( renderObject.bundle !== null ) {

  			renderObjectData.version = renderObject.bundle.version;

  		}

  		return true;

  	}

  	/**
  	 * Checks if the given render object requires a refresh.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {NodeFrame} nodeFrame - The current node frame.
  	 * @return {boolean} Whether the given render object requires a refresh or not.
  	 */
  	needsRefresh( renderObject, nodeFrame ) {

  		if ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) || this.needsVelocity( nodeFrame.renderer ) )
  			return true;

  		const { renderId } = nodeFrame;

  		if ( this.renderId !== renderId ) {

  			this.renderId = renderId;

  			return true;

  		}

  		const isStatic = renderObject.object.static === true;
  		const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;

  		if ( isStatic || isBundle )
  			return false;

  		const notEqual = this.equals( renderObject ) !== true;

  		return notEqual;

  	}

  }

  // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
  // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
  // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
  // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
  // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
  function cyrb53( value, seed = 0 ) {

  	let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;

  	if ( value instanceof Array ) {

  		for ( let i = 0, val; i < value.length; i ++ ) {

  			val = value[ i ];
  			h1 = Math.imul( h1 ^ val, 2654435761 );
  			h2 = Math.imul( h2 ^ val, 1597334677 );

  		}

  	} else {

  		for ( let i = 0, ch; i < value.length; i ++ ) {

  			ch = value.charCodeAt( i );
  			h1 = Math.imul( h1 ^ ch, 2654435761 );
  			h2 = Math.imul( h2 ^ ch, 1597334677 );

  		}

  	}

  	h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );
  	h1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );
  	h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );
  	h2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );

  	return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );

  }

  /**
   * Computes a hash for the given string.
   *
   * @method
   * @param {string} str - The string to be hashed.
   * @return {number} The hash.
   */
  const hashString = ( str ) => cyrb53( str );

  /**
   * Computes a hash for the given array.
   *
   * @method
   * @param {Array<number>} array - The array to be hashed.
   * @return {number} The hash.
   */
  const hashArray = ( array ) => cyrb53( array );

  /**
   * Computes a hash for the given list of parameters.
   *
   * @method
   * @param {...number} params - A list of parameters.
   * @return {number} The hash.
   */
  const hash$1 = ( ...params ) => cyrb53( params );

  /**
   * Computes a cache key for the given node.
   *
   * @method
   * @param {Object|Node} object - The object to be hashed.
   * @param {boolean} [force=false] - Whether to force a cache key computation or not.
   * @return {number} The hash.
   */
  function getCacheKey$1( object, force = false ) {

  	const values = [];

  	if ( object.isNode === true ) {

  		values.push( object.id );
  		object = object.getSelf();

  	}

  	for ( const { property, childNode } of getNodeChildren( object ) ) {

  		values.push( cyrb53( property.slice( 0, -4 ) ), childNode.getCacheKey( force ) );

  	}

  	return cyrb53( values );

  }

  /**
   * This generator function can be used to iterate over the node children
   * of the given object.
   *
   * @generator
   * @param {Object} node - The object to be hashed.
   * @param {boolean} [toJSON=false] - Whether to return JSON or not.
   * @yields {Object} A result node holding the property, index (if available) and the child node.
   */
  function* getNodeChildren( node, toJSON = false ) {

  	for ( const property in node ) {

  		// Ignore private properties.
  		if ( property.startsWith( '_' ) === true ) continue;

  		const object = node[ property ];

  		if ( Array.isArray( object ) === true ) {

  			for ( let i = 0; i < object.length; i ++ ) {

  				const child = object[ i ];

  				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

  					yield { property, index: i, childNode: child };

  				}

  			}

  		} else if ( object && object.isNode === true ) {

  			yield { property, childNode: object };

  		} else if ( typeof object === 'object' ) {

  			for ( const subProperty in object ) {

  				const child = object[ subProperty ];

  				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

  					yield { property, index: subProperty, childNode: child };

  				}

  			}

  		}

  	}

  }

  const typeFromLength = /*@__PURE__*/ new Map( [
  	[ 1, 'float' ],
  	[ 2, 'vec2' ],
  	[ 3, 'vec3' ],
  	[ 4, 'vec4' ],
  	[ 9, 'mat3' ],
  	[ 16, 'mat4' ]
  ] );

  const dataFromObject = /*@__PURE__*/ new WeakMap();

  /**
   * Returns the data type for the given the length.
   *
   * @method
   * @param {number} length - The length.
   * @return {string} The data type.
   */
  function getTypeFromLength( length ) {

  	return typeFromLength.get( length );

  }

  /**
   * Returns the data type for the given value.
   *
   * @method
   * @param {any} value - The value.
   * @return {?string} The data type.
   */
  function getValueType( value ) {

  	if ( value === undefined || value === null ) return null;

  	const typeOf = typeof value;

  	if ( value.isNode === true ) {

  		return 'node';

  	} else if ( typeOf === 'number' ) {

  		return 'float';

  	} else if ( typeOf === 'boolean' ) {

  		return 'bool';

  	} else if ( typeOf === 'string' ) {

  		return 'string';

  	} else if ( typeOf === 'function' ) {

  		return 'shader';

  	} else if ( value.isVector2 === true ) {

  		return 'vec2';

  	} else if ( value.isVector3 === true ) {

  		return 'vec3';

  	} else if ( value.isVector4 === true ) {

  		return 'vec4';

  	} else if ( value.isMatrix2 === true ) {

  		return 'mat2';

  	} else if ( value.isMatrix3 === true ) {

  		return 'mat3';

  	} else if ( value.isMatrix4 === true ) {

  		return 'mat4';

  	} else if ( value.isColor === true ) {

  		return 'color';

  	} else if ( value instanceof ArrayBuffer ) {

  		return 'ArrayBuffer';

  	}

  	return null;

  }

  /**
   * Returns the value/object for the given data type and parameters.
   *
   * @method
   * @param {string} type - The given type.
   * @param {...any} params - A parameter list.
   * @return {any} The value/object.
   */
  function getValueFromType( type, ...params ) {

  	const last4 = type ? type.slice( -4 ) : undefined;

  	if ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()

  		if ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];
  		else if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];
  		else if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];

  	}

  	if ( type === 'color' ) {

  		return new Color( ...params );

  	} else if ( last4 === 'vec2' ) {

  		return new Vector2( ...params );

  	} else if ( last4 === 'vec3' ) {

  		return new Vector3( ...params );

  	} else if ( last4 === 'vec4' ) {

  		return new Vector4( ...params );

  	} else if ( last4 === 'mat2' ) {

  		return new Matrix2( ...params );

  	} else if ( last4 === 'mat3' ) {

  		return new Matrix3( ...params );

  	} else if ( last4 === 'mat4' ) {

  		return new Matrix4( ...params );

  	} else if ( type === 'bool' ) {

  		return params[ 0 ] || false;

  	} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {

  		return params[ 0 ] || 0;

  	} else if ( type === 'string' ) {

  		return params[ 0 ] || '';

  	} else if ( type === 'ArrayBuffer' ) {

  		return base64ToArrayBuffer( params[ 0 ] );

  	}

  	return null;

  }

  /**
   * Gets the object data that can be shared between different rendering steps.
   *
   * @param {Object} object - The object to get the data for.
   * @return {Object} The object data.
   */
  function getDataFromObject( object ) {

  	let data = dataFromObject.get( object );

  	if ( data === undefined ) {

  		data = {};
  		dataFromObject.set( object, data );

  	}

  	return data;

  }

  /**
   * Converts the given array buffer to a Base64 string.
   *
   * @method
   * @param {ArrayBuffer} arrayBuffer - The array buffer.
   * @return {string} The Base64 string.
   */
  function arrayBufferToBase64( arrayBuffer ) {

  	let chars = '';

  	const array = new Uint8Array( arrayBuffer );

  	for ( let i = 0; i < array.length; i ++ ) {

  		chars += String.fromCharCode( array[ i ] );

  	}

  	return btoa( chars );

  }

  /**
   * Converts the given Base64 string to an array buffer.
   *
   * @method
   * @param {string} base64 - The Base64 string.
   * @return {ArrayBuffer} The array buffer.
   */
  function base64ToArrayBuffer( base64 ) {

  	return Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;

  }

  /**
   * Possible shader stages.
   *
   * @property {string} VERTEX The vertex shader stage.
   * @property {string} FRAGMENT The fragment shader stage.
   */
  const NodeShaderStage = {
  	VERTEX: 'vertex'};

  /**
   * Update types of a node.
   *
   * @property {string} NONE The update method is not executed.
   * @property {string} FRAME The update method is executed per frame.
   * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.
   * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.
   */
  const NodeUpdateType = {
  	NONE: 'none',
  	FRAME: 'frame',
  	RENDER: 'render',
  	OBJECT: 'object'
  };

  /**
   * Access types of a node. These are relevant for compute and storage usage.
   *
   * @property {string} READ_ONLY Read-only access
   * @property {string} WRITE_ONLY Write-only access.
   * @property {string} READ_WRITE Read and write access.
   */
  const NodeAccess = {
  	READ_ONLY: 'readOnly',
  	WRITE_ONLY: 'writeOnly',
  	READ_WRITE: 'readWrite',
  };

  const defaultShaderStages = [ 'fragment', 'vertex' ];
  const defaultBuildStages = [ 'setup', 'analyze', 'generate' ];
  const shaderStages = [ ...defaultShaderStages, 'compute' ];
  const vectorComponents = [ 'x', 'y', 'z', 'w' ];

  const _parentBuildStage = {
  	analyze: 'setup',
  	generate: 'analyze'
  };

  let _nodeId = 0;

  /**
   * Base class for all nodes.
   *
   * @augments EventDispatcher
   */
  class Node extends EventDispatcher {

  	static get type() {

  		return 'Node';

  	}

  	/**
  	 * Constructs a new node.
  	 *
  	 * @param {?string} nodeType - The node type.
  	 */
  	constructor( nodeType = null ) {

  		super();

  		/**
  		 * The node type. This represents the result type of the node (e.g. `float` or `vec3`).
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.nodeType = nodeType;

  		/**
  		 * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.
  		 *
  		 * @type {string}
  		 * @default 'none'
  		 */
  		this.updateType = NodeUpdateType.NONE;

  		/**
  		 * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.
  		 *
  		 * @type {string}
  		 * @default 'none'
  		 */
  		this.updateBeforeType = NodeUpdateType.NONE;

  		/**
  		 * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.
  		 *
  		 * @type {string}
  		 * @default 'none'
  		 */
  		this.updateAfterType = NodeUpdateType.NONE;

  		/**
  		 * The UUID of the node.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = MathUtils.generateUUID();

  		/**
  		 * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  		/**
  		 * Whether this node is global or not. This property is relevant for the internal
  		 * node caching system. All nodes which should be declared just once should
  		 * set this flag to `true` (a typical example is {@link AttributeNode}).
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.global = false;

  		/**
  		 * Create a list of parents for this node during the build process.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.parents = false;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNode = true;

  		// private

  		/**
  		 * The cache key of this node.
  		 *
  		 * @private
  		 * @type {?number}
  		 * @default null
  		 */
  		this._cacheKey = null;

  		/**
  		 * The cache key 's version.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 0
  		 */
  		this._cacheKeyVersion = 0;

  		Object.defineProperty( this, 'id', { value: _nodeId ++ } );

  	}

  	/**
  	 * Set this property to `true` when the node should be regenerated.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) {

  			this.version ++;

  		}

  	}

  	/**
  	 * The type of the class. The value is usually the constructor name.
  	 *
  	 * @type {string}
   	 * @readonly
  	 */
  	get type() {

  		return this.constructor.type;

  	}

  	/**
  	 * Convenient method for defining {@link Node#update}.
  	 *
  	 * @param {Function} callback - The update method.
  	 * @param {string} updateType - The update type.
  	 * @return {Node} A reference to this node.
  	 */
  	onUpdate( callback, updateType ) {

  		this.updateType = updateType;
  		this.update = callback.bind( this.getSelf() );

  		return this;

  	}

  	/**
  	 * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
  	 * this method automatically sets the update type to `FRAME`.
  	 *
  	 * @param {Function} callback - The update method.
  	 * @return {Node} A reference to this node.
  	 */
  	onFrameUpdate( callback ) {

  		return this.onUpdate( callback, NodeUpdateType.FRAME );

  	}

  	/**
  	 * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
  	 * this method automatically sets the update type to `RENDER`.
  	 *
  	 * @param {Function} callback - The update method.
  	 * @return {Node} A reference to this node.
  	 */
  	onRenderUpdate( callback ) {

  		return this.onUpdate( callback, NodeUpdateType.RENDER );

  	}

  	/**
  	 * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
  	 * this method automatically sets the update type to `OBJECT`.
  	 *
  	 * @param {Function} callback - The update method.
  	 * @return {Node} A reference to this node.
  	 */
  	onObjectUpdate( callback ) {

  		return this.onUpdate( callback, NodeUpdateType.OBJECT );

  	}

  	/**
  	 * Convenient method for defining {@link Node#updateReference}.
  	 *
  	 * @param {Function} callback - The update method.
  	 * @return {Node} A reference to this node.
  	 */
  	onReference( callback ) {

  		this.updateReference = callback.bind( this.getSelf() );

  		return this;

  	}

  	/**
  	 * The `this` reference might point to a Proxy so this method can be used
  	 * to get the reference to the actual node instance.
  	 *
  	 * @return {Node} A reference to the node.
  	 */
  	getSelf() {

  		// Returns non-node object.

  		return this.self || this;

  	}

  	/**
  	 * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
  	 * to such objects based on a given state (e.g. the current node frame or builder).
  	 *
  	 * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
  	 * @return {any} The updated reference.
  	 */
  	updateReference( /*state*/ ) {

  		return this;

  	}

  	/**
  	 * By default this method returns the value of the {@link Node#global} flag. This method
  	 * can be overwritten in derived classes if an analytical way is required to determine the
  	 * global cache referring to the current shader-stage.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {boolean} Whether this node is global or not.
  	 */
  	isGlobal( /*builder*/ ) {

  		return this.global;

  	}

  	/**
  	 * Generator function that can be used to iterate over the child nodes.
  	 *
  	 * @generator
  	 * @yields {Node} A child node.
  	 */
  	* getChildren() {

  		for ( const { childNode } of getNodeChildren( this ) ) {

  			yield childNode;

  		}

  	}

  	/**
  	 * Calling this method dispatches the `dispose` event. This event can be used
  	 * to register event listeners for clean up tasks.
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	/**
  	 * Callback for {@link Node#traverse}.
  	 *
  	 * @callback traverseCallback
  	 * @param {Node} node - The current node.
  	 */

  	/**
  	 * Can be used to traverse through the node's hierarchy.
  	 *
  	 * @param {traverseCallback} callback - A callback that is executed per node.
  	 */
  	traverse( callback ) {

  		callback( this );

  		for ( const childNode of this.getChildren() ) {

  			childNode.traverse( callback );

  		}

  	}

  	/**
  	 * Returns the cache key for this node.
  	 *
  	 * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
  	 * @return {number} The cache key of the node.
  	 */
  	getCacheKey( force = false ) {

  		force = force || this.version !== this._cacheKeyVersion;

  		if ( force === true || this._cacheKey === null ) {

  			this._cacheKey = hash$1( getCacheKey$1( this, force ), this.customCacheKey() );
  			this._cacheKeyVersion = this.version;

  		}

  		return this._cacheKey;

  	}

  	/**
  	 * Generate a custom cache key for this node.
  	 *
  	 * @return {number} The cache key of the node.
  	 */
  	customCacheKey() {

  		return 0;

  	}

  	/**
  	 * Returns the references to this node which is by default `this`.
  	 *
  	 * @return {Node} A reference to this node.
  	 */
  	getScope() {

  		return this;

  	}

  	/**
  	 * Returns the hash of the node which is used to identify the node. By default it's
  	 * the {@link Node#uuid} however derived node classes might have to overwrite this method
  	 * depending on their implementation.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The hash.
  	 */
  	getHash( /*builder*/ ) {

  		return this.uuid;

  	}

  	/**
  	 * Returns the update type of {@link Node#update}.
  	 *
  	 * @return {NodeUpdateType} The update type.
  	 */
  	getUpdateType() {

  		return this.updateType;

  	}

  	/**
  	 * Returns the update type of {@link Node#updateBefore}.
  	 *
  	 * @return {NodeUpdateType} The update type.
  	 */
  	getUpdateBeforeType() {

  		return this.updateBeforeType;

  	}

  	/**
  	 * Returns the update type of {@link Node#updateAfter}.
  	 *
  	 * @return {NodeUpdateType} The update type.
  	 */
  	getUpdateAfterType() {

  		return this.updateAfterType;

  	}

  	/**
  	 * Certain types are composed of multiple elements. For example a `vec3`
  	 * is composed of three `float` values. This method returns the type of
  	 * these elements.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The type of the node.
  	 */
  	getElementType( builder ) {

  		const type = this.getNodeType( builder );
  		const elementType = builder.getElementType( type );

  		return elementType;

  	}

  	/**
  	 * Returns the node member type for the given name.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string} name - The name of the member.
  	 * @return {string} The type of the node.
  	 */
  	getMemberType( /*builder, name*/ ) {

  		return 'void';

  	}

  	/**
  	 * Returns the node's type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The type of the node.
  	 */
  	getNodeType( builder ) {

  		const nodeProperties = builder.getNodeProperties( this );

  		if ( nodeProperties.outputNode ) {

  			return nodeProperties.outputNode.getNodeType( builder );

  		}

  		return this.nodeType;

  	}

  	/**
  	 * This method is used during the build process of a node and ensures
  	 * equal nodes are not built multiple times but just once. For example if
  	 * `attribute( 'uv' )` is used multiple times by the user, the build
  	 * process makes sure to process just the first node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node} The shared node if possible. Otherwise `this` is returned.
  	 */
  	getShared( builder ) {

  		const hash = this.getHash( builder );
  		const nodeFromHash = builder.getNodeFromHash( hash );

  		return nodeFromHash || this;

  	}

  	/**
  	 * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
  	 * This method is often overwritten in derived modules to prepare the node which is used as the output/result.
  	 * The output node must be returned in the `return` statement.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {?Node} The output node.
  	 */
  	setup( builder ) {

  		const nodeProperties = builder.getNodeProperties( this );

  		let index = 0;

  		for ( const childNode of this.getChildren() ) {

  			nodeProperties[ 'node' + index ++ ] = childNode;

  		}

  		// return a outputNode if exists or null

  		return nodeProperties.outputNode || null;

  	}

  	/**
  	 * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
  	 * This stage analyzes the node hierarchy and ensures descendent nodes are built.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {?Node} output - The target output node.
  	 */
  	analyze( builder, output = null ) {

  		const usageCount = builder.increaseUsage( this );

  		if ( this.parents === true ) {

  			const nodeData = builder.getDataFromNode( this, 'any' );
  			nodeData.stages = nodeData.stages || {};
  			nodeData.stages[ builder.shaderStage ] = nodeData.stages[ builder.shaderStage ] || [];
  			nodeData.stages[ builder.shaderStage ].push( output );

  		}

  		if ( usageCount === 1 ) {

  			// node flow children

  			const nodeProperties = builder.getNodeProperties( this );

  			for ( const childNode of Object.values( nodeProperties ) ) {

  				if ( childNode && childNode.isNode === true ) {

  					childNode.build( builder, this );

  				}

  			}

  		}

  	}

  	/**
  	 * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
  	 * This state builds the output node and returns the resulting shader string.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {?string} output - Can be used to define the output type.
  	 * @return {?string} The generated shader string.
  	 */
  	generate( builder, output ) {

  		const { outputNode } = builder.getNodeProperties( this );

  		if ( outputNode && outputNode.isNode === true ) {

  			return outputNode.build( builder, output );

  		}

  	}

  	/**
  	 * The method can be implemented to update the node's internal state before it is used to render an object.
  	 * The {@link Node#updateBeforeType} property defines how often the update is executed.
  	 *
  	 * @abstract
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
  	 */
  	updateBefore( /*frame*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * The method can be implemented to update the node's internal state after it was used to render an object.
  	 * The {@link Node#updateAfterType} property defines how often the update is executed.
  	 *
  	 * @abstract
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
  	 */
  	updateAfter( /*frame*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * The method can be implemented to update the node's internal state when it is used to render an object.
  	 * The {@link Node#updateType} property defines how often the update is executed.
  	 *
  	 * @abstract
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
  	 */
  	update( /*frame*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * This method performs the build of a node. The behavior and return value depend on the current build stage:
  	 * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
  	 * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
  	 * - **generate**: Generates the shader code for the node. Returns the generated shader string.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string|Node|null} [output=null] - Can be used to define the output type.
  	 * @return {Node|string|null} The result of the build process, depending on the build stage.
  	 */
  	build( builder, output = null ) {

  		const refNode = this.getShared( builder );

  		if ( this !== refNode ) {

  			return refNode.build( builder, output );

  		}

  		//

  		const nodeData = builder.getDataFromNode( this );
  		nodeData.buildStages = nodeData.buildStages || {};
  		nodeData.buildStages[ builder.buildStage ] = true;

  		const parentBuildStage = _parentBuildStage[ builder.buildStage ];

  		if ( parentBuildStage && nodeData.buildStages[ parentBuildStage ] !== true ) {

  			// force parent build stage (setup or analyze)

  			const previousBuildStage = builder.getBuildStage();

  			builder.setBuildStage( parentBuildStage );

  			this.build( builder );

  			builder.setBuildStage( previousBuildStage );

  		}

  		//

  		builder.addNode( this );
  		builder.addChain( this );

  		/* Build stages expected results:
  			- "setup"		-> Node
  			- "analyze"		-> null
  			- "generate"	-> String
  		*/
  		let result = null;

  		const buildStage = builder.getBuildStage();

  		if ( buildStage === 'setup' ) {

  			this.updateReference( builder );

  			const properties = builder.getNodeProperties( this );

  			if ( properties.initialized !== true ) {

  				//const stackNodesBeforeSetup = builder.stack.nodes.length;

  				properties.initialized = true;
  				properties.outputNode = this.setup( builder ) || properties.outputNode || null;

  				/*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {

  					// !! no outputNode !!
  					//outputNode = builder.stack;

  				}*/

  				for ( const childNode of Object.values( properties ) ) {

  					if ( childNode && childNode.isNode === true ) {

  						if ( childNode.parents === true ) {

  							const childProperties = builder.getNodeProperties( childNode );
  							childProperties.parents = childProperties.parents || [];
  							childProperties.parents.push( this );

  						}

  						childNode.build( builder );

  					}

  				}

  			}

  			result = properties.outputNode;

  		} else if ( buildStage === 'analyze' ) {

  			this.analyze( builder, output );

  		} else if ( buildStage === 'generate' ) {

  			const isGenerateOnce = this.generate.length === 1;

  			if ( isGenerateOnce ) {

  				const type = this.getNodeType( builder );
  				const nodeData = builder.getDataFromNode( this );

  				result = nodeData.snippet;

  				if ( result === undefined ) {

  					if ( nodeData.generated === undefined ) {

  						nodeData.generated = true;

  						result = this.generate( builder ) || '';

  						nodeData.snippet = result;

  					} else {

  						console.warn( 'THREE.Node: Recursion detected.', this );

  						result = '/* Recursion detected. */';

  					}

  				} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {

  					builder.addFlowCodeHierarchy( this, builder.context.nodeBlock );

  				}

  				result = builder.format( result, type, output );

  			} else {

  				result = this.generate( builder, output ) || '';

  			}

  		}

  		builder.removeChain( this );
  		builder.addSequentialNode( this );

  		return result;

  	}

  	/**
  	 * Returns the child nodes as a JSON object.
  	 *
  	 * @return {Array<Object>} An iterable list of serialized child objects as JSON.
  	 */
  	getSerializeChildren() {

  		return getNodeChildren( this );

  	}

  	/**
  	 * Serializes the node to JSON.
  	 *
  	 * @param {Object} json - The output JSON object.
  	 */
  	serialize( json ) {

  		const nodeChildren = this.getSerializeChildren();

  		const inputNodes = {};

  		for ( const { property, index, childNode } of nodeChildren ) {

  			if ( index !== undefined ) {

  				if ( inputNodes[ property ] === undefined ) {

  					inputNodes[ property ] = Number.isInteger( index ) ? [] : {};

  				}

  				inputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;

  			} else {

  				inputNodes[ property ] = childNode.toJSON( json.meta ).uuid;

  			}

  		}

  		if ( Object.keys( inputNodes ).length > 0 ) {

  			json.inputNodes = inputNodes;

  		}

  	}

  	/**
  	 * Deserializes the node from the given JSON.
  	 *
  	 * @param {Object} json - The JSON object.
  	 */
  	deserialize( json ) {

  		if ( json.inputNodes !== undefined ) {

  			const nodes = json.meta.nodes;

  			for ( const property in json.inputNodes ) {

  				if ( Array.isArray( json.inputNodes[ property ] ) ) {

  					const inputArray = [];

  					for ( const uuid of json.inputNodes[ property ] ) {

  						inputArray.push( nodes[ uuid ] );

  					}

  					this[ property ] = inputArray;

  				} else if ( typeof json.inputNodes[ property ] === 'object' ) {

  					const inputObject = {};

  					for ( const subProperty in json.inputNodes[ property ] ) {

  						const uuid = json.inputNodes[ property ][ subProperty ];

  						inputObject[ subProperty ] = nodes[ uuid ];

  					}

  					this[ property ] = inputObject;

  				} else {

  					const uuid = json.inputNodes[ property ];

  					this[ property ] = nodes[ uuid ];

  				}

  			}

  		}

  	}

  	/**
  	 * Serializes the node into the three.js JSON Object/Scene format.
  	 *
  	 * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
  	 * @return {Object} The serialized node.
  	 */
  	toJSON( meta ) {

  		const { uuid, type } = this;
  		const isRoot = ( meta === undefined || typeof meta === 'string' );

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {},
  				nodes: {}
  			};

  		}

  		// serialize

  		let data = meta.nodes[ uuid ];

  		if ( data === undefined ) {

  			data = {
  				uuid,
  				type,
  				meta,
  				metadata: {
  					version: 4.7,
  					type: 'Node',
  					generator: 'Node.toJSON'
  				}
  			};

  			if ( isRoot !== true ) meta.nodes[ data.uuid ] = data;

  			this.serialize( data );

  			delete data.meta;

  		}

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const nodes = extractFromCache( meta.nodes );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;
  			if ( nodes.length > 0 ) data.nodes = nodes;

  		}

  		return data;

  	}

  }

  /**
   * Base class for representing element access on an array-like
   * node data structures.
   *
   * @augments Node
   */
  class ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute

  	static get type() {

  		return 'ArrayElementNode';

  	}

  	/**
  	 * Constructs an array element node.
  	 *
  	 * @param {Node} node - The array-like node.
  	 * @param {Node} indexNode - The index node that defines the element access.
  	 */
  	constructor( node, indexNode ) {

  		super();

  		/**
  		 * The array-like node.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The index node that defines the element access.
  		 *
  		 * @type {Node}
  		 */
  		this.indexNode = indexNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isArrayElementNode = true;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from the array-like node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		return this.node.getElementType( builder );

  	}

  	generate( builder ) {

  		const indexType = this.indexNode.getNodeType( builder );

  		const nodeSnippet = this.node.build( builder );
  		const indexSnippet = this.indexNode.build( builder, ! builder.isVector( indexType ) && builder.isInteger( indexType ) ? indexType : 'uint' );

  		return `${ nodeSnippet }[ ${ indexSnippet } ]`;

  	}

  }

  /**
   * This module is part of the TSL core and usually not used in app level code.
   * It represents a convert operation during the shader generation process
   * meaning it converts the data type of a node to a target data type.
   *
   * @augments Node
   */
  class ConvertNode extends Node {

  	static get type() {

  		return 'ConvertNode';

  	}

  	/**
  	 * Constructs a new convert node.
  	 *
  	 * @param {Node} node - The node which type should be converted.
  	 * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
  	 */
  	constructor( node, convertTo ) {

  		super();

  		/**
  		 * The node which type should be converted.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The target node type. Multiple types can be defined by separating them with a `|` sign.
  		 *
  		 * @type {string}
  		 */
  		this.convertTo = convertTo;

  	}

  	/**
  	 * This method is overwritten since the implementation tries to infer the best
  	 * matching type from the {@link ConvertNode#convertTo} property.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		const requestType = this.node.getNodeType( builder );

  		let convertTo = null;

  		for ( const overloadingType of this.convertTo.split( '|' ) ) {

  			if ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {

  				convertTo = overloadingType;

  			}

  		}

  		return convertTo;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.convertTo = this.convertTo;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.convertTo = data.convertTo;

  	}

  	generate( builder, output ) {

  		const node = this.node;
  		const type = this.getNodeType( builder );

  		const snippet = node.build( builder, type );

  		return builder.format( snippet, type, output );

  	}

  }

  /**
   * This module uses cache management to create temporary variables
   * if the node is used more than once to prevent duplicate calculations.
   *
   * The class acts as a base class for many other nodes types.
   *
   * @augments Node
   */
  class TempNode extends Node {

  	static get type() {

  		return 'TempNode';

  	}

  	/**
  	 * Constructs a temp node.
  	 *
  	 * @param {?string} nodeType - The node type.
  	 */
  	constructor( nodeType = null ) {

  		super( nodeType );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isTempNode = true;

  	}

  	/**
  	 * Whether this node is used more than once in context of other nodes.
  	 *
  	 * @param {NodeBuilder} builder - The node builder.
  	 * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
  	 */
  	hasDependencies( builder ) {

  		return builder.getDataFromNode( this ).usageCount > 1;

  	}

  	build( builder, output ) {

  		const buildStage = builder.getBuildStage();

  		if ( buildStage === 'generate' ) {

  			const type = builder.getVectorType( this.getNodeType( builder, output ) );
  			const nodeData = builder.getDataFromNode( this );

  			if ( nodeData.propertyName !== undefined ) {

  				return builder.format( nodeData.propertyName, type, output );

  			} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {

  				const snippet = super.build( builder, type );

  				const nodeVar = builder.getVarFromNode( this, null, type );
  				const propertyName = builder.getPropertyName( nodeVar );

  				builder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );

  				nodeData.snippet = snippet;
  				nodeData.propertyName = propertyName;

  				return builder.format( nodeData.propertyName, type, output );

  			}

  		}

  		return super.build( builder, output );

  	}

  }

  /**
   * This module is part of the TSL core and usually not used in app level code.
   * It represents a join operation during the shader generation process.
   * For example in can compose/join two single floats into a `vec2` type.
   *
   * @augments TempNode
   */
  class JoinNode extends TempNode {

  	static get type() {

  		return 'JoinNode';

  	}

  	/**
  	 * Constructs a new join node.
  	 *
  	 * @param {Array<Node>} nodes - An array of nodes that should be joined.
  	 * @param {?string} [nodeType=null] - The node type.
  	 */
  	constructor( nodes = [], nodeType = null ) {

  		super( nodeType );

  		/**
  		 * An array of nodes that should be joined.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.nodes = nodes;

  	}

  	/**
  	 * This method is overwritten since the node type must be inferred from the
  	 * joined data length if not explicitly defined.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		if ( this.nodeType !== null ) {

  			return builder.getVectorType( this.nodeType );

  		}

  		return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );
  		const maxLength = builder.getTypeLength( type );

  		const nodes = this.nodes;

  		const primitiveType = builder.getComponentType( type );

  		const snippetValues = [];

  		let length = 0;

  		for ( const input of nodes ) {

  			if ( length >= maxLength ) {

  				console.error( `THREE.TSL: Length of parameters exceeds maximum length of function '${ type }()' type.` );
  				break;

  			}

  			let inputType = input.getNodeType( builder );
  			let inputTypeLength = builder.getTypeLength( inputType );
  			let inputSnippet;

  			if ( length + inputTypeLength > maxLength ) {

  				console.error( `THREE.TSL: Length of '${ type }()' data exceeds maximum length of output type.` );

  				inputTypeLength = maxLength - length;
  				inputType = builder.getTypeFromLength( inputTypeLength );

  			}

  			length += inputTypeLength;
  			inputSnippet = input.build( builder, inputType );

  			const inputPrimitiveType = builder.getComponentType( inputType );

  			if ( inputPrimitiveType !== primitiveType ) {

  				inputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );

  			}

  			snippetValues.push( inputSnippet );

  		}

  		const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

  		return builder.format( snippet, type, output );

  	}

  }

  const _stringVectorComponents = vectorComponents.join( '' );

  /**
   * This module is part of the TSL core and usually not used in app level code.
   * `SplitNode` represents a property access operation which means it is
   * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.
   * For example:
   * ```js
   * const redValue = color.r;
   * ```
   *
   * @augments Node
   */
  class SplitNode extends Node {

  	static get type() {

  		return 'SplitNode';

  	}

  	/**
  	 * Constructs a new split node.
  	 *
  	 * @param {Node} node - The node that should be accessed.
  	 * @param {string} [components='x'] - The components that should be accessed.
  	 */
  	constructor( node, components = 'x' ) {

  		super();

  		/**
  		 * The node that should be accessed.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The components that should be accessed.
  		 *
  		 * @type {string}
  		 */
  		this.components = components;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSplitNode = true;

  	}

  	/**
  	 * Returns the vector length which is computed based on the requested components.
  	 *
  	 * @return {number} The vector length.
  	 */
  	getVectorLength() {

  		let vectorLength = this.components.length;

  		for ( const c of this.components ) {

  			vectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );

  		}

  		return vectorLength;

  	}

  	/**
  	 * Returns the component type of the node's type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The component type.
  	 */
  	getComponentType( builder ) {

  		return builder.getComponentType( this.node.getNodeType( builder ) );

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from requested components.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		return builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );

  	}

  	generate( builder, output ) {

  		const node = this.node;
  		const nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );

  		let snippet = null;

  		if ( nodeTypeLength > 1 ) {

  			let type = null;

  			const componentsLength = this.getVectorLength();

  			if ( componentsLength >= nodeTypeLength ) {

  				// needed expand the input node

  				type = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );

  			}

  			const nodeSnippet = node.build( builder, type );

  			if ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {

  				// unnecessary swizzle

  				snippet = builder.format( nodeSnippet, type, output );

  			} else {

  				snippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );

  			}

  		} else {

  			// ignore .components if .node returns float/integer

  			snippet = node.build( builder, output );

  		}

  		return snippet;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.components = this.components;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.components = data.components;

  	}

  }

  /**
   * This module is part of the TSL core and usually not used in app level code.
   * `SetNode` represents a set operation which means it is used to implement any
   * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.
   * For example:
   * ```js
   * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );
   * ```
   *
   * @augments TempNode
   */
  class SetNode extends TempNode {

  	static get type() {

  		return 'SetNode';

  	}

  	/**
  	 * Constructs a new set node.
  	 *
  	 * @param {Node} sourceNode - The node that should be updated.
  	 * @param {string} components - The components that should be updated.
  	 * @param {Node} targetNode - The value node.
  	 */
  	constructor( sourceNode, components, targetNode ) {

  		super();

  		/**
  		 * The node that should be updated.
  		 *
  		 * @type {Node}
  		 */
  		this.sourceNode = sourceNode;

  		/**
  		 * The components that should be updated.
  		 *
  		 * @type {string}
  		 */
  		this.components = components;

  		/**
  		 * The value node.
  		 *
  		 * @type {Node}
  		 */
  		this.targetNode = targetNode;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		return this.sourceNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const { sourceNode, components, targetNode } = this;

  		const sourceType = this.getNodeType( builder );

  		const componentType = builder.getComponentType( targetNode.getNodeType( builder ) );
  		const targetType = builder.getTypeFromLength( components.length, componentType );

  		const targetSnippet = targetNode.build( builder, targetType );
  		const sourceSnippet = sourceNode.build( builder, sourceType );

  		const length = builder.getTypeLength( sourceType );
  		const snippetValues = [];

  		for ( let i = 0; i < length; i ++ ) {

  			const component = vectorComponents[ i ];

  			if ( component === components[ 0 ] ) {

  				snippetValues.push( targetSnippet );

  				i += components.length - 1;

  			} else {

  				snippetValues.push( sourceSnippet + '.' + component );

  			}

  		}

  		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

  	}

  }

  /**
   * This module is part of the TSL core and usually not used in app level code.
   * It represents a flip operation during the shader generation process
   * meaning it flips normalized values with the following formula:
   * ```
   * x = 1 - x;
   * ```
   * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and
   * `flipSTPQ()` method invocations on node objects. For example:
   * ```js
   * uvNode = uvNode.flipY();
   * ```
   *
   * @augments TempNode
   */
  class FlipNode extends TempNode {

  	static get type() {

  		return 'FlipNode';

  	}

  	/**
  	 * Constructs a new flip node.
  	 *
  	 * @param {Node} sourceNode - The node which component(s) should be flipped.
  	 * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
  	 */
  	constructor( sourceNode, components ) {

  		super();

  		/**
  		 * The node which component(s) should be flipped.
  		 *
  		 * @type {Node}
  		 */
  		this.sourceNode = sourceNode;

  		/**
  		 * The components that should be flipped e.g. `'x'` or `'xy'`.
  		 *
  		 * @type {string}
  		 */
  		this.components = components;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from the source node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		return this.sourceNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const { components, sourceNode } = this;

  		const sourceType = this.getNodeType( builder );
  		const sourceSnippet = sourceNode.build( builder );

  		const sourceCache = builder.getVarFromNode( this );
  		const sourceProperty = builder.getPropertyName( sourceCache );

  		builder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );

  		const length = builder.getTypeLength( sourceType );
  		const snippetValues = [];

  		let componentIndex = 0;

  		for ( let i = 0; i < length; i ++ ) {

  			const component = vectorComponents[ i ];

  			if ( component === components[ componentIndex ] ) {

  				snippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );

  				componentIndex ++;

  			} else {

  				snippetValues.push( sourceProperty + '.' + component );

  			}

  		}

  		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

  	}

  }

  /**
   * Base class for representing data input nodes.
   *
   * @augments Node
   */
  class InputNode extends Node {

  	static get type() {

  		return 'InputNode';

  	}

  	/**
  	 * Constructs a new input node.
  	 *
  	 * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
  	 * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
  	 */
  	constructor( value, nodeType = null ) {

  		super( nodeType );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInputNode = true;

  		/**
  		 * The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
  		 *
  		 * @type {any}
  		 */
  		this.value = value;

  		/**
  		 * The precision of the value in the shader.
  		 *
  		 * @type {?('low'|'medium'|'high')}
  		 * @default null
  		 */
  		this.precision = null;

  	}

  	getNodeType( /*builder*/ ) {

  		if ( this.nodeType === null ) {

  			return getValueType( this.value );

  		}

  		return this.nodeType;

  	}

  	/**
  	 * Returns the input type of the node which is by default the node type. Derived modules
  	 * might overwrite this method and use a fixed type or compute one analytically.
  	 *
  	 * A typical example for different input and node types are textures. The input type of a
  	 * normal RGBA texture is `texture` whereas its node type is `vec4`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( builder ) {

  		return this.getNodeType( builder );

  	}

  	/**
  	 * Sets the precision to the given value. The method can be
  	 * overwritten in derived classes if the final precision must be computed
  	 * analytically.
  	 *
  	 * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
  	 * @return {InputNode} A reference to this node.
  	 */
  	setPrecision( precision ) {

  		this.precision = precision;

  		return this;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.value = this.value;

  		if ( this.value && this.value.toArray ) data.value = this.value.toArray();

  		data.valueType = getValueType( this.value );
  		data.nodeType = this.nodeType;

  		if ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );

  		data.precision = this.precision;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.nodeType = data.nodeType;
  		this.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;

  		this.precision = data.precision || null;

  		if ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );

  	}

  	generate( /*builder, output*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  const _regNum = /float|u?int/;

  /**
   * Class for representing a constant value in the shader.
   *
   * @augments InputNode
   */
  class ConstNode extends InputNode {

  	static get type() {

  		return 'ConstNode';

  	}

  	/**
  	 * Constructs a new input node.
  	 *
  	 * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
  	 * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
  	 */
  	constructor( value, nodeType = null ) {

  		super( value, nodeType );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isConstNode = true;

  	}

  	/**
  	 * Generates the shader string of the value with the current node builder.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The generated value as a shader string.
  	 */
  	generateConst( builder ) {

  		return builder.generateConst( this.getNodeType( builder ), this.value );

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );

  		if ( _regNum.test( type ) && _regNum.test( output ) ) {

  			return builder.generateConst( output, this.value );

  		}

  		return builder.format( this.generateConst( builder ), type, output );

  	}

  }

  /**
   * Base class for representing member access on an object-like
   * node data structures.
   *
   * @augments Node
   */
  class MemberNode extends Node {

  	static get type() {

  		return 'MemberNode';

  	}

  	/**
  	 * Constructs an array element node.
  	 *
  	 * @param {Node} node - The array-like node.
  	 * @param {string} property - The property name.
  	 */
  	constructor( node, property ) {

  		super();

  		/**
  		 * The array-like node.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The property name.
  		 *
  		 * @type {Node}
  		 */
  		this.property = property;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMemberNode = true;

  	}

  	getNodeType( builder ) {

  		return this.node.getMemberType( builder, this.property );

  	}

  	generate( builder ) {

  		const propertyName = this.node.build( builder );

  		return propertyName + '.' + this.property;

  	}

  }

  let currentStack = null;

  const NodeElements = new Map();

  function addMethodChaining( name, nodeElement ) {

  	if ( NodeElements.has( name ) ) {

  		console.warn( `THREE.TSL: Redefinition of method chaining '${ name }'.` );
  		return;

  	}

  	if ( typeof nodeElement !== 'function' ) throw new Error( `THREE.TSL: Node element ${ name } is not a function` );

  	NodeElements.set( name, nodeElement );

  }

  const parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );
  const parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );

  const shaderNodeHandler = {

  	setup( NodeClosure, params ) {

  		const inputs = params.shift();

  		return NodeClosure( nodeObjects( inputs ), ...params );

  	},

  	get( node, prop, nodeObj ) {

  		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

  			if ( node.isStackNode !== true && prop === 'assign' ) {

  				return ( ...params ) => {

  					currentStack.assign( nodeObj, ...params );

  					return nodeObj;

  				};

  			} else if ( NodeElements.has( prop ) ) {

  				const nodeElement = NodeElements.get( prop );

  				return node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );

  			} else if ( prop === 'self' ) {

  				return node;

  			} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {

  				const nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );

  				return node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );

  			} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {

  				// accessing properties ( swizzle )

  				prop = parseSwizzle( prop );

  				return nodeObject( new SplitNode( nodeObj, prop ) );

  			} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

  				// set properties ( swizzle ) and sort to xyzw sequence

  				prop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );

  				return ( value ) => nodeObject( new SetNode( node, prop, nodeObject( value ) ) );

  			} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

  				// set properties ( swizzle ) and sort to xyzw sequence

  				prop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );

  				return () => nodeObject( new FlipNode( nodeObject( node ), prop ) );

  			} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {

  				// accessing property

  				if ( prop === 'width' ) prop = 'x';
  				else if ( prop === 'height' ) prop = 'y';
  				else if ( prop === 'depth' ) prop = 'z';

  				return nodeObject( new SplitNode( node, prop ) );

  			} else if ( /^\d+$/.test( prop ) === true ) {

  				// accessing array

  				return nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );

  			} else if ( /^get$/.test( prop ) === true ) {

  				// accessing properties

  				return ( value ) => nodeObject( new MemberNode( nodeObj, value ) );

  			}

  		}

  		return Reflect.get( node, prop, nodeObj );

  	},

  	set( node, prop, value, nodeObj ) {

  		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

  			// setting properties

  			if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test( prop ) === true ) {

  				nodeObj[ prop ].assign( value );

  				return true;

  			}

  		}

  		return Reflect.set( node, prop, value, nodeObj );

  	}

  };

  const nodeObjectsCacheMap = new WeakMap();
  const nodeBuilderFunctionsCacheMap = new WeakMap();

  const ShaderNodeObject = function ( obj, altType = null ) {

  	const type = getValueType( obj );

  	if ( type === 'node' ) {

  		let nodeObject = nodeObjectsCacheMap.get( obj );

  		if ( nodeObject === undefined ) {

  			nodeObject = new Proxy( obj, shaderNodeHandler );

  			nodeObjectsCacheMap.set( obj, nodeObject );
  			nodeObjectsCacheMap.set( nodeObject, nodeObject );

  		}

  		return nodeObject;

  	} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {

  		return nodeObject( getConstNode( obj, altType ) );

  	} else if ( type === 'shader' ) {

  		return obj.isFn ? obj : Fn( obj );

  	}

  	return obj;

  };

  const ShaderNodeObjects = function ( objects, altType = null ) {

  	for ( const name in objects ) {

  		objects[ name ] = nodeObject( objects[ name ], altType );

  	}

  	return objects;

  };

  const ShaderNodeArray = function ( array, altType = null ) {

  	const len = array.length;

  	for ( let i = 0; i < len; i ++ ) {

  		array[ i ] = nodeObject( array[ i ], altType );

  	}

  	return array;

  };

  const ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {

  	const assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );

  	let fn, name = scope, minParams, maxParams;

  	function verifyParamsLimit( params ) {

  		let tslName;

  		if ( name ) tslName = /[a-z]/i.test( name ) ? name + '()' : name;
  		else tslName = NodeClass.type;

  		if ( minParams !== undefined && params.length < minParams ) {

  			console.error( `THREE.TSL: "${ tslName }" parameter length is less than minimum required.` );

  			return params.concat( new Array( minParams - params.length ).fill( 0 ) );

  		} else if ( maxParams !== undefined && params.length > maxParams ) {

  			console.error( `THREE.TSL: "${ tslName }" parameter length exceeds limit.` );

  			return params.slice( 0, maxParams );

  		}

  		return params;

  	}

  	if ( scope === null ) {

  		fn = ( ...params ) => {

  			return assignNode( new NodeClass( ...nodeArray( verifyParamsLimit( params ) ) ) );

  		};

  	} else if ( factor !== null ) {

  		factor = nodeObject( factor );

  		fn = ( ...params ) => {

  			return assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ), factor ) );

  		};

  	} else {

  		fn = ( ...params ) => {

  			return assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ) ) );

  		};

  	}

  	fn.setParameterLength = ( ...params ) => {

  		if ( params.length === 1 ) minParams = maxParams = params[ 0 ];
  		else if ( params.length === 2 ) [ minParams, maxParams ] = params;

  		return fn;

  	};

  	fn.setName = ( value ) => {

  		name = value;

  		return fn;

  	};

  	return fn;

  };

  const ShaderNodeImmutable = function ( NodeClass, ...params ) {

  	return nodeObject( new NodeClass( ...nodeArray( params ) ) );

  };

  class ShaderCallNodeInternal extends Node {

  	constructor( shaderNode, inputNodes ) {

  		super();

  		this.shaderNode = shaderNode;
  		this.inputNodes = inputNodes;

  		this.isShaderCallNodeInternal = true;

  	}

  	getNodeType( builder ) {

  		return this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );

  	}

  	getMemberType( builder, name ) {

  		return this.getOutputNode( builder ).getMemberType( builder, name );

  	}

  	call( builder ) {

  		const { shaderNode, inputNodes } = this;

  		const properties = builder.getNodeProperties( shaderNode );

  		const subBuild = builder.getClosestSubBuild( shaderNode.subBuilds ) || '';
  		const subBuildProperty = subBuild || 'default';

  		if ( properties[ subBuildProperty ] ) {

  			return properties[ subBuildProperty ];

  		}

  		//

  		const previousSubBuildFn = builder.subBuildFn;

  		builder.subBuildFn = subBuild;

  		let result = null;

  		if ( shaderNode.layout ) {

  			let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );

  			if ( functionNodesCacheMap === undefined ) {

  				functionNodesCacheMap = new WeakMap();

  				nodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );

  			}

  			let functionNode = functionNodesCacheMap.get( shaderNode );

  			if ( functionNode === undefined ) {

  				functionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );

  				functionNodesCacheMap.set( shaderNode, functionNode );

  			}

  			builder.addInclude( functionNode );

  			result = nodeObject( functionNode.call( inputNodes ) );

  		} else {

  			const jsFunc = shaderNode.jsFunc;
  			const outputNode = inputNodes !== null || jsFunc.length > 1 ? jsFunc( inputNodes || [], builder ) : jsFunc( builder );

  			result = nodeObject( outputNode );

  		}

  		builder.subBuildFn = previousSubBuildFn;

  		if ( shaderNode.once ) {

  			properties[ subBuildProperty ] = result;

  		}

  		return result;

  	}

  	setupOutput( builder ) {

  		builder.addStack();

  		builder.stack.outputNode = this.call( builder );

  		return builder.removeStack();

  	}

  	getOutputNode( builder ) {

  		const properties = builder.getNodeProperties( this );
  		const subBuildOutput = builder.getSubBuildOutput( this );

  		properties[ subBuildOutput ] = properties[ subBuildOutput ] || this.setupOutput( builder );
  		properties[ subBuildOutput ].subBuild = builder.getClosestSubBuild( this );

  		return properties[ subBuildOutput ];

  	}

  	build( builder, output = null ) {

  		let result = null;

  		const buildStage = builder.getBuildStage();
  		const properties = builder.getNodeProperties( this );

  		const subBuildOutput = builder.getSubBuildOutput( this );
  		const outputNode = this.getOutputNode( builder );

  		if ( buildStage === 'setup' ) {

  			const subBuildInitialized = builder.getSubBuildProperty( 'initialized', this );

  			if ( properties[ subBuildInitialized ] !== true ) {

  				properties[ subBuildInitialized ] = true;

  				properties[ subBuildOutput ] = this.getOutputNode( builder );
  				properties[ subBuildOutput ].build( builder );

  				// If the shaderNode has subBuilds, add them to the chaining nodes
  				// so they can be built later in the build process.

  				if ( this.shaderNode.subBuilds ) {

  					for ( const node of builder.chaining ) {

  						const nodeData = builder.getDataFromNode( node, 'any' );
  						nodeData.subBuilds = nodeData.subBuilds || new Set();

  						for ( const subBuild of this.shaderNode.subBuilds ) {

  							nodeData.subBuilds.add( subBuild );

  						}

  						//builder.getDataFromNode( node ).subBuilds = nodeData.subBuilds;

  					}

  				}

  			}

  			result = properties[ subBuildOutput ];

  		} else if ( buildStage === 'analyze' ) {

  			outputNode.build( builder, output );

  		} else if ( buildStage === 'generate' ) {

  			result = outputNode.build( builder, output ) || '';

  		}

  		return result;

  	}

  }

  class ShaderNodeInternal extends Node {

  	constructor( jsFunc, nodeType ) {

  		super( nodeType );

  		this.jsFunc = jsFunc;
  		this.layout = null;

  		this.global = true;

  		this.once = false;

  	}

  	setLayout( layout ) {

  		this.layout = layout;

  		return this;

  	}

  	call( inputs = null ) {

  		nodeObjects( inputs );

  		return nodeObject( new ShaderCallNodeInternal( this, inputs ) );

  	}

  	setup() {

  		return this.call();

  	}

  }

  const bools = [ false, true ];
  const uints = [ 0, 1, 2, 3 ];
  const ints = [ -1, -2 ];
  const floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];

  const boolsCacheMap = new Map();
  for ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );

  const uintsCacheMap = new Map();
  for ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );

  const intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );
  for ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );

  const floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );
  for ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );
  for ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );

  const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };

  const constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );

  const getConstNode = ( value, type ) => {

  	if ( constNodesCacheMap.has( value ) ) {

  		return constNodesCacheMap.get( value );

  	} else if ( value.isNode === true ) {

  		return value;

  	} else {

  		return new ConstNode( value, type );

  	}

  };

  const ConvertType = function ( type, cacheMap = null ) {

  	return ( ...params ) => {

  		if ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {

  			params = [ getValueFromType( type, ...params ) ];

  		}

  		if ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {

  			return nodeObject( cacheMap.get( params[ 0 ] ) );

  		}

  		if ( params.length === 1 ) {

  			const node = getConstNode( params[ 0 ], type );
  			if ( node.nodeType === type ) return nodeObject( node );
  			return nodeObject( new ConvertNode( node, type ) );

  		}

  		const nodes = params.map( param => getConstNode( param ) );
  		return nodeObject( new JoinNode( nodes, type ) );

  	};

  };

  // exports

  const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function

  // utils

  const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;

  // shader node base

  function ShaderNode( jsFunc, nodeType ) {

  	return new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );

  }

  const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );
  const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );
  const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );
  const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );
  const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );

  let fnId = 0;

  const Fn = ( jsFunc, layout = null ) => {

  	let nodeType = null;

  	if ( layout !== null ) {

  		if ( typeof layout === 'object' ) {

  			nodeType = layout.return;

  		} else {

  			if ( typeof layout === 'string' ) {

  				nodeType = layout;

  			} else {

  				console.error( 'THREE.TSL: Invalid layout type.' );

  			}

  			layout = null;

  		}

  	}

  	const shaderNode = new ShaderNode( jsFunc, nodeType );

  	const fn = ( ...params ) => {

  		let inputs;

  		nodeObjects( params );

  		const isArrayAsParameter = params[ 0 ] && ( params[ 0 ].isNode || Object.getPrototypeOf( params[ 0 ] ) !== Object.prototype );

  		if ( isArrayAsParameter ) {

  			inputs = [ ...params ];

  		} else {

  			inputs = params[ 0 ];

  		}

  		const fnCall = shaderNode.call( inputs );

  		if ( nodeType === 'void' ) fnCall.toStack();

  		return fnCall;

  	};

  	fn.shaderNode = shaderNode;
  	fn.id = shaderNode.id;

  	fn.isFn = true;

  	fn.getNodeType = ( ...params ) => shaderNode.getNodeType( ...params );
  	fn.getCacheKey = ( ...params ) => shaderNode.getCacheKey( ...params );

  	fn.setLayout = ( layout ) => {

  		shaderNode.setLayout( layout );

  		return fn;

  	};

  	fn.once = ( subBuilds = null ) => {

  		shaderNode.once = true;
  		shaderNode.subBuilds = subBuilds;

  		return fn;

  	};

  	if ( layout !== null ) {

  		if ( typeof layout.inputs !== 'object' ) {

  			const fullLayout = {
  				name: 'fn' + fnId ++,
  				type: nodeType,
  				inputs: []
  			};

  			for ( const name in layout ) {

  				if ( name === 'return' ) continue;

  				fullLayout.inputs.push( {
  					name: name,
  					type: layout[ name ]
  				} );

  			}

  			layout = fullLayout;

  		}

  		fn.setLayout( layout );

  	}

  	return fn;

  };

  //

  const setCurrentStack = ( stack ) => {

  	currentStack = stack;

  };

  const getCurrentStack = () => currentStack;

  /**
   * Represent a conditional node using if/else statements.
   *
   * ```js
   * If( condition, function )
   * 	.ElseIf( condition, function )
   * 	.Else( function )
   * ```
   * @tsl
   * @function
   * @param {...any} params - The parameters for the conditional node.
   * @returns {StackNode} The conditional node.
   */
  const If = ( ...params ) => currentStack.If( ...params );

  /**
   * Add the given node to the current stack.
   *
   * @param {Node} node - The node to add.
   * @returns {Node} The node that was added to the stack.
   */
  function Stack( node ) {

  	if ( currentStack ) currentStack.add( node );

  	return node;

  }

  addMethodChaining( 'toStack', Stack );

  // types

  const color = new ConvertType( 'color' );

  const float = new ConvertType( 'float', cacheMaps.float );
  const int = new ConvertType( 'int', cacheMaps.ints );
  const uint = new ConvertType( 'uint', cacheMaps.uint );
  const bool = new ConvertType( 'bool', cacheMaps.bool );

  const vec2 = new ConvertType( 'vec2' );
  const ivec2 = new ConvertType( 'ivec2' );
  const uvec2 = new ConvertType( 'uvec2' );
  const bvec2 = new ConvertType( 'bvec2' );

  const vec3 = new ConvertType( 'vec3' );
  const ivec3 = new ConvertType( 'ivec3' );
  const uvec3 = new ConvertType( 'uvec3' );
  const bvec3 = new ConvertType( 'bvec3' );

  const vec4 = new ConvertType( 'vec4' );
  const ivec4 = new ConvertType( 'ivec4' );
  const uvec4 = new ConvertType( 'uvec4' );
  const bvec4 = new ConvertType( 'bvec4' );

  const mat2 = new ConvertType( 'mat2' );
  const mat3 = new ConvertType( 'mat3' );
  const mat4 = new ConvertType( 'mat4' );

  addMethodChaining( 'toColor', color );
  addMethodChaining( 'toFloat', float );
  addMethodChaining( 'toInt', int );
  addMethodChaining( 'toUint', uint );
  addMethodChaining( 'toBool', bool );
  addMethodChaining( 'toVec2', vec2 );
  addMethodChaining( 'toIVec2', ivec2 );
  addMethodChaining( 'toUVec2', uvec2 );
  addMethodChaining( 'toBVec2', bvec2 );
  addMethodChaining( 'toVec3', vec3 );
  addMethodChaining( 'toIVec3', ivec3 );
  addMethodChaining( 'toUVec3', uvec3 );
  addMethodChaining( 'toBVec3', bvec3 );
  addMethodChaining( 'toVec4', vec4 );
  addMethodChaining( 'toIVec4', ivec4 );
  addMethodChaining( 'toUVec4', uvec4 );
  addMethodChaining( 'toBVec4', bvec4 );
  addMethodChaining( 'toMat2', mat2 );
  addMethodChaining( 'toMat3', mat3 );
  addMethodChaining( 'toMat4', mat4 );

  // basic nodes

  const element = /*@__PURE__*/ nodeProxy( ArrayElementNode ).setParameterLength( 2 );
  const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );

  addMethodChaining( 'element', element );
  addMethodChaining( 'convert', convert );

  addMethodChaining( 'append', ( node ) => { // @deprecated, r176

  	console.warn( 'THREE.TSL: .append() has been renamed to .toStack().' );
  	return Stack( node );

  } );

  /**
   * This class represents a shader property. It can be used
   * to explicitly define a property and assign a value to it.
   *
   * ```js
   * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );
   *```
   * `PropertyNode` is used by the engine to predefined common material properties
   * for TSL code.
   *
   * @augments Node
   */
  class PropertyNode extends Node {

  	static get type() {

  		return 'PropertyNode';

  	}

  	/**
  	 * Constructs a new property node.
  	 *
  	 * @param {string} nodeType - The type of the node.
  	 * @param {?string} [name=null] - The name of the property in the shader.
  	 * @param {boolean} [varying=false] - Whether this property is a varying or not.
  	 */
  	constructor( nodeType, name = null, varying = false ) {

  		super( nodeType );

  		/**
  		 * The name of the property in the shader. If no name is defined,
  		 * the node system auto-generates one.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.name = name;

  		/**
  		 * Whether this property is a varying or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.varying = varying;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPropertyNode = true;

  		/**
  		 * This flag is used for global cache.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  	}

  	getHash( builder ) {

  		return this.name || super.getHash( builder );

  	}

  	generate( builder ) {

  		let nodeVar;

  		if ( this.varying === true ) {

  			nodeVar = builder.getVaryingFromNode( this, this.name );
  			nodeVar.needsInterpolation = true;

  		} else {

  			nodeVar = builder.getVarFromNode( this, this.name );

  		}

  		return builder.getPropertyName( nodeVar );

  	}

  }

  /**
   * TSL function for creating a property node.
   *
   * @tsl
   * @function
   * @param {string} type - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @returns {PropertyNode}
   */
  const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );

  /**
   * TSL function for creating a varying property node.
   *
   * @tsl
   * @function
   * @param {string} type - The type of the node.
   * @param {?string} [name=null] - The name of the varying in the shader.
   * @returns {PropertyNode}
   */
  const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );

  /**
   * TSL object that represents the shader variable `DiffuseColor`.
   *
   * @tsl
   * @type {PropertyNode<vec4>}
   */
  const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );

  /**
   * TSL object that represents the shader variable `EmissiveColor`.
   *
   * @tsl
   * @type {PropertyNode<vec3>}
   */
  const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );

  /**
   * TSL object that represents the shader variable `Roughness`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );

  /**
   * TSL object that represents the shader variable `Metalness`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );

  /**
   * TSL object that represents the shader variable `Clearcoat`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );

  /**
   * TSL object that represents the shader variable `ClearcoatRoughness`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );

  /**
   * TSL object that represents the shader variable `Sheen`.
   *
   * @tsl
   * @type {PropertyNode<vec3>}
   */
  const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );

  /**
   * TSL object that represents the shader variable `SheenRoughness`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );

  /**
   * TSL object that represents the shader variable `Iridescence`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );

  /**
   * TSL object that represents the shader variable `IridescenceIOR`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );

  /**
   * TSL object that represents the shader variable `IridescenceThickness`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );

  /**
   * TSL object that represents the shader variable `AlphaT`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );

  /**
   * TSL object that represents the shader variable `Anisotropy`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );

  /**
   * TSL object that represents the shader variable `AnisotropyT`.
   *
   * @tsl
   * @type {PropertyNode<vec3>}
   */
  const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );

  /**
   * TSL object that represents the shader variable `AnisotropyB`.
   *
   * @tsl
   * @type {PropertyNode<vec3>}
   */
  const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );

  /**
   * TSL object that represents the shader variable `SpecularColor`.
   *
   * @tsl
   * @type {PropertyNode<color>}
   */
  const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );

  /**
   * TSL object that represents the shader variable `SpecularF90`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );

  /**
   * TSL object that represents the shader variable `Shininess`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );

  /**
   * TSL object that represents the shader variable `Output`.
   *
   * @tsl
   * @type {PropertyNode<vec4>}
   */
  const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );

  /**
   * TSL object that represents the shader variable `dashSize`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );

  /**
   * TSL object that represents the shader variable `gapSize`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );

  /**
   * TSL object that represents the shader variable `IOR`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );

  /**
   * TSL object that represents the shader variable `Transmission`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );

  /**
   * TSL object that represents the shader variable `Thickness`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );

  /**
   * TSL object that represents the shader variable `AttenuationDistance`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );

  /**
   * TSL object that represents the shader variable `AttenuationColor`.
   *
   * @tsl
   * @type {PropertyNode<color>}
   */
  const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );

  /**
   * TSL object that represents the shader variable `Dispersion`.
   *
   * @tsl
   * @type {PropertyNode<float>}
   */
  const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );

  /**
   * This node can be used to group single instances of {@link UniformNode}
   * and manage them as a uniform buffer.
   *
   * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`
   * will be used when defining the {@link UniformNode#groupNode} property.
   *
   * - `objectGroup`: Uniform buffer per object.
   * - `renderGroup`: Shared uniform buffer, updated once per render call.
   * - `frameGroup`: Shared uniform buffer, updated once per frame.
   *
   * @augments Node
   */
  class UniformGroupNode extends Node {

  	static get type() {

  		return 'UniformGroupNode';

  	}

  	/**
  	 * Constructs a new uniform group node.
  	 *
  	 * @param {string} name - The name of the uniform group node.
  	 * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
  	 * @param {number} [order=1] - Influences the internal sorting.
  	 */
  	constructor( name, shared = false, order = 1 ) {

  		super( 'string' );

  		/**
  		 * The name of the uniform group node.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * Whether this uniform group node is shared or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.shared = shared;

  		/**
  		 * Influences the internal sorting.
  		 * TODO: Add details when this property should be changed.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.order = order;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isUniformGroup = true;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.name = this.name;
  		data.version = this.version;
  		data.shared = this.shared;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.name = data.name;
  		this.version = data.version;
  		this.shared = data.shared;

  	}

  }

  /**
   * TSL function for creating a uniform group node with the given name.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the uniform group node.
   * @returns {UniformGroupNode}
   */
  const uniformGroup = ( name ) => new UniformGroupNode( name );

  /**
   * TSL function for creating a shared uniform group node with the given name and order.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the uniform group node.
   * @param {number} [order=0] - Influences the internal sorting.
   * @returns {UniformGroupNode}
   */
  const sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );

  /**
   * TSL object that represents a shared uniform group node which is updated once per frame.
   *
   * @tsl
   * @type {UniformGroupNode}
   */
  const frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );

  /**
   * TSL object that represents a shared uniform group node which is updated once per render.
   *
   * @tsl
   * @type {UniformGroupNode}
   */
  const renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );

  /**
   * TSL object that represents a uniform group node which is updated once per object.
   *
   * @tsl
   * @type {UniformGroupNode}
   */
  const objectGroup = /*@__PURE__*/ uniformGroup( 'object' );

  /**
   * Class for representing a uniform.
   *
   * @augments InputNode
   */
  class UniformNode extends InputNode {

  	static get type() {

  		return 'UniformNode';

  	}

  	/**
  	 * Constructs a new uniform node.
  	 *
  	 * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
  	 * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
  	 */
  	constructor( value, nodeType = null ) {

  		super( value, nodeType );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isUniformNode = true;

  		/**
  		 * The name or label of the uniform.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.name = '';

  		/**
  		 * The uniform group of this uniform. By default, uniforms are
  		 * managed per object but they might belong to a shared group
  		 * which is updated per frame or render call.
  		 *
  		 * @type {UniformGroupNode}
  		 */
  		this.groupNode = objectGroup;

  	}

  	/**
  	 * Sets the {@link UniformNode#name} property.
  	 *
  	 * @param {string} name - The name of the uniform.
  	 * @return {UniformNode} A reference to this node.
  	 */
  	label( name ) {

  		this.name = name;

  		return this;

  	}

  	/**
  	 * Sets the {@link UniformNode#groupNode} property.
  	 *
  	 * @param {UniformGroupNode} group - The uniform group.
  	 * @return {UniformNode} A reference to this node.
  	 */
  	setGroup( group ) {

  		this.groupNode = group;

  		return this;

  	}

  	/**
  	 * Returns the {@link UniformNode#groupNode}.
  	 *
  	 * @return {UniformGroupNode} The uniform group.
  	 */
  	getGroup() {

  		return this.groupNode;

  	}

  	/**
  	 * By default, this method returns the result of {@link Node#getHash} but derived
  	 * classes might overwrite this method with a different implementation.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The uniform hash.
  	 */
  	getUniformHash( builder ) {

  		return this.getHash( builder );

  	}

  	onUpdate( callback, updateType ) {

  		const self = this.getSelf();

  		callback = callback.bind( self );

  		return super.onUpdate( ( frame ) => {

  			const value = callback( frame, self );

  			if ( value !== undefined ) {

  				this.value = value;

  			}

  	 	}, updateType );

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );

  		const hash = this.getUniformHash( builder );

  		let sharedNode = builder.getNodeFromHash( hash );

  		if ( sharedNode === undefined ) {

  			builder.setHashNode( this, hash );

  			sharedNode = this;

  		}

  		const sharedNodeType = sharedNode.getInputType( builder );

  		const nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );
  		const propertyName = builder.getPropertyName( nodeUniform );

  		if ( builder.context.label !== undefined ) delete builder.context.label;

  		return builder.format( propertyName, type, output );

  	}

  }

  /**
   * TSL function for creating a uniform node.
   *
   * @tsl
   * @function
   * @param {any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {string} [arg2] - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   * @returns {UniformNode}
   */
  const uniform = ( arg1, arg2 ) => {

  	const nodeType = getConstNodeType( arg2 || arg1 );

  	// @TODO: get ConstNode from .traverse() in the future
  	const value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;

  	return nodeObject( new UniformNode( value, nodeType ) );

  };

  /**
   * ArrayNode represents a collection of nodes, typically created using the {@link array} function.
   * ```js
   * const colors = array( [
   * 	vec3( 1, 0, 0 ),
   * 	vec3( 0, 1, 0 ),
   * 	vec3( 0, 0, 1 )
   * ] );
   *
   * const redColor = tintColors.element( 0 );
   *
   * @augments TempNode
   */
  class ArrayNode extends TempNode {

  	static get type() {

  		return 'ArrayNode';

  	}

  	/**
  	 * Constructs a new array node.
  	 *
  	 * @param {?string} nodeType - The data type of the elements.
  	 * @param {number} count - Size of the array.
  	 * @param {?Array<Node>} [values=null] - Array default values.
  	 */
  	constructor( nodeType, count, values = null ) {

  		super( nodeType );

  		/**
  		 * Array size.
  		 *
  		 * @type {number}
  		 */
  		this.count = count;

  		/**
  		 * Array default values.
  		 *
  		 * @type {?Array<Node>}
  		 */
  		this.values = values;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isArrayNode = true;

  	}

  	/**
  	 * Returns the node's type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The type of the node.
  	 */
  	getNodeType( builder ) {

  		if ( this.nodeType === null ) {

  			this.nodeType = this.values[ 0 ].getNodeType( builder );

  		}

  		return this.nodeType;

  	}

  	/**
  	 * Returns the node's type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The type of the node.
  	 */
  	getElementType( builder ) {

  		return this.getNodeType( builder );

  	}

  	/**
  	 * This method builds the output node and returns the resulting array as a shader string.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The generated shader string.
  	 */
  	generate( builder ) {

  		const type = this.getNodeType( builder );

  		return builder.generateArray( type, this.count, this.values );

  	}

  }

  /**
   * TSL function for creating an array node.
   *
   * @tsl
   * @function
   * @param {string|Array<Node>} nodeTypeOrValues - A string representing the element type (e.g., 'vec3')
   * or an array containing the default values (e.g., [ vec3() ]).
   * @param {?number} [count] - Size of the array.
   * @returns {ArrayNode}
   */
  const array$1 = ( ...params ) => {

  	let node;

  	if ( params.length === 1 ) {

  		const values = params[ 0 ];

  		node = new ArrayNode( null, values.length, values );

  	} else {

  		const nodeType = params[ 0 ];
  		const count = params[ 1 ];

  		node = new ArrayNode( nodeType, count );

  	}

  	return nodeObject( node );

  };

  addMethodChaining( 'toArray', ( node, count ) => array$1( Array( count ).fill( node ) ) );

  /**
   * These node represents an assign operation. Meaning a node is assigned
   * to another node.
   *
   * @augments TempNode
   */
  class AssignNode extends TempNode {

  	static get type() {

  		return 'AssignNode';

  	}

  	/**
  	 * Constructs a new assign node.
  	 *
  	 * @param {Node} targetNode - The target node.
  	 * @param {Node} sourceNode - The source type.
  	 */
  	constructor( targetNode, sourceNode ) {

  		super();

  		/**
  		 * The target node.
  		 *
  		 * @type {Node}
  		 */
  		this.targetNode = targetNode;

  		/**
  		 * The source node.
  		 *
  		 * @type {Node}
  		 */
  		this.sourceNode = sourceNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isAssignNode = true;

  	}

  	/**
  	 * Whether this node is used more than once in context of other nodes. This method
  	 * is overwritten since it always returns `false` (assigns are unique).
  	 *
  	 * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
  	 */
  	hasDependencies() {

  		return false;

  	}

  	getNodeType( builder, output ) {

  		return output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';

  	}

  	/**
  	 * Whether a split is required when assigning source to target. This can happen when the component length of
  	 * target and source data type does not match.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {boolean} Whether a split is required when assigning source to target.
  	 */
  	needsSplitAssign( builder ) {

  		const { targetNode } = this;

  		if ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {

  			const targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );
  			const assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;

  			return assignDifferentVector;

  		}

  		return false;

  	}

  	setup( builder ) {

  		const { targetNode, sourceNode } = this;

  		const properties = builder.getNodeProperties( this );
  		properties.sourceNode = sourceNode;
  		properties.targetNode = targetNode.context( { assign: true } );

  	}

  	generate( builder, output ) {

  		const { targetNode, sourceNode } = builder.getNodeProperties( this );

  		const needsSplitAssign = this.needsSplitAssign( builder );

  		const targetType = targetNode.getNodeType( builder );

  		const target = targetNode.build( builder );
  		const source = sourceNode.build( builder, targetType );

  		const sourceType = sourceNode.getNodeType( builder );

  		const nodeData = builder.getDataFromNode( this );

  		//

  		let snippet;

  		if ( nodeData.initialized === true ) {

  			if ( output !== 'void' ) {

  				snippet = target;

  			}

  		} else if ( needsSplitAssign ) {

  			const sourceVar = builder.getVarFromNode( this, null, targetType );
  			const sourceProperty = builder.getPropertyName( sourceVar );

  			builder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );

  			const splitNode = targetNode.node;
  			const splitTargetNode = splitNode.node.context( { assign: true } );

  			const targetRoot = splitTargetNode.build( builder );

  			for ( let i = 0; i < splitNode.components.length; i ++ ) {

  				const component = splitNode.components[ i ];

  				builder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );

  			}

  			if ( output !== 'void' ) {

  				snippet = target;

  			}

  		} else {

  			snippet = `${ target } = ${ source }`;

  			if ( output === 'void' || sourceType === 'void' ) {

  				builder.addLineFlowCode( snippet, this );

  				if ( output !== 'void' ) {

  					snippet = target;

  				}

  			}

  		}

  		nodeData.initialized = true;

  		return builder.format( snippet, targetType, output );

  	}

  }

  /**
   * TSL function for creating an assign node.
   *
   * @tsl
   * @function
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   * @returns {AssignNode}
   */
  const assign = /*@__PURE__*/ nodeProxy( AssignNode ).setParameterLength( 2 );

  addMethodChaining( 'assign', assign );

  /**
   * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted
   * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate
   * this logic.
   *
   * @augments TempNode
   */
  class FunctionCallNode extends TempNode {

  	static get type() {

  		return 'FunctionCallNode';

  	}

  	/**
  	 * Constructs a new function call node.
  	 *
  	 * @param {?FunctionNode} functionNode - The function node.
  	 * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
  	 */
  	constructor( functionNode = null, parameters = {} ) {

  		super();

  		/**
  		 * The function node.
  		 *
  		 * @type {?FunctionNode}
  		 * @default null
  		 */
  		this.functionNode = functionNode;

  		/**
  		 * The parameters of the function call.
  		 *
  		 * @type {Object<string, Node>}
  		 * @default {}
  		 */
  		this.parameters = parameters;

  	}

  	/**
  	 * Sets the parameters of the function call node.
  	 *
  	 * @param {Object<string, Node>} parameters - The parameters to set.
  	 * @return {FunctionCallNode} A reference to this node.
  	 */
  	setParameters( parameters ) {

  		this.parameters = parameters;

  		return this;

  	}

  	/**
  	 * Returns the parameters of the function call node.
  	 *
  	 * @return {Object<string, Node>} The parameters of this node.
  	 */
  	getParameters() {

  		return this.parameters;

  	}

  	getNodeType( builder ) {

  		return this.functionNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const params = [];

  		const functionNode = this.functionNode;

  		const inputs = functionNode.getInputs( builder );
  		const parameters = this.parameters;

  		const generateInput = ( node, inputNode ) => {

  			const type = inputNode.type;
  			const pointer = type === 'pointer';

  			let output;

  			if ( pointer ) output = '&' + node.build( builder );
  			else output = node.build( builder, type );

  			return output;

  		};

  		if ( Array.isArray( parameters ) ) {

  			if ( parameters.length > inputs.length ) {

  				console.error( 'THREE.TSL: The number of provided parameters exceeds the expected number of inputs in \'Fn()\'.' );

  				parameters.length = inputs.length;

  			} else if ( parameters.length < inputs.length ) {

  				console.error( 'THREE.TSL: The number of provided parameters is less than the expected number of inputs in \'Fn()\'.' );

  				while ( parameters.length < inputs.length ) {

  					parameters.push( float( 0 ) );

  				}

  			}

  			for ( let i = 0; i < parameters.length; i ++ ) {

  				params.push( generateInput( parameters[ i ], inputs[ i ] ) );

  			}

  		} else {

  			for ( const inputNode of inputs ) {

  				const node = parameters[ inputNode.name ];

  				if ( node !== undefined ) {

  					params.push( generateInput( node, inputNode ) );

  				} else {

  					console.error( `THREE.TSL: Input '${ inputNode.name }' not found in \'Fn()\'.` );

  					params.push( generateInput( float( 0 ), inputNode ) );

  				}

  			}

  		}

  		const functionName = functionNode.build( builder, 'property' );

  		return `${ functionName }( ${ params.join( ', ' ) } )`;

  	}

  }

  const call = ( func, ...params ) => {

  	params = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );

  	return nodeObject( new FunctionCallNode( nodeObject( func ), params ) );

  };

  addMethodChaining( 'call', call );

  const _vectorOperators = {
  	'==': 'equal',
  	'!=': 'notEqual',
  	'<': 'lessThan',
  	'>': 'greaterThan',
  	'<=': 'lessThanEqual',
  	'>=': 'greaterThanEqual',
  	'%': 'mod'
  };

  /**
   * This node represents basic mathematical and logical operations like addition,
   * subtraction or comparisons (e.g. `equal()`).
   *
   * @augments TempNode
   */
  class OperatorNode extends TempNode {

  	static get type() {

  		return 'OperatorNode';

  	}

  	/**
  	 * Constructs a new operator node.
  	 *
  	 * @param {string} op - The operator.
  	 * @param {Node} aNode - The first input.
  	 * @param {Node} bNode - The second input.
  	 * @param {...Node} params - Additional input parameters.
  	 */
  	constructor( op, aNode, bNode, ...params ) {

  		super();

  		if ( params.length > 0 ) {

  			let finalOp = new OperatorNode( op, aNode, bNode );

  			for ( let i = 0; i < params.length - 1; i ++ ) {

  				finalOp = new OperatorNode( op, finalOp, params[ i ] );

  			}

  			aNode = finalOp;
  			bNode = params[ params.length - 1 ];

  		}

  		/**
  		 * The operator.
  		 *
  		 * @type {string}
  		 */
  		this.op = op;

  		/**
  		 * The first input.
  		 *
  		 * @type {Node}
  		 */
  		this.aNode = aNode;

  		/**
  		 * The second input.
  		 *
  		 * @type {Node}
  		 */
  		this.bNode = bNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isOperatorNode = true;

  	}

  	/**
  	 * Returns the operator method name.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string} output - The output type.
  	 * @returns {string} The operator method name.
  	 */
  	getOperatorMethod( builder, output ) {

  		return builder.getMethod( _vectorOperators[ this.op ], output );

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from the operator
  	 * and the input node types.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		const op = this.op;

  		const aNode = this.aNode;
  		const bNode = this.bNode;

  		const typeA = aNode.getNodeType( builder );
  		const typeB = bNode ? bNode.getNodeType( builder ) : null;

  		if ( typeA === 'void' || typeB === 'void' ) {

  			return 'void';

  		} else if ( op === '%' ) {

  			return typeA;

  		} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {

  			return builder.getIntegerType( typeA );

  		} else if ( op === '!' || op === '&&' || op === '||' || op === '^^' ) {

  			return 'bool';

  		} else if ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {

  			const typeLength = Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );

  			return typeLength > 1 ? `bvec${ typeLength }` : 'bool';

  		} else {

  			// Handle matrix operations

  			if ( builder.isMatrix( typeA ) ) {

  				if ( typeB === 'float' ) {

  					return typeA; // matrix * scalar = matrix

  				} else if ( builder.isVector( typeB ) ) {

  					return builder.getVectorFromMatrix( typeA ); // matrix * vector

  				} else if ( builder.isMatrix( typeB ) ) {

  					return typeA; // matrix * matrix

  				}

  			} else if ( builder.isMatrix( typeB ) ) {

  				if ( typeA === 'float' ) {

  					return typeB; // scalar * matrix = matrix

  				} else if ( builder.isVector( typeA ) ) {

  					return builder.getVectorFromMatrix( typeB ); // vector * matrix

  				}

  			}

  			// Handle non-matrix cases

  			if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {

  				// anytype x anytype: use the greater length vector

  				return typeB;

  			}

  			return typeA;

  		}

  	}

  	generate( builder, output ) {

  		const op = this.op;

  		const { aNode, bNode } = this;

  		const type = this.getNodeType( builder );

  		let typeA = null;
  		let typeB = null;

  		if ( type !== 'void' ) {

  			typeA = aNode.getNodeType( builder );
  			typeB = bNode ? bNode.getNodeType( builder ) : null;

  			if ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' || op === '!=' ) {

  				if ( builder.isVector( typeA ) ) {

  					typeB = typeA;

  				} else if ( builder.isVector( typeB ) ) {

  					typeA = typeB;

  				} else if ( typeA !== typeB ) {

  					typeA = typeB = 'float';

  				}

  			} else if ( op === '>>' || op === '<<' ) {

  				typeA = type;
  				typeB = builder.changeComponentType( typeB, 'uint' );

  			} else if ( op === '%' ) {

  				typeA = type;
  				typeB = builder.isInteger( typeA ) && builder.isInteger( typeB ) ? typeB : typeA;

  			} else if ( builder.isMatrix( typeA ) ) {

  				if ( typeB === 'float' ) {

  					// Keep matrix type for typeA, but ensure typeB stays float

  					typeB = 'float';

  				} else if ( builder.isVector( typeB ) ) {

  					// matrix x vector
  					typeB = builder.getVectorFromMatrix( typeA );

  				} else if ( builder.isMatrix( typeB ) ) ; else {

  					typeA = typeB = type;

  				}

  			} else if ( builder.isMatrix( typeB ) ) {

  				if ( typeA === 'float' ) {

  					// Keep matrix type for typeB, but ensure typeA stays float

  					typeA = 'float';

  				} else if ( builder.isVector( typeA ) ) {

  					// vector x matrix

  					typeA = builder.getVectorFromMatrix( typeB );

  				} else {

  					typeA = typeB = type;

  				}

  			} else {

  				// anytype x anytype

  				typeA = typeB = type;

  			}

  		} else {

  			typeA = typeB = type;

  		}

  		const a = aNode.build( builder, typeA );
  		const b = bNode ? bNode.build( builder, typeB ) : null;

  		const fnOpSnippet = builder.getFunctionOperator( op );

  		if ( output !== 'void' ) {

  			const isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;

  			if ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {

  				if ( isGLSL ) {

  					if ( builder.isVector( typeA ) ) {

  						return builder.format( `${ this.getOperatorMethod( builder, output ) }( ${ a }, ${ b } )`, type, output );

  					} else {

  						return builder.format( `( ${ a } ${ op } ${ b } )`, type, output );

  					}

  				} else {

  					// WGSL

  					return builder.format( `( ${ a } ${ op } ${ b } )`, type, output );

  				}

  			} else if ( op === '%' ) {

  				if ( builder.isInteger( typeB ) ) {

  					return builder.format( `( ${ a } % ${ b } )`, type, output );

  				} else {

  					return builder.format( `${ this.getOperatorMethod( builder, type ) }( ${ a }, ${ b } )`, type, output );

  				}

  			} else if ( op === '!' || op === '~' ) {

  				return builder.format( `(${op}${a})`, typeA, output );

  			} else if ( fnOpSnippet ) {

  				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

  			} else {

  				// Handle matrix operations

  				if ( builder.isMatrix( typeA ) && typeB === 'float' ) {

  					return builder.format( `( ${ b } ${ op } ${ a } )`, type, output );

  				} else if ( typeA === 'float' && builder.isMatrix( typeB ) ) {

  					return builder.format( `${ a } ${ op } ${ b }`, type, output );

  				} else {

  					let snippet = `( ${ a } ${ op } ${ b } )`;

  					if ( ! isGLSL && type === 'bool' && builder.isVector( typeA ) && builder.isVector( typeB ) ) {

  						snippet = `all${ snippet }`;

  					}

  					return builder.format( snippet, type, output );

  				}

  			}

  		} else if ( typeA !== 'void' ) {

  			if ( fnOpSnippet ) {

  				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

  			} else {

  				if ( builder.isMatrix( typeA ) && typeB === 'float' ) {

  					return builder.format( `${ b } ${ op } ${ a }`, type, output );

  				} else {

  					return builder.format( `${ a } ${ op } ${ b }`, type, output );

  				}

  			}

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.op = this.op;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.op = data.op;

  	}

  }

  /**
   * Returns the addition of two or more value.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  const add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' ).setParameterLength( 2, Infinity ).setName( 'add' );

  /**
   * Returns the subtraction of two or more value.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  const sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' ).setParameterLength( 2, Infinity ).setName( 'sub' );

  /**
   * Returns the multiplication of two or more value.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  const mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' ).setParameterLength( 2, Infinity ).setName( 'mul' );

  /**
   * Returns the division of two or more value.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  const div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' ).setParameterLength( 2, Infinity ).setName( 'div' );

  /**
   * Computes the remainder of dividing the first node by the second one.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const mod = /*@__PURE__*/ nodeProxy( OperatorNode, '%' ).setParameterLength( 2 ).setName( 'mod' );

  /**
   * Checks if two nodes are equal.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' ).setParameterLength( 2 ).setName( 'equal' );

  /**
   * Checks if two nodes are not equal.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' ).setParameterLength( 2 ).setName( 'notEqual' );

  /**
   * Checks if the first node is less than the second.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' ).setParameterLength( 2 ).setName( 'lessThan' );

  /**
   * Checks if the first node is greater than the second.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' ).setParameterLength( 2 ).setName( 'greaterThan' );

  /**
   * Checks if the first node is less than or equal to the second.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' ).setParameterLength( 2 ).setName( 'lessThanEqual' );

  /**
   * Checks if the first node is greater than or equal to the second.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' ).setParameterLength( 2 ).setName( 'greaterThanEqual' );

  /**
   * Performs a logical AND operation on multiple nodes.
   *
   * @tsl
   * @function
   * @param {...Node} nodes - The input nodes to be combined using AND.
   * @returns {OperatorNode}
   */
  const and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' ).setParameterLength( 2, Infinity ).setName( 'and' );

  /**
   * Performs a logical OR operation on multiple nodes.
   *
   * @tsl
   * @function
   * @param {...Node} nodes - The input nodes to be combined using OR.
   * @returns {OperatorNode}
   */
  const or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' ).setParameterLength( 2, Infinity ).setName( 'or' );

  /**
   * Performs logical NOT on a node.
   *
   * @tsl
   * @function
   * @param {Node} value - The value.
   * @returns {OperatorNode}
   */
  const not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' ).setParameterLength( 1 ).setName( 'not' );

  /**
   * Performs logical XOR on two nodes.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' ).setParameterLength( 2 ).setName( 'xor' );

  /**
   * Performs bitwise AND on two nodes.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' ).setParameterLength( 2 ).setName( 'bitAnd' );

  /**
   * Performs bitwise NOT on a node.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' ).setParameterLength( 2 ).setName( 'bitNot' );

  /**
   * Performs bitwise OR on two nodes.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' ).setParameterLength( 2 ).setName( 'bitOr' );

  /**
   * Performs bitwise XOR on two nodes.
   *
   * @tsl
   * @function
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' ).setParameterLength( 2 ).setName( 'bitXor' );

  /**
   * Shifts a node to the left.
   *
   * @tsl
   * @function
   * @param {Node} a - The node to shift.
   * @param {Node} b - The value to shift.
   * @returns {OperatorNode}
   */
  const shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' ).setParameterLength( 2 ).setName( 'shiftLeft' );

  /**
   * Shifts a node to the right.
   *
   * @tsl
   * @function
   * @param {Node} a - The node to shift.
   * @param {Node} b - The value to shift.
   * @returns {OperatorNode}
   */
  const shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' ).setParameterLength( 2 ).setName( 'shiftRight' );

  /**
   * Increments a node by 1.
   *
   * @tsl
   * @function
   * @param {Node} a - The node to increment.
   * @returns {OperatorNode}
   */
  const incrementBefore = Fn( ( [ a ] ) => {

  	a.addAssign( 1 );
  	return a;

  } );

  /**
   * Decrements a node by 1.
   *
   * @tsl
   * @function
   * @param {Node} a - The node to decrement.
   * @returns {OperatorNode}
   */
  const decrementBefore = Fn( ( [ a ] ) => {

  	a.subAssign( 1 );
  	return a;

  } );

  /**
   * Increments a node by 1 and returns the previous value.
   *
   * @tsl
   * @function
   * @param {Node} a - The node to increment.
   * @returns {OperatorNode}
   */
  const increment = /*@__PURE__*/ Fn( ( [ a ] ) => {

  	const temp = int( a ).toConst();
  	a.addAssign( 1 );
  	return temp;

  } );

  /**
   * Decrements a node by 1 and returns the previous value.
   *
   * @tsl
   * @function
   * @param {Node} a - The node to decrement.
   * @returns {OperatorNode}
   */
  const decrement = /*@__PURE__*/ Fn( ( [ a ] ) => {

  	const temp = int( a ).toConst();
  	a.subAssign( 1 );
  	return temp;

  } );

  addMethodChaining( 'add', add );
  addMethodChaining( 'sub', sub );
  addMethodChaining( 'mul', mul );
  addMethodChaining( 'div', div );
  addMethodChaining( 'mod', mod );
  addMethodChaining( 'equal', equal );
  addMethodChaining( 'notEqual', notEqual );
  addMethodChaining( 'lessThan', lessThan );
  addMethodChaining( 'greaterThan', greaterThan );
  addMethodChaining( 'lessThanEqual', lessThanEqual );
  addMethodChaining( 'greaterThanEqual', greaterThanEqual );
  addMethodChaining( 'and', and );
  addMethodChaining( 'or', or );
  addMethodChaining( 'not', not );
  addMethodChaining( 'xor', xor );
  addMethodChaining( 'bitAnd', bitAnd );
  addMethodChaining( 'bitNot', bitNot );
  addMethodChaining( 'bitOr', bitOr );
  addMethodChaining( 'bitXor', bitXor );
  addMethodChaining( 'shiftLeft', shiftLeft );
  addMethodChaining( 'shiftRight', shiftRight );

  addMethodChaining( 'incrementBefore', incrementBefore );
  addMethodChaining( 'decrementBefore', decrementBefore );
  addMethodChaining( 'increment', increment );
  addMethodChaining( 'decrement', decrement );

  /**
   * @tsl
   * @function
   * @deprecated since r175. Use {@link mod} instead.
   *
   * @param {Node} a - The first input.
   * @param {Node} b - The second input.
   * @returns {OperatorNode}
   */
  const modInt = ( a, b ) => { // @deprecated, r175

  	console.warn( 'THREE.TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.' );
  	return mod( int( a ), int( b ) );

  };

  addMethodChaining( 'modInt', modInt );

  /**
   * This node represents a variety of mathematical methods available in shaders.
   * They are divided into three categories:
   *
   * - Methods with one input like `sin`, `cos` or `normalize`.
   * - Methods with two inputs like `dot`, `cross` or `pow`.
   * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.
   *
   * @augments TempNode
   */
  class MathNode extends TempNode {

  	static get type() {

  		return 'MathNode';

  	}

  	/**
  	 * Constructs a new math node.
  	 *
  	 * @param {string} method - The method name.
  	 * @param {Node} aNode - The first input.
  	 * @param {?Node} [bNode=null] - The second input.
  	 * @param {?Node} [cNode=null] - The third input.
  	 */
  	constructor( method, aNode, bNode = null, cNode = null ) {

  		super();

  		// Allow the max() and min() functions to take an arbitrary number of arguments.

  		if ( ( method === MathNode.MAX || method === MathNode.MIN ) && arguments.length > 3 ) {

  			let finalOp = new MathNode( method, aNode, bNode );

  			for ( let i = 2; i < arguments.length - 1; i ++ ) {

  				finalOp = new MathNode( method, finalOp, arguments[ i ] );

  			}

  			aNode = finalOp;
  			bNode = arguments[ arguments.length - 1 ];
  			cNode = null;

  		}

  		/**
  		 * The method name.
  		 *
  		 * @type {string}
  		 */
  		this.method = method;

  		/**
  		 * The first input.
  		 *
  		 * @type {Node}
  		 */
  		this.aNode = aNode;

  		/**
  		 * The second input.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.bNode = bNode;

  		/**
  		 * The third input.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.cNode = cNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMathNode = true;

  	}

  	/**
  	 * The input type is inferred from the node types of the input nodes.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( builder ) {

  		const aType = this.aNode.getNodeType( builder );
  		const bType = this.bNode ? this.bNode.getNodeType( builder ) : null;
  		const cType = this.cNode ? this.cNode.getNodeType( builder ) : null;

  		const aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );
  		const bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );
  		const cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );

  		if ( aLen > bLen && aLen > cLen ) {

  			return aType;

  		} else if ( bLen > cLen ) {

  			return bType;

  		} else if ( cLen > aLen ) {

  			return cType;

  		}

  		return aType;

  	}

  	/**
  	 * The selected method as well as the input type determine the node type of this node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		const method = this.method;

  		if ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {

  			return 'float';

  		} else if ( method === MathNode.CROSS ) {

  			return 'vec3';

  		} else if ( method === MathNode.ALL || method === MathNode.ANY ) {

  			return 'bool';

  		} else if ( method === MathNode.EQUALS ) {

  			return builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );

  		} else {

  			return this.getInputType( builder );

  		}

  	}

  	setup( builder ) {

  		const { aNode, bNode, method } = this;

  		let outputNode = null;

  		if ( method === MathNode.ONE_MINUS ) {

  			outputNode = sub( 1.0, aNode );

  		} else if ( method === MathNode.RECIPROCAL ) {

  			outputNode = div( 1.0, aNode );

  		} else if ( method === MathNode.DIFFERENCE ) {

  			outputNode = abs( sub( aNode, bNode ) );

  		} else if ( method === MathNode.TRANSFORM_DIRECTION ) {

  			// dir can be either a direction vector or a normal vector
  			// upper-left 3x3 of matrix is assumed to be orthogonal

  			let tA = aNode;
  			let tB = bNode;

  			if ( builder.isMatrix( tA.getNodeType( builder ) ) ) {

  				tB = vec4( vec3( tB ), 0.0 );

  			} else {

  				tA = vec4( vec3( tA ), 0.0 );

  			}

  			const mulNode = mul( tA, tB ).xyz;

  			outputNode = normalize( mulNode );

  		}

  		if ( outputNode !== null ) {

  			return outputNode;

  		} else {

  			return super.setup( builder );

  		}

  	}

  	generate( builder, output ) {

  		const properties = builder.getNodeProperties( this );

  		if ( properties.outputNode ) {

  			return super.generate( builder, output );

  		}

  		let method = this.method;

  		const type = this.getNodeType( builder );
  		const inputType = this.getInputType( builder );

  		const a = this.aNode;
  		const b = this.bNode;
  		const c = this.cNode;

  		const coordinateSystem = builder.renderer.coordinateSystem;

  		if ( method === MathNode.NEGATE ) {

  			return builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );

  		} else {

  			const params = [];

  			if ( method === MathNode.CROSS ) {

  				params.push(
  					a.build( builder, type ),
  					b.build( builder, type )
  				);

  			} else if ( coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP ) {

  				params.push(
  					a.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),
  					b.build( builder, inputType )
  				);

  			} else if ( coordinateSystem === WebGLCoordinateSystem && ( method === MathNode.MIN || method === MathNode.MAX ) ) {

  				params.push(
  					a.build( builder, inputType ),
  					b.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )
  				);

  			} else if ( method === MathNode.REFRACT ) {

  				params.push(
  					a.build( builder, inputType ),
  					b.build( builder, inputType ),
  					c.build( builder, 'float' )
  				);

  			} else if ( method === MathNode.MIX ) {

  				params.push(
  					a.build( builder, inputType ),
  					b.build( builder, inputType ),
  					c.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )
  				);

  			} else {

  				if ( coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null ) {

  					method = 'atan2';

  				}

  				if ( builder.shaderStage !== 'fragment' && ( method === MathNode.DFDX || method === MathNode.DFDY ) ) {

  					console.warn( `THREE.TSL: '${ method }' is not supported in the ${ builder.shaderStage } stage.` );

  					method = '/*' + method + '*/';

  				}

  				params.push( a.build( builder, inputType ) );
  				if ( b !== null ) params.push( b.build( builder, inputType ) );
  				if ( c !== null ) params.push( c.build( builder, inputType ) );

  			}

  			return builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.method = this.method;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.method = data.method;

  	}

  }

  // 1 input

  MathNode.ALL = 'all';
  MathNode.ANY = 'any';

  MathNode.RADIANS = 'radians';
  MathNode.DEGREES = 'degrees';
  MathNode.EXP = 'exp';
  MathNode.EXP2 = 'exp2';
  MathNode.LOG = 'log';
  MathNode.LOG2 = 'log2';
  MathNode.SQRT = 'sqrt';
  MathNode.INVERSE_SQRT = 'inversesqrt';
  MathNode.FLOOR = 'floor';
  MathNode.CEIL = 'ceil';
  MathNode.NORMALIZE = 'normalize';
  MathNode.FRACT = 'fract';
  MathNode.SIN = 'sin';
  MathNode.COS = 'cos';
  MathNode.TAN = 'tan';
  MathNode.ASIN = 'asin';
  MathNode.ACOS = 'acos';
  MathNode.ATAN = 'atan';
  MathNode.ABS = 'abs';
  MathNode.SIGN = 'sign';
  MathNode.LENGTH = 'length';
  MathNode.NEGATE = 'negate';
  MathNode.ONE_MINUS = 'oneMinus';
  MathNode.DFDX = 'dFdx';
  MathNode.DFDY = 'dFdy';
  MathNode.ROUND = 'round';
  MathNode.RECIPROCAL = 'reciprocal';
  MathNode.TRUNC = 'trunc';
  MathNode.FWIDTH = 'fwidth';
  MathNode.TRANSPOSE = 'transpose';

  // 2 inputs

  MathNode.BITCAST = 'bitcast';
  MathNode.EQUALS = 'equals';
  MathNode.MIN = 'min';
  MathNode.MAX = 'max';
  MathNode.STEP = 'step';
  MathNode.REFLECT = 'reflect';
  MathNode.DISTANCE = 'distance';
  MathNode.DIFFERENCE = 'difference';
  MathNode.DOT = 'dot';
  MathNode.CROSS = 'cross';
  MathNode.POW = 'pow';
  MathNode.TRANSFORM_DIRECTION = 'transformDirection';

  // 3 inputs

  MathNode.MIX = 'mix';
  MathNode.CLAMP = 'clamp';
  MathNode.REFRACT = 'refract';
  MathNode.SMOOTHSTEP = 'smoothstep';
  MathNode.FACEFORWARD = 'faceforward';

  // 1 inputs

  /**
   * A small value used to handle floating-point precision errors.
   *
   * @tsl
   * @type {Node<float>}
   */
  const EPSILON = /*@__PURE__*/ float( 1e-6 );

  /**
   * Represents PI.
   *
   * @tsl
   * @type {Node<float>}
   */
  const PI = /*@__PURE__*/ float( Math.PI );

  /**
   * Returns `true` if all components of `x` are `true`.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node<bool>}
   */
  const all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL ).setParameterLength( 1 );

  /**
   * Returns `true` if any components of `x` are `true`.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node<bool>}
   */
  const any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY ).setParameterLength( 1 );

  /**
   * Converts a quantity in degrees to radians.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The input in degrees.
   * @returns {Node}
   */
  const radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS ).setParameterLength( 1 );

  /**
   * Convert a quantity in radians to degrees.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The input in radians.
   * @returns {Node}
   */
  const degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES ).setParameterLength( 1 );

  /**
   * Returns the natural exponentiation of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP ).setParameterLength( 1 );

  /**
   * Returns 2 raised to the power of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 ).setParameterLength( 1 );

  /**
   * Returns the natural logarithm of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG ).setParameterLength( 1 );

  /**
   * Returns the base 2 logarithm of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 ).setParameterLength( 1 );

  /**
   * Returns the square root of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT ).setParameterLength( 1 );

  /**
   * Returns the inverse of the square root of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT ).setParameterLength( 1 );

  /**
   * Finds the nearest integer less than or equal to the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR ).setParameterLength( 1 );

  /**
   * Finds the nearest integer that is greater than or equal to the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL ).setParameterLength( 1 );

  /**
   * Calculates the unit vector in the same direction as the original vector.
   *
   * @tsl
   * @function
   * @param {Node} x - The input vector.
   * @returns {Node}
   */
  const normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE ).setParameterLength( 1 );

  /**
   * Computes the fractional part of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT ).setParameterLength( 1 );

  /**
   * Returns the sine of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN ).setParameterLength( 1 );

  /**
   * Returns the cosine of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS ).setParameterLength( 1 );

  /**
   * Returns the tangent of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN ).setParameterLength( 1 );

  /**
   * Returns the arcsine of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN ).setParameterLength( 1 );

  /**
   * Returns the arccosine of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS ).setParameterLength( 1 );

  /**
   * Returns the arc-tangent of the parameter.
   * If two parameters are provided, the result is `atan2(y/x)`.
   *
   * @tsl
   * @function
   * @param {Node | number} y - The y parameter.
   * @param {?(Node | number)} x - The x parameter.
   * @returns {Node}
   */
  const atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN ).setParameterLength( 1, 2 );

  /**
   * Returns the absolute value of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS ).setParameterLength( 1 );

  /**
   * Extracts the sign of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN ).setParameterLength( 1 );

  /**
   * Calculates the length of a vector.
   *
   * @tsl
   * @function
   * @param {Node} x - The parameter.
   * @returns {Node<float>}
   */
  const length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH ).setParameterLength( 1 );

  /**
   * Negates the value of the parameter (-x).
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE ).setParameterLength( 1 );

  /**
   * Return `1` minus the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS ).setParameterLength( 1 );

  /**
   * Returns the partial derivative of the parameter with respect to x.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX ).setParameterLength( 1 );

  /**
   * Returns the partial derivative of the parameter with respect to y.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY ).setParameterLength( 1 );

  /**
   * Rounds the parameter to the nearest integer.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND ).setParameterLength( 1 );

  /**
   * Returns the reciprocal of the parameter `(1/x)`.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL ).setParameterLength( 1 );

  /**
   * Truncates the parameter, removing the fractional part.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC ).setParameterLength( 1 );

  /**
   * Returns the sum of the absolute derivatives in x and y.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The parameter.
   * @returns {Node}
   */
  const fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH ).setParameterLength( 1 );

  /**
   * Returns the transpose of a matrix.
   *
   * @tsl
   * @function
   * @param {Node<mat2|mat3|mat4>} x - The parameter.
   * @returns {Node}
   */
  const transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE ).setParameterLength( 1 );

  /**
   * Returns `true` if `x` equals `y`.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The first parameter.
   * @param {Node | number} y - The second parameter.
   * @deprecated since r175. Use {@link equal} instead.
   * @returns {Node<bool>}
   */
  const equals = ( x, y ) => { // @deprecated, r172

  	console.warn( 'THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"' );
  	return equal( x, y );

  };

  /**
   * Returns the least of the given values.
   *
   * @tsl
   * @function
   * @param {...(Node | number)} values - The values to compare.
   * @returns {Node}
   */
  const min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN ).setParameterLength( 2, Infinity );

  /**
   * Returns the greatest of the given values.
   *
   * @tsl
   * @function
   * @param {...(Node | number)} values - The values to compare.
   * @returns {Node}
   */
  const max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX ).setParameterLength( 2, Infinity );

  /**
   * Generate a step function by comparing two values.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The y parameter.
   * @param {Node | number} y - The x parameter.
   * @returns {Node}
   */
  const step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP ).setParameterLength( 2 );

  /**
   * Calculates the reflection direction for an incident vector.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} I - The incident vector.
   * @param {Node<vec2|vec3|vec4>} N - The normal vector.
   * @returns {Node<vec2|vec3|vec4>}
   */
  const reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT ).setParameterLength( 2 );

  /**
   * Calculates the distance between two points.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} x - The first point.
   * @param {Node<vec2|vec3|vec4>} y - The second point.
   * @returns {Node<float>}
   */
  const distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE ).setParameterLength( 2 );

  /**
   * Calculates the absolute difference between two values.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The first parameter.
   * @param {Node | number} y - The second parameter.
   * @returns {Node}
   */
  const difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE ).setParameterLength( 2 );

  /**
   * Calculates the dot product of two vectors.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} x - The first vector.
   * @param {Node<vec2|vec3|vec4>} y - The second vector.
   * @returns {Node<float>}
   */
  const dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT ).setParameterLength( 2 );

  /**
   * Calculates the cross product of two vectors.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} x - The first vector.
   * @param {Node<vec2|vec3|vec4>} y - The second vector.
   * @returns {Node<vec2|vec3|vec4>}
   */
  const cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS ).setParameterLength( 2 );

  /**
   * Return the value of the first parameter raised to the power of the second one.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The first parameter.
   * @param {Node | number} y - The second parameter.
   * @returns {Node}
   */
  const pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW ).setParameterLength( 2 );

  /**
   * Returns the square of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The first parameter.
   * @returns {Node}
   */
  const pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 ).setParameterLength( 1 );

  /**
   * Returns the cube of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The first parameter.
   * @returns {Node}
   */
  const pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 ).setParameterLength( 1 );

  /**
   * Returns the fourth power of the parameter.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The first parameter.
   * @returns {Node}
   */
  const pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 ).setParameterLength( 1 );

  /**
   * Transforms the direction of a vector by a matrix and then normalizes the result.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} direction - The direction vector.
   * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.
   * @returns {Node}
   */
  const transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION ).setParameterLength( 2 );

  /**
   * Returns the cube root of a number.
   *
   * @tsl
   * @function
   * @param {Node | number} a - The first parameter.
   * @returns {Node}
   */
  const cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );

  /**
   * Calculate the squared length of a vector.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} a - The vector.
   * @returns {Node<float>}
   */
  const lengthSq = ( a ) => dot( a, a );

  /**
   * Linearly interpolates between two values.
   *
   * @tsl
   * @function
   * @param {Node | number} a - The first parameter.
   * @param {Node | number} b - The second parameter.
   * @param {Node | number} t - The interpolation value.
   * @returns {Node}
   */
  const mix$2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX ).setParameterLength( 3 );

  /**
   * Constrains a value to lie between two further values.
   *
   * @tsl
   * @function
   * @param {Node | number} value - The value to constrain.
   * @param {Node | number} [low=0] - The lower bound.
   * @param {Node | number} [high=1] - The upper bound.
   * @returns {Node}
   */
  const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );

  /**
   * Constrains a value between `0` and `1`.
   *
   * @tsl
   * @function
   * @param {Node | number} value - The value to constrain.
   * @returns {Node}
   */
  const saturate$1 = ( value ) => clamp( value );

  /**
   * Calculates the refraction direction for an incident vector.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} I - The incident vector.
   * @param {Node<vec2|vec3|vec4>} N - The normal vector.
   * @param {Node<float>} eta - The ratio of indices of refraction.
   * @returns {Node<vec2|vec3|vec4>}
   */
  const refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT ).setParameterLength( 3 );

  /**
   * Performs a Hermite interpolation between two values.
   *
   * @tsl
   * @function
   * @param {Node | number} low - The value of the lower edge of the Hermite function.
   * @param {Node | number} high - The value of the upper edge of the Hermite function.
   * @param {Node | number} x - The source value for interpolation.
   * @returns {Node}
   */
  const smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP ).setParameterLength( 3 );

  /**
   * Returns a vector pointing in the same direction as another.
   *
   * @tsl
   * @function
   * @param {Node<vec2|vec3|vec4>} N - The vector to orient.
   * @param {Node<vec2|vec3|vec4>} I - The incident vector.
   * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.
   * @returns {Node<vec2|vec3|vec4>}
   */
  const faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD ).setParameterLength( 3 );

  /**
   * Returns a random value for the given uv.
   *
   * @tsl
   * @function
   * @param {Node<vec2>} uv - The uv node.
   * @returns {Node<float>}
   */
  const rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {

  	const a = 12.9898, b = 78.233, c = 43758.5453;
  	const dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );

  	return fract( sin( sn ).mul( c ) );

  } );

  /**
   * Alias for `mix()` with a different parameter order.
   *
   * @tsl
   * @function
   * @param {Node | number} t - The interpolation value.
   * @param {Node | number} e1 - The first parameter.
   * @param {Node | number} e2 - The second parameter.
   * @returns {Node}
   */
  const mixElement = ( t, e1, e2 ) => mix$2( e1, e2, t );

  /**
   * Alias for `smoothstep()` with a different parameter order.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The source value for interpolation.
   * @param {Node | number} low - The value of the lower edge of the Hermite function.
   * @param {Node | number} high - The value of the upper edge of the Hermite function.
   * @returns {Node}
   */
  const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );

  /**
   * Alias for `step()` with a different parameter order.
   *
   * @tsl
   * @function
   * @param {Node | number} x - The source value for interpolation.
   * @param {Node | number} edge - The edge value.
   * @returns {Node}
   */
  const stepElement = ( x, edge ) => step( edge, x );

  /**
   * Returns the arc-tangent of the quotient of its parameters.
   *
   * @tsl
   * @function
   * @deprecated since r172. Use {@link atan} instead.
   *
   * @param {Node | number} y - The y parameter.
   * @param {Node | number} x - The x parameter.
   * @returns {Node}
   */
  const atan2 = ( y, x ) => { // @deprecated, r172

  	console.warn( 'THREE.TSL: "atan2" is overloaded. Use "atan" instead.' );
  	return atan( y, x );

  };

  // Method chaining

  addMethodChaining( 'all', all );
  addMethodChaining( 'any', any );
  addMethodChaining( 'equals', equals );

  addMethodChaining( 'radians', radians );
  addMethodChaining( 'degrees', degrees );
  addMethodChaining( 'exp', exp );
  addMethodChaining( 'exp2', exp2 );
  addMethodChaining( 'log', log );
  addMethodChaining( 'log2', log2 );
  addMethodChaining( 'sqrt', sqrt );
  addMethodChaining( 'inverseSqrt', inverseSqrt );
  addMethodChaining( 'floor', floor );
  addMethodChaining( 'ceil', ceil );
  addMethodChaining( 'normalize', normalize );
  addMethodChaining( 'fract', fract );
  addMethodChaining( 'sin', sin );
  addMethodChaining( 'cos', cos );
  addMethodChaining( 'tan', tan );
  addMethodChaining( 'asin', asin );
  addMethodChaining( 'acos', acos );
  addMethodChaining( 'atan', atan );
  addMethodChaining( 'abs', abs );
  addMethodChaining( 'sign', sign );
  addMethodChaining( 'length', length );
  addMethodChaining( 'lengthSq', lengthSq );
  addMethodChaining( 'negate', negate );
  addMethodChaining( 'oneMinus', oneMinus );
  addMethodChaining( 'dFdx', dFdx );
  addMethodChaining( 'dFdy', dFdy );
  addMethodChaining( 'round', round );
  addMethodChaining( 'reciprocal', reciprocal );
  addMethodChaining( 'trunc', trunc );
  addMethodChaining( 'fwidth', fwidth );
  addMethodChaining( 'atan2', atan2 );
  addMethodChaining( 'min', min$1 );
  addMethodChaining( 'max', max$1 );
  addMethodChaining( 'step', stepElement );
  addMethodChaining( 'reflect', reflect );
  addMethodChaining( 'distance', distance );
  addMethodChaining( 'dot', dot );
  addMethodChaining( 'cross', cross );
  addMethodChaining( 'pow', pow );
  addMethodChaining( 'pow2', pow2 );
  addMethodChaining( 'pow3', pow3 );
  addMethodChaining( 'pow4', pow4 );
  addMethodChaining( 'transformDirection', transformDirection );
  addMethodChaining( 'mix', mixElement );
  addMethodChaining( 'clamp', clamp );
  addMethodChaining( 'refract', refract );
  addMethodChaining( 'smoothstep', smoothstepElement );
  addMethodChaining( 'faceForward', faceForward );
  addMethodChaining( 'difference', difference );
  addMethodChaining( 'saturate', saturate$1 );
  addMethodChaining( 'cbrt', cbrt );
  addMethodChaining( 'transpose', transpose );
  addMethodChaining( 'rand', rand );

  /**
   * Represents a logical `if/else` statement. Can be used as an alternative
   * to the `If()`/`Else()` syntax.
   *
   * The corresponding TSL `select()` looks like so:
   * ```js
   * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
   * ```
   * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`
   * determine the outcome of the entire statement.
   *
   * @augments Node
   */
  class ConditionalNode extends Node {

  	static get type() {

  		return 'ConditionalNode';

  	}

  	/**
  	 * Constructs a new conditional node.
  	 *
  	 * @param {Node} condNode - The node that defines the condition.
  	 * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
  	 * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
  	 */
  	constructor( condNode, ifNode, elseNode = null ) {

  		super();

  		/**
  		 * The node that defines the condition.
  		 *
  		 * @type {Node}
  		 */
  		this.condNode = condNode;

  		/**
  		 * The node that is evaluate when the condition ends up `true`.
  		 *
  		 * @type {Node}
  		 */
  		this.ifNode = ifNode;

  		/**
  		 * The node that is evaluate when the condition ends up `false`.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.elseNode = elseNode;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from the if/else
  	 * nodes.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		const { ifNode, elseNode } = builder.getNodeProperties( this );

  		if ( ifNode === undefined ) {

  			// fallback setup

  			this.setup( builder );

  			return this.getNodeType( builder );

  		}

  		const ifType = ifNode.getNodeType( builder );

  		if ( elseNode !== null ) {

  			const elseType = elseNode.getNodeType( builder );

  			if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

  				return elseType;

  			}

  		}

  		return ifType;

  	}

  	setup( builder ) {

  		const condNode = this.condNode.cache();
  		const ifNode = this.ifNode.cache();
  		const elseNode = this.elseNode ? this.elseNode.cache() : null;

  		//

  		const currentNodeBlock = builder.context.nodeBlock;

  		builder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;
  		if ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;

  		//

  		const properties = builder.getNodeProperties( this );
  		properties.condNode = condNode;
  		properties.ifNode = ifNode.context( { nodeBlock: ifNode } );
  		properties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );

  		const nodeData = builder.getDataFromNode( this );

  		if ( nodeData.nodeProperty !== undefined ) {

  			return nodeData.nodeProperty;

  		}

  		const { condNode, ifNode, elseNode } = builder.getNodeProperties( this );

  		const functionNode = builder.currentFunctionNode;
  		const needsOutput = output !== 'void';
  		const nodeProperty = needsOutput ? property( type ).build( builder ) : '';

  		nodeData.nodeProperty = nodeProperty;

  		const nodeSnippet = condNode.build( builder, 'bool' );

  		builder.addFlowCode( `\n${ builder.tab }if ( ${ nodeSnippet } ) {\n\n` ).addFlowTab();

  		let ifSnippet = ifNode.build( builder, type );

  		if ( ifSnippet ) {

  			if ( needsOutput ) {

  				ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';

  			} else {

  				ifSnippet = 'return ' + ifSnippet + ';';

  				if ( functionNode === null ) {

  					console.warn( 'THREE.TSL: Return statement used in an inline \'Fn()\'. Define a layout struct to allow return values.' );

  					ifSnippet = '// ' + ifSnippet;

  				}

  			}

  		}

  		builder.removeFlowTab().addFlowCode( builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}' );

  		if ( elseNode !== null ) {

  			builder.addFlowCode( ' else {\n\n' ).addFlowTab();

  			let elseSnippet = elseNode.build( builder, type );

  			if ( elseSnippet ) {

  				if ( needsOutput ) {

  					elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';

  				} else {

  					elseSnippet = 'return ' + elseSnippet + ';';

  					if ( functionNode === null ) {

  						console.warn( 'THREE.TSL: Return statement used in an inline \'Fn()\'. Define a layout struct to allow return values.' );

  						elseSnippet = '// ' + elseSnippet;

  					}

  				}

  			}

  			builder.removeFlowTab().addFlowCode( builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n' );

  		} else {

  			builder.addFlowCode( '\n\n' );

  		}

  		return builder.format( nodeProperty, type, output );

  	}

  }

  /**
   * TSL function for creating a conditional node.
   *
   * @tsl
   * @function
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   * @returns {ConditionalNode}
   */
  const select$1 = /*@__PURE__*/ nodeProxy( ConditionalNode ).setParameterLength( 2, 3 );

  addMethodChaining( 'select', select$1 );

  /**
   * This node can be used as a context management component for another node.
   * {@link NodeBuilder} performs its node building process in a specific context and
   * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:
   *
   * ```js
   *node.context( { getUV: () => customCoord } );
   *```
   * @augments Node
   */
  class ContextNode extends Node {

  	static get type() {

  		return 'ContextNode';

  	}

  	/**
  	 * Constructs a new context node.
  	 *
  	 * @param {Node} node - The node whose context should be modified.
  	 * @param {Object} [value={}] - The modified context data.
  	 */
  	constructor( node, value = {} ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isContextNode = true;

  		/**
  		 * The node whose context should be modified.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The modified context data.
  		 *
  		 * @type {Object}
  		 * @default {}
  		 */
  		this.value = value;

  	}

  	/**
  	 * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
  	 *
  	 * @return {Node} A reference to {@link ContextNode#node}.
  	 */
  	getScope() {

  		return this.node.getScope();

  	}

  	/**
  	 * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		return this.node.getNodeType( builder );

  	}

  	analyze( builder ) {

  		const previousContext = builder.getContext();

  		builder.setContext( { ...builder.context, ...this.value } );

  		this.node.build( builder );

  		builder.setContext( previousContext );

  	}

  	setup( builder ) {

  		const previousContext = builder.getContext();

  		builder.setContext( { ...builder.context, ...this.value } );

  		this.node.build( builder );

  		builder.setContext( previousContext );

  	}

  	generate( builder, output ) {

  		const previousContext = builder.getContext();

  		builder.setContext( { ...builder.context, ...this.value } );

  		const snippet = this.node.build( builder, output );

  		builder.setContext( previousContext );

  		return snippet;

  	}

  }

  /**
   * TSL function for creating a context node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   * @returns {ContextNode}
   */
  const context = /*@__PURE__*/ nodeProxy( ContextNode ).setParameterLength( 1, 2 );

  /**
   * TSL function for defining a label context value for a given node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node whose context should be modified.
   * @param {string} name - The name/label to set.
   * @returns {ContextNode}
   */
  const label = ( node, name ) => context( node, { label: name } );

  addMethodChaining( 'context', context );
  addMethodChaining( 'label', label );

  /**
   * Class for representing shader variables as nodes. Variables are created from
   * existing nodes like the following:
   *
   * ```js
   * const depth = sampleDepth( uvNode ).toVar( 'depth' );
   * ```
   *
   * @augments Node
   */
  class VarNode extends Node {

  	static get type() {

  		return 'VarNode';

  	}

  	/**
  	 * Constructs a new variable node.
  	 *
  	 * @param {Node} node - The node for which a variable should be created.
  	 * @param {?string} [name=null] - The name of the variable in the shader.
  	 * @param {boolean} [readOnly=false] - The read-only flag.
  	 */
  	constructor( node, name = null, readOnly = false ) {

  		super();

  		/**
  		 * The node for which a variable should be created.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The name of the variable in the shader. If no name is defined,
  		 * the node system auto-generates one.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.name = name;

  		/**
  		 * `VarNode` sets this property to `true` by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isVarNode = true;

  		/**
  		 *
  		 * The read-only flag.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.readOnly = readOnly;

  		/**
  		 *
  		 * Add this flag to the node system to indicate that this node require parents.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.parents = true;

  	}

  	getMemberType( builder, name ) {

  		return this.node.getMemberType( builder, name );

  	}

  	getElementType( builder ) {

  		return this.node.getElementType( builder );

  	}

  	getNodeType( builder ) {

  		return this.node.getNodeType( builder );

  	}

  	generate( builder ) {

  		const { node, name, readOnly } = this;
  		const { renderer } = builder;

  		const isWebGPUBackend = renderer.backend.isWebGPUBackend === true;

  		let isDeterministic = false;
  		let shouldTreatAsReadOnly = false;

  		if ( readOnly ) {

  			isDeterministic = builder.isDeterministic( node );

  			shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;

  		}

  		const vectorType = builder.getVectorType( this.getNodeType( builder ) );
  		const snippet = node.build( builder, vectorType );

  		const nodeVar = builder.getVarFromNode( this, name, vectorType, undefined, shouldTreatAsReadOnly );

  		const propertyName = builder.getPropertyName( nodeVar );

  		let declarationPrefix = propertyName;

  		if ( shouldTreatAsReadOnly ) {

  			if ( isWebGPUBackend ) {

  				declarationPrefix = isDeterministic
  					? `const ${ propertyName }`
  					: `let ${ propertyName }`;

  			} else {

  				const count = builder.getArrayCount( node );

  				declarationPrefix = `const ${ builder.getVar( nodeVar.type, propertyName, count ) }`;

  			}

  		}

  		builder.addLineFlowCode( `${ declarationPrefix } = ${ snippet }`, this );

  		return propertyName;

  	}

  }

  /**
   * TSL function for creating a var node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} name - The name of the variable in the shader.
   * @returns {VarNode}
   */
  const createVar = /*@__PURE__*/ nodeProxy( VarNode );

  /**
   * TSL function for creating a var node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} name - The name of the variable in the shader.
   * @returns {VarNode}
   */
  const Var = ( node, name = null ) => createVar( node, name ).toStack();

  /**
   * TSL function for creating a const node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node for which a constant should be created.
   * @param {?string} name - The name of the constant in the shader.
   * @returns {VarNode}
   */
  const Const = ( node, name = null ) => createVar( node, name, true ).toStack();

  // Method chaining

  addMethodChaining( 'toVar', Var );
  addMethodChaining( 'toConst', Const );

  // Deprecated

  /**
   * @tsl
   * @function
   * @deprecated since r170. Use `Var( node )` or `node.toVar()` instead.
   *
   * @param {any} node
   * @returns {VarNode}
   */
  const temp = ( node ) => { // @deprecated, r170

  	console.warn( 'TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.' );

  	return createVar( node );

  };

  addMethodChaining( 'temp', temp );

  /**
   * This node is used to build a sub-build in the node system.
   *
   * @augments Node
   * @param {Node} node - The node to be built in the sub-build.
   * @param {string} name - The name of the sub-build.
   * @param {string|null} [nodeType=null] - The type of the node, if known.
   */
  class SubBuildNode extends Node {

  	static get type() {

  		return 'SubBuild';

  	}

  	constructor( node, name, nodeType = null ) {

  		super( nodeType );

  		/**
  		 * The node to be built in the sub-build.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The name of the sub-build.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSubBuildNode = true;

  	}

  	getNodeType( builder ) {

  		if ( this.nodeType !== null ) return this.nodeType;

  		builder.addSubBuild( this.name );

  		const nodeType = this.node.getNodeType( builder );

  		builder.removeSubBuild();

  		return nodeType;

  	}

  	build( builder, ...params ) {

  		builder.addSubBuild( this.name );

  		const data = this.node.build( builder, ...params );

  		builder.removeSubBuild();

  		return data;

  	}

  }

  /**
   * Creates a new sub-build node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node to be built in the sub-build.
   * @param {string} name - The name of the sub-build.
   * @param {string|null} [type=null] - The type of the node, if known.
   * @returns {Node} A node object wrapping the SubBuildNode instance.
   */
  const subBuild = ( node, name, type = null ) => nodeObject( new SubBuildNode( nodeObject( node ), name, type ) );

  /**
   * Class for representing shader varyings as nodes. Varyings are create from
   * existing nodes like the following:
   *
   * ```js
   * const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );
   * ```
   *
   * @augments Node
   */
  class VaryingNode extends Node {

  	static get type() {

  		return 'VaryingNode';

  	}

  	/**
  	 * Constructs a new varying node.
  	 *
  	 * @param {Node} node - The node for which a varying should be created.
  	 * @param {?string} name - The name of the varying in the shader.
  	 */
  	constructor( node, name = null ) {

  		super();

  		/**
  		 * The node for which a varying should be created.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The name of the varying in the shader. If no name is defined,
  		 * the node system auto-generates one.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.name = name;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isVaryingNode = true;

  		/**
  		 * The interpolation type of the varying data.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.interpolationType = null;

  		/**
  		 * The interpolation sampling type of varying data.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.interpolationSampling = null;

  		/**
  		 * This flag is used for global cache.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  	}

  	/**
  	 * Defines the interpolation type of the varying.
  	 *
  	 * @param {string} type - The interpolation type.
  	 * @param {?string} sampling - The interpolation sampling type
  	 * @return {VaryingNode} A reference to this node.
  	 */
  	setInterpolation( type, sampling = null ) {

  		this.interpolationType = type;
  		this.interpolationSampling = sampling;

  		return this;

  	}

  	getHash( builder ) {

  		return this.name || super.getHash( builder );

  	}

  	getNodeType( builder ) {

  		// VaryingNode is auto type

  		return this.node.getNodeType( builder );

  	}

  	/**
  	 * This method performs the setup of a varying node with the current node builder.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {NodeVarying} The node varying from the node builder.
  	 */
  	setupVarying( builder ) {

  		const properties = builder.getNodeProperties( this );

  		let varying = properties.varying;

  		if ( varying === undefined ) {

  			const name = this.name;
  			const type = this.getNodeType( builder );
  			const interpolationType = this.interpolationType;
  			const interpolationSampling = this.interpolationSampling;

  			properties.varying = varying = builder.getVaryingFromNode( this, name, type, interpolationType, interpolationSampling );
  			properties.node = subBuild( this.node, 'VERTEX' );

  		}

  		// this property can be used to check if the varying can be optimized for a variable
  		varying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );

  		return varying;

  	}

  	setup( builder ) {

  		this.setupVarying( builder );

  		builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );

  	}

  	analyze( builder ) {

  		this.setupVarying( builder );

  		builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );

  	}

  	generate( builder ) {

  		const propertyKey = builder.getSubBuildProperty( 'property', builder.currentStack );
  		const properties = builder.getNodeProperties( this );
  		const varying = this.setupVarying( builder );

  		if ( properties[ propertyKey ] === undefined ) {

  			const type = this.getNodeType( builder );
  			const propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );

  			// force node run in vertex stage
  			builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, properties.node, type, propertyName );

  			properties[ propertyKey ] = propertyName;

  		}

  		return builder.getPropertyName( varying );

  	}

  }

  /**
   * TSL function for creating a varying node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   * @returns {VaryingNode}
   */
  const varying = /*@__PURE__*/ nodeProxy( VaryingNode ).setParameterLength( 1, 2 );

  /**
   * Computes a node in the vertex stage.
   *
   * @tsl
   * @function
   * @param {Node} node - The node which should be executed in the vertex stage.
   * @returns {VaryingNode}
   */
  const vertexStage = ( node ) => varying( node );

  addMethodChaining( 'toVarying', varying );
  addMethodChaining( 'toVertexStage', vertexStage );

  // Deprecated

  addMethodChaining( 'varying', ( ...params ) => { // @deprecated, r173

  	console.warn( 'THREE.TSL: .varying() has been renamed to .toVarying().' );
  	return varying( ...params );

  } );

  addMethodChaining( 'vertexStage', ( ...params ) => { // @deprecated, r173

  	console.warn( 'THREE.TSL: .vertexStage() has been renamed to .toVertexStage().' );
  	return varying( ...params );

  } );

  /**
   * Converts the given color value from sRGB to linear-sRGB color space.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The sRGB color.
   * @return {Node<vec3>} The linear-sRGB color.
   */
  const sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	const a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );
  	const b = color.mul( 0.0773993808 );
  	const factor = color.lessThanEqual( 0.04045 );

  	const rgbResult = mix$2( a, b, factor );

  	return rgbResult;

  } ).setLayout( {
  	name: 'sRGBTransferEOTF',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' }
  	]
  } );

  /**
   * Converts the given color value from linear-sRGB to sRGB color space.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The linear-sRGB color.
   * @return {Node<vec3>} The sRGB color.
   */
  const sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	const a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );
  	const b = color.mul( 12.92 );
  	const factor = color.lessThanEqual( 0.0031308 );

  	const rgbResult = mix$2( a, b, factor );

  	return rgbResult;

  } ).setLayout( {
  	name: 'sRGBTransferOETF',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' }
  	]
  } );

  const WORKING_COLOR_SPACE = 'WorkingColorSpace';
  const OUTPUT_COLOR_SPACE = 'OutputColorSpace';

  /**
   * This node represents a color space conversion. Meaning it converts
   * a color value from a source to a target color space.
   *
   * @augments TempNode
   */
  class ColorSpaceNode extends TempNode {

  	static get type() {

  		return 'ColorSpaceNode';

  	}

  	/**
  	 * Constructs a new color space node.
  	 *
  	 * @param {Node} colorNode - Represents the color to convert.
  	 * @param {string} source - The source color space.
  	 * @param {string} target - The target color space.
  	 */
  	constructor( colorNode, source, target ) {

  		super( 'vec4' );

  		/**
  		 * Represents the color to convert.
  		 *
  		 * @type {Node}
  		 */
  		this.colorNode = colorNode;

  		/**
  		 * The source color space.
  		 *
  		 * @type {string}
  		 */
  		this.source = source;

  		/**
  		 * The target color space.
  		 *
  		 * @type {string}
  		 */
  		this.target = target;

  	}

  	/**
  	 * This method resolves the constants `WORKING_COLOR_SPACE` and
  	 * `OUTPUT_COLOR_SPACE` based on the current configuration of the
  	 * color management and renderer.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string} colorSpace - The color space to resolve.
  	 * @return {string} The resolved color space.
  	 */
  	resolveColorSpace( builder, colorSpace ) {

  		if ( colorSpace === WORKING_COLOR_SPACE ) {

  			return ColorManagement.workingColorSpace;

  		} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {

  			return builder.context.outputColorSpace || builder.renderer.outputColorSpace;

  		}

  		return colorSpace;

  	}

  	setup( builder ) {

  		const { colorNode } = this;

  		const source = this.resolveColorSpace( builder, this.source );
  		const target = this.resolveColorSpace( builder, this.target );

  		let outputNode = colorNode;

  		if ( ColorManagement.enabled === false || source === target || ! source || ! target ) {

  			return outputNode;

  		}

  		if ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {

  			outputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );

  		}

  		if ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {

  			outputNode = vec4(
  				mat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),
  				outputNode.a
  			);

  		}

  		if ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {

  			outputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );

  		}

  		return outputNode;

  	}

  }

  /**
   * TSL function for converting a given color node from the current working color space to the given color space.
   *
   * @tsl
   * @function
   * @param {Node} node - Represents the node to convert.
   * @param {string} targetColorSpace - The target color space.
   * @returns {ColorSpaceNode}
   */
  const workingToColorSpace = ( node, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, targetColorSpace ) );

  /**
   * TSL function for converting a given color node from the given color space to the current working color space.
   *
   * @tsl
   * @function
   * @param {Node} node - Represents the node to convert.
   * @param {string} sourceColorSpace - The source color space.
   * @returns {ColorSpaceNode}
   */
  const colorSpaceToWorking = ( node, sourceColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, WORKING_COLOR_SPACE ) );

  addMethodChaining( 'workingToColorSpace', workingToColorSpace );
  addMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );

  // TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode

  /**
   * This class is only relevant if the referenced property is array-like.
   * In this case, `ReferenceElementNode` allows to refer to a specific
   * element inside the data structure via an index.
   *
   * @augments ArrayElementNode
   */
  let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {

  	static get type() {

  		return 'ReferenceElementNode';

  	}

  	/**
  	 * Constructs a new reference element node.
  	 *
  	 * @param {ReferenceBaseNode} referenceNode - The reference node.
  	 * @param {Node} indexNode - The index node that defines the element access.
  	 */
  	constructor( referenceNode, indexNode ) {

  		super( referenceNode, indexNode );

  		/**
  		 * Similar to {@link ReferenceBaseNode#reference}, an additional
  		 * property references to the current node.
  		 *
  		 * @type {?ReferenceBaseNode}
  		 * @default null
  		 */
  		this.referenceNode = referenceNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isReferenceElementNode = true;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from
  	 * the uniform type of the reference node.
  	 *
  	 * @return {string} The node type.
  	 */
  	getNodeType() {

  		return this.referenceNode.uniformType;

  	}

  	generate( builder ) {

  		const snippet = super.generate( builder );
  		const arrayType = this.referenceNode.getNodeType();
  		const elementType = this.getNodeType();

  		return builder.format( snippet, arrayType, elementType );

  	}

  };

  /**
   * Base class for nodes which establishes a reference to a property of another object.
   * In this way, the value of the node is automatically linked to the value of
   * referenced object. Reference nodes internally represent the linked value
   * as a uniform.
   *
   * @augments Node
   */
  class ReferenceBaseNode extends Node {

  	static get type() {

  		return 'ReferenceBaseNode';

  	}

  	/**
  	 * Constructs a new reference base node.
  	 *
  	 * @param {string} property - The name of the property the node refers to.
  	 * @param {string} uniformType - The uniform type that should be used to represent the property value.
  	 * @param {?Object} [object=null] - The object the property belongs to.
  	 * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
  	 */
  	constructor( property, uniformType, object = null, count = null ) {

  		super();

  		/**
  		 * The name of the property the node refers to.
  		 *
  		 * @type {string}
  		 */
  		this.property = property;

  		/**
  		 * The uniform type that should be used to represent the property value.
  		 *
  		 * @type {string}
  		 */
  		this.uniformType = uniformType;

  		/**
  		 * The object the property belongs to.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.object = object;

  		/**
  		 * When the linked property is an array, this parameter defines its length.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this.count = count;

  		/**
  		 * The property name might have dots so nested properties can be referred.
  		 * The hierarchy of the names is stored inside this array.
  		 *
  		 * @type {Array<string>}
  		 */
  		this.properties = property.split( '.' );

  		/**
  		 * Points to the current referred object. This property exists next to {@link ReferenceNode#object}
  		 * since the final reference might be updated from calling code.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.reference = object;

  		/**
  		 * The uniform node that holds the value of the reference node.
  		 *
  		 * @type {UniformNode}
  		 * @default null
  		 */
  		this.node = null;

  		/**
  		 * The uniform group of the internal uniform.
  		 *
  		 * @type {UniformGroupNode}
  		 * @default null
  		 */
  		this.group = null;

  		/**
  		 * Overwritten since reference nodes are updated per object.
  		 *
  		 * @type {string}
  		 * @default 'object'
  		 */
  		this.updateType = NodeUpdateType.OBJECT;

  	}

  	/**
  	 * Sets the uniform group for this reference node.
  	 *
  	 * @param {UniformGroupNode} group - The uniform group to set.
  	 * @return {ReferenceBaseNode} A reference to this node.
  	 */
  	setGroup( group ) {

  		this.group = group;

  		return this;

  	}

  	/**
  	 * When the referred property is array-like, this method can be used
  	 * to access elements via an index node.
  	 *
  	 * @param {IndexNode} indexNode - indexNode.
  	 * @return {ReferenceElementNode} A reference to an element.
  	 */
  	element( indexNode ) {

  		return nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );

  	}

  	/**
  	 * Sets the node type which automatically defines the internal
  	 * uniform type.
  	 *
  	 * @param {string} uniformType - The type to set.
  	 */
  	setNodeType( uniformType ) {

  		const node = uniform( null, uniformType ).getSelf();

  		if ( this.group !== null ) {

  			node.setGroup( this.group );

  		}

  		this.node = node;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from
  	 * the type of the reference node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		if ( this.node === null ) {

  			this.updateReference( builder );
  			this.updateValue();

  		}

  		return this.node.getNodeType( builder );

  	}

  	/**
  	 * Returns the property value from the given referred object.
  	 *
  	 * @param {Object} [object=this.reference] - The object to retrieve the property value from.
  	 * @return {any} The value.
  	 */
  	getValueFromReference( object = this.reference ) {

  		const { properties } = this;

  		let value = object[ properties[ 0 ] ];

  		for ( let i = 1; i < properties.length; i ++ ) {

  			value = value[ properties[ i ] ];

  		}

  		return value;

  	}

  	/**
  	 * Allows to update the reference based on the given state. The state is only
  	 * evaluated {@link ReferenceBaseNode#object} is not set.
  	 *
  	 * @param {(NodeFrame|NodeBuilder)} state - The current state.
  	 * @return {Object} The updated reference.
  	 */
  	updateReference( state ) {

  		this.reference = this.object !== null ? this.object : state.object;

  		return this.reference;

  	}

  	/**
  	 * The output of the reference node is the internal uniform node.
  	 *
  	 * @return {UniformNode} The output node.
  	 */
  	setup() {

  		this.updateValue();

  		return this.node;

  	}

  	/**
  	 * Overwritten to update the internal uniform value.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( /*frame*/ ) {

  		this.updateValue();

  	}

  	/**
  	 * Retrieves the value from the referred object property and uses it
  	 * to updated the internal uniform.
  	 */
  	updateValue() {

  		if ( this.node === null ) this.setNodeType( this.uniformType );

  		const value = this.getValueFromReference();

  		if ( Array.isArray( value ) ) {

  			this.node.array = value;

  		} else {

  			this.node.value = value;

  		}

  	}

  }

  /**
   * TSL function for creating a reference base node.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the property the node refers to.
   * @param {string} type - The uniform type that should be used to represent the property value.
   * @param {Object} object - The object the property belongs to.
   * @returns {ReferenceBaseNode}
   */
  const reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );

  /**
   * This node is a special type of reference node which is intended
   * for linking renderer properties with node values.
   * ```js
   * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );
   * ```
   * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will
   * automatically be updated.
   *
   * @augments ReferenceBaseNode
   */
  class RendererReferenceNode extends ReferenceBaseNode {

  	static get type() {

  		return 'RendererReferenceNode';

  	}

  	/**
  	 * Constructs a new renderer reference node.
  	 *
  	 * @param {string} property - The name of the property the node refers to.
  	 * @param {string} inputType - The uniform type that should be used to represent the property value.
  	 * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
  	 * the node refers to the renderer of the current state.
  	 */
  	constructor( property, inputType, renderer = null ) {

  		super( property, inputType, renderer );

  		/**
  		 * The renderer the property belongs to. When no renderer is set,
  		 * the node refers to the renderer of the current state.
  		 *
  		 * @type {?Renderer}
  		 * @default null
  		 */
  		this.renderer = renderer;

  		this.setGroup( renderGroup );

  	}

  	/**
  	 * Updates the reference based on the given state. The state is only evaluated
  	 * {@link RendererReferenceNode#renderer} is not set.
  	 *
  	 * @param {(NodeFrame|NodeBuilder)} state - The current state.
  	 * @return {Object} The updated reference.
  	 */
  	updateReference( state ) {

  		this.reference = this.renderer !== null ? this.renderer : state.renderer;

  		return this.reference;

  	}

  }

  /**
   * TSL function for creating a renderer reference node.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the property the node refers to.
   * @param {string} type - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   * @returns {RendererReferenceNode}
   */
  const rendererReference = ( name, type, renderer = null ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );

  /**
   * This node represents a tone mapping operation.
   *
   * @augments TempNode
   */
  class ToneMappingNode extends TempNode {

  	static get type() {

  		return 'ToneMappingNode';

  	}

  	/**
  	 * Constructs a new tone mapping node.
  	 *
  	 * @param {number} toneMapping - The tone mapping type.
  	 * @param {Node} exposureNode - The tone mapping exposure.
  	 * @param {Node} [colorNode=null] - The color node to process.
  	 */
  	constructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {

  		super( 'vec3' );

  		/**
  		 * The tone mapping type.
  		 *
  		 * @type {number}
  		 */
  		this.toneMapping = toneMapping;

  		/**
  		 * The tone mapping exposure.
  		 *
  		 * @type {Node}
  		 * @default null
  		 */
  		this.exposureNode = exposureNode;

  		/**
  		 * Represents the color to process.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.colorNode = colorNode;

  	}

  	/**
  	 * Overwrites the default `customCacheKey()` implementation by including the tone
  	 * mapping type into the cache key.
  	 *
  	 * @return {number} The hash.
  	 */
  	customCacheKey() {

  		return hash$1( this.toneMapping );

  	}

  	setup( builder ) {

  		const colorNode = this.colorNode || builder.context.color;
  		const toneMapping = this.toneMapping;

  		if ( toneMapping === NoToneMapping ) return colorNode;

  		let outputNode = null;

  		const toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );

  		if ( toneMappingFn !== null ) {

  			outputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );

  		} else {

  			console.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );

  			outputNode = colorNode;

  		}

  		return outputNode;

  	}

  }

  /**
   * TSL function for creating a tone mapping node.
   *
   * @tsl
   * @function
   * @param {number} mapping - The tone mapping type.
   * @param {Node<float> | number} exposure - The tone mapping exposure.
   * @param {Node<vec3> | Color} color - The color node to process.
   * @returns {ToneMappingNode<vec3>}
   */
  const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );

  /**
   * TSL object that represents the global tone mapping exposure of the renderer.
   *
   * @tsl
   * @type {RendererReferenceNode<vec3>}
   */
  const toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );

  addMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );

  /**
   * In earlier `three.js` versions it was only possible to define attribute data
   * on geometry level. With `BufferAttributeNode`, it is also possible to do this
   * on the node level.
   * ```js
   * const geometry = new THREE.PlaneGeometry();
   * const positionAttribute = geometry.getAttribute( 'position' );
   *
   * const colors = [];
   * for ( let i = 0; i < position.count; i ++ ) {
   * 	colors.push( 1, 0, 0 );
   * }
   *
   * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
   * ```
   * This new approach is especially interesting when geometry data are generated via
   * compute shaders. The below line converts a storage buffer into an attribute node.
   * ```js
   * material.positionNode = positionBuffer.toAttribute();
   * ```
   * @augments InputNode
   */
  class BufferAttributeNode extends InputNode {

  	static get type() {

  		return 'BufferAttributeNode';

  	}

  	/**
  	 * Constructs a new buffer attribute node.
  	 *
  	 * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
  	 * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
  	 * @param {number} [bufferStride=0] - The buffer stride.
  	 * @param {number} [bufferOffset=0] - The buffer offset.
  	 */
  	constructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {

  		super( value, bufferType );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBufferNode = true;

  		/**
  		 * The buffer type (e.g. `'vec3'`).
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.bufferType = bufferType;

  		/**
  		 * The buffer stride.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.bufferStride = bufferStride;

  		/**
  		 * The buffer offset.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.bufferOffset = bufferOffset;

  		/**
  		 * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,
  		 * if you are planning to update the attribute data per frame.
  		 *
  		 * @type {number}
  		 * @default StaticDrawUsage
  		 */
  		this.usage = StaticDrawUsage;

  		/**
  		 * Whether the attribute is instanced or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.instanced = false;

  		/**
  		 * A reference to the buffer attribute.
  		 *
  		 * @type {?BufferAttribute}
  		 * @default null
  		 */
  		this.attribute = null;

  		/**
  		 * `BufferAttributeNode` sets this property to `true` by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  		if ( value && value.isBufferAttribute === true ) {

  			this.attribute = value;
  			this.usage = value.usage;
  			this.instanced = value.isInstancedBufferAttribute;

  		}

  	}

  	/**
  	 * This method is overwritten since the attribute data might be shared
  	 * and thus the hash should be shared as well.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The hash.
  	 */
  	getHash( builder ) {

  		if ( this.bufferStride === 0 && this.bufferOffset === 0 ) {

  			let bufferData = builder.globalCache.getData( this.value );

  			if ( bufferData === undefined ) {

  				bufferData = {
  					node: this
  				};

  				builder.globalCache.setData( this.value, bufferData );

  			}

  			return bufferData.node.uuid;

  		}

  		return this.uuid;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from
  	 * the buffer attribute.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		if ( this.bufferType === null ) {

  			this.bufferType = builder.getTypeFromAttribute( this.attribute );

  		}

  		return this.bufferType;

  	}

  	/**
  	 * Depending on which value was passed to the node, `setup()` behaves
  	 * differently. If no instance of `BufferAttribute` was passed, the method
  	 * creates an internal attribute and configures it respectively.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		if ( this.attribute !== null ) return;

  		const type = this.getNodeType( builder );
  		const array = this.value;
  		const itemSize = builder.getTypeLength( type );
  		const stride = this.bufferStride || itemSize;
  		const offset = this.bufferOffset;

  		const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );
  		const bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );

  		buffer.setUsage( this.usage );

  		this.attribute = bufferAttribute;
  		this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute

  	}

  	/**
  	 * Generates the code snippet of the buffer attribute node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The generated code snippet.
  	 */
  	generate( builder ) {

  		const nodeType = this.getNodeType( builder );

  		const nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );
  		const propertyName = builder.getPropertyName( nodeAttribute );

  		let output = null;

  		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

  			this.name = propertyName;

  			output = propertyName;

  		} else {

  			const nodeVarying = varying( this );

  			output = nodeVarying.build( builder, nodeType );

  		}

  		return output;

  	}

  	/**
  	 * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( /*builder*/ ) {

  		return 'bufferAttribute';

  	}

  	/**
  	 * Sets the `usage` property to the given value.
  	 *
  	 * @param {number} value - The usage to set.
  	 * @return {BufferAttributeNode} A reference to this node.
  	 */
  	setUsage( value ) {

  		this.usage = value;

  		if ( this.attribute && this.attribute.isBufferAttribute === true ) {

  			this.attribute.usage = value;

  		}

  		return this;

  	}

  	/**
  	 * Sets the `instanced` property to the given value.
  	 *
  	 * @param {boolean} value - The value to set.
  	 * @return {BufferAttributeNode} A reference to this node.
  	 */
  	setInstanced( value ) {

  		this.instanced = value;

  		return this;

  	}

  }

  /**
   * TSL function for creating a buffer attribute node.
   *
   * @tsl
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [stride=0] - The buffer stride.
   * @param {number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  const bufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );

  /**
   * TSL function for creating a buffer attribute node but with dynamic draw usage.
   * Use this function if attribute data are updated per frame.
   *
   * @tsl
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [stride=0] - The buffer stride.
   * @param {number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  const dynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );

  /**
   * TSL function for creating a buffer attribute node but with enabled instancing
   *
   * @tsl
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [stride=0] - The buffer stride.
   * @param {number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  const instancedBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );

  /**
   * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing
   *
   * @tsl
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [stride=0] - The buffer stride.
   * @param {number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  const instancedDynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );

  addMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );

  /**
   * TODO
   *
   * @augments Node
   */
  class ComputeNode extends Node {

  	static get type() {

  		return 'ComputeNode';

  	}

  	/**
  	 * Constructs a new compute node.
  	 *
  	 * @param {Node} computeNode - TODO
  	 * @param {number} count - TODO.
  	 * @param {Array<number>} [workgroupSize=[64]] - TODO.
  	 */
  	constructor( computeNode, count, workgroupSize = [ 64 ] ) {

  		super( 'void' );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isComputeNode = true;

  		/**
  		 * TODO
  		 *
  		 * @type {Node}
  		 */
  		this.computeNode = computeNode;

  		/**
  		 * TODO
  		 *
  		 * @type {number}
  		 */
  		this.count = count;

  		/**
  		 * TODO
  		 *
  		 * @type {Array<number>}
  		 * @default [64]
  		 */
  		this.workgroupSize = workgroupSize;

  		/**
  		 * TODO
  		 *
  		 * @type {number}
  		 */
  		this.dispatchCount = 0;

  		/**
  		 * TODO
  		 *
  		 * @type {number}
  		 */
  		this.version = 1;

  		/**
  		 * The name or label of the uniform.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.name = '';

  		/**
  		 * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}
  		 * is executed once per object by default.
  		 *
  		 * @type {string}
  		 * @default 'object'
  		 */
  		this.updateBeforeType = NodeUpdateType.OBJECT;

  		/**
  		 * TODO
  		 *
  		 * @type {?Function}
  		 */
  		this.onInitFunction = null;

  		this.updateDispatchCount();

  	}

  	/**
  	 * Executes the `dispose` event for this node.
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	/**
  	 * Sets the {@link ComputeNode#name} property.
  	 *
  	 * @param {string} name - The name of the uniform.
  	 * @return {ComputeNode} A reference to this node.
  	 */
  	label( name ) {

  		this.name = name;

  		return this;

  	}

  	/**
  	 * TODO
  	 */
  	updateDispatchCount() {

  		const { count, workgroupSize } = this;

  		let size = workgroupSize[ 0 ];

  		for ( let i = 1; i < workgroupSize.length; i ++ )
  			size *= workgroupSize[ i ];

  		this.dispatchCount = Math.ceil( count / size );

  	}

  	/**
  	 * TODO
  	 *
  	 * @param {Function} callback - TODO.
  	 * @return {ComputeNode} A reference to this node.
  	 */
  	onInit( callback ) {

  		this.onInitFunction = callback;

  		return this;

  	}

  	/**
  	 * The method execute the compute for this node.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	updateBefore( { renderer } ) {

  		renderer.compute( this );

  	}

  	setup( builder ) {

  		const result = this.computeNode.build( builder );

  		if ( result ) {

  			const properties = builder.getNodeProperties( this );
  			properties.outputComputeNode = result.outputNode;

  			result.outputNode = null;

  		}

  		return result;

  	}

  	generate( builder, output ) {

  		const { shaderStage } = builder;

  		if ( shaderStage === 'compute' ) {

  			const snippet = this.computeNode.build( builder, 'void' );

  			if ( snippet !== '' ) {

  				builder.addLineFlowCode( snippet, this );

  			}

  		} else {

  			const properties = builder.getNodeProperties( this );
  			const outputComputeNode = properties.outputComputeNode;

  			if ( outputComputeNode ) {

  				return outputComputeNode.build( builder, output );

  			}

  		}

  	}

  }

  /**
   * TSL function for creating a compute node.
   *
   * @tsl
   * @function
   * @param {Node} node - TODO
   * @param {number} count - TODO.
   * @param {Array<number>} [workgroupSize=[64]] - TODO.
   * @returns {AtomicFunctionNode}
   */
  const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );

  addMethodChaining( 'compute', compute );

  /**
   * This node can be used as a cache management component for another node.
   * Caching is in general used by default in {@link NodeBuilder} but this node
   * allows the usage of a shared parent cache during the build process.
   *
   * @augments Node
   */
  class CacheNode extends Node {

  	static get type() {

  		return 'CacheNode';

  	}

  	/**
  	 * Constructs a new cache node.
  	 *
  	 * @param {Node} node - The node that should be cached.
  	 * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
  	 */
  	constructor( node, parent = true ) {

  		super();

  		/**
  		 * The node that should be cached.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * Whether this node refers to a shared parent cache or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.parent = parent;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCacheNode = true;

  	}

  	getNodeType( builder ) {

  		const previousCache = builder.getCache();
  		const cache = builder.getCacheFromNode( this, this.parent );

  		builder.setCache( cache );

  		const nodeType = this.node.getNodeType( builder );

  		builder.setCache( previousCache );

  		return nodeType;

  	}

  	build( builder, ...params ) {

  		const previousCache = builder.getCache();
  		const cache = builder.getCacheFromNode( this, this.parent );

  		builder.setCache( cache );

  		const data = this.node.build( builder, ...params );

  		builder.setCache( previousCache );

  		return data;

  	}

  }

  /**
   * TSL function for creating a cache node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent] - Whether this node refers to a shared parent cache or not.
   * @returns {CacheNode}
   */
  const cache = ( node, parent ) => nodeObject( new CacheNode( nodeObject( node ), parent ) );

  addMethodChaining( 'cache', cache );

  /**
   * The class generates the code of a given node but returns another node in the output.
   * This can be used to call a method or node that does not return a value, i.e.
   * type `void` on an input where returning a value is required. Example:
   *
   * ```js
   * material.colorNode = myColor.bypass( runVoidFn() )
   *```
   *
   * @augments Node
   */
  class BypassNode extends Node {

  	static get type() {

  		return 'BypassNode';

  	}

  	/**
  	 * Constructs a new bypass node.
  	 *
  	 * @param {Node} outputNode - The output node.
  	 * @param {Node} callNode - The call node.
  	 */
  	constructor( outputNode, callNode ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBypassNode = true;

  		/**
  		 * The output node.
  		 *
  		 * @type {Node}
  		 */
  		this.outputNode = outputNode;

  		/**
  		 * The call node.
  		 *
  		 * @type {Node}
  		 */
  		this.callNode = callNode;

  	}

  	getNodeType( builder ) {

  		return this.outputNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const snippet = this.callNode.build( builder, 'void' );

  		if ( snippet !== '' ) {

  			builder.addLineFlowCode( snippet, this );

  		}

  		return this.outputNode.build( builder );

  	}

  }

  /**
   * TSL function for creating a bypass node.
   *
   * @tsl
   * @function
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   * @returns {BypassNode}
   */
  const bypass = /*@__PURE__*/ nodeProxy( BypassNode ).setParameterLength( 2 );

  addMethodChaining( 'bypass', bypass );

  /**
   * This node allows to remap a node value from one range into another. E.g a value of
   * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.
   * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.
   *
   * @augments Node
   */
  class RemapNode extends Node {

  	static get type() {

  		return 'RemapNode';

  	}

  	/**
  	 * Constructs a new remap node.
  	 *
  	 * @param {Node} node - The node that should be remapped.
  	 * @param {Node} inLowNode - The source or current lower bound of the range.
  	 * @param {Node} inHighNode - The source or current upper bound of the range.
  	 * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
  	 * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
  	 */
  	constructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {

  		super();

  		/**
  		 * The node that should be remapped.
  		 *
  		 * @type {Node}
  		 */
  		this.node = node;

  		/**
  		 * The source or current lower bound of the range.
  		 *
  		 * @type {Node}
  		 */
  		this.inLowNode = inLowNode;

  		/**
  		 * The source or current upper bound of the range.
  		 *
  		 * @type {Node}
  		 */
  		this.inHighNode = inHighNode;

  		/**
  		 * The target lower bound of the range.
  		 *
  		 * @type {Node}
  		 * @default float(0)
  		 */
  		this.outLowNode = outLowNode;

  		/**
  		 * The target upper bound of the range.
  		 *
  		 * @type {Node}
  		 * @default float(1)
  		 */
  		this.outHighNode = outHighNode;

  		/**
  		 * Whether the node value should be clamped before
  		 * remapping it to the target range.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.doClamp = true;

  	}

  	setup() {

  		const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;

  		let t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );

  		if ( doClamp === true ) t = t.clamp();

  		return t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );

  	}

  }

  /**
   * TSL function for creating a remap node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.
   * @returns {RemapNode}
   */
  const remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } ).setParameterLength( 3, 5 );

  /**
   * TSL function for creating a remap node, but with enabled clamping.
   *
   * @tsl
   * @function
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.
   * @returns {RemapNode}
   */
  const remapClamp = /*@__PURE__*/ nodeProxy( RemapNode ).setParameterLength( 3, 5 );

  addMethodChaining( 'remap', remap );
  addMethodChaining( 'remapClamp', remapClamp );

  /**
   * This class can be used to implement basic expressions in shader code.
   * Basic examples for that are `return`, `continue` or `discard` statements.
   *
   * @augments Node
   */
  class ExpressionNode extends Node {

  	static get type() {

  		return 'ExpressionNode';

  	}

  	/**
  	 * Constructs a new expression node.
  	 *
  	 * @param {string} [snippet=''] - The native code snippet.
  	 * @param {string} [nodeType='void'] - The node type.
  	 */
  	constructor( snippet = '', nodeType = 'void' ) {

  		super( nodeType );

  		/**
  		 * The native code snippet.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.snippet = snippet;

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );
  		const snippet = this.snippet;

  		if ( type === 'void' ) {

  			builder.addLineFlowCode( snippet, this );

  		} else {

  			return builder.format( snippet, type, output );

  		}

  	}

  }

  /**
   * TSL function for creating an expression node.
   *
   * @tsl
   * @function
   * @param {string} [snippet] - The native code snippet.
   * @param {?string} [nodeType='void'] - The node type.
   * @returns {ExpressionNode}
   */
  const expression = /*@__PURE__*/ nodeProxy( ExpressionNode ).setParameterLength( 1, 2 );

  /**
   * Represents a `discard` shader operation in TSL.
   *
   * @tsl
   * @function
   * @param {?ConditionalNode} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.
   * @return {Node} The `discard` expression.
   */
  const Discard = ( conditional ) => ( conditional ? select$1( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).toStack();

  addMethodChaining( 'discard', Discard );

  /**
   * Normally, tone mapping and color conversion happens automatically
   * before outputting pixel too the default (screen) framebuffer. In certain
   * post processing setups this happens to late because certain effects
   * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used
   * to apply tone mapping and color space conversion at an arbitrary point
   * in the effect chain.
   *
   * When applying tone mapping and color space conversion manually with this node,
   * you have to set {@link PostProcessing#outputColorTransform} to `false`.
   *
   * ```js
   * const postProcessing = new PostProcessing( renderer );
   * postProcessing.outputColorTransform = false;
   *
   * const scenePass = pass( scene, camera );
   * const outputPass = renderOutput( scenePass );
   *
   * postProcessing.outputNode = outputPass;
   * ```
   *
   * @augments TempNode
   */
  class RenderOutputNode extends TempNode {

  	static get type() {

  		return 'RenderOutputNode';

  	}

  	/**
  	 * Constructs a new render output node.
  	 *
  	 * @param {Node} colorNode - The color node to process.
  	 * @param {?number} toneMapping - The tone mapping type.
  	 * @param {?string} outputColorSpace - The output color space.
  	 */
  	constructor( colorNode, toneMapping, outputColorSpace ) {

  		super( 'vec4' );

  		/**
  		 * The color node to process.
  		 *
  		 * @type {Node}
  		 */
  		this.colorNode = colorNode;

  		/**
  		 * The tone mapping type.
  		 *
  		 * @type {?number}
  		 */
  		this.toneMapping = toneMapping;

  		/**
  		 * The output color space.
  		 *
  		 * @type {?string}
  		 */
  		this.outputColorSpace = outputColorSpace;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRenderOutputNode = true;

  	}

  	setup( { context } ) {

  		let outputNode = this.colorNode || context.color;

  		// tone mapping

  		const toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;
  		const outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;

  		if ( toneMapping !== NoToneMapping ) {

  			outputNode = outputNode.toneMapping( toneMapping );

  		}

  		// working to output color space

  		if ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {

  			outputNode = outputNode.workingToColorSpace( outputColorSpace );

  		}

  		return outputNode;

  	}

  }

  /**
   * TSL function for creating a posterize node.
   *
   * @tsl
   * @function
   * @param {Node} color - The color node to process.
   * @param {?number} [toneMapping=null] - The tone mapping type.
   * @param {?string} [outputColorSpace=null] - The output color space.
   * @returns {RenderOutputNode}
   */
  const renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );

  addMethodChaining( 'renderOutput', renderOutput );

  class DebugNode extends TempNode {

  	static get type() {

  		return 'DebugNode';

  	}

  	constructor( node, callback = null ) {

  		super();

  		this.node = node;
  		this.callback = callback;

  	}

  	getNodeType( builder ) {

  		return this.node.getNodeType( builder );

  	}

  	setup( builder ) {

  		return this.node.build( builder );

  	}

  	analyze( builder ) {

  		return this.node.build( builder );

  	}

  	generate( builder ) {

  		const callback = this.callback;
  		const snippet = this.node.build( builder );

  		const title = '--- TSL debug - ' + builder.shaderStage + ' shader ---';
  		const border = '-'.repeat( title.length );

  		let code = '';
  		code += '// #' + title + '#\n';
  		code += builder.flow.code.replace( /^\t/mg, '' ) + '\n';
  		code += '/* ... */ ' + snippet + ' /* ... */\n';
  		code += '// #' + border + '#\n';

  		if ( callback !== null ) {

  			callback( builder, code );

  		} else {

  			console.log( code );

  		}

  		return snippet;

  	}

  }

  /**
   * TSL function for creating a debug node.
   *
   * @tsl
   * @function
   * @param {Node} node - The node to debug.
   * @param {?Function} [callback=null] - Optional callback function to handle the debug output.
   * @returns {DebugNode}
   */
  const debug = ( node, callback = null ) => nodeObject( new DebugNode( nodeObject( node ), callback ) );

  addMethodChaining( 'debug', debug );

  /**
   * Base class for representing shader attributes as nodes.
   *
   * @augments Node
   */
  class AttributeNode extends Node {

  	static get type() {

  		return 'AttributeNode';

  	}

  	/**
  	 * Constructs a new attribute node.
  	 *
  	 * @param {string} attributeName - The name of the attribute.
  	 * @param {?string} nodeType - The node type.
  	 */
  	constructor( attributeName, nodeType = null ) {

  		super( nodeType );

  		/**
  		 * `AttributeNode` sets this property to `true` by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  		this._attributeName = attributeName;

  	}

  	getHash( builder ) {

  		return this.getAttributeName( builder );

  	}

  	getNodeType( builder ) {

  		let nodeType = this.nodeType;

  		if ( nodeType === null ) {

  			const attributeName = this.getAttributeName( builder );

  			if ( builder.hasGeometryAttribute( attributeName ) ) {

  				const attribute = builder.geometry.getAttribute( attributeName );

  				nodeType = builder.getTypeFromAttribute( attribute );

  			} else {

  				nodeType = 'float';

  			}

  		}

  		return nodeType;

  	}

  	/**
  	 * Sets the attribute name to the given value. The method can be
  	 * overwritten in derived classes if the final name must be computed
  	 * analytically.
  	 *
  	 * @param {string} attributeName - The name of the attribute.
  	 * @return {AttributeNode} A reference to this node.
  	 */
  	setAttributeName( attributeName ) {

  		this._attributeName = attributeName;

  		return this;

  	}

  	/**
  	 * Returns the attribute name of this node. The method can be
  	 * overwritten in derived classes if the final name must be computed
  	 * analytically.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The attribute name.
  	 */
  	getAttributeName( /*builder*/ ) {

  		return this._attributeName;

  	}

  	generate( builder ) {

  		const attributeName = this.getAttributeName( builder );
  		const nodeType = this.getNodeType( builder );
  		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

  		if ( geometryAttribute === true ) {

  			const attribute = builder.geometry.getAttribute( attributeName );
  			const attributeType = builder.getTypeFromAttribute( attribute );

  			const nodeAttribute = builder.getAttribute( attributeName, attributeType );

  			if ( builder.shaderStage === 'vertex' ) {

  				return builder.format( nodeAttribute.name, attributeType, nodeType );

  			} else {

  				const nodeVarying = varying( this );

  				return nodeVarying.build( builder, nodeType );

  			}

  		} else {

  			console.warn( `AttributeNode: Vertex attribute "${ attributeName }" not found on geometry.` );

  			return builder.generateConst( nodeType );

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.global = this.global;
  		data._attributeName = this._attributeName;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.global = data.global;
  		this._attributeName = data._attributeName;

  	}

  }

  /**
   * TSL function for creating an attribute node.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the attribute.
   * @param {?string} [nodeType=null] - The node type.
   * @returns {AttributeNode}
   */
  const attribute = ( name, nodeType = null ) => nodeObject( new AttributeNode( name, nodeType ) );

  /**
   * TSL function for creating an uv attribute node with the given index.
   *
   * @tsl
   * @function
   * @param {number} [index=0] - The uv index.
   * @return {AttributeNode<vec2>} The uv attribute node.
   */
  const uv$1 = ( index = 0 ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );

  /**
   * A node that represents the dimensions of a texture. The texture size is
   * retrieved in the shader via built-in shader functions like `textureDimensions()`
   * or `textureSize()`.
   *
   * @augments Node
   */
  class TextureSizeNode extends Node {

  	static get type() {

  		return 'TextureSizeNode';

  	}

  	/**
  	 * Constructs a new texture size node.
  	 *
  	 * @param {TextureNode} textureNode - A texture node which size should be retrieved.
  	 * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
  	 */
  	constructor( textureNode, levelNode = null ) {

  		super( 'uvec2' );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isTextureSizeNode = true;

  		/**
  		 * A texture node which size should be retrieved.
  		 *
  		 * @type {TextureNode}
  		 */
  		this.textureNode = textureNode;

  		/**
  		 * A level node which defines the requested mip.
  		 *
  		 * @type {Node<int>}
  		 * @default null
  		 */
  		this.levelNode = levelNode;

  	}

  	generate( builder, output ) {

  		const textureProperty = this.textureNode.build( builder, 'property' );
  		const level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );

  		return builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );

  	}

  }

  /**
   * TSL function for creating a texture size node.
   *
   * @tsl
   * @function
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   * @returns {TextureSizeNode}
   */
  const textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode ).setParameterLength( 1, 2 );

  /**
   * A special type of uniform node that computes the
   * maximum mipmap level for a given texture node.
   *
   * ```js
   * const level = maxMipLevel( textureNode );
   * ```
   *
   * @augments UniformNode
   */
  class MaxMipLevelNode extends UniformNode {

  	static get type() {

  		return 'MaxMipLevelNode';

  	}

  	/**
  	 * Constructs a new max mip level node.
  	 *
  	 * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
  	 */
  	constructor( textureNode ) {

  		super( 0 );

  		/**
  		 * The texture node to compute the max mip level for.
  		 *
  		 * @private
  		 * @type {TextureNode}
  		 */
  		this._textureNode = textureNode;

  		/**
  		 * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates
  		 * the texture once per frame in its {@link MaxMipLevelNode#update} method.
  		 *
  		 * @type {string}
  		 * @default 'frame'
  		 */
  		this.updateType = NodeUpdateType.FRAME;

  	}

  	/**
  	 * The texture node to compute the max mip level for.
  	 *
  	 * @readonly
  	 * @type {TextureNode}
  	 */
  	get textureNode() {

  		return this._textureNode;

  	}

  	/**
  	 * The texture.
  	 *
  	 * @readonly
  	 * @type {Texture}
  	 */
  	get texture() {

  		return this._textureNode.value;

  	}

  	update() {

  		const texture = this.texture;
  		const images = texture.images;
  		const image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;

  		if ( image && image.width !== undefined ) {

  			const { width, height } = image;

  			this.value = Math.log2( Math.max( width, height ) );

  		}

  	}

  }

  /**
   * TSL function for creating a max mip level node.
   *
   * @tsl
   * @function
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   * @returns {MaxMipLevelNode}
   */
  const maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode ).setParameterLength( 1 );

  const EmptyTexture$1 = /*@__PURE__*/ new Texture();

  /**
   * This type of uniform node represents a 2D texture.
   *
   * @augments UniformNode
   */
  class TextureNode extends UniformNode {

  	static get type() {

  		return 'TextureNode';

  	}

  	/**
  	 * Constructs a new texture node.
  	 *
  	 * @param {Texture} [value=EmptyTexture] - The texture.
  	 * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
  	 * @param {?Node<int>} [levelNode=null] - The level node.
  	 * @param {?Node<float>} [biasNode=null] - The bias node.
  	 */
  	constructor( value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null ) {

  		super( value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isTextureNode = true;

  		/**
  		 * Represents the texture coordinates.
  		 *
  		 * @type {?Node<vec2|vec3>}
  		 * @default null
  		 */
  		this.uvNode = uvNode;

  		/**
  		 * Represents the mip level that should be selected.
  		 *
  		 * @type {?Node<int>}
  		 * @default null
  		 */
  		this.levelNode = levelNode;

  		/**
  		 * Represents the bias to be applied during level-of-detail computation.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.biasNode = biasNode;

  		/**
  		 * Represents a reference value a texture sample is compared to.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.compareNode = null;

  		/**
  		 * When using texture arrays, the depth node defines the layer to select.
  		 *
  		 * @type {?Node<int>}
  		 * @default null
  		 */
  		this.depthNode = null;

  		/**
  		 * When defined, a texture is sampled using explicit gradients.
  		 *
  		 * @type {?Array<Node<vec2>>}
  		 * @default null
  		 */
  		this.gradNode = null;

  		/**
  		 * Whether texture values should be sampled or fetched.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.sampler = true;

  		/**
  		 * Whether the uv transformation matrix should be
  		 * automatically updated or not. Use `setUpdateMatrix()`
  		 * if you want to change the value of the property.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.updateMatrix = false;

  		/**
  		 * By default the `update()` method is not executed. `setUpdateMatrix()`
  		 * sets the value to `frame` when the uv transformation matrix should
  		 * automatically be updated.
  		 *
  		 * @type {string}
  		 * @default 'none'
  		 */
  		this.updateType = NodeUpdateType.NONE;

  		/**
  		 * The reference node.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.referenceNode = null;

  		/**
  		 * The texture value is stored in a private property.
  		 *
  		 * @private
  		 * @type {Texture}
  		 */
  		this._value = value;

  		/**
  		 * The uniform node that represents the uv transformation matrix.
  		 *
  		 * @private
  		 * @type {?UniformNode<mat3>}
  		 */
  		this._matrixUniform = null;

  		this.setUpdateMatrix( uvNode === null );

  	}

  	set value( value ) {

  		if ( this.referenceNode ) {

  			this.referenceNode.value = value;

  		} else {

  			this._value = value;

  		}

  	}

  	/**
  	 * The texture value.
  	 *
  	 * @type {Texture}
  	 */
  	get value() {

  		return this.referenceNode ? this.referenceNode.value : this._value;

  	}

  	/**
  	 * Overwritten since the uniform hash is defined by the texture's UUID.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The uniform hash.
  	 */
  	getUniformHash( /*builder*/ ) {

  		return this.value.uuid;

  	}

  	/**
  	 * Overwritten since the node type is inferred from the texture type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( /*builder*/ ) {

  		if ( this.value.isDepthTexture === true ) return 'float';

  		if ( this.value.type === UnsignedIntType ) {

  			return 'uvec4';

  		} else if ( this.value.type === IntType ) {

  			return 'ivec4';

  		}

  		return 'vec4';

  	}

  	/**
  	 * Overwrites the default implementation to return a fixed value `'texture'`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( /*builder*/ ) {

  		return 'texture';

  	}

  	/**
  	 * Returns a default uvs based on the current texture's channel.
  	 *
  	 * @return {AttributeNode<vec2>} The default uvs.
  	 */
  	getDefaultUV() {

  		return uv$1( this.value.channel );

  	}

  	/**
  	 * Overwritten to always return the texture reference of the node.
  	 *
  	 * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
  	 * @return {Texture} The texture reference.
  	 */
  	updateReference( /*state*/ ) {

  		return this.value;

  	}

  	/**
  	 * Transforms the given uv node with the texture transformation matrix.
  	 *
  	 * @param {Node} uvNode - The uv node to transform.
  	 * @return {Node} The transformed uv node.
  	 */
  	getTransformedUV( uvNode ) {

  		if ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );

  		return this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;

  	}

  	/**
  	 * Defines whether the uv transformation matrix should automatically be updated or not.
  	 *
  	 * @param {boolean} value - The update toggle.
  	 * @return {TextureNode} A reference to this node.
  	 */
  	setUpdateMatrix( value ) {

  		this.updateMatrix = value;
  		this.updateType = value ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;

  		return this;

  	}

  	/**
  	 * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
  	 * to modify the uv node for correct sampling.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node} uvNode - The uv node to setup.
  	 * @return {Node} The updated uv node.
  	 */
  	setupUV( builder, uvNode ) {

  		const texture = this.value;

  		if ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {

  			if ( this.sampler ) {

  				uvNode = uvNode.flipY();

  			} else {

  				uvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );

  			}

  		}

  		return uvNode;

  	}

  	/**
  	 * Setups texture node by preparing the internal nodes for code generation.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		const properties = builder.getNodeProperties( this );
  		properties.referenceNode = this.referenceNode;

  		//

  		const texture = this.value;

  		if ( ! texture || texture.isTexture !== true ) {

  			throw new Error( 'THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().' );

  		}

  		//

  		let uvNode = this.uvNode;

  		if ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {

  			uvNode = builder.context.getUV( this, builder );

  		}

  		if ( ! uvNode ) uvNode = this.getDefaultUV();

  		if ( this.updateMatrix === true ) {

  			uvNode = this.getTransformedUV( uvNode );

  		}

  		uvNode = this.setupUV( builder, uvNode );

  		//

  		let levelNode = this.levelNode;

  		if ( levelNode === null && builder.context.getTextureLevel ) {

  			levelNode = builder.context.getTextureLevel( this );

  		}

  		//

  		properties.uvNode = uvNode;
  		properties.levelNode = levelNode;
  		properties.biasNode = this.biasNode;
  		properties.compareNode = this.compareNode;
  		properties.gradNode = this.gradNode;
  		properties.depthNode = this.depthNode;

  	}

  	/**
  	 * Generates the uv code snippet.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node} uvNode - The uv node to generate code for.
  	 * @return {string} The generated code snippet.
  	 */
  	generateUV( builder, uvNode ) {

  		return uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );

  	}

  	/**
  	 * Generates the snippet for the texture sampling.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string} textureProperty - The texture property.
  	 * @param {string} uvSnippet - The uv snippet.
  	 * @param {?string} levelSnippet - The level snippet.
  	 * @param {?string} biasSnippet - The bias snippet.
  	 * @param {?string} depthSnippet - The depth snippet.
  	 * @param {?string} compareSnippet - The compare snippet.
  	 * @param {?Array<string>} gradSnippet - The grad snippet.
  	 * @return {string} The generated code snippet.
  	 */
  	generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {

  		const texture = this.value;

  		let snippet;

  		if ( levelSnippet ) {

  			snippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );

  		} else if ( biasSnippet ) {

  			snippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );

  		} else if ( gradSnippet ) {

  			snippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );

  		} else if ( compareSnippet ) {

  			snippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );

  		} else if ( this.sampler === false ) {

  			snippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );

  		} else {

  			snippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );

  		}

  		return snippet;

  	}

  	/**
  	 * Generates the code snippet of the texture node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string} output - The current output.
  	 * @return {string} The generated code snippet.
  	 */
  	generate( builder, output ) {

  		const texture = this.value;

  		const properties = builder.getNodeProperties( this );
  		const textureProperty = super.generate( builder, 'property' );

  		if ( /^sampler/.test( output ) ) {

  			return textureProperty + '_sampler';

  		} else if ( builder.isReference( output ) ) {

  			return textureProperty;

  		} else {

  			const nodeData = builder.getDataFromNode( this );

  			let propertyName = nodeData.propertyName;

  			if ( propertyName === undefined ) {

  				const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;

  				const uvSnippet = this.generateUV( builder, uvNode );
  				const levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;
  				const biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;
  				const depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;
  				const compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;
  				const gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;

  				const nodeVar = builder.getVarFromNode( this );

  				propertyName = builder.getPropertyName( nodeVar );

  				const snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );

  				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

  				nodeData.snippet = snippet;
  				nodeData.propertyName = propertyName;

  			}

  			let snippet = propertyName;
  			const nodeType = this.getNodeType( builder );

  			if ( builder.needsToWorkingColorSpace( texture ) ) {

  				snippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );

  			}

  			return builder.format( snippet, nodeType, output );

  		}

  	}

  	/**
  	 * Sets the sampler value.
  	 *
  	 * @param {boolean} value - The sampler value to set.
  	 * @return {TextureNode} A reference to this texture node.
  	 */
  	setSampler( value ) {

  		this.sampler = value;

  		return this;

  	}

  	/**
  	 * Returns the sampler value.
  	 *
  	 * @return {boolean} The sampler value.
  	 */
  	getSampler() {

  		return this.sampler;

  	}

  	// @TODO: Move to TSL

  	/**
  	 * @function
  	 * @deprecated since r172. Use {@link TextureNode#sample} instead.
  	 *
  	 * @param {Node} uvNode - The uv node.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	uv( uvNode ) { // @deprecated, r172

  		console.warn( 'THREE.TextureNode: .uv() has been renamed. Use .sample() instead.' );

  		return this.sample( uvNode );

  	}

  	/**
  	 * Samples the texture with the given uv node.
  	 *
  	 * @param {Node} uvNode - The uv node.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	sample( uvNode ) {

  		const textureNode = this.clone();
  		textureNode.uvNode = nodeObject( uvNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	/**
  	 * Samples a blurred version of the texture by defining an internal bias.
  	 *
  	 * @param {Node<float>} amountNode - How blurred the texture should be.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	blur( amountNode ) {

  		const textureNode = this.clone();
  		textureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );
  		textureNode.referenceNode = this.getSelf();

  		const map = textureNode.value;

  		if ( textureNode.generateMipmaps === false && ( map && map.generateMipmaps === false || map.minFilter === NearestFilter || map.magFilter === NearestFilter ) ) {

  			console.warn( 'THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.' );

  			textureNode.biasNode = null;

  		}

  		return nodeObject( textureNode );

  	}

  	/**
  	 * Samples a specific mip of the texture.
  	 *
  	 * @param {Node<int>} levelNode - The mip level to sample.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	level( levelNode ) {

  		const textureNode = this.clone();
  		textureNode.levelNode = nodeObject( levelNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	/**
  	 * Returns the texture size of the requested level.
  	 *
  	 * @param {Node<int>} levelNode - The level to compute the size for.
  	 * @return {TextureSizeNode} The texture size.
  	 */
  	size( levelNode ) {

  		return textureSize( this, levelNode );

  	}

  	/**
  	 * Samples the texture with the given bias.
  	 *
  	 * @param {Node<float>} biasNode - The bias node.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	bias( biasNode ) {

  		const textureNode = this.clone();
  		textureNode.biasNode = nodeObject( biasNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	/**
  	 * Samples the texture by executing a compare operation.
  	 *
  	 * @param {Node<float>} compareNode - The node that defines the compare value.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	compare( compareNode ) {

  		const textureNode = this.clone();
  		textureNode.compareNode = nodeObject( compareNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	/**
  	 * Samples the texture using an explicit gradient.
  	 *
  	 * @param {Node<vec2>} gradNodeX - The gradX node.
  	 * @param {Node<vec2>} gradNodeY - The gradY node.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	grad( gradNodeX, gradNodeY ) {

  		const textureNode = this.clone();
  		textureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	/**
  	 * Samples the texture by defining a depth node.
  	 *
  	 * @param {Node<int>} depthNode - The depth node.
  	 * @return {TextureNode} A texture node representing the texture sample.
  	 */
  	depth( depthNode ) {

  		const textureNode = this.clone();
  		textureNode.depthNode = nodeObject( depthNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	// --

  	serialize( data ) {

  		super.serialize( data );

  		data.value = this.value.toJSON( data.meta ).uuid;
  		data.sampler = this.sampler;
  		data.updateMatrix = this.updateMatrix;
  		data.updateType = this.updateType;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.value = data.meta.textures[ data.value ];
  		this.sampler = data.sampler;
  		this.updateMatrix = data.updateMatrix;
  		this.updateType = data.updateType;

  	}

  	/**
  	 * The update is used to implement the update of the uv transformation matrix.
  	 */
  	update() {

  		const texture = this.value;
  		const matrixUniform = this._matrixUniform;

  		if ( matrixUniform !== null ) matrixUniform.value = texture.matrix;

  		if ( texture.matrixAutoUpdate === true ) {

  			texture.updateMatrix();

  		}

  	}

  	/**
  	 * Clones the texture node.
  	 *
  	 * @return {TextureNode} The cloned texture node.
  	 */
  	clone() {

  		const newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );
  		newNode.sampler = this.sampler;
  		newNode.depthNode = this.depthNode;
  		newNode.compareNode = this.compareNode;
  		newNode.gradNode = this.gradNode;

  		return newNode;

  	}

  }

  /**
   * TSL function for creating a texture node.
   *
   * @tsl
   * @function
   * @param {?Texture} value - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   * @returns {TextureNode}
   */
  const textureBase = /*@__PURE__*/ nodeProxy( TextureNode ).setParameterLength( 1, 4 ).setName( 'texture' );

  /**
   * TSL function for creating a texture node or sample a texture node already existing.
   *
   * @tsl
   * @function
   * @param {?Texture|TextureNode} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   * @returns {TextureNode}
   */
  const texture = ( value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null ) => {

  	let textureNode;

  	if ( value && value.isTextureNode === true ) {

  		textureNode = nodeObject( value.clone() );
  		textureNode.referenceNode = value.getSelf(); // Ensure the reference is set to the original node

  		if ( uvNode !== null ) textureNode.uvNode = nodeObject( uvNode );
  		if ( levelNode !== null ) textureNode.levelNode = nodeObject( levelNode );
  		if ( biasNode !== null ) textureNode.biasNode = nodeObject( biasNode );

  	} else {

  		textureNode = textureBase( value, uvNode, levelNode, biasNode );

  	}

  	return textureNode;

  };

  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @tsl
   * @function
   * @param {?Texture|TextureNode} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   * @returns {TextureNode}
   */
  const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );

  /**
   * A special type of uniform node which represents array-like data
   * as uniform buffers. The access usually happens via `element()`
   * which returns an instance of {@link ArrayElementNode}. For example:
   *
   * ```js
   * const bufferNode = buffer( array, 'mat4', count );
   * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
   * ```
   * In general, it is recommended to use the more managed {@link UniformArrayNode}
   * since it handles more input types and automatically cares about buffer paddings.
   *
   * @augments UniformNode
   */
  class BufferNode extends UniformNode {

  	static get type() {

  		return 'BufferNode';

  	}

  	/**
  	 * Constructs a new buffer node.
  	 *
  	 * @param {Array<number>} value - Array-like buffer data.
  	 * @param {string} bufferType - The data type of the buffer.
  	 * @param {number} [bufferCount=0] - The count of buffer elements.
  	 */
  	constructor( value, bufferType, bufferCount = 0 ) {

  		super( value, bufferType );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBufferNode = true;

  		/**
  		 * The data type of the buffer.
  		 *
  		 * @type {string}
  		 */
  		this.bufferType = bufferType;

  		/**
  		 * The uniform node that holds the value of the reference node.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.bufferCount = bufferCount;

  	}

  	/**
  	 * The data type of the buffer elements.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The element type.
  	 */
  	getElementType( builder ) {

  		return this.getNodeType( builder );

  	}

  	/**
  	 * Overwrites the default implementation to return a fixed value `'buffer'`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( /*builder*/ ) {

  		return 'buffer';

  	}

  }

  /**
   * TSL function for creating a buffer node.
   *
   * @tsl
   * @function
   * @param {Array} value - Array-like buffer data.
   * @param {string} type - The data type of a buffer element.
   * @param {number} count - The count of buffer elements.
   * @returns {BufferNode}
   */
  const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );

  /**
   * Represents the element access on uniform array nodes.
   *
   * @augments ArrayElementNode
   */
  class UniformArrayElementNode extends ArrayElementNode {

  	static get type() {

  		return 'UniformArrayElementNode';

  	}

  	/**
  	 * Constructs a new buffer node.
  	 *
  	 * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
  	 * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
  	 */
  	constructor( uniformArrayNode, indexNode ) {

  		super( uniformArrayNode, indexNode );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isArrayBufferElementNode = true;

  	}

  	generate( builder ) {

  		const snippet = super.generate( builder );
  		const type = this.getNodeType();
  		const paddedType = this.node.getPaddedType();

  		return builder.format( snippet, paddedType, type );

  	}

  }

  /**
   * Similar to {@link BufferNode} this module represents array-like data as
   * uniform buffers. Unlike {@link BufferNode}, it can handle more common
   * data types in the array (e.g `three.js` primitives) and automatically
   * manage buffer padding. It should be the first choice when working with
   * uniforms buffers.
   * ```js
   * const tintColors = uniformArray( [
   * 	new Color( 1, 0, 0 ),
   * 	new Color( 0, 1, 0 ),
   * 	new Color( 0, 0, 1 )
   * ], 'color' );
   *
   * const redColor = tintColors.element( 0 );
   *
   * @augments BufferNode
   */
  class UniformArrayNode extends BufferNode {

  	static get type() {

  		return 'UniformArrayNode';

  	}

  	/**
  	 * Constructs a new uniform array node.
  	 *
  	 * @param {Array<any>} value - Array holding the buffer data.
  	 * @param {?string} [elementType=null] - The data type of a buffer element.
  	 */
  	constructor( value, elementType = null ) {

  		super( null );

  		/**
  		 * Array holding the buffer data. Unlike {@link BufferNode}, the array can
  		 * hold number primitives as well as three.js objects like vectors, matrices
  		 * or colors.
  		 *
  		 * @type {Array<any>}
  		 */
  		this.array = value;

  		/**
  		 * The data type of an array element.
  		 *
  		 * @type {string}
  		 */
  		this.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;

  		/**
  		 * The padded type. Uniform buffers must conform to a certain buffer layout
  		 * so a separate type is computed to ensure correct buffer size.
  		 *
  		 * @type {string}
  		 */
  		this.paddedType = this.getPaddedType();

  		/**
  		 * Overwritten since uniform array nodes are updated per render.
  		 *
  		 * @type {string}
  		 * @default 'render'
  		 */
  		this.updateType = NodeUpdateType.RENDER;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isArrayBufferNode = true;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from the
  	 * {@link UniformArrayNode#paddedType}.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( /*builder*/ ) {

  		return this.paddedType;

  	}

  	/**
  	 * The data type of the array elements.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The element type.
  	 */
  	getElementType() {

  		return this.elementType;

  	}

  	/**
  	 * Returns the padded type based on the element type.
  	 *
  	 * @return {string} The padded type.
  	 */
  	getPaddedType() {

  		const elementType = this.elementType;

  		let paddedType = 'vec4';

  		if ( elementType === 'mat2' ) {

  			paddedType = 'mat2';

  		} else if ( /mat/.test( elementType ) === true ) {

  			paddedType = 'mat4';

  		} else if ( elementType.charAt( 0 ) === 'i' ) {

  			paddedType = 'ivec4';

  		} else if ( elementType.charAt( 0 ) === 'u' ) {

  			paddedType = 'uvec4';

  		}

  		return paddedType;

  	}

  	/**
  	 * The update makes sure to correctly transfer the data from the (complex) objects
  	 * in the array to the internal, correctly padded value buffer.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( /*frame*/ ) {

  		const { array, value } = this;

  		const elementType = this.elementType;

  		if ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;

  				value[ index ] = array[ i ];

  			}

  		} else if ( elementType === 'color' ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;
  				const vector = array[ i ];

  				value[ index ] = vector.r;
  				value[ index + 1 ] = vector.g;
  				value[ index + 2 ] = vector.b || 0;
  				//value[ index + 3 ] = vector.a || 0;

  			}

  		} else if ( elementType === 'mat2' ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;
  				const matrix = array[ i ];

  				value[ index ] = matrix.elements[ 0 ];
  				value[ index + 1 ] = matrix.elements[ 1 ];
  				value[ index + 2 ] = matrix.elements[ 2 ];
  				value[ index + 3 ] = matrix.elements[ 3 ];

  			}

  		} else if ( elementType === 'mat3' ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 16;
  				const matrix = array[ i ];

  				value[ index ] = matrix.elements[ 0 ];
  				value[ index + 1 ] = matrix.elements[ 1 ];
  				value[ index + 2 ] = matrix.elements[ 2 ];

  				value[ index + 4 ] = matrix.elements[ 3 ];
  				value[ index + 5 ] = matrix.elements[ 4 ];
  				value[ index + 6 ] = matrix.elements[ 5 ];

  				value[ index + 8 ] = matrix.elements[ 6 ];
  				value[ index + 9 ] = matrix.elements[ 7 ];
  				value[ index + 10 ] = matrix.elements[ 8 ];

  				value[ index + 15 ] = 1;

  			}

  		} else if ( elementType === 'mat4' ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 16;
  				const matrix = array[ i ];

  				for ( let i = 0; i < matrix.elements.length; i ++ ) {

  					value[ index + i ] = matrix.elements[ i ];

  				}

  			}

  		} else {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;
  				const vector = array[ i ];

  				value[ index ] = vector.x;
  				value[ index + 1 ] = vector.y;
  				value[ index + 2 ] = vector.z || 0;
  				value[ index + 3 ] = vector.w || 0;

  			}

  		}

  	}

  	/**
  	 * Implement the value buffer creation based on the array data.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @return {null}
  	 */
  	setup( builder ) {

  		const length = this.array.length;
  		const elementType = this.elementType;

  		let arrayType = Float32Array;

  		const paddedType = this.paddedType;
  		const paddedElementLength = builder.getTypeLength( paddedType );

  		if ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;
  		if ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;

  		this.value = new arrayType( length * paddedElementLength );
  		this.bufferCount = length;
  		this.bufferType = paddedType;

  		return super.setup( builder );

  	}

  	/**
  	 * Overwrites the default `element()` method to provide element access
  	 * based on {@link UniformArrayNode}.
  	 *
  	 * @param {IndexNode} indexNode - The index node.
  	 * @return {UniformArrayElementNode}
  	 */
  	element( indexNode ) {

  		return nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );

  	}

  }

  /**
   * TSL function for creating an uniform array node.
   *
   * @tsl
   * @function
   * @param {Array<any>} values - Array-like data.
   * @param {?string} [nodeType] - The data type of the array elements.
   * @returns {UniformArrayNode}
   */
  const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );

  /**
   * The node allows to set values for built-in shader variables. That is
   * required for features like hardware-accelerated vertex clipping.
   *
   * @augments Node
   */
  class BuiltinNode extends Node {

  	/**
  	 * Constructs a new builtin node.
  	 *
  	 * @param {string} name - The name of the built-in shader variable.
  	 */
  	constructor( name ) {

  		super( 'float' );

  		/**
  		 * The name of the built-in shader variable.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBuiltinNode = true;

  	}

  	/**
  	 * Generates the code snippet of the builtin node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The generated code snippet.
  	 */
  	generate( /* builder */ ) {

  		return this.name;

  	}

  }

  /**
   * TSL function for creating a builtin node.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the built-in shader variable.
   * @returns {BuiltinNode}
   */
  const builtin = nodeProxy( BuiltinNode ).setParameterLength( 1 );

  /**
   * TSL object that represents the current `index` value of the camera if used ArrayCamera.
   *
   * @tsl
   * @type {UniformNode<uint>}
   */
  const cameraIndex = /*@__PURE__*/ uniform( 0, 'uint' ).label( 'u_cameraIndex' ).setGroup( sharedUniformGroup( 'cameraIndex' ) ).toVarying( 'v_cameraIndex' );

  /**
   * TSL object that represents the `near` value of the camera used for the current render.
   *
   * @tsl
   * @type {UniformNode<float>}
   */
  const cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );

  /**
   * TSL object that represents the `far` value of the camera used for the current render.
   *
   * @tsl
   * @type {UniformNode<float>}
   */
  const cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );

  /**
   * TSL object that represents the projection matrix of the camera used for the current render.
   *
   * @tsl
   * @type {UniformNode<mat4>}
   */
  const cameraProjectionMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {

  	let cameraProjectionMatrix;

  	if ( camera.isArrayCamera && camera.cameras.length > 0 ) {

  		const matrices = [];

  		for ( const subCamera of camera.cameras ) {

  			matrices.push( subCamera.projectionMatrix );

  		}

  		const cameraProjectionMatrices = uniformArray( matrices ).setGroup( renderGroup ).label( 'cameraProjectionMatrices' );

  		cameraProjectionMatrix = cameraProjectionMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toVar( 'cameraProjectionMatrix' );

  	} else {

  		cameraProjectionMatrix = uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );

  	}

  	return cameraProjectionMatrix;

  } ).once() )();

  /**
   * TSL object that represents the view matrix of the camera used for the current render.
   *
   * @tsl
   * @type {UniformNode<mat4>}
   */
  const cameraViewMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {

  	let cameraViewMatrix;

  	if ( camera.isArrayCamera && camera.cameras.length > 0 ) {

  		const matrices = [];

  		for ( const subCamera of camera.cameras ) {

  			matrices.push( subCamera.matrixWorldInverse );

  		}

  		const cameraViewMatrices = uniformArray( matrices ).setGroup( renderGroup ).label( 'cameraViewMatrices' );

  		cameraViewMatrix = cameraViewMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toVar( 'cameraViewMatrix' );

  	} else {

  		cameraViewMatrix = uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );

  	}

  	return cameraViewMatrix;

  } ).once() )();

  /**
   * TSL object that represents the position in world space of the camera used for the current render.
   *
   * @tsl
   * @type {UniformNode<vec3>}
   */
  const cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );

  const _sphere = /*@__PURE__*/ new Sphere();

  /**
   * This node can be used to access transformation related metrics of 3D objects.
   * Depending on the selected scope, a different metric is represented as a uniform
   * in the shader. The following scopes are supported:
   *
   * - `POSITION`: The object's position in world space.
   * - `VIEW_POSITION`: The object's position in view/camera space.
   * - `DIRECTION`: The object's direction in world space.
   * - `SCALE`: The object's scale in world space.
   * - `WORLD_MATRIX`: The object's matrix in world space.
   *
   * @augments Node
   */
  class Object3DNode extends Node {

  	static get type() {

  		return 'Object3DNode';

  	}

  	/**
  	 * Constructs a new object 3D node.
  	 *
  	 * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
  	 * @param {?Object3D} [object3d=null] - The 3D object.
  	 */
  	constructor( scope, object3d = null ) {

  		super();

  		/**
  		 * The node reports a different type of transformation depending on the scope.
  		 *
  		 * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}
  		 */
  		this.scope = scope;

  		/**
  		 * The 3D object.
  		 *
  		 * @type {?Object3D}
  		 * @default null
  		 */
  		this.object3d = object3d;

  		/**
  		 * Overwritten since this type of node is updated per object.
  		 *
  		 * @type {string}
  		 * @default 'object'
  		 */
  		this.updateType = NodeUpdateType.OBJECT;

  		/**
  		 * Holds the value of the node as a uniform.
  		 *
  		 * @type {UniformNode}
  		 */
  		this.uniformNode = new UniformNode( null );

  	}

  	/**
  	 * Overwritten since the node type is inferred from the scope.
  	 *
  	 * @return {string} The node type.
  	 */
  	getNodeType() {

  		const scope = this.scope;

  		if ( scope === Object3DNode.WORLD_MATRIX ) {

  			return 'mat4';

  		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

  			return 'vec3';

  		} else if ( scope === Object3DNode.RADIUS ) {

  			return 'float';

  		}

  	}

  	/**
  	 * Updates the uniform value depending on the scope.
  	 *
  	 * @param {NodeFrame} frame - The current node frame.
  	 */
  	update( frame ) {

  		const object = this.object3d;
  		const uniformNode = this.uniformNode;
  		const scope = this.scope;

  		if ( scope === Object3DNode.WORLD_MATRIX ) {

  			uniformNode.value = object.matrixWorld;

  		} else if ( scope === Object3DNode.POSITION ) {

  			uniformNode.value = uniformNode.value || new Vector3();

  			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

  		} else if ( scope === Object3DNode.SCALE ) {

  			uniformNode.value = uniformNode.value || new Vector3();

  			uniformNode.value.setFromMatrixScale( object.matrixWorld );

  		} else if ( scope === Object3DNode.DIRECTION ) {

  			uniformNode.value = uniformNode.value || new Vector3();

  			object.getWorldDirection( uniformNode.value );

  		} else if ( scope === Object3DNode.VIEW_POSITION ) {

  			const camera = frame.camera;

  			uniformNode.value = uniformNode.value || new Vector3();
  			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

  			uniformNode.value.applyMatrix4( camera.matrixWorldInverse );

  		} else if ( scope === Object3DNode.RADIUS ) {

  			const geometry = frame.object.geometry;

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

  			uniformNode.value = _sphere.radius;

  		}

  	}

  	/**
  	 * Generates the code snippet of the uniform node. The node type of the uniform
  	 * node also depends on the selected scope.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The generated code snippet.
  	 */
  	generate( builder ) {

  		const scope = this.scope;

  		if ( scope === Object3DNode.WORLD_MATRIX ) {

  			this.uniformNode.nodeType = 'mat4';

  		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

  			this.uniformNode.nodeType = 'vec3';

  		} else if ( scope === Object3DNode.RADIUS ) {

  			this.uniformNode.nodeType = 'float';

  		}

  		return this.uniformNode.build( builder );

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.scope = this.scope;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.scope = data.scope;

  	}

  }

  Object3DNode.WORLD_MATRIX = 'worldMatrix';
  Object3DNode.POSITION = 'position';
  Object3DNode.SCALE = 'scale';
  Object3DNode.VIEW_POSITION = 'viewPosition';
  Object3DNode.DIRECTION = 'direction';
  Object3DNode.RADIUS = 'radius';

  /**
   * TSL function for creating an object 3D node that represents the object's position in world space.
   *
   * @tsl
   * @function
   * @param {?Object3D} [object3d] - The 3D object.
   * @returns {Object3DNode<vec3>}
   */
  const objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION ).setParameterLength( 1 );

  /**
   * This type of node is a specialized version of `Object3DNode`
   * with larger set of model related metrics. Unlike `Object3DNode`,
   * `ModelNode` extracts the reference to the 3D object from the
   * current node frame state.
   *
   * @augments Object3DNode
   */
  class ModelNode extends Object3DNode {

  	static get type() {

  		return 'ModelNode';

  	}

  	/**
  	 * Constructs a new object model node.
  	 *
  	 * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
  	 */
  	constructor( scope ) {

  		super( scope );

  	}

  	/**
  	 * Extracts the model reference from the frame state and then
  	 * updates the uniform value depending on the scope.
  	 *
  	 * @param {NodeFrame} frame - The current node frame.
  	 */
  	update( frame ) {

  		this.object3d = frame.object;

  		super.update( frame );

  	}

  }

  /**
   * TSL object that represents the object's direction in world space.
   *
   * @tsl
   * @type {ModelNode<vec3>}
   */
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );

  /**
   * TSL object that represents the object's world matrix.
   *
   * @tsl
   * @type {ModelNode<mat4>}
   */
  const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );

  /**
   * TSL object that represents the object's position in world space.
   *
   * @tsl
   * @type {ModelNode<vec3>}
   */
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );

  /**
   * TSL object that represents the object's scale in world space.
   *
   * @tsl
   * @type {ModelNode<vec3>}
   */
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );

  /**
   * TSL object that represents the object's position in view/camera space.
   *
   * @tsl
   * @type {ModelNode<vec3>}
   */
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );

  /**
   * TSL object that represents the object's radius.
   *
   * @tsl
   * @type {ModelNode<float>}
   */
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.RADIUS );

  /**
   * TSL object that represents the object's normal matrix.
   *
   * @tsl
   * @type {UniformNode<mat3>}
   */
  const modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );

  /**
   * TSL object that represents the object's model view matrix.
   *
   * @tsl
   * @type {Node<mat4>}
   */
  const modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

  	return builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix;

  } ).once() )().toVar( 'modelViewMatrix' );

  // GPU Precision

  /**
   * TSL object that represents the object's model view in `mediump` precision.
   *
   * @tsl
   * @type {Node<mat4>}
   */
  const mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );

  // CPU Precision

  /**
   * TSL object that represents the object's model view in `highp` precision
   * which is achieved by computing the matrix in JS and not in the shader.
   *
   * @tsl
   * @type {Node<mat4>}
   */
  const highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

  	builder.context.isHighPrecisionModelViewMatrix = true;

  	return uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {

  		return object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

  	} );

  } ).once() )().toVar( 'highpModelViewMatrix' );

  /**
   * TSL object that represents the object's model normal view in `highp` precision
   * which is achieved by computing the matrix in JS and not in the shader.
   *
   * @tsl
   * @type {Node<mat3>}
   */
  const highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

  	const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;

  	return uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {

  		if ( isHighPrecisionModelViewMatrix !== true ) {

  			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

  		}

  		return object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  	} );

  } ).once() )().toVar( 'highpModelNormalViewMatrix' );

  /**
   * TSL object that represents the position attribute of the current rendered object.
   *
   * @tsl
   * @type {AttributeNode<vec3>}
   */
  const positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );

  /**
   * TSL object that represents the vertex position in local space of the current rendered object.
   *
   * @tsl
   * @type {AttributeNode<vec3>}
   */
  const positionLocal = /*@__PURE__*/ positionGeometry.toVarying( 'positionLocal' );

  /**
   * TSL object that represents the previous vertex position in local space of the current rendered object.
   * Used in context of {@link VelocityNode} for rendering motion vectors.
   *
   * @tsl
   * @type {AttributeNode<vec3>}
   */
  const positionPrevious = /*@__PURE__*/ positionGeometry.toVarying( 'positionPrevious' );

  /**
   * TSL object that represents the vertex position in world space of the current rendered object.
   *
   * @tsl
   * @type {VaryingNode<vec3>}
   */
  const positionWorld = /*@__PURE__*/ ( Fn( ( builder ) => {

  	return modelWorldMatrix.mul( positionLocal ).xyz.toVarying( builder.getSubBuildProperty( 'v_positionWorld' ) );

  }, 'vec3' ).once( [ 'POSITION' ] ) )();

  /**
   * TSL object that represents the position world direction of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const positionWorldDirection = /*@__PURE__*/ ( Fn( () => {

  	const vertexPWD = positionLocal.transformDirection( modelWorldMatrix ).toVarying( 'v_positionWorldDirection' );

  	return vertexPWD.normalize().toVar( 'positionWorldDirection' );

  }, 'vec3' ).once( [ 'POSITION' ] ) )();

  /**
   * TSL object that represents the vertex position in view space of the current rendered object.
   *
   * @tsl
   * @type {VaryingNode<vec3>}
   */
  const positionView = /*@__PURE__*/ ( Fn( ( builder ) => {

  	return builder.context.setupPositionView().toVarying( 'v_positionView' );

  }, 'vec3' ).once( [ 'POSITION' ] ) )();

  /**
   * TSL object that represents the position view direction of the current rendered object.
   *
   * @tsl
   * @type {VaryingNode<vec3>}
   */
  const positionViewDirection = /*@__PURE__*/ positionView.negate().toVarying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );

  /**
   * This node can be used to evaluate whether a primitive is front or back facing.
   *
   * @augments Node
   */
  class FrontFacingNode extends Node {

  	static get type() {

  		return 'FrontFacingNode';

  	}

  	/**
  	 * Constructs a new front facing node.
  	 */
  	constructor() {

  		super( 'bool' );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isFrontFacingNode = true;

  	}

  	generate( builder ) {

  		if ( builder.shaderStage !== 'fragment' ) return 'true';

  		//

  		const { renderer, material } = builder;

  		if ( renderer.coordinateSystem === WebGLCoordinateSystem ) {

  			if ( material.side === BackSide ) {

  				return 'false';

  			}

  		}

  		return builder.getFrontFacing();

  	}

  }

  /**
   * TSL object that represents whether a primitive is front or back facing
   *
   * @tsl
   * @type {FrontFacingNode<bool>}
   */
  const frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );

  /**
   * TSL object that represents the front facing status as a number instead of a bool.
   * `1` means front facing, `-1` means back facing.
   *
   * @tsl
   * @type {Node<float>}
   */
  const faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );

  /**
   * Converts a direction vector to a face direction vector based on the material's side.
   *
   * If the material is set to `BackSide`, the direction is inverted.
   * If the material is set to `DoubleSide`, the direction is multiplied by `faceDirection`.
   *
   * @tsl
   * @param {Node<vec3>} direction - The direction vector to convert.
   * @returns {Node<vec3>} The converted direction vector.
   */
  const directionToFaceDirection = /*@__PURE__*/ Fn( ( [ direction ], { material } ) => {

  	const side = material.side;

  	if ( side === BackSide ) {

  		direction = direction.mul( -1 );

  	} else if ( side === DoubleSide ) {

  		direction = direction.mul( faceDirection );

  	}

  	return direction;

  } );

  /**
   * TSL object that represents the normal attribute of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );

  /**
   * TSL object that represents the vertex normal in local space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {

  	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

  		console.warn( 'THREE.TSL: Vertex attribute "normal" not found on geometry.' );

  		return vec3( 0, 1, 0 );

  	}

  	return normalGeometry;

  }, 'vec3' ).once() )().toVar( 'normalLocal' );

  /**
   * TSL object that represents the flat vertex normal in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );

  /**
   * TSL object that represents the vertex normal in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalViewGeometry = /*@__PURE__*/ ( Fn( ( builder ) => {

  	let node;

  	if ( builder.material.flatShading === true ) {

  		node = normalFlat;

  	} else {

  		node = transformNormalToView( normalLocal ).toVarying( 'v_normalViewGeometry' ).normalize();

  	}

  	return node;

  }, 'vec3' ).once() )().toVar( 'normalViewGeometry' );

  /**
   * TSL object that represents the vertex normal in world space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalWorldGeometry = /*@__PURE__*/ ( Fn( ( builder ) => {

  	let normal = normalViewGeometry.transformDirection( cameraViewMatrix );

  	if ( builder.material.flatShading !== true ) {

  		normal = normal.toVarying( 'v_normalWorldGeometry' );

  	}

  	return normal.normalize().toVar( 'normalWorldGeometry' );

  }, 'vec3' ).once() )();

  /**
   * TSL object that represents the transformed vertex normal in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalView = /*@__PURE__*/ ( Fn( ( { subBuildFn, material, context } ) => {

  	let node;

  	if ( subBuildFn === 'NORMAL' || subBuildFn === 'VERTEX' ) {

  		node = normalViewGeometry;

  		if ( material.flatShading !== true ) {

  			node = directionToFaceDirection( node );

  		}

  	} else {

  		// Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)

  		node = context.setupNormal().context( { getUV: null } );

  	}

  	return node;

  }, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'normalView' );

  /**
   * TSL object that represents the transformed vertex normal in world space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const normalWorld = /*@__PURE__*/ normalView.transformDirection( cameraViewMatrix ).toVar( 'normalWorld' );

  /**
   * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const clearcoatNormalView = /*@__PURE__*/ ( Fn( ( { subBuildFn, context } ) => {

  	let node;

  	if ( subBuildFn === 'NORMAL' || subBuildFn === 'VERTEX' ) {

  		node = normalView;

  	} else {

  		// Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)

  		node = context.setupClearcoatNormal().context( { getUV: null } );

  	}

  	return node;

  }, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'clearcoatNormalView' );

  /**
   * Transforms the normal with the given matrix.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} normal - The normal.
   * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.
   * @return {Node<vec3>} The transformed normal.
   */
  const transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {

  	const m = mat3( matrix );

  	const transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );

  	return m.mul( transformedNormal ).xyz;

  } );

  /**
   * Transforms the given normal from local to view space.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} normal - The normal.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed normal.
   */
  const transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {

  	const modelNormalViewMatrix = builder.renderer.overrideNodes.modelNormalViewMatrix;

  	if ( modelNormalViewMatrix !== null ) {

  		return modelNormalViewMatrix.transformDirection( normal );

  	}

  	//

  	const transformedNormal = modelNormalMatrix.mul( normal );

  	return cameraViewMatrix.transformDirection( transformedNormal );

  } );

  // Deprecated

  /**
   * TSL object that represents the transformed vertex normal in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   * @deprecated since r178. Use `normalView` instead.
   */
  ( Fn( () => { // @deprecated, r177

  	console.warn( 'THREE.TSL: "transformedNormalView" is deprecated. Use "normalView" instead.' );
  	return normalView;

  } ).once( [ 'NORMAL', 'VERTEX' ] ) )();

  /**
   * TSL object that represents the transformed vertex normal in world space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   * @deprecated since r178. Use `normalWorld` instead.
   */
  ( Fn( () => { // @deprecated, r177

  	console.warn( 'THREE.TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.' );
  	return normalWorld;

  } ).once( [ 'NORMAL', 'VERTEX' ] ) )();

  /**
   * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   * @deprecated since r178. Use `clearcoatNormalView` instead.
   */
  ( Fn( () => { // @deprecated, r177

  	console.warn( 'THREE.TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.' );
  	return clearcoatNormalView;

  } ).once( [ 'NORMAL', 'VERTEX' ] ) )();

  const _e1$1 = /*@__PURE__*/ new Euler();
  const _m1$1 = /*@__PURE__*/ new Matrix4();

  /**
   * TSL object that represents the refraction ratio of the material used for rendering the current object.
   *
   * @tsl
   * @type {UniformNode<float>}
   */
  const materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onObjectUpdate( ( { material } ) => material.refractionRatio );

  /**
   * TSL object that represents the intensity of environment maps of PBR materials.
   * When `material.envMap` is set, the value is `material.envMapIntensity` otherwise `scene.environmentIntensity`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialEnvIntensity = /*@__PURE__*/ uniform( 1 ).onReference( ( { material } ) => material ).onObjectUpdate( function ( { material, scene } ) {

  	return material.envMap ? material.envMapIntensity : scene.environmentIntensity;

  } );

  /**
   * TSL object that represents the rotation of environment maps.
   * When `material.envMap` is set, the value is `material.envMapRotation`. `scene.environmentRotation` controls the
   * rotation of `scene.environment` instead.
   *
   * @tsl
   * @type {Node<mat4>}
   */
  const materialEnvRotation = /*@__PURE__*/ uniform( new Matrix4() ).onReference( function ( frame ) {

  	return frame.material;

  } ).onObjectUpdate( function ( { material, scene } ) {

  	const rotation = ( scene.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

  	if ( rotation ) {

  		_e1$1.copy( rotation );

  		_m1$1.makeRotationFromEuler( _e1$1 );

  	} else {

  		_m1$1.identity();

  	}

  	return _m1$1;

  } );

  /**
   * The reflect vector in view space.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( normalView );

  /**
   * The refract vector in view space.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const refractView = /*@__PURE__*/ positionViewDirection.negate().refract( normalView, materialRefractionRatio );

  /**
   * Used for sampling cube maps when using cube reflection mapping.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );

  /**
   * Used for sampling cube maps when using cube refraction mapping.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );

  const EmptyTexture = /*@__PURE__*/ new CubeTexture();

  /**
   * This type of uniform node represents a cube texture.
   *
   * @augments TextureNode
   */
  class CubeTextureNode extends TextureNode {

  	static get type() {

  		return 'CubeTextureNode';

  	}

  	/**
  	 * Constructs a new cube texture node.
  	 *
  	 * @param {CubeTexture} value - The cube texture.
  	 * @param {?Node<vec3>} [uvNode=null] - The uv node.
  	 * @param {?Node<int>} [levelNode=null] - The level node.
  	 * @param {?Node<float>} [biasNode=null] - The bias node.
  	 */
  	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

  		super( value, uvNode, levelNode, biasNode );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCubeTextureNode = true;

  	}

  	/**
  	 * Overwrites the default implementation to return a fixed value `'cubeTexture'`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( /*builder*/ ) {

  		return 'cubeTexture';

  	}

  	/**
  	 * Returns a default uvs based on the mapping type of the cube texture.
  	 *
  	 * @return {Node<vec3>} The default uv attribute.
  	 */
  	getDefaultUV() {

  		const texture = this.value;

  		if ( texture.mapping === CubeReflectionMapping ) {

  			return reflectVector;

  		} else if ( texture.mapping === CubeRefractionMapping ) {

  			return refractVector;

  		} else {

  			console.error( 'THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping );

  			return vec3( 0, 0, 0 );

  		}

  	}

  	/**
  	 * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
  	 * for cube textures. The uv transformation matrix is not applied to cube textures.
  	 *
  	 * @param {boolean} value - The update toggle.
  	 */
  	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode

  	/**
  	 * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
  	 * to modify the uv node for correct sampling.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node} uvNode - The uv node to setup.
  	 * @return {Node} The updated uv node.
  	 */
  	setupUV( builder, uvNode ) {

  		const texture = this.value;

  		if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {

  			uvNode = vec3( uvNode.x.negate(), uvNode.yz );

  		}

  		return materialEnvRotation.mul( uvNode );

  	}

  	/**
  	 * Generates the uv code snippet.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node} cubeUV - The uv node to generate code for.
  	 * @return {string} The generated code snippet.
  	 */
  	generateUV( builder, cubeUV ) {

  		return cubeUV.build( builder, 'vec3' );

  	}

  }

  /**
   * TSL function for creating a cube texture node.
   *
   * @tsl
   * @function
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   * @returns {CubeTextureNode}
   */
  const cubeTextureBase = /*@__PURE__*/ nodeProxy( CubeTextureNode ).setParameterLength( 1, 4 ).setName( 'cubeTexture' );

  /**
   * TSL function for creating a cube texture uniform node.
   *
   * @tsl
   * @function
   * @param {?CubeTexture|CubeTextureNode} [value=EmptyTexture] - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   * @returns {CubeTextureNode}
   */
  const cubeTexture = ( value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null ) => {

  	let textureNode;

  	if ( value && value.isCubeTextureNode === true ) {

  		textureNode = nodeObject( value.clone() );
  		textureNode.referenceNode = value.getSelf(); // Ensure the reference is set to the original node

  		if ( uvNode !== null ) textureNode.uvNode = nodeObject( uvNode );
  		if ( levelNode !== null ) textureNode.levelNode = nodeObject( levelNode );
  		if ( biasNode !== null ) textureNode.biasNode = nodeObject( biasNode );

  	} else {

  		textureNode = cubeTextureBase( value, uvNode, levelNode, biasNode );

  	}

  	return textureNode;

  };

  // TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode

  /**
   * This class is only relevant if the referenced property is array-like.
   * In this case, `ReferenceElementNode` allows to refer to a specific
   * element inside the data structure via an index.
   *
   * @augments ArrayElementNode
   */
  class ReferenceElementNode extends ArrayElementNode {

  	static get type() {

  		return 'ReferenceElementNode';

  	}

  	/**
  	 * Constructs a new reference element node.
  	 *
  	 * @param {?ReferenceNode} referenceNode - The reference node.
  	 * @param {Node} indexNode - The index node that defines the element access.
  	 */
  	constructor( referenceNode, indexNode ) {

  		super( referenceNode, indexNode );

  		/**
  		 * Similar to {@link ReferenceNode#reference}, an additional
  		 * property references to the current node.
  		 *
  		 * @type {?ReferenceNode}
  		 * @default null
  		 */
  		this.referenceNode = referenceNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isReferenceElementNode = true;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from
  	 * the uniform type of the reference node.
  	 *
  	 * @return {string} The node type.
  	 */
  	getNodeType() {

  		return this.referenceNode.uniformType;

  	}

  	generate( builder ) {

  		const snippet = super.generate( builder );
  		const arrayType = this.referenceNode.getNodeType();
  		const elementType = this.getNodeType();

  		return builder.format( snippet, arrayType, elementType );

  	}

  }

  /**
   * This type of node establishes a reference to a property of another object.
   * In this way, the value of the node is automatically linked to the value of
   * referenced object. Reference nodes internally represent the linked value
   * as a uniform.
   *
   * @augments Node
   */
  class ReferenceNode extends Node {

  	static get type() {

  		return 'ReferenceNode';

  	}

  	/**
  	 * Constructs a new reference node.
  	 *
  	 * @param {string} property - The name of the property the node refers to.
  	 * @param {string} uniformType - The uniform type that should be used to represent the property value.
  	 * @param {?Object} [object=null] - The object the property belongs to.
  	 * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
  	 */
  	constructor( property, uniformType, object = null, count = null ) {

  		super();

  		/**
  		 * The name of the property the node refers to.
  		 *
  		 * @type {string}
  		 */
  		this.property = property;

  		/**
  		 * The uniform type that should be used to represent the property value.
  		 *
  		 * @type {string}
  		 */
  		this.uniformType = uniformType;

  		/**
  		 * The object the property belongs to.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.object = object;

  		/**
  		 * When the linked property is an array, this parameter defines its length.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this.count = count;

  		/**
  		 * The property name might have dots so nested properties can be referred.
  		 * The hierarchy of the names is stored inside this array.
  		 *
  		 * @type {Array<string>}
  		 */
  		this.properties = property.split( '.' );

  		/**
  		 * Points to the current referred object. This property exists next to {@link ReferenceNode#object}
  		 * since the final reference might be updated from calling code.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.reference = object;

  		/**
  		 * The uniform node that holds the value of the reference node.
  		 *
  		 * @type {UniformNode}
  		 * @default null
  		 */
  		this.node = null;

  		/**
  		 * The uniform group of the internal uniform.
  		 *
  		 * @type {UniformGroupNode}
  		 * @default null
  		 */
  		this.group = null;

  		/**
  		 * An optional label of the internal uniform node.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.name = null;

  		/**
  		 * Overwritten since reference nodes are updated per object.
  		 *
  		 * @type {string}
  		 * @default 'object'
  		 */
  		this.updateType = NodeUpdateType.OBJECT;

  	}

  	/**
  	 * When the referred property is array-like, this method can be used
  	 * to access elements via an index node.
  	 *
  	 * @param {IndexNode} indexNode - indexNode.
  	 * @return {ReferenceElementNode} A reference to an element.
  	 */
  	element( indexNode ) {

  		return nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );

  	}

  	/**
  	 * Sets the uniform group for this reference node.
  	 *
  	 * @param {UniformGroupNode} group - The uniform group to set.
  	 * @return {ReferenceNode} A reference to this node.
  	 */
  	setGroup( group ) {

  		this.group = group;

  		return this;

  	}

  	/**
  	 * Sets the label for the internal uniform.
  	 *
  	 * @param {string} name - The label to set.
  	 * @return {ReferenceNode} A reference to this node.
  	 */
  	label( name ) {

  		this.name = name;

  		return this;

  	}

  	/**
  	 * Sets the node type which automatically defines the internal
  	 * uniform type.
  	 *
  	 * @param {string} uniformType - The type to set.
  	 */
  	setNodeType( uniformType ) {

  		let node = null;

  		if ( this.count !== null ) {

  			node = buffer( null, uniformType, this.count );

  		} else if ( Array.isArray( this.getValueFromReference() ) ) {

  			node = uniformArray( null, uniformType );

  		} else if ( uniformType === 'texture' ) {

  			node = texture( null );

  		} else if ( uniformType === 'cubeTexture' ) {

  			node = cubeTexture( null );

  		} else {

  			node = uniform( null, uniformType );

  		}

  		if ( this.group !== null ) {

  			node.setGroup( this.group );

  		}

  		if ( this.name !== null ) node.label( this.name );

  		this.node = node.getSelf();

  	}

  	/**
  	 * This method is overwritten since the node type is inferred from
  	 * the type of the reference node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		if ( this.node === null ) {

  			this.updateReference( builder );
  			this.updateValue();

  		}

  		return this.node.getNodeType( builder );

  	}

  	/**
  	 * Returns the property value from the given referred object.
  	 *
  	 * @param {Object} [object=this.reference] - The object to retrieve the property value from.
  	 * @return {any} The value.
  	 */
  	getValueFromReference( object = this.reference ) {

  		const { properties } = this;

  		let value = object[ properties[ 0 ] ];

  		for ( let i = 1; i < properties.length; i ++ ) {

  			value = value[ properties[ i ] ];

  		}

  		return value;

  	}

  	/**
  	 * Allows to update the reference based on the given state. The state is only
  	 * evaluated {@link ReferenceNode#object} is not set.
  	 *
  	 * @param {(NodeFrame|NodeBuilder)} state - The current state.
  	 * @return {Object} The updated reference.
  	 */
  	updateReference( state ) {

  		this.reference = this.object !== null ? this.object : state.object;

  		return this.reference;

  	}

  	/**
  	 * The output of the reference node is the internal uniform node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {UniformNode} The output node.
  	 */
  	setup( /* builder */ ) {

  		this.updateValue();

  		return this.node;

  	}

  	/**
  	 * Overwritten to update the internal uniform value.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( /*frame*/ ) {

  		this.updateValue();

  	}

  	/**
  	 * Retrieves the value from the referred object property and uses it
  	 * to updated the internal uniform.
  	 */
  	updateValue() {

  		if ( this.node === null ) this.setNodeType( this.uniformType );

  		const value = this.getValueFromReference();

  		if ( Array.isArray( value ) ) {

  			this.node.array = value;

  		} else {

  			this.node.value = value;

  		}

  	}

  }

  /**
   * TSL function for creating a reference node.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the property the node refers to.
   * @param {string} type - The uniform type that should be used to represent the property value.
   * @param {?Object} [object] - The object the property belongs to.
   * @returns {ReferenceNode}
   */
  const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );

  /**
   * TSL function for creating a reference node. Use this function if you want need a reference
   * to an array-like property that should be represented as a uniform buffer.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the property the node refers to.
   * @param {string} type - The uniform type that should be used to represent the property value.
   * @param {number} count - The number of value inside the array-like object.
   * @param {Object} object - An array-like object the property belongs to.
   * @returns {ReferenceNode}
   */
  const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );

  /**
   * This node is a special type of reference node which is intended
   * for linking material properties with node values.
   * ```js
   * const opacityNode = materialReference( 'opacity', 'float', material );
   * ```
   * When changing `material.opacity`, the node value of `opacityNode` will
   * automatically be updated.
   *
   * @augments ReferenceNode
   */
  class MaterialReferenceNode extends ReferenceNode {

  	static get type() {

  		return 'MaterialReferenceNode';

  	}

  	/**
  	 * Constructs a new material reference node.
  	 *
  	 * @param {string} property - The name of the property the node refers to.
  	 * @param {string} inputType - The uniform type that should be used to represent the property value.
  	 * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
  	 * the node refers to the material of the current rendered object.
  	 */
  	constructor( property, inputType, material = null ) {

  		super( property, inputType, material );

  		/**
  		 * The material the property belongs to. When no material is set,
  		 * the node refers to the material of the current rendered object.
  		 *
  		 * @type {?Material}
  		 * @default null
  		 */
  		this.material = material;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMaterialReferenceNode = true;

  	}

  	/**
  	 * Updates the reference based on the given state. The state is only evaluated
  	 * {@link MaterialReferenceNode#material} is not set.
  	 *
  	 * @param {(NodeFrame|NodeBuilder)} state - The current state.
  	 * @return {Object} The updated reference.
  	 */
  	updateReference( state ) {

  		this.reference = this.material !== null ? this.material : state.material;

  		return this.reference;

  	}

  }

  /**
   * TSL function for creating a material reference node.
   *
   * @tsl
   * @function
   * @param {string} name - The name of the property the node refers to.
   * @param {string} type - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to.
   * When no material is set, the node refers to the material of the current rendered object.
   * @returns {MaterialReferenceNode}
   */
  const materialReference = ( name, type, material = null ) => nodeObject( new MaterialReferenceNode( name, type, material ) );

  // Normal Mapping Without Precomputed Tangents
  // http://www.thetenthplanet.de/archives/1180

  const uv = uv$1();

  const q0 = positionView.dFdx();
  const q1 = positionView.dFdy();
  const st0 = uv.dFdx();
  const st1 = uv.dFdy();

  const N$1 = normalView;

  const q1perp = q1.cross( N$1 );
  const q0perp = N$1.cross( q0 );

  const T$1 = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );
  const B$1 = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );

  const det = T$1.dot( T$1 ).max( B$1.dot( B$1 ) );
  const scale = det.equal( 0.0 ).select( 0.0, det.inverseSqrt() );

  /**
   * Tangent vector in view space, computed dynamically from geometry and UV derivatives.
   * Useful for normal mapping without precomputed tangents.
   *
   * Reference: http://www.thetenthplanet.de/archives/1180
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const tangentViewFrame = /*@__PURE__*/ T$1.mul( scale ).toVar( 'tangentViewFrame' );

  /**
   * Bitangent vector in view space, computed dynamically from geometry and UV derivatives.
   * Complements the tangentViewFrame for constructing the tangent space basis.
   *
   * Reference: http://www.thetenthplanet.de/archives/1180
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const bitangentViewFrame = /*@__PURE__*/ B$1.mul( scale ).toVar( 'bitangentViewFrame' );

  /**
   * TSL object that represents the tangent attribute of the current rendered object.
   *
   * @tsl
   * @type {Node<vec4>}
   */
  const tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {

  	if ( builder.geometry.hasAttribute( 'tangent' ) === false ) {

  		builder.geometry.computeTangents();

  	}

  	return attribute( 'tangent', 'vec4' );

  } )();

  /**
   * TSL object that represents the vertex tangent in local space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );

  /**
   * TSL object that represents the vertex tangent in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const tangentView = /*@__PURE__*/ ( Fn( ( { subBuildFn, geometry, material } ) => {

  	let node;

  	if ( subBuildFn === 'VERTEX' || geometry.hasAttribute( 'tangent' ) ) {

  		node = modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.toVarying( 'v_tangentView' ).normalize();

  	} else {

  		node = tangentViewFrame;

  	}

  	if ( material.flatShading !== true ) {

  		node = directionToFaceDirection( node );

  	}

  	return node;

  }, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'tangentView' );

  /**
   * Returns the bitangent node and assigns it to a varying if the material is not flat shaded.
   *
   * @tsl
   * @private
   * @param {Node<vec3>} crossNormalTangent - The cross product of the normal and tangent vectors.
   * @param {string} varyingName - The name of the varying to assign the bitangent to.
   * @returns {Node<vec3>} The bitangent node.
   */
  const getBitangent = /*@__PURE__*/ Fn( ( [ crossNormalTangent, varyingName ], { subBuildFn, material } ) => {

  	let bitangent = crossNormalTangent.mul( tangentGeometry.w ).xyz;

  	if ( subBuildFn === 'NORMAL' && material.flatShading !== true ) {

  		bitangent = bitangent.toVarying( varyingName );

  	}

  	return bitangent;

  } ).once( [ 'NORMAL' ] );

  /**
   * TSL object that represents the vertex bitangent in view space of the current rendered object.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const bitangentView = /*@__PURE__*/ ( Fn( ( { subBuildFn, geometry, material } ) => {

  	let node;

  	if ( subBuildFn === 'VERTEX' || geometry.hasAttribute( 'tangent' ) ) {

  		node = getBitangent( normalView.cross( tangentView ), 'v_bitangentView' ).normalize();

  	} else {

  		node = bitangentViewFrame;

  	}

  	if ( material.flatShading !== true ) {

  		node = directionToFaceDirection( node );

  	}

  	return node;

  }, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'bitangentView' );

  /**
   * TSL object that represents the TBN matrix in view space.
   *
   * @tsl
   * @type {Node<mat3>}
   */
  const TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView ).toVar( 'TBNViewMatrix' );

  /**
   * TSL function for computing bent normals.
   *
   * @tsl
   * @function
   * @returns {Node<vec3>} Bent normals.
   */
  const bentNormalView = /*@__PURE__*/ ( Fn( () => {

  	// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy

  	let bentNormal = anisotropyB.cross( positionViewDirection );
  	bentNormal = bentNormal.cross( anisotropyB ).normalize();
  	bentNormal = mix$2( bentNormal, normalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();

  	return bentNormal;

  } ).once() )();

  /**
   * This class can be used for applying normals maps to materials.
   *
   * ```js
   * material.normalNode = normalMap( texture( normalTex ) );
   * ```
   *
   * @augments TempNode
   */
  class NormalMapNode extends TempNode {

  	static get type() {

  		return 'NormalMapNode';

  	}

  	/**
  	 * Constructs a new normal map node.
  	 *
  	 * @param {Node<vec3>} node - Represents the normal map data.
  	 * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
  	 */
  	constructor( node, scaleNode = null ) {

  		super( 'vec3' );

  		/**
  		 * Represents the normal map data.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.node = node;

  		/**
  		 * Controls the intensity of the effect.
  		 *
  		 * @type {?Node<vec2>}
  		 * @default null
  		 */
  		this.scaleNode = scaleNode;

  		/**
  		 * The normal map type.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  	}

  	setup( { material } ) {

  		const { normalMapType, scaleNode } = this;

  		let normalMap = this.node.mul( 2.0 ).sub( 1.0 );

  		if ( scaleNode !== null ) {

  			let scale = scaleNode;

  			if ( material.flatShading === true ) {

  				scale = directionToFaceDirection( scale );

  			}

  			normalMap = vec3( normalMap.xy.mul( scale ), normalMap.z );

  		}

  		let output = null;

  		if ( normalMapType === ObjectSpaceNormalMap ) {

  			output = transformNormalToView( normalMap );

  		} else if ( normalMapType === TangentSpaceNormalMap ) {

  			output = TBNViewMatrix.mul( normalMap ).normalize();

  		} else {

  			console.error( `THREE.NodeMaterial: Unsupported normal map type: ${ normalMapType }` );

  			output = normalView; // Fallback to default normal view

  		}

  		return output;

  	}

  }

  /**
   * TSL function for creating a normal map node.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   * @returns {NormalMapNode}
   */
  const normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode ).setParameterLength( 1, 2 );

  // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
  // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

  const dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {

  	// It's used to preserve the same TextureNode instance
  	const sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv$1() ), forceUVContext: true } );

  	const Hll = float( sampleTexture( ( uvNode ) => uvNode ) );

  	return vec2(
  		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),
  		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )
  	).mul( bumpScale );

  } );

  // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

  const perturbNormalArb = Fn( ( inputs ) => {

  	const { surf_pos, surf_norm, dHdxy } = inputs;

  	// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
  	const vSigmaX = surf_pos.dFdx().normalize();
  	const vSigmaY = surf_pos.dFdy().normalize();
  	const vN = surf_norm; // normalized

  	const R1 = vSigmaY.cross( vN );
  	const R2 = vN.cross( vSigmaX );

  	const fDet = vSigmaX.dot( R1 ).mul( faceDirection );

  	const vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );

  	return fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();

  } );

  /**
   * This class can be used for applying bump maps to materials.
   *
   * ```js
   * material.normalNode = bumpMap( texture( bumpTex ) );
   * ```
   *
   * @augments TempNode
   */
  class BumpMapNode extends TempNode {

  	static get type() {

  		return 'BumpMapNode';

  	}

  	/**
  	 * Constructs a new bump map node.
  	 *
  	 * @param {Node<float>} textureNode - Represents the bump map data.
  	 * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
  	 */
  	constructor( textureNode, scaleNode = null ) {

  		super( 'vec3' );

  		/**
  		 * Represents the bump map data.
  		 *
  		 * @type {Node<float>}
  		 */
  		this.textureNode = textureNode;

  		/**
  		 * Controls the intensity of the bump effect.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.scaleNode = scaleNode;

  	}

  	setup() {

  		const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
  		const dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );

  		return perturbNormalArb( {
  			surf_pos: positionView,
  			surf_norm: normalView,
  			dHdxy
  		} );

  	}

  }

  /**
   * TSL function for creating a bump map node.
   *
   * @tsl
   * @function
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   * @returns {BumpMapNode}
   */
  const bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode ).setParameterLength( 1, 2 );

  const _propertyCache = new Map();

  /**
   * This class should simplify the node access to material properties.
   * It internal uses reference nodes to make sure  changes to material
   * properties are automatically reflected to predefined TSL objects
   * like e.g. `materialColor`.
   *
   * @augments Node
   */
  class MaterialNode extends Node {

  	static get type() {

  		return 'MaterialNode';

  	}

  	/**
  	 * Constructs a new material node.
  	 *
  	 * @param {string} scope - The scope defines what kind of material property is referred by the node.
  	 */
  	constructor( scope ) {

  		super();

  		/**
  		 * The scope defines what material property is referred by the node.
  		 *
  		 * @type {string}
  		 */
  		this.scope = scope;

  	}

  	/**
  	 * Returns a cached reference node for the given property and type.
  	 *
  	 * @param {string} property - The name of the material property.
  	 * @param {string} type - The uniform type of the property.
  	 * @return {MaterialReferenceNode} A material reference node representing the property access.
  	 */
  	getCache( property, type ) {

  		let node = _propertyCache.get( property );

  		if ( node === undefined ) {

  			node = materialReference( property, type );

  			_propertyCache.set( property, node );

  		}

  		return node;

  	}

  	/**
  	 * Returns a float-typed material reference node for the given property name.
  	 *
  	 * @param {string} property - The name of the material property.
  	 * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
  	 */
  	getFloat( property ) {

  		return this.getCache( property, 'float' );

  	}

  	/**
  	 * Returns a color-typed material reference node for the given property name.
  	 *
  	 * @param {string} property - The name of the material property.
  	 * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
  	 */
  	getColor( property ) {

  		return this.getCache( property, 'color' );

  	}

  	/**
  	 * Returns a texture-typed material reference node for the given property name.
  	 *
  	 * @param {string} property - The name of the material property.
  	 * @return {MaterialReferenceNode} A material reference node representing the property access.
  	 */
  	getTexture( property ) {

  		return this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );

  	}

  	/**
  	 * The node setup is done depending on the selected scope. Multiple material properties
  	 * might be grouped into a single node composition if they logically belong together.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node} The node representing the selected scope.
  	 */
  	setup( builder ) {

  		const material = builder.context.material;
  		const scope = this.scope;

  		let node = null;

  		if ( scope === MaterialNode.COLOR ) {

  			const colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();

  			if ( material.map && material.map.isTexture === true ) {

  				node = colorNode.mul( this.getTexture( 'map' ) );

  			} else {

  				node = colorNode;

  			}

  		} else if ( scope === MaterialNode.OPACITY ) {

  			const opacityNode = this.getFloat( scope );

  			if ( material.alphaMap && material.alphaMap.isTexture === true ) {

  				node = opacityNode.mul( this.getTexture( 'alpha' ) );

  			} else {

  				node = opacityNode;

  			}

  		} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {

  			if ( material.specularMap && material.specularMap.isTexture === true ) {

  				node = this.getTexture( 'specular' ).r;

  			} else {

  				node = float( 1 );

  			}

  		} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {

  			const specularIntensityNode = this.getFloat( scope );

  			if ( material.specularIntensityMap && material.specularIntensityMap.isTexture === true ) {

  				node = specularIntensityNode.mul( this.getTexture( scope ).a );

  			} else {

  				node = specularIntensityNode;

  			}

  		} else if ( scope === MaterialNode.SPECULAR_COLOR ) {

  			const specularColorNode = this.getColor( scope );

  			if ( material.specularColorMap && material.specularColorMap.isTexture === true ) {

  				node = specularColorNode.mul( this.getTexture( scope ).rgb );

  			} else {

  				node = specularColorNode;

  			}

  		} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches

  			const roughnessNode = this.getFloat( scope );

  			if ( material.roughnessMap && material.roughnessMap.isTexture === true ) {

  				node = roughnessNode.mul( this.getTexture( scope ).g );

  			} else {

  				node = roughnessNode;

  			}

  		} else if ( scope === MaterialNode.METALNESS ) {

  			const metalnessNode = this.getFloat( scope );

  			if ( material.metalnessMap && material.metalnessMap.isTexture === true ) {

  				node = metalnessNode.mul( this.getTexture( scope ).b );

  			} else {

  				node = metalnessNode;

  			}

  		} else if ( scope === MaterialNode.EMISSIVE ) {

  			const emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );
  			const emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );

  			if ( material.emissiveMap && material.emissiveMap.isTexture === true ) {

  				node = emissiveNode.mul( this.getTexture( scope ) );

  			} else {

  				node = emissiveNode;

  			}

  		} else if ( scope === MaterialNode.NORMAL ) {

  			if ( material.normalMap ) {

  				node = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );
  				node.normalMapType = material.normalMapType;

  			} else if ( material.bumpMap ) {

  				node = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );

  			} else {

  				node = normalView;

  			}

  		} else if ( scope === MaterialNode.CLEARCOAT ) {

  			const clearcoatNode = this.getFloat( scope );

  			if ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {

  				node = clearcoatNode.mul( this.getTexture( scope ).r );

  			} else {

  				node = clearcoatNode;

  			}

  		} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {

  			const clearcoatRoughnessNode = this.getFloat( scope );

  			if ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {

  				node = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );

  			} else {

  				node = clearcoatRoughnessNode;

  			}

  		} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {

  			if ( material.clearcoatNormalMap ) {

  				node = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );

  			} else {

  				node = normalView;

  			}

  		} else if ( scope === MaterialNode.SHEEN ) {

  			const sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU

  			if ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {

  				node = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );

  			} else {

  				node = sheenNode;

  			}

  		} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {

  			const sheenRoughnessNode = this.getFloat( scope );

  			if ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {

  				node = sheenRoughnessNode.mul( this.getTexture( scope ).a );

  			} else {

  				node = sheenRoughnessNode;

  			}

  			node = node.clamp( 0.07, 1.0 );

  		} else if ( scope === MaterialNode.ANISOTROPY ) {

  			if ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {

  				const anisotropyPolar = this.getTexture( scope );
  				const anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );

  				node = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );

  			} else {

  				node = materialAnisotropyVector;

  			}

  		} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {

  			const iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );

  			if ( material.iridescenceThicknessMap ) {

  				const iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );

  				node = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );

  			} else {

  				node = iridescenceThicknessMaximum;

  			}

  		} else if ( scope === MaterialNode.TRANSMISSION ) {

  			const transmissionNode = this.getFloat( scope );

  			if ( material.transmissionMap ) {

  				node = transmissionNode.mul( this.getTexture( scope ).r );

  			} else {

  				node = transmissionNode;

  			}

  		} else if ( scope === MaterialNode.THICKNESS ) {

  			const thicknessNode = this.getFloat( scope );

  			if ( material.thicknessMap ) {

  				node = thicknessNode.mul( this.getTexture( scope ).g );

  			} else {

  				node = thicknessNode;

  			}

  		} else if ( scope === MaterialNode.IOR ) {

  			node = this.getFloat( scope );

  		} else if ( scope === MaterialNode.LIGHT_MAP ) {

  			node = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );

  		} else if ( scope === MaterialNode.AO ) {

  			node = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );

  		} else if ( scope === MaterialNode.LINE_DASH_OFFSET ) {

  			node = ( material.dashOffset ) ? this.getFloat( scope ) : float( 0 );

  		} else {

  			const outputType = this.getNodeType( builder );

  			node = this.getCache( scope, outputType );

  		}

  		return node;

  	}

  }

  MaterialNode.ALPHA_TEST = 'alphaTest';
  MaterialNode.COLOR = 'color';
  MaterialNode.OPACITY = 'opacity';
  MaterialNode.SHININESS = 'shininess';
  MaterialNode.SPECULAR = 'specular';
  MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
  MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
  MaterialNode.SPECULAR_COLOR = 'specularColor';
  MaterialNode.REFLECTIVITY = 'reflectivity';
  MaterialNode.ROUGHNESS = 'roughness';
  MaterialNode.METALNESS = 'metalness';
  MaterialNode.NORMAL = 'normal';
  MaterialNode.CLEARCOAT = 'clearcoat';
  MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
  MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
  MaterialNode.EMISSIVE = 'emissive';
  MaterialNode.ROTATION = 'rotation';
  MaterialNode.SHEEN = 'sheen';
  MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
  MaterialNode.ANISOTROPY = 'anisotropy';
  MaterialNode.IRIDESCENCE = 'iridescence';
  MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
  MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
  MaterialNode.IOR = 'ior';
  MaterialNode.TRANSMISSION = 'transmission';
  MaterialNode.THICKNESS = 'thickness';
  MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
  MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
  MaterialNode.LINE_SCALE = 'scale';
  MaterialNode.LINE_DASH_SIZE = 'dashSize';
  MaterialNode.LINE_GAP_SIZE = 'gapSize';
  MaterialNode.LINE_WIDTH = 'linewidth';
  MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
  MaterialNode.POINT_SIZE = 'size';
  MaterialNode.DISPERSION = 'dispersion';
  MaterialNode.LIGHT_MAP = 'light';
  MaterialNode.AO = 'ao';

  /**
   * TSL object that represents alpha test of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );

  /**
   * TSL object that represents the diffuse color of the current material.
   * The value is composed via `color` * `map`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );

  /**
   * TSL object that represents the shininess of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );

  /**
   * TSL object that represents the emissive color of the current material.
   * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );

  /**
   * TSL object that represents the opacity of the current material.
   * The value is composed via `opacity` * `alphaMap`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );

  /**
   * TSL object that represents the specular of the current material.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );

  /**
   * TSL object that represents the specular intensity of the current material.
   * The value is composed via `specularIntensity` * `specularMap.a`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );

  /**
   * TSL object that represents the specular color of the current material.
   * The value is composed via `specularColor` * `specularMap.rgb`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );

  /**
   * TSL object that represents the specular strength of the current material.
   * The value is composed via `specularMap.r`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );

  /**
   * TSL object that represents the reflectivity of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );

  /**
   * TSL object that represents the roughness of the current material.
   * The value is composed via `roughness` * `roughnessMap.g`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );

  /**
   * TSL object that represents the metalness of the current material.
   * The value is composed via `metalness` * `metalnessMap.b`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );

  /**
   * TSL object that represents the normal of the current material.
   * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL );

  /**
   * TSL object that represents the clearcoat of the current material.
   * The value is composed via `clearcoat` * `clearcoatMap.r`
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );

  /**
   * TSL object that represents the clearcoat roughness of the current material.
   * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );

  /**
   * TSL object that represents the clearcoat normal of the current material.
   * The value will be either `clearcoatNormalMap` or `normalView`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL );

  /**
   * TSL object that represents the rotation of the current sprite material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );

  /**
   * TSL object that represents the sheen color of the current material.
   * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );

  /**
   * TSL object that represents the sheen roughness of the current material.
   * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );

  /**
   * TSL object that represents the anisotropy of the current material.
   *
   * @tsl
   * @type {Node<vec2>}
   */
  const materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );

  /**
   * TSL object that represents the iridescence of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );

  /**
   * TSL object that represents the iridescence IOR of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );

  /**
   * TSL object that represents the iridescence thickness of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );

  /**
   * TSL object that represents the transmission of the current material.
   * The value is composed via `transmission` * `transmissionMap.r`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );

  /**
   * TSL object that represents the thickness of the current material.
   * The value is composed via `thickness` * `thicknessMap.g`.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );

  /**
   * TSL object that represents the IOR of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );

  /**
   * TSL object that represents the attenuation distance of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );

  /**
   * TSL object that represents the attenuation color of the current material.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );

  /**
   * TSL object that represents the scale of the current dashed line material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );

  /**
   * TSL object that represents the dash size of the current dashed line material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );

  /**
   * TSL object that represents the gap size of the current dashed line material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );

  /**
   * TSL object that represents the line width of the current line material.
   *
   * @tsl
   * @type {Node<float>}
   */
  /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );

  /**
   * TSL object that represents the dash offset of the current line material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );

  /**
   * TSL object that represents the point size of the current points material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialPointSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_SIZE );

  /**
   * TSL object that represents the dispersion of the current material.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );

  /**
   * TSL object that represents the light map of the current material.
   * The value is composed via `lightMapIntensity` * `lightMap.rgb`.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );

  /**
   * TSL object that represents the ambient occlusion map of the current material.
   * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.
   *
   * @tsl
   * @type {Node<float>}
   */
  const materialAO = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO );

  /**
   * TSL object that represents the anisotropy vector of the current material.
   *
   * @tsl
   * @type {Node<vec2>}
   */
  const materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {

  	return frame.material;

  } ).onRenderUpdate( function ( { material } ) {

  	this.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

  } );

  /**
   * TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.
   *
   * @tsl
   * @type {VaryingNode<vec4>}
   */
  const modelViewProjection = /*@__PURE__*/ ( Fn( ( builder ) => {

  	return builder.context.setupModelViewProjection();

  }, 'vec4' ).once() )().toVarying( 'v_modelViewProjection' );

  /**
   * This class represents shader indices of different types. The following predefined node
   * objects cover frequent use cases:
   *
   * - `vertexIndex`: The index of a vertex within a mesh.
   * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.
   * - `drawIndex`: The index of a draw call.
   * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.
   * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.
   * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.
   *
   * @augments Node
   */
  class IndexNode extends Node {

  	static get type() {

  		return 'IndexNode';

  	}

  	/**
  	 * Constructs a new index node.
  	 *
  	 * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
  	 */
  	constructor( scope ) {

  		super( 'uint' );

  		/**
  		 * The scope of the index node.
  		 *
  		 * @type {string}
  		 */
  		this.scope = scope;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isIndexNode = true;

  	}

  	generate( builder ) {

  		const nodeType = this.getNodeType( builder );
  		const scope = this.scope;

  		let propertyName;

  		if ( scope === IndexNode.VERTEX ) {

  			propertyName = builder.getVertexIndex();

  		} else if ( scope === IndexNode.INSTANCE ) {

  			propertyName = builder.getInstanceIndex();

  		} else if ( scope === IndexNode.DRAW ) {

  			propertyName = builder.getDrawIndex();

  		} else if ( scope === IndexNode.INVOCATION_LOCAL ) {

  			propertyName = builder.getInvocationLocalIndex();

  		} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {

  			propertyName = builder.getInvocationSubgroupIndex();

  		} else if ( scope === IndexNode.SUBGROUP ) {

  			propertyName = builder.getSubgroupIndex();

  		} else {

  			throw new Error( 'THREE.IndexNode: Unknown scope: ' + scope );

  		}

  		let output;

  		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

  			output = propertyName;

  		} else {

  			const nodeVarying = varying( this );

  			output = nodeVarying.build( builder, nodeType );

  		}

  		return output;

  	}

  }

  IndexNode.VERTEX = 'vertex';
  IndexNode.INSTANCE = 'instance';
  IndexNode.SUBGROUP = 'subgroup';
  IndexNode.INVOCATION_LOCAL = 'invocationLocal';
  IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
  IndexNode.DRAW = 'draw';

  /**
   * TSL object that represents the index of a vertex within a mesh.
   *
   * @tsl
   * @type {IndexNode}
   */
  const vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );

  /**
   * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.
   *
   * @tsl
   * @type {IndexNode}
   */
  const instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );

  /**
   * TSL object that represents the index of the subgroup the current compute invocation belongs to.
   *
   * @tsl
   * @type {IndexNode}
   */
  /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );

  /**
   * TSL object that represents the index of a compute invocation within the scope of a subgroup.
   *
   * @tsl
   * @type {IndexNode}
   */
  /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );

  /**
   * TSL object that represents the index of a compute invocation within the scope of a workgroup load.
   *
   * @tsl
   * @type {IndexNode}
   */
  /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );

  /**
   * TSL object that represents the index of a draw call.
   *
   * @tsl
   * @type {IndexNode}
   */
  const drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );

  /**
   * This node implements the vertex shader logic which is required
   * when rendering 3D objects via instancing. The code makes sure
   * vertex positions, normals and colors can be modified via instanced
   * data.
   *
   * @augments Node
   */
  class InstanceNode extends Node {

  	static get type() {

  		return 'InstanceNode';

  	}

  	/**
  	 * Constructs a new instance node.
  	 *
  	 * @param {number} count - The number of instances.
  	 * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
  	 * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
  	 */
  	constructor( count, instanceMatrix, instanceColor = null ) {

  		super( 'void' );

  		/**
  		 * The number of instances.
  		 *
  		 * @type {number}
  		 */
  		this.count = count;

  		/**
  		 * Instanced buffer attribute representing the transformation of instances.
  		 *
  		 * @type {InstancedBufferAttribute}
  		 */
  		this.instanceMatrix = instanceMatrix;

  		/**
  		 * Instanced buffer attribute representing the color of instances.
  		 *
  		 * @type {InstancedBufferAttribute}
  		 */
  		this.instanceColor = instanceColor;

  		/**
  		 * The node that represents the instance matrix data.
  		 *
  		 * @type {?Node}
  		 */
  		this.instanceMatrixNode = null;

  		/**
  		 * The node that represents the instance color data.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.instanceColorNode = null;

  		/**
  		 * The update type is set to `frame` since an update
  		 * of instanced buffer data must be checked per frame.
  		 *
  		 * @type {string}
  		 * @default 'frame'
  		 */
  		this.updateType = NodeUpdateType.FRAME;

  		/**
  		 * A reference to a buffer that is used by `instanceMatrixNode`.
  		 *
  		 * @type {?InstancedInterleavedBuffer}
  		 */
  		this.buffer = null;

  		/**
  		 * A reference to a buffer that is used by `instanceColorNode`.
  		 *
  		 * @type {?InstancedBufferAttribute}
  		 */
  		this.bufferColor = null;

  	}

  	/**
  	 * Setups the internal buffers and nodes and assigns the transformed vertex data
  	 * to predefined node variables for accumulation. That follows the same patterns
  	 * like with morph and skinning nodes.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		const { count, instanceMatrix, instanceColor } = this;

  		let { instanceMatrixNode, instanceColorNode } = this;

  		if ( instanceMatrixNode === null ) {

  			// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.

  			if ( count <= 1000 ) {

  				instanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );

  			} else {

  				const buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );

  				this.buffer = buffer;

  				const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

  				const instanceBuffers = [
  					// F.Signature -> bufferAttribute( array, type, stride, offset )
  					bufferFn( buffer, 'vec4', 16, 0 ),
  					bufferFn( buffer, 'vec4', 16, 4 ),
  					bufferFn( buffer, 'vec4', 16, 8 ),
  					bufferFn( buffer, 'vec4', 16, 12 )
  				];

  				instanceMatrixNode = mat4( ...instanceBuffers );

  			}

  			this.instanceMatrixNode = instanceMatrixNode;

  		}

  		if ( instanceColor && instanceColorNode === null ) {

  			const buffer = new InstancedBufferAttribute( instanceColor.array, 3 );

  			const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

  			this.bufferColor = buffer;

  			instanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );

  			this.instanceColorNode = instanceColorNode;

  		}

  		// POSITION

  		const instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;
  		positionLocal.assign( instancePosition );

  		// NORMAL

  		if ( builder.hasGeometryAttribute( 'normal' ) ) {

  			const instanceNormal = transformNormal( normalLocal, instanceMatrixNode );

  			// ASSIGNS

  			normalLocal.assign( instanceNormal );

  		}

  		// COLOR

  		if ( this.instanceColorNode !== null ) {

  			varyingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );

  		}

  	}

  	/**
  	 * Checks if the internal buffers required an update.
  	 *
  	 * @param {NodeFrame} frame - The current node frame.
  	 */
  	update( /*frame*/ ) {

  		if ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version ) {

  			this.buffer.version = this.instanceMatrix.version;

  		}

  		if ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version ) {

  			this.bufferColor.version = this.instanceColor.version;

  		}

  	}

  }

  /**
   * This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.
   * It allows an easier setup of the instance node.
   *
   * @augments InstanceNode
   */
  class InstancedMeshNode extends InstanceNode {

  	static get type() {

  		return 'InstancedMeshNode';

  	}

  	/**
  	 * Constructs a new instanced mesh node.
  	 *
  	 * @param {InstancedMesh} instancedMesh - The instanced mesh.
  	 */
  	constructor( instancedMesh ) {

  		const { count, instanceMatrix, instanceColor } = instancedMesh;

  		super( count, instanceMatrix, instanceColor );

  		/**
  		 * A reference to the instanced mesh.
  		 *
  		 * @type {InstancedMesh}
  		 */
  		this.instancedMesh = instancedMesh;

  	}

  }

  /**
   * TSL function for creating an instanced mesh node.
   *
   * @tsl
   * @function
   * @param {InstancedMesh} instancedMesh - The instancedMesh.
   * @returns {InstancedMeshNode}
   */
  const instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode ).setParameterLength( 1 );

  /**
   * This node implements the vertex shader logic which is required
   * when rendering 3D objects via batching. `BatchNode` must be used
   * with instances of {@link BatchedMesh}.
   *
   * @augments Node
   */
  class BatchNode extends Node {

  	static get type() {

  		return 'BatchNode';

  	}

  	/**
  	 * Constructs a new batch node.
  	 *
  	 * @param {BatchedMesh} batchMesh - A reference to batched mesh.
  	 */
  	constructor( batchMesh ) {

  		super( 'void' );

  		/**
  		 * A reference to batched mesh.
  		 *
  		 * @type {BatchedMesh}
  		 */
  		this.batchMesh = batchMesh;

  		/**
  		 * The batching index node.
  		 *
  		 * @type {?IndexNode}
  		 * @default null
  		 */
  		this.batchingIdNode = null;

  	}

  	/**
  	 * Setups the internal buffers and nodes and assigns the transformed vertex data
  	 * to predefined node variables for accumulation. That follows the same patterns
  	 * like with morph and skinning nodes.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		if ( this.batchingIdNode === null ) {

  			if ( builder.getDrawIndex() === null ) {

  				this.batchingIdNode = instanceIndex;

  			} else {

  				this.batchingIdNode = drawIndex;

  			}

  		}

  		const getIndirectIndex = Fn( ( [ id ] ) => {

  			const size = int( textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 ).x );
  			const x = int( id ).mod( size );
  			const y = int( id ).div( size );
  			return textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;

  		} ).setLayout( {
  			name: 'getIndirectIndex',
  			type: 'uint',
  			inputs: [
  				{ name: 'id', type: 'int' }
  			]
  		} );

  		const indirectId = getIndirectIndex( int( this.batchingIdNode ) );

  		const matricesTexture = this.batchMesh._matricesTexture;

  		const size = int( textureSize( textureLoad( matricesTexture ), 0 ).x );
  		const j = float( indirectId ).mul( 4 ).toInt().toVar();

  		const x = j.mod( size );
  		const y = j.div( size );
  		const batchingMatrix = mat4(
  			textureLoad( matricesTexture, ivec2( x, y ) ),
  			textureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),
  			textureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),
  			textureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )
  		);


  		const colorsTexture = this.batchMesh._colorsTexture;

  		if ( colorsTexture !== null ) {

  			const getBatchingColor = Fn( ( [ id ] ) => {

  				const size = int( textureSize( textureLoad( colorsTexture ), 0 ).x );
  				const j = id;
  				const x = j.mod( size );
  				const y = j.div( size );
  				return textureLoad( colorsTexture, ivec2( x, y ) ).rgb;

  			} ).setLayout( {
  				name: 'getBatchingColor',
  				type: 'vec3',
  				inputs: [
  					{ name: 'id', type: 'int' }
  				]
  			} );

  			const color = getBatchingColor( indirectId );

  			varyingProperty( 'vec3', 'vBatchColor' ).assign( color );

  		}

  		const bm = mat3( batchingMatrix );

  		positionLocal.assign( batchingMatrix.mul( positionLocal ) );

  		const transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );

  		const batchingNormal = bm.mul( transformedNormal ).xyz;

  		normalLocal.assign( batchingNormal );

  		if ( builder.hasGeometryAttribute( 'tangent' ) ) {

  			tangentLocal.mulAssign( bm );

  		}

  	}

  }

  /**
   * TSL function for creating a batch node.
   *
   * @tsl
   * @function
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   * @returns {BatchNode}
   */
  const batch = /*@__PURE__*/ nodeProxy( BatchNode ).setParameterLength( 1 );

  const _frameId = new WeakMap();

  /**
   * This node implements the vertex transformation shader logic which is required
   * for skinning/skeletal animation.
   *
   * @augments Node
   */
  class SkinningNode extends Node {

  	static get type() {

  		return 'SkinningNode';

  	}

  	/**
  	 * Constructs a new skinning node.
  	 *
  	 * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
  	 */
  	constructor( skinnedMesh ) {

  		super( 'void' );

  		/**
  		 * The skinned mesh.
  		 *
  		 * @type {SkinnedMesh}
  		 */
  		this.skinnedMesh = skinnedMesh;

  		/**
  		 * The update type overwritten since skinning nodes are updated per object.
  		 *
  		 * @type {string}
  		 */
  		this.updateType = NodeUpdateType.OBJECT;

  		//

  		/**
  		 * The skin index attribute.
  		 *
  		 * @type {AttributeNode}
  		 */
  		this.skinIndexNode = attribute( 'skinIndex', 'uvec4' );

  		/**
  		 * The skin weight attribute.
  		 *
  		 * @type {AttributeNode}
  		 */
  		this.skinWeightNode = attribute( 'skinWeight', 'vec4' );

  		/**
  		 * The bind matrix node.
  		 *
  		 * @type {Node<mat4>}
  		 */
  		this.bindMatrixNode = reference( 'bindMatrix', 'mat4' );

  		/**
  		 * The bind matrix inverse node.
  		 *
  		 * @type {Node<mat4>}
  		 */
  		this.bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );

  		/**
  		 * The bind matrices as a uniform buffer node.
  		 *
  		 * @type {Node}
  		 */
  		this.boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

  		/**
  		 * The current vertex position in local space.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.positionNode = positionLocal;

  		/**
  		 * The result of vertex position in local space.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.toPositionNode = positionLocal;

  		/**
  		 * The previous bind matrices as a uniform buffer node.
  		 * Required for computing motion vectors.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.previousBoneMatricesNode = null;

  	}

  	/**
  	 * Transforms the given vertex position via skinning.
  	 *
  	 * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
  	 * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
  	 * @return {Node<vec3>} The transformed vertex position.
  	 */
  	getSkinnedPosition( boneMatrices = this.boneMatricesNode, position = this.positionNode ) {

  		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

  		const boneMatX = boneMatrices.element( skinIndexNode.x );
  		const boneMatY = boneMatrices.element( skinIndexNode.y );
  		const boneMatZ = boneMatrices.element( skinIndexNode.z );
  		const boneMatW = boneMatrices.element( skinIndexNode.w );

  		// POSITION

  		const skinVertex = bindMatrixNode.mul( position );

  		const skinned = add(
  			boneMatX.mul( skinWeightNode.x ).mul( skinVertex ),
  			boneMatY.mul( skinWeightNode.y ).mul( skinVertex ),
  			boneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),
  			boneMatW.mul( skinWeightNode.w ).mul( skinVertex )
  		);

  		return bindMatrixInverseNode.mul( skinned ).xyz;

  	}

  	/**
  	 * Transforms the given vertex normal via skinning.
  	 *
  	 * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
  	 * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
  	 * @return {Node<vec3>} The transformed vertex normal.
  	 */
  	getSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {

  		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

  		const boneMatX = boneMatrices.element( skinIndexNode.x );
  		const boneMatY = boneMatrices.element( skinIndexNode.y );
  		const boneMatZ = boneMatrices.element( skinIndexNode.z );
  		const boneMatW = boneMatrices.element( skinIndexNode.w );

  		// NORMAL

  		let skinMatrix = add(
  			skinWeightNode.x.mul( boneMatX ),
  			skinWeightNode.y.mul( boneMatY ),
  			skinWeightNode.z.mul( boneMatZ ),
  			skinWeightNode.w.mul( boneMatW )
  		);

  		skinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );

  		return skinMatrix.transformDirection( normal ).xyz;

  	}

  	/**
  	 * Computes the transformed/skinned vertex position of the previous frame.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The skinned position from the previous frame.
  	 */
  	getPreviousSkinnedPosition( builder ) {

  		const skinnedMesh = builder.object;

  		if ( this.previousBoneMatricesNode === null ) {

  			skinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );

  			this.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

  		}

  		return this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );

  	}

  	/**
  	 * Returns `true` if bone matrices from the previous frame are required. Relevant
  	 * when computing motion vectors with {@link VelocityNode}.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {boolean} Whether bone matrices from the previous frame are required or not.
  	 */
  	needsPreviousBoneMatrices( builder ) {

  		const mrt = builder.renderer.getMRT();

  		return ( mrt && mrt.has( 'velocity' ) ) || getDataFromObject( builder.object ).useVelocity === true;

  	}

  	/**
  	 * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The transformed vertex position.
  	 */
  	setup( builder ) {

  		if ( this.needsPreviousBoneMatrices( builder ) ) {

  			positionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );

  		}

  		const skinPosition = this.getSkinnedPosition();

  		if ( this.toPositionNode ) this.toPositionNode.assign( skinPosition );

  		//

  		if ( builder.hasGeometryAttribute( 'normal' ) ) {

  			const skinNormal = this.getSkinnedNormal();

  			normalLocal.assign( skinNormal );

  			if ( builder.hasGeometryAttribute( 'tangent' ) ) {

  				tangentLocal.assign( skinNormal );

  			}

  		}

  		return skinPosition;

  	}

  	/**
  	 * Generates the code snippet of the skinning node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {string} output - The current output.
  	 * @return {string} The generated code snippet.
  	 */
  	generate( builder, output ) {

  		if ( output !== 'void' ) {

  			return super.generate( builder, output );

  		}

  	}

  	/**
  	 * Updates the state of the skinned mesh by updating the skeleton once per frame.
  	 *
  	 * @param {NodeFrame} frame - The current node frame.
  	 */
  	update( frame ) {

  		const skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;

  		if ( _frameId.get( skeleton ) === frame.frameId ) return;

  		_frameId.set( skeleton, frame.frameId );

  		if ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );

  		skeleton.update();

  	}

  }

  /**
   * TSL function for creating a skinning node.
   *
   * @tsl
   * @function
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   * @returns {SkinningNode}
   */
  const skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );

  /**
   * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:
   * ```js
   * Loop( count, ( { i } ) => {
   *
   * } );
   * ```
   * However, it is also possible to define a start and end ranges, data types and loop conditions:
   * ```js
   * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {
   *
   * } );
   *```
   * Nested loops can be defined in a compacted form:
   * ```js
   * Loop( 10, 5, ( { i, j } ) => {
   *
   * } );
   * ```
   * Loops that should run backwards can be defined like so:
   * ```js
   * Loop( { start: 10 }, () => {} );
   * ```
   * It is possible to execute with boolean values, similar to the `while` syntax.
   * ```js
   * const value = float( 0 ).toVar();
   *
   * Loop( value.lessThan( 10 ), () => {
   *
   * 	value.addAssign( 1 );
   *
   * } );
   * ```
   * The module also provides `Break()` and `Continue()` TSL expression for loop control.
   * @augments Node
   */
  class LoopNode extends Node {

  	static get type() {

  		return 'LoopNode';

  	}

  	/**
  	 * Constructs a new loop node.
  	 *
  	 * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
  	 */
  	constructor( params = [] ) {

  		super();

  		this.params = params;

  	}

  	/**
  	 * Returns a loop variable name based on an index. The pattern is
  	 * `0` = `i`, `1`= `j`, `2`= `k` and so on.
  	 *
  	 * @param {number} index - The index.
  	 * @return {string} The loop variable name.
  	 */
  	getVarName( index ) {

  		return String.fromCharCode( 'i'.charCodeAt( 0 ) + index );

  	}

  	/**
  	 * Returns properties about this node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Object} The node properties.
  	 */
  	getProperties( builder ) {

  		const properties = builder.getNodeProperties( this );

  		if ( properties.stackNode !== undefined ) return properties;

  		//

  		const inputs = {};

  		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

  			const param = this.params[ i ];

  			const name = ( param.isNode !== true && param.name ) || this.getVarName( i );
  			const type = ( param.isNode !== true && param.type ) || 'int';

  			inputs[ name ] = expression( name, type );

  		}

  		const stack = builder.addStack(); // TODO: cache() it

  		properties.returnsNode = this.params[ this.params.length - 1 ]( inputs, builder );
  		properties.stackNode = stack;

  		const baseParam = this.params[ 0 ];

  		if ( baseParam.isNode !== true && typeof baseParam.update === 'function' ) {

  			properties.updateNode = Fn( this.params[ 0 ].update )( inputs );

  		}

  		builder.removeStack();

  		return properties;

  	}

  	/**
  	 * This method is overwritten since the node type is inferred based on the loop configuration.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		const { returnsNode } = this.getProperties( builder );

  		return returnsNode ? returnsNode.getNodeType( builder ) : 'void';

  	}

  	setup( builder ) {

  		// setup properties

  		this.getProperties( builder );

  	}

  	generate( builder ) {

  		const properties = this.getProperties( builder );

  		const params = this.params;
  		const stackNode = properties.stackNode;

  		for ( let i = 0, l = params.length - 1; i < l; i ++ ) {

  			const param = params[ i ];

  			let isWhile = false, start = null, end = null, name = null, type = null, condition = null, update = null;

  			if ( param.isNode ) {

  				if ( param.getNodeType( builder ) === 'bool' ) {

  					isWhile = true;
  					type = 'bool';
  					end = param.build( builder, type );

  				} else {

  					type = 'int';
  					name = this.getVarName( i );
  					start = '0';
  					end = param.build( builder, type );
  					condition = '<';

  				}

  			} else {

  				type = param.type || 'int';
  				name = param.name || this.getVarName( i );
  				start = param.start;
  				end = param.end;
  				condition = param.condition;
  				update = param.update;

  				if ( typeof start === 'number' ) start = builder.generateConst( type, start );
  				else if ( start && start.isNode ) start = start.build( builder, type );

  				if ( typeof end === 'number' ) end = builder.generateConst( type, end );
  				else if ( end && end.isNode ) end = end.build( builder, type );

  				if ( start !== undefined && end === undefined ) {

  					start = start + ' - 1';
  					end = '0';
  					condition = '>=';

  				} else if ( end !== undefined && start === undefined ) {

  					start = '0';
  					condition = '<';

  				}

  				if ( condition === undefined ) {

  					if ( Number( start ) > Number( end ) ) {

  						condition = '>=';

  					} else {

  						condition = '<';

  					}

  				}

  			}

  			let loopSnippet;

  			if ( isWhile ) {

  				loopSnippet = `while ( ${ end } )`;

  			} else {

  				const internalParam = { start, end};

  				//

  				const startSnippet = internalParam.start;
  				const endSnippet = internalParam.end;

  				let updateSnippet;

  				const deltaOperator = () => condition.includes( '<' ) ? '+=' : '-=';

  				if ( update !== undefined && update !== null ) {

  					switch ( typeof update ) {

  						case 'function':

  							const flow = builder.flowStagesNode( properties.updateNode, 'void' );
  							const snippet = flow.code.replace( /\t|;/g, '' );

  							updateSnippet = snippet;

  							break;

  						case 'number':

  							updateSnippet = name + ' ' + deltaOperator() + ' ' + builder.generateConst( type, update );

  							break;

  						case 'string':

  							updateSnippet = name + ' ' + update;

  							break;

  						default:

  							if ( update.isNode ) {

  								updateSnippet = name + ' ' + deltaOperator() + ' ' + update.build( builder );

  							} else {

  								console.error( 'THREE.TSL: \'Loop( { update: ... } )\' is not a function, string or number.' );

  								updateSnippet = 'break /* invalid update */';

  							}

  					}

  				} else {

  					if ( type === 'int' || type === 'uint' ) {

  						update = condition.includes( '<' ) ? '++' : '--';

  					} else {

  						update = deltaOperator() + ' 1.';

  					}

  					updateSnippet = name + ' ' + update;

  				}

  				const declarationSnippet = builder.getVar( type, name ) + ' = ' + startSnippet;
  				const conditionalSnippet = name + ' ' + condition + ' ' + endSnippet;

  				loopSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;

  			}

  			builder.addFlowCode( ( i === 0 ? '\n' : '' ) + builder.tab + loopSnippet + ' {\n\n' ).addFlowTab();

  		}

  		const stackSnippet = stackNode.build( builder, 'void' );

  		const returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';

  		builder.removeFlowTab().addFlowCode( '\n' + builder.tab + stackSnippet );

  		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

  			builder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\n\n' ).removeFlowTab();

  		}

  		builder.addFlowTab();

  		return returnsSnippet;

  	}

  }

  /**
   * TSL function for creating a loop node.
   *
   * @tsl
   * @function
   * @param {...any} params - A list of parameters.
   * @returns {LoopNode}
   */
  const Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).toStack();

  /**
   * TSL function for creating a `Break()` expression.
   *
   * @tsl
   * @function
   * @returns {ExpressionNode}
   */
  const Break = () => expression( 'break' ).toStack();

  const _morphTextures = /*@__PURE__*/ new WeakMap();
  const _morphVec4 = /*@__PURE__*/ new Vector4();

  const getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {

  	const texelIndex = int( vertexIndex ).mul( stride ).add( offset );

  	const y = texelIndex.div( width );
  	const x = texelIndex.sub( y.mul( width ) );

  	const bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth ).xyz;

  	return bufferAttrib.mul( influence );

  } );

  function getEntry( geometry ) {

  	const hasMorphPosition = geometry.morphAttributes.position !== undefined;
  	const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
  	const hasMorphColors = geometry.morphAttributes.color !== undefined;

  	// instead of using attributes, the WebGL 2 code path encodes morph targets
  	// into an array of data textures. Each layer represents a single morph target.

  	const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  	const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  	let entry = _morphTextures.get( geometry );

  	if ( entry === undefined || entry.count !== morphTargetsCount ) {

  		if ( entry !== undefined ) entry.texture.dispose();

  		const morphTargets = geometry.morphAttributes.position || [];
  		const morphNormals = geometry.morphAttributes.normal || [];
  		const morphColors = geometry.morphAttributes.color || [];

  		let vertexDataCount = 0;

  		if ( hasMorphPosition === true ) vertexDataCount = 1;
  		if ( hasMorphNormals === true ) vertexDataCount = 2;
  		if ( hasMorphColors === true ) vertexDataCount = 3;

  		let width = geometry.attributes.position.count * vertexDataCount;
  		let height = 1;

  		const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'

  		if ( width > maxTextureSize ) {

  			height = Math.ceil( width / maxTextureSize );
  			width = maxTextureSize;

  		}

  		const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

  		const bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
  		bufferTexture.type = FloatType;
  		bufferTexture.needsUpdate = true;

  		// fill buffer

  		const vertexDataStride = vertexDataCount * 4;

  		for ( let i = 0; i < morphTargetsCount; i ++ ) {

  			const morphTarget = morphTargets[ i ];
  			const morphNormal = morphNormals[ i ];
  			const morphColor = morphColors[ i ];

  			const offset = width * height * 4 * i;

  			for ( let j = 0; j < morphTarget.count; j ++ ) {

  				const stride = j * vertexDataStride;

  				if ( hasMorphPosition === true ) {

  					_morphVec4.fromBufferAttribute( morphTarget, j );

  					buffer[ offset + stride + 0 ] = _morphVec4.x;
  					buffer[ offset + stride + 1 ] = _morphVec4.y;
  					buffer[ offset + stride + 2 ] = _morphVec4.z;
  					buffer[ offset + stride + 3 ] = 0;

  				}

  				if ( hasMorphNormals === true ) {

  					_morphVec4.fromBufferAttribute( morphNormal, j );

  					buffer[ offset + stride + 4 ] = _morphVec4.x;
  					buffer[ offset + stride + 5 ] = _morphVec4.y;
  					buffer[ offset + stride + 6 ] = _morphVec4.z;
  					buffer[ offset + stride + 7 ] = 0;

  				}

  				if ( hasMorphColors === true ) {

  					_morphVec4.fromBufferAttribute( morphColor, j );

  					buffer[ offset + stride + 8 ] = _morphVec4.x;
  					buffer[ offset + stride + 9 ] = _morphVec4.y;
  					buffer[ offset + stride + 10 ] = _morphVec4.z;
  					buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;

  				}

  			}

  		}

  		entry = {
  			count: morphTargetsCount,
  			texture: bufferTexture,
  			stride: vertexDataCount,
  			size: new Vector2( width, height )
  		};

  		_morphTextures.set( geometry, entry );

  		function disposeTexture() {

  			bufferTexture.dispose();

  			_morphTextures.delete( geometry );

  			geometry.removeEventListener( 'dispose', disposeTexture );

  		}

  		geometry.addEventListener( 'dispose', disposeTexture );

  	}

  	return entry;

  }

  /**
   * This node implements the vertex transformation shader logic which is required
   * for morph target animation.
   *
   * @augments Node
   */
  class MorphNode extends Node {

  	static get type() {

  		return 'MorphNode';

  	}

  	/**
  	 * Constructs a new morph node.
  	 *
  	 * @param {Mesh} mesh - The mesh holding the morph targets.
  	 */
  	constructor( mesh ) {

  		super( 'void' );

  		/**
  		 * The mesh holding the morph targets.
  		 *
  		 * @type {Mesh}
  		 */
  		this.mesh = mesh;

  		/**
  		 * A uniform node which represents the morph base influence value.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.morphBaseInfluence = uniform( 1 );

  		/**
  		 * The update type overwritten since morph nodes are updated per object.
  		 *
  		 * @type {string}
  		 */
  		this.updateType = NodeUpdateType.OBJECT;

  	}

  	/**
  	 * Setups the morph node by assigning the transformed vertex data to predefined node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		const { geometry } = builder;

  		const hasMorphPosition = geometry.morphAttributes.position !== undefined;
  		const hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;

  		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  		// nodes

  		const { texture: bufferMap, stride, size } = getEntry( geometry );

  		if ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );
  		if ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );

  		const width = int( size.width );

  		Loop( morphTargetsCount, ( { i } ) => {

  			const influence = float( 0 ).toVar();

  			if ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {

  				influence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );

  			} else {

  				influence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );

  			}

  			If( influence.notEqual( 0 ), () => {

  				if ( hasMorphPosition === true ) {

  					positionLocal.addAssign( getMorph( {
  						bufferMap,
  						influence,
  						stride,
  						width,
  						depth: i,
  						offset: int( 0 )
  					} ) );

  				}

  				if ( hasMorphNormals === true ) {

  					normalLocal.addAssign( getMorph( {
  						bufferMap,
  						influence,
  						stride,
  						width,
  						depth: i,
  						offset: int( 1 )
  					} ) );

  				}

  			} );

  		} );

  	}

  	/**
  	 * Updates the state of the morphed mesh by updating the base influence.
  	 *
  	 * @param {NodeFrame} frame - The current node frame.
  	 */
  	update( /*frame*/ ) {

  		const morphBaseInfluence = this.morphBaseInfluence;

  		if ( this.mesh.geometry.morphTargetsRelative ) {

  			morphBaseInfluence.value = 1;

  		} else {

  			morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );

  		}

  	}

  }

  /**
   * TSL function for creating a morph node.
   *
   * @tsl
   * @function
   * @param {Mesh} mesh - The mesh holding the morph targets.
   * @returns {MorphNode}
   */
  const morphReference = /*@__PURE__*/ nodeProxy( MorphNode ).setParameterLength( 1 );

  /**
   * Base class for lighting nodes.
   *
   * @augments Node
   */
  class LightingNode extends Node {

  	static get type() {

  		return 'LightingNode';

  	}

  	/**
  	 * Constructs a new lighting node.
  	 */
  	constructor() {

  		super( 'vec3' );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLightingNode = true;

  	}

  }

  /**
   * A generic class that can be used by nodes which contribute
   * ambient occlusion to the scene. E.g. an ambient occlusion map
   * node can be used as input for this module. Used in {@link NodeMaterial}.
   *
   * @augments LightingNode
   */
  class AONode extends LightingNode {

  	static get type() {

  		return 'AONode';

  	}

  	/**
  	 * Constructs a new AO node.
  	 *
  	 * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
  	 */
  	constructor( aoNode = null ) {

  		super();

  		/**
  		 * The ambient occlusion node.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.aoNode = aoNode;

  	}

  	setup( builder ) {

  		builder.context.ambientOcclusion.mulAssign( this.aoNode );

  	}

  }

  /**
   * `LightingContextNode` represents an extension of the {@link ContextNode} module
   * by adding lighting specific context data. It represents the runtime context of
   * {@link LightsNode}.
   *
   * @augments ContextNode
   */
  class LightingContextNode extends ContextNode {

  	static get type() {

  		return 'LightingContextNode';

  	}

  	/**
  	 * Constructs a new lighting context node.
  	 *
  	 * @param {LightsNode} lightsNode - The lights node.
  	 * @param {?LightingModel} [lightingModel=null] - The current lighting model.
  	 * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
  	 * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
  	 */
  	constructor( lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {

  		super( lightsNode );

  		/**
  		 * The current lighting model.
  		 *
  		 * @type {?LightingModel}
  		 * @default null
  		 */
  		this.lightingModel = lightingModel;

  		/**
  		 * A backdrop node.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.backdropNode = backdropNode;

  		/**
  		 * A backdrop alpha node.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.backdropAlphaNode = backdropAlphaNode;

  		this._value = null;

  	}

  	/**
  	 * Returns a lighting context object.
  	 *
  	 * @return {{
  	 * radiance: Node<vec3>,
  	 * irradiance: Node<vec3>,
  	 * iblIrradiance: Node<vec3>,
  	 * ambientOcclusion: Node<float>,
  	 * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
  	 * backdrop: Node<vec3>,
  	 * backdropAlpha: Node<float>
  	 * }} The lighting context object.
  	 */
  	getContext() {

  		const { backdropNode, backdropAlphaNode } = this;

  		const directDiffuse = vec3().toVar( 'directDiffuse' ),
  			directSpecular = vec3().toVar( 'directSpecular' ),
  			indirectDiffuse = vec3().toVar( 'indirectDiffuse' ),
  			indirectSpecular = vec3().toVar( 'indirectSpecular' );

  		const reflectedLight = {
  			directDiffuse,
  			directSpecular,
  			indirectDiffuse,
  			indirectSpecular
  		};

  		const context = {
  			radiance: vec3().toVar( 'radiance' ),
  			irradiance: vec3().toVar( 'irradiance' ),
  			iblIrradiance: vec3().toVar( 'iblIrradiance' ),
  			ambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),
  			reflectedLight,
  			backdrop: backdropNode,
  			backdropAlpha: backdropAlphaNode
  		};

  		return context;

  	}

  	setup( builder ) {

  		this.value = this._value || ( this._value = this.getContext() );
  		this.value.lightingModel = this.lightingModel || builder.context.lightingModel;

  		return super.setup( builder );

  	}

  }

  const lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );

  /**
   * A generic class that can be used by nodes which contribute
   * irradiance to the scene. E.g. a light map node can be used
   * as input for this module. Used in {@link NodeMaterial}.
   *
   * @augments LightingNode
   */
  class IrradianceNode extends LightingNode {

  	static get type() {

  		return 'IrradianceNode';

  	}

  	/**
  	 * Constructs a new irradiance node.
  	 *
  	 * @param {Node<vec3>} node - A node contributing irradiance.
  	 */
  	constructor( node ) {

  		super();

  		/**
  		 * A node contributing irradiance.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.node = node;

  	}

  	setup( builder ) {

  		builder.context.irradiance.addAssign( this.node );

  	}

  }

  let screenSizeVec, viewportVec;

  /**
   * This node provides a collection of screen related metrics.
   * Depending on {@link ScreenNode#scope}, the nodes can represent
   * resolution or viewport data as well as fragment or uv coordinates.
   *
   * @augments Node
   */
  class ScreenNode extends Node {

  	static get type() {

  		return 'ScreenNode';

  	}

  	/**
  	 * Constructs a new screen node.
  	 *
  	 * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.
  	 */
  	constructor( scope ) {

  		super();

  		/**
  		 * The node represents different metric depending on which scope is selected.
  		 *
  		 * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.
  		 * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.
  		 * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.
  		 * - `ScreenNode.UV`: Normalized coordinates.
  		 *
  		 * @type {('coordinate'|'viewport'|'size'|'uv')}
  		 */
  		this.scope = scope;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isViewportNode = true;

  	}

  	/**
  	 * This method is overwritten since the node type depends on the selected scope.
  	 *
  	 * @return {('vec2'|'vec4')} The node type.
  	 */
  	getNodeType() {

  		if ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';
  		else return 'vec2';

  	}

  	/**
  	 * This method is overwritten since the node's update type depends on the selected scope.
  	 *
  	 * @return {NodeUpdateType} The update type.
  	 */
  	getUpdateType() {

  		let updateType = NodeUpdateType.NONE;

  		if ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {

  			updateType = NodeUpdateType.RENDER;

  		}

  		this.updateType = updateType;

  		return updateType;

  	}

  	/**
  	 * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
  	 * from the current renderer.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( { renderer } ) {

  		const renderTarget = renderer.getRenderTarget();

  		if ( this.scope === ScreenNode.VIEWPORT ) {

  			if ( renderTarget !== null ) {

  				viewportVec.copy( renderTarget.viewport );

  			} else {

  				renderer.getViewport( viewportVec );

  				viewportVec.multiplyScalar( renderer.getPixelRatio() );

  			}

  		} else {

  			if ( renderTarget !== null ) {

  				screenSizeVec.width = renderTarget.width;
  				screenSizeVec.height = renderTarget.height;

  			} else {

  				renderer.getDrawingBufferSize( screenSizeVec );

  			}

  		}

  	}

  	setup( /*builder*/ ) {

  		const scope = this.scope;

  		let output = null;

  		if ( scope === ScreenNode.SIZE ) {

  			output = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );

  		} else if ( scope === ScreenNode.VIEWPORT ) {

  			output = uniform( viewportVec || ( viewportVec = new Vector4() ) );

  		} else {

  			output = vec2( screenCoordinate.div( screenSize ) );

  		}

  		return output;

  	}

  	generate( builder ) {

  		if ( this.scope === ScreenNode.COORDINATE ) {

  			let coord = builder.getFragCoord();

  			if ( builder.isFlipY() ) {

  				// follow webgpu standards

  				const size = builder.getNodeProperties( screenSize ).outputNode.build( builder );

  				coord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;

  			}

  			return coord;

  		}

  		return super.generate( builder );

  	}

  }

  ScreenNode.COORDINATE = 'coordinate';
  ScreenNode.VIEWPORT = 'viewport';
  ScreenNode.SIZE = 'size';
  ScreenNode.UV = 'uv';

  // Screen

  /**
   * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.
   *
   * @tsl
   * @type {ScreenNode<vec2>}
   */
  const screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );

  /**
   * TSL object that represents the screen resolution in physical pixel units.
   *
   * @tsl
   * @type {ScreenNode<vec2>}
   */
  const screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );

  /**
   * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.
   *
   * @tsl
   * @type {ScreenNode<vec2>}
   */
  const screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );

  // Viewport

  /**
   * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.
   *
   * @tsl
   * @type {ScreenNode<vec4>}
   */
  const viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );

  /**
   * TSL object that represents the viewport resolution in physical pixel units.
   *
   * @tsl
   * @type {ScreenNode<vec2>}
   */
  viewport.zw;

  /**
   * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.
   *
   * @tsl
   * @type {ScreenNode<vec2>}
   */
  /*@__PURE__*/ screenCoordinate.sub( viewport.xy );

  const _size$4 = /*@__PURE__*/ new Vector2();

  /**
   * A special type of texture node which represents the data of the current viewport
   * as a texture. The module extracts data from the current bound framebuffer with
   * a copy operation so no extra render pass is required to produce the texture data
   * (which is good for performance). `ViewportTextureNode` can be used as an input for a
   * variety of effects like refractive or transmissive materials.
   *
   * @augments TextureNode
   */
  class ViewportTextureNode extends TextureNode {

  	static get type() {

  		return 'ViewportTextureNode';

  	}

  	/**
  	 * Constructs a new viewport texture node.
  	 *
  	 * @param {Node} [uvNode=screenUV] - The uv node.
  	 * @param {?Node} [levelNode=null] - The level node.
  	 * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
  	 */
  	constructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {

  		if ( framebufferTexture === null ) {

  			framebufferTexture = new FramebufferTexture();
  			framebufferTexture.minFilter = LinearMipmapLinearFilter;

  		}

  		super( framebufferTexture, uvNode, levelNode );

  		/**
  		 * Whether to generate mipmaps or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isOutputTextureNode = true;

  		/**
  		 * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
  		 * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.
  		 *
  		 * @type {string}
  		 * @default 'frame'
  		 */
  		this.updateBeforeType = NodeUpdateType.FRAME;

  	}

  	updateBefore( frame ) {

  		const renderer = frame.renderer;
  		renderer.getDrawingBufferSize( _size$4 );

  		//

  		const framebufferTexture = this.value;

  		if ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {

  			framebufferTexture.image.width = _size$4.width;
  			framebufferTexture.image.height = _size$4.height;
  			framebufferTexture.needsUpdate = true;

  		}

  		//

  		const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
  		framebufferTexture.generateMipmaps = this.generateMipmaps;

  		renderer.copyFramebufferToTexture( framebufferTexture );

  		framebufferTexture.generateMipmaps = currentGenerateMipmaps;

  	}

  	clone() {

  		const viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );
  		viewportTextureNode.generateMipmaps = this.generateMipmaps;

  		return viewportTextureNode;

  	}

  }

  /**
   * TSL function for creating a viewport texture node with enabled mipmap generation.
   *
   * @tsl
   * @function
   * @param {?Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   * @returns {ViewportTextureNode}
   */
  const viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } ).setParameterLength( 0, 3 );

  let sharedDepthbuffer = null;

  /**
   * Represents the depth of the current viewport as a texture. This module
   * can be used in combination with viewport texture to achieve effects
   * that require depth evaluation.
   *
   * @augments ViewportTextureNode
   */
  class ViewportDepthTextureNode extends ViewportTextureNode {

  	static get type() {

  		return 'ViewportDepthTextureNode';

  	}

  	/**
  	 * Constructs a new viewport depth texture node.
  	 *
  	 * @param {Node} [uvNode=screenUV] - The uv node.
  	 * @param {?Node} [levelNode=null] - The level node.
  	 */
  	constructor( uvNode = screenUV, levelNode = null ) {

  		if ( sharedDepthbuffer === null ) {

  			sharedDepthbuffer = new DepthTexture();

  		}

  		super( uvNode, levelNode, sharedDepthbuffer );

  	}

  }

  /**
   * TSL function for a viewport depth texture node.
   *
   * @tsl
   * @function
   * @param {?Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @returns {ViewportDepthTextureNode}
   */
  const viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode ).setParameterLength( 0, 2 );

  /**
   * This node offers a collection of features in context of the depth logic in the fragment shader.
   * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current
   * fragment or for depth evaluation purposes.
   *
   * @augments Node
   */
  class ViewportDepthNode extends Node {

  	static get type() {

  		return 'ViewportDepthNode';

  	}

  	/**
  	 * Constructs a new viewport depth node.
  	 *
  	 * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
  	 * @param {?Node} [valueNode=null] - The value node.
  	 */
  	constructor( scope, valueNode = null ) {

  		super( 'float' );

  		/**
  		 * The node behaves differently depending on which scope is selected.
  		 *
  		 * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.
  		 * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).
  		 * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.
  		 * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.
  		 *
  		 * @type {('depth'|'depthBase'|'linearDepth')}
  		 */
  		this.scope = scope;

  		/**
  		 * Can be used to define a custom depth value.
  		 * The property is ignored in the `ViewportDepthNode.DEPTH` scope.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.valueNode = valueNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isViewportDepthNode = true;

  	}

  	generate( builder ) {

  		const { scope } = this;

  		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

  			return builder.getFragDepth();

  		}

  		return super.generate( builder );

  	}

  	setup( { camera } ) {

  		const { scope } = this;
  		const value = this.valueNode;

  		let node = null;

  		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

  			if ( value !== null ) {

   				node = depthBase().assign( value );

  			}

  		} else if ( scope === ViewportDepthNode.DEPTH ) {

  			if ( camera.isPerspectiveCamera ) {

  				node = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );

  			} else {

  				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

  			}

  		} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {

  			if ( value !== null ) {

  				if ( camera.isPerspectiveCamera ) {

  					const viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );

  					node = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

  				} else {

  					node = value;

  				}

  			} else {

  				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

  			}

  		}

  		return node;

  	}

  }

  ViewportDepthNode.DEPTH_BASE = 'depthBase';
  ViewportDepthNode.DEPTH = 'depth';
  ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';

  // NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

  /**
   * TSL function for converting a viewZ value to an orthographic depth value.
   *
   * @tsl
   * @function
   * @param {Node<float>} viewZ - The viewZ node.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );

  /**
   * TSL function for converting a viewZ value to a perspective depth value.
   *
   * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.
   *
   * @tsl
   * @function
   * @param {Node<float>} viewZ - The viewZ node.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );

  /**
   * TSL function for converting a perspective depth value to a viewZ value.
   *
   * @tsl
   * @function
   * @param {Node<float>} depth - The perspective depth.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );

  /**
   * TSL function for converting a viewZ value to a logarithmic depth value.
   *
   * @tsl
   * @function
   * @param {Node<float>} viewZ - The viewZ node.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  const viewZToLogarithmicDepth = ( viewZ, near, far ) => {

  	// NOTE: viewZ must be negative--see explanation at the end of this comment block.
  	// The final logarithmic depth formula used here is adapted from one described in an
  	// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),
  	// which was an improvement upon an earlier formula one described in an
  	// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).
  	// Ulrich's formula is the following:
  	//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )
  	//     where K = 2^k - 1, and k is the number of bits in the depth buffer.
  	// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead
  	// opted for a "C-constant" for resolution adjustment of objects near the camera.
  	// Outerra states: "Notice that the 'C' variant doesn’t use a near plane distance, it has it
  	// set at 0" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).
  	// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.
  	// It was debated here whether Outerra's "C-constant" or Ulrich's "near plane" variant should
  	// be used, and ultimately Ulrich's "near plane" version was chosen.
  	// Outerra eventually made another improvement to their original "C-constant" variant,
  	// but it still does not incorporate the camera near plane (for this version,
  	// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).
  	// Here we make 4 changes to Ulrich's formula:
  	// 1. Clamp the camera near plane so we don't divide by 0.
  	// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).
  	// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).
  	// 4. To maintain consistency with the functions "viewZToOrthographicDepth" and "viewZToPerspectiveDepth",
  	//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,
  	//    so we do the same here, hence the 'viewZ.negate()' call.
  	// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u
  	near = near.max( 1e-6 ).toVar();
  	const numerator = log2( viewZ.negate().div( near ) );
  	const denominator = log2( far.div( near ) );
  	return numerator.div( denominator );

  };

  /**
   * TSL function for defining a value for the current fragment's depth.
   *
   * @tsl
   * @function
   * @param {Node<float>} value - The depth value to set.
   * @returns {ViewportDepthNode<float>}
   */
  const depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );

  /**
   * TSL object that represents the depth value for the current fragment.
   *
   * @tsl
   * @type {ViewportDepthNode}
   */
  const depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );

  /**
   * TSL function for converting a perspective depth value to linear depth.
   *
   * @tsl
   * @function
   * @param {?Node<float>} [value=null] - The perspective depth. If `null` is provided, the current fragment's depth is used.
   * @returns {ViewportDepthNode<float>}
   */
  const linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH ).setParameterLength( 0, 1 );

  /**
   * TSL object that represents the linear (orthographic) depth value of the current fragment
   *
   * @tsl
   * @type {ViewportDepthNode}
   */
  /*@__PURE__*/ linearDepth( viewportDepthTexture() );

  depth.assign = ( value ) => depthBase( value );

  /**
   * This node is used in {@link NodeMaterial} to setup the clipping
   * which can happen hardware-accelerated (if supported) and optionally
   * use alpha-to-coverage for anti-aliasing clipped edges.
   *
   * @augments Node
   */
  class ClippingNode extends Node {

  	static get type() {

  		return 'ClippingNode';

  	}

  	/**
  	 * Constructs a new clipping node.
  	 *
  	 * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
  	 * the selected scope influences the behavior of the node and what type of code is generated.
  	 */
  	constructor( scope = ClippingNode.DEFAULT ) {

  		super();

  		/**
  		 * The node's scope. Similar to other nodes, the selected scope influences
  		 * the behavior of the node and what type of code is generated.
  		 *
  		 * @type {('default'|'hardware'|'alphaToCoverage')}
  		 */
  		this.scope = scope;

  	}

  	/**
  	 * Setups the node depending on the selected scope.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node} The result node.
  	 */
  	setup( builder ) {

  		super.setup( builder );

  		const clippingContext = builder.clippingContext;
  		const { intersectionPlanes, unionPlanes } = clippingContext;

  		this.hardwareClipping = builder.material.hardwareClipping;

  		if ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {

  			return this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );

  		} else if ( this.scope === ClippingNode.HARDWARE ) {

  			return this.setupHardwareClipping( unionPlanes, builder );

  		} else {

  			return this.setupDefault( intersectionPlanes, unionPlanes );

  		}

  	}

  	/**
  	 * Setups alpha to coverage.
  	 *
  	 * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
  	 * @param {Array<Vector4>} unionPlanes - The union planes.
  	 * @return {Node} The result node.
  	 */
  	setupAlphaToCoverage( intersectionPlanes, unionPlanes ) {

  		return Fn( () => {

  			const distanceToPlane = float().toVar( 'distanceToPlane' );
  			const distanceGradient = float().toVar( 'distanceToGradient' );

  			const clipOpacity = float( 1 ).toVar( 'clipOpacity' );

  			const numUnionPlanes = unionPlanes.length;

  			if ( this.hardwareClipping === false && numUnionPlanes > 0 ) {

  				const clippingPlanes = uniformArray( unionPlanes );

  				Loop( numUnionPlanes, ( { i } ) => {

  					const plane = clippingPlanes.element( i );

  					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
  					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

  					clipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );

  				} );

  			}

  			const numIntersectionPlanes = intersectionPlanes.length;

  			if ( numIntersectionPlanes > 0 ) {

  				const clippingPlanes = uniformArray( intersectionPlanes );
  				const intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );

  				Loop( numIntersectionPlanes, ( { i } ) => {

  					const plane = clippingPlanes.element( i );

  					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
  					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

  					intersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );

  				} );

  				clipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );

  			}

  			diffuseColor.a.mulAssign( clipOpacity );

  			diffuseColor.a.equal( 0.0 ).discard();

  		} )();

  	}

  	/**
  	 * Setups the default clipping.
  	 *
  	 * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
  	 * @param {Array<Vector4>} unionPlanes - The union planes.
  	 * @return {Node} The result node.
  	 */
  	setupDefault( intersectionPlanes, unionPlanes ) {

  		return Fn( () => {

  			const numUnionPlanes = unionPlanes.length;

  			if ( this.hardwareClipping === false && numUnionPlanes > 0 ) {

  				const clippingPlanes = uniformArray( unionPlanes );

  				Loop( numUnionPlanes, ( { i } ) => {

  					const plane = clippingPlanes.element( i );
  					positionView.dot( plane.xyz ).greaterThan( plane.w ).discard();

  				} );

  			}

  			const numIntersectionPlanes = intersectionPlanes.length;

  			if ( numIntersectionPlanes > 0 ) {

  				const clippingPlanes = uniformArray( intersectionPlanes );
  				const clipped = bool( true ).toVar( 'clipped' );

  				Loop( numIntersectionPlanes, ( { i } ) => {

  					const plane = clippingPlanes.element( i );
  					clipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );

  				} );

  				clipped.discard();

  			}

  		} )();

  	}

  	/**
  	 * Setups hardware clipping.
  	 *
  	 * @param {Array<Vector4>} unionPlanes - The union planes.
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node} The result node.
  	 */
  	setupHardwareClipping( unionPlanes, builder ) {

  		const numUnionPlanes = unionPlanes.length;

  		builder.enableHardwareClipping( numUnionPlanes );

  		return Fn( () => {

  			const clippingPlanes = uniformArray( unionPlanes );
  			const hw_clip_distances = builtin( builder.getClipDistance() );

  			Loop( numUnionPlanes, ( { i } ) => {

  				const plane = clippingPlanes.element( i );

  				const distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();
  				hw_clip_distances.element( i ).assign( distance );

  			} );

  		} )();

  	}

  }

  ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
  ClippingNode.DEFAULT = 'default';
  ClippingNode.HARDWARE = 'hardware';

  /**
   * TSL function for setting up the default clipping logic.
   *
   * @tsl
   * @function
   * @returns {ClippingNode}
   */
  const clipping = () => nodeObject( new ClippingNode() );

  /**
   * TSL function for setting up alpha to coverage.
   *
   * @tsl
   * @function
   * @returns {ClippingNode}
   */
  const clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );

  /**
   * TSL function for setting up hardware-based clipping.
   *
   * @tsl
   * @function
   * @returns {ClippingNode}
   */
  const hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );

  // See: https://casual-effects.com/research/Wyman2017Hashed/index.html

  const ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

  const hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {

  	return fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );

  } );

  const hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {

  	return hash2D( vec2( hash2D( value.xy ), value.z ) );

  } );

  const getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {

  	// Find the discretized derivatives of our coordinates
  	const maxDeriv = max$1(
  		length( dFdx( position.xyz ) ),
  		length( dFdy( position.xyz ) )
  	);

  	const pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );

  	// Find two nearest log-discretized noise scales
  	const pixScales = vec2(
  		exp2( floor( log2( pixScale ) ) ),
  		exp2( ceil( log2( pixScale ) ) )
  	);

  	// Compute alpha thresholds at our two noise scales
  	const alpha = vec2(
  		hash3D( floor( pixScales.x.mul( position.xyz ) ) ),
  		hash3D( floor( pixScales.y.mul( position.xyz ) ) ),
  	);

  	// Factor to interpolate lerp with
  	const lerpFactor = fract( log2( pixScale ) );

  	// Interpolate alpha threshold from noise at two scales
  	const x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );

  	// Pass into CDF to compute uniformly distrib threshold
  	const a = min$1( lerpFactor, lerpFactor.oneMinus() );
  	const cases = vec3(
  		x.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),
  		x.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),
  		sub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );

  	// Find our final, uniformly distributed alpha threshold (ατ)
  	const threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );

  	// Avoids ατ == 0. Could also do ατ =1-ατ
  	return clamp( threshold, 1.0e-6, 1.0 );

  } ).setLayout( {
  	name: 'getAlphaHashThreshold',
  	type: 'float',
  	inputs: [
  		{ name: 'position', type: 'vec3' }
  	]
  } );

  /**
   * An attribute node for representing vertex colors.
   *
   * @augments AttributeNode
   */
  class VertexColorNode extends AttributeNode {

  	static get type() {

  		return 'VertexColorNode';

  	}

  	/**
  	 * Constructs a new vertex color node.
  	 *
  	 * @param {number} index - The attribute index.
  	 */
  	constructor( index ) {

  		super( null, 'vec4' );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isVertexColorNode = true;

  		/**
  		 * The attribute index to enable more than one sets of vertex colors.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.index = index;

  	}

  	/**
  	 * Overwrites the default implementation by honoring the attribute index.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The attribute name.
  	 */
  	getAttributeName( /*builder*/ ) {

  		const index = this.index;

  		return 'color' + ( index > 0 ? index : '' );

  	}

  	generate( builder ) {

  		const attributeName = this.getAttributeName( builder );
  		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

  		let result;

  		if ( geometryAttribute === true ) {

  			result = super.generate( builder );

  		} else {

  			// Vertex color fallback should be white
  			result = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );

  		}

  		return result;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.index = this.index;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.index = data.index;

  	}

  }

  /**
   * TSL function for creating a reference node.
   *
   * @tsl
   * @function
   * @param {number} [index=0] - The attribute index.
   * @returns {VertexColorNode}
   */
  const vertexColor = ( index = 0 ) => nodeObject( new VertexColorNode( index ) );

  /**
   * Premultiplies the RGB channels of a color by its alpha channel.
   *
   * This function is useful for converting a non-premultiplied alpha color
   * into a premultiplied alpha format, where the RGB values are scaled
   * by the alpha value. Premultiplied alpha is often used in graphics
   * rendering for certain operations, such as compositing and image processing.
   *
   * @tsl
   * @function
   * @param {Node<vec4>} color - The input color with non-premultiplied alpha.
   * @return {Node<vec4>} The color with premultiplied alpha.
   */
  const premultiplyAlpha = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	return vec4( color.rgb.mul( color.a ), color.a );

  }, { color: 'vec4', return: 'vec4' } );

  /**
   * Base class for all node materials.
   *
   * @augments Material
   */
  class NodeMaterial extends Material {

  	static get type() {

  		return 'NodeMaterial';

  	}

  	/**
  	 * Represents the type of the node material.
  	 *
  	 * @type {string}
  	 */
  	get type() {

  		return this.constructor.type;

  	}

  	set type( _value ) { /* */ }

  	/**
  	 * Constructs a new node material.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNodeMaterial = true;

  		/**
  		 * Whether this material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		/**
  		 * Whether this material is affected by lights or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.lights = false;

  		/**
  		 * Whether this material uses hardware clipping or not.
  		 * This property is managed by the engine and should not be
  		 * modified by apps.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.hardwareClipping = false;

  		/**
  		 * Node materials which set their `lights` property to `true`
  		 * are affected by all lights of the scene. Sometimes selective
  		 * lighting is wanted which means only _some_ lights in the scene
  		 * affect a material. This can be achieved by creating an instance
  		 * of {@link LightsNode} with a list of selective
  		 * lights and assign the node to this property.
  		 *
  		 * ```js
  		 * const customLightsNode = lights( [ light1, light2 ] );
  		 * material.lightsNode = customLightsNode;
  		 * ```
  		 *
  		 * @type {?LightsNode}
  		 * @default null
  		 */
  		this.lightsNode = null;

  		/**
  		 * The environment of node materials can be defined by an environment
  		 * map assigned to the `envMap` property or by `Scene.environment`
  		 * if the node material is a PBR material. This node property allows to overwrite
  		 * the default behavior and define the environment with a custom node.
  		 *
  		 * ```js
  		 * material.envNode = pmremTexture( renderTarget.texture );
  		 * ```
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.envNode = null;

  		/**
  		 * The lighting of node materials might be influenced by ambient occlusion.
  		 * The default AO is inferred from an ambient occlusion map assigned to `aoMap`
  		 * and the respective `aoMapIntensity`. This node property allows to overwrite
  		 * the default and define the ambient occlusion with a custom node instead.
  		 *
  		 * If you don't want to overwrite the diffuse color but modify the existing
  		 * values instead, use {@link materialAO}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.aoNode = null;

  		/**
  		 * The diffuse color of node materials is by default inferred from the
  		 * `color` and `map` properties. This node property allows to overwrite the default
  		 * and define the diffuse color with a node instead.
  		 *
  		 * ```js
  		 * material.colorNode = color( 0xff0000 ); // define red color
  		 * ```
  		 *
  		 * If you don't want to overwrite the diffuse color but modify the existing
  		 * values instead, use {@link materialColor}.
  		 *
  		 * ```js
  		 * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint
  		 * ```
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.colorNode = null;

  		/**
  		 * The normals of node materials are by default inferred from the `normalMap`/`normalScale`
  		 * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default
  		 * and define the normals with a node instead.
  		 *
  		 * If you don't want to overwrite the normals but modify the existing values instead,
  		 * use {@link materialNormal}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.normalNode = null;

  		/**
  		 * The opacity of node materials is by default inferred from the `opacity`
  		 * and `alphaMap` properties. This node property allows to overwrite the default
  		 * and define the opacity with a node instead.
  		 *
  		 * If you don't want to overwrite the normals but modify the existing
  		 * value instead, use {@link materialOpacity}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.opacityNode = null;

  		/**
  		 * This node can be used to implement a variety of filter-like effects. The idea is
  		 * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it
  		 * to create an arbitrary effect and then assign the node composition to this property.
  		 * Everything behind the object using this material will now be affected by a filter.
  		 *
  		 * ```js
  		 * const material = new NodeMaterial()
  		 * material.transparent = true;
  		 *
  		 * // everything behind the object will be monochromatic
  		 * material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );
  		 * ```
  		 *
  		 * Backdrop computations are part of the lighting so only lit materials can use this property.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.backdropNode = null;

  		/**
  		 * This node allows to modulate the influence of `backdropNode` to the outgoing light.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.backdropAlphaNode = null;

  		/**
  		 * The alpha test of node materials is by default inferred from the `alphaTest`
  		 * property. This node property allows to overwrite the default and define the
  		 * alpha test with a node instead.
  		 *
  		 * If you don't want to overwrite the alpha test but modify the existing
  		 * value instead, use {@link materialAlphaTest}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.alphaTestNode = null;


  		/**
  		 * Discards the fragment if the mask value is `false`.
  		 *
  		 * @type {?Node<bool>}
  		 * @default null
  		 */
  		this.maskNode = null;

  		/**
  		 * The local vertex positions are computed based on multiple factors like the
  		 * attribute data, morphing or skinning. This node property allows to overwrite
  		 * the default and define local vertex positions with nodes instead.
  		 *
  		 * If you don't want to overwrite the vertex positions but modify the existing
  		 * values instead, use {@link positionLocal}.
  		 *
  		 *```js
  		 * material.positionNode = positionLocal.add( displace );
  		 * ```
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.positionNode = null;

  		/**
  		 * This node property is intended for logic which modifies geometry data once or per animation step.
  		 * Apps usually place such logic randomly in initialization routines or in the animation loop.
  		 * `geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications
  		 * can be implemented.
  		 *
  		 * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example
  		 * would be a GPU based particle system that provides a node material for usage on app level. The particle
  		 * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is
  		 * eventually assigned to `geometryNode`.
  		 *
  		 * @type {?Function}
  		 * @default null
  		 */
  		this.geometryNode = null;

  		/**
  		 * Allows to overwrite depth values in the fragment shader.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.depthNode = null;

  		/**
  		 * Allows to overwrite the position used for shadow map rendering which
  		 * is by default {@link positionWorld}, the vertex position
  		 * in world space.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.receivedShadowPositionNode = null;

  		/**
  		 * Allows to overwrite the geometry position used for shadow map projection which
  		 * is by default {@link positionLocal}, the vertex position in local space.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.castShadowPositionNode = null;

  		/**
  		 * This node can be used to influence how an object using this node material
  		 * receive shadows.
  		 *
  		 * ```js
  		 * const totalShadows = float( 1 ).toVar();
  		 * material.receivedShadowNode = Fn( ( [ shadow ] ) => {
  		 * 	totalShadows.mulAssign( shadow );
  		 * 	//return float( 1 ); // bypass received shadows
  		 * 	return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color
  		 * } );
  		 *
  		 * @type {?(Function|FunctionNode<vec4>)}
  		 * @default null
  		 */
  		this.receivedShadowNode = null;

  		/**
  		 * This node can be used to influence how an object using this node material
  		 * casts shadows. To apply a color to shadows, you can simply do:
  		 *
  		 * ```js
  		 * material.castShadowNode = vec4( 1, 0, 0, 1 );
  		 * ```
  		 *
  		 * Which can be nice to fake colored shadows of semi-transparent objects. It
  		 * is also common to use the property with `Fn` function so checks are performed
  		 * per fragment.
  		 *
  		 * ```js
  		 * materialCustomShadow.castShadowNode = Fn( () => {
  		 * 	hash( vertexIndex ).greaterThan( 0.5 ).discard();
  		 * 	return materialColor;
  		 * } )();
  		 *  ```
  		 *
  		 * @type {?Node<vec4>}
  		 * @default null
  		 */
  		this.castShadowNode = null;

  		/**
  		 * This node can be used to define the final output of the material.
  		 *
  		 * TODO: Explain the differences to `fragmentNode`.
  		 *
  		 * @type {?Node<vec4>}
  		 * @default null
  		 */
  		this.outputNode = null;

  		/**
  		 * MRT configuration is done on renderer or pass level. This node allows to
  		 * overwrite what values are written into MRT targets on material level. This
  		 * can be useful for implementing selective FX features that should only affect
  		 * specific objects.
  		 *
  		 * @type {?MRTNode}
  		 * @default null
  		 */
  		this.mrtNode = null;

  		/**
  		 * This node property can be used if you need complete freedom in implementing
  		 * the fragment shader. Assigning a node will replace the built-in material
  		 * logic used in the fragment stage.
  		 *
  		 * @type {?Node<vec4>}
  		 * @default null
  		 */
  		this.fragmentNode = null;

  		/**
  		 * This node property can be used if you need complete freedom in implementing
  		 * the vertex shader. Assigning a node will replace the built-in material logic
  		 * used in the vertex stage.
  		 *
  		 * @type {?Node<vec4>}
  		 * @default null
  		 */
  		this.vertexNode = null;

  		// Deprecated properties

  		Object.defineProperty( this, 'shadowPositionNode', { // @deprecated, r176

  			get: () => {

  				return this.receivedShadowPositionNode;

  			},

  			set: ( value ) => {

  				console.warn( 'THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".' );

  				this.receivedShadowPositionNode = value;

  			}

  		} );

  	}

  	/**
  	 * Allows to define a custom cache key that influence the material key computation
  	 * for render objects.
  	 *
  	 * @return {string} The custom cache key.
  	 */
  	customProgramCacheKey() {

  		return this.type + getCacheKey$1( this );

  	}

  	/**
  	 * Builds this material with the given node builder.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	build( builder ) {

  		this.setup( builder );

  	}

  	/**
  	 * Setups a node material observer with the given builder.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {NodeMaterialObserver} The node material observer.
  	 */
  	setupObserver( builder ) {

  		return new NodeMaterialObserver( builder );

  	}

  	/**
  	 * Setups the vertex and fragment stage of this node material.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		builder.context.setupNormal = () => subBuild( this.setupNormal( builder ), 'NORMAL', 'vec3' );
  		builder.context.setupPositionView = () => this.setupPositionView( builder );
  		builder.context.setupModelViewProjection = () => this.setupModelViewProjection( builder );

  		const renderer = builder.renderer;
  		const renderTarget = renderer.getRenderTarget();

  		// < VERTEX STAGE >

  		builder.addStack();

  		const mvp = subBuild( this.setupVertex( builder ), 'VERTEX' );

  		const vertexNode = this.vertexNode || mvp;

  		builder.stack.outputNode = vertexNode;

  		this.setupHardwareClipping( builder );

  		if ( this.geometryNode !== null ) {

  			builder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );

  		}

  		builder.addFlow( 'vertex', builder.removeStack() );

  		// < FRAGMENT STAGE >

  		builder.addStack();

  		let resultNode;

  		const clippingNode = this.setupClipping( builder );

  		if ( this.depthWrite === true || this.depthTest === true ) {

  			// only write depth if depth buffer is configured

  			if ( renderTarget !== null ) {

  				if ( renderTarget.depthBuffer === true ) this.setupDepth( builder );

  			} else {

  				if ( renderer.depth === true ) this.setupDepth( builder );

  			}

  		}

  		if ( this.fragmentNode === null ) {

  			this.setupDiffuseColor( builder );
  			this.setupVariants( builder );

  			const outgoingLightNode = this.setupLighting( builder );

  			if ( clippingNode !== null ) builder.stack.add( clippingNode );

  			// force unsigned floats - useful for RenderTargets

  			const basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );

  			resultNode = this.setupOutput( builder, basicOutput );

  			// OUTPUT NODE

  			output.assign( resultNode );

  			//

  			const isCustomOutput = this.outputNode !== null;

  			if ( isCustomOutput ) resultNode = this.outputNode;

  			// MRT

  			if ( renderTarget !== null ) {

  				const mrt = renderer.getMRT();
  				const materialMRT = this.mrtNode;

  				if ( mrt !== null ) {

  					if ( isCustomOutput ) output.assign( resultNode );

  					resultNode = mrt;

  					if ( materialMRT !== null ) {

  						resultNode = mrt.merge( materialMRT );

  					}

  				} else if ( materialMRT !== null ) {

  					resultNode = materialMRT;

  				}

  			}

  		} else {

  			let fragmentNode = this.fragmentNode;

  			if ( fragmentNode.isOutputStructNode !== true ) {

  				fragmentNode = vec4( fragmentNode );

  			}

  			resultNode = this.setupOutput( builder, fragmentNode );

  		}

  		builder.stack.outputNode = resultNode;

  		builder.addFlow( 'fragment', builder.removeStack() );

  		// < OBSERVER >

  		builder.observer = this.setupObserver( builder );

  	}

  	/**
  	 * Setups the clipping node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {ClippingNode} The clipping node.
  	 */
  	setupClipping( builder ) {

  		if ( builder.clippingContext === null ) return null;

  		const { unionPlanes, intersectionPlanes } = builder.clippingContext;

  		let result = null;

  		if ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {

  			const samples = builder.renderer.samples;

  			if ( this.alphaToCoverage && samples > 1 ) {

  				// to be added to flow when the color/alpha value has been determined
  				result = clippingAlpha();

  			} else {

  				builder.stack.add( clipping() );

  			}

  		}

  		return result;

  	}

  	/**
  	 * Setups the hardware clipping if available on the current device.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupHardwareClipping( builder ) {

  		this.hardwareClipping = false;

  		if ( builder.clippingContext === null ) return;

  		const candidateCount = builder.clippingContext.unionPlanes.length;

  		// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances

  		if ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {

  			builder.stack.add( hardwareClipping() );

  			this.hardwareClipping = true;

  		}

  		return;

  	}

  	/**
  	 * Setups the depth of this material.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupDepth( builder ) {

  		const { renderer, camera } = builder;

  		// Depth

  		let depthNode = this.depthNode;

  		if ( depthNode === null ) {

  			const mrt = renderer.getMRT();

  			if ( mrt && mrt.has( 'depth' ) ) {

  				depthNode = mrt.get( 'depth' );

  			} else if ( renderer.logarithmicDepthBuffer === true ) {

  				if ( camera.isPerspectiveCamera ) {

  					depthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );

  				} else {

  					depthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

  				}

  			}

  		}

  		if ( depthNode !== null ) {

  			depth.assign( depthNode ).toStack();

  		}

  	}

  	/**
  	 * Setups the position node in view space. This method exists
  	 * so derived node materials can modify the implementation e.g. sprite materials.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The position in view space.
  	 */
  	setupPositionView( /*builder*/ ) {

  		return modelViewMatrix.mul( positionLocal ).xyz;

  	}

  	/**
  	 * Setups the position in clip space.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec4>} The position in view space.
  	 */
  	setupModelViewProjection( /*builder*/ ) {

  		return cameraProjectionMatrix.mul( positionView );

  	}

  	/**
  	 * Setups the logic for the vertex stage.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec4>} The position in clip space.
  	 */
  	setupVertex( builder ) {

  		builder.addStack();

  		this.setupPosition( builder );

  		builder.context.vertex = builder.removeStack();

  		return modelViewProjection;

  	}

  	/**
  	 * Setups the computation of the position in local space.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The position in local space.
  	 */
  	setupPosition( builder ) {

  		const { object, geometry } = builder;

  		if ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {

  			morphReference( object ).toStack();

  		}

  		if ( object.isSkinnedMesh === true ) {

  			skinning( object ).toStack();

  		}

  		if ( this.displacementMap ) {

  			const displacementMap = materialReference( 'displacementMap', 'texture' );
  			const displacementScale = materialReference( 'displacementScale', 'float' );
  			const displacementBias = materialReference( 'displacementBias', 'float' );

  			positionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );

  		}

  		if ( object.isBatchedMesh ) {

  			batch( object ).toStack();

  		}

  		if ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {

  			instancedMesh( object ).toStack();

  		}

  		if ( this.positionNode !== null ) {

  			positionLocal.assign( subBuild( this.positionNode, 'POSITION', 'vec3' ) );

  		}

  		return positionLocal;

  	}

  	/**
  	 * Setups the computation of the material's diffuse color.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {BufferGeometry} geometry - The geometry.
  	 */
  	setupDiffuseColor( { object, geometry } ) {

  		// MASK

  		if ( this.maskNode !== null ) {

  			// Discard if the mask is `false`

  			bool( this.maskNode ).not().discard();

  		}

  		// COLOR

  		let colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;

  		// VERTEX COLORS

  		if ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {

  			colorNode = colorNode.mul( vertexColor() );

  		}

  		// INSTANCED COLORS

  		if ( object.instanceColor ) {

  			const instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );

  			colorNode = instanceColor.mul( colorNode );

  		}

  		if ( object.isBatchedMesh && object._colorsTexture ) {

  			const batchColor = varyingProperty( 'vec3', 'vBatchColor' );

  			colorNode = batchColor.mul( colorNode );

  		}

  		// DIFFUSE COLOR

  		diffuseColor.assign( colorNode );

  		// OPACITY

  		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;
  		diffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );

  		// ALPHA TEST

  		let alphaTestNode = null;

  		if ( this.alphaTestNode !== null || this.alphaTest > 0 ) {

  			alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;

  			diffuseColor.a.lessThanEqual( alphaTestNode ).discard();

  		}

  		// ALPHA HASH

  		if ( this.alphaHash === true ) {

  			diffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();

  		}

  		// OPAQUE

  		const isOpaque = this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false;

  		if ( isOpaque ) {

  			diffuseColor.a.assign( 1.0 );

  		} else if ( alphaTestNode === null ) {

  			diffuseColor.a.lessThanEqual( 0 ).discard();

  		}

  	}

  	/**
  	 * Abstract interface method that can be implemented by derived materials
  	 * to setup material-specific node variables.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupVariants( /*builder*/ ) {

  		// Interface function.

  	}

  	/**
  	 * Setups the outgoing light node variable
  	 *
  	 * @return {Node<vec3>} The outgoing light node.
  	 */
  	setupOutgoingLight() {

  		return ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;

  	}

  	/**
  	 * Setups the normal node from the material.
  	 *
  	 * @return {Node<vec3>} The normal node.
  	 */
  	setupNormal() {

  		return this.normalNode ? vec3( this.normalNode ) : materialNormal;

  	}

  	/**
  	 * Setups the environment node from the material.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec4>} The environment node.
  	 */
  	setupEnvironment( /*builder*/ ) {

  		let node = null;

  		if ( this.envNode ) {

  			node = this.envNode;

  		} else if ( this.envMap ) {

  			node = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );

  		}

  		return node;

  	}

  	/**
  	 * Setups the light map node from the material.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The light map node.
  	 */
  	setupLightMap( builder ) {

  		let node = null;

  		if ( builder.material.lightMap ) {

  			node = new IrradianceNode( materialLightMap );

  		}

  		return node;

  	}

  	/**
  	 * Setups the lights node based on the scene, environment and material.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {LightsNode} The lights node.
  	 */
  	setupLights( builder ) {

  		const materialLightsNode = [];

  		//

  		const envNode = this.setupEnvironment( builder );

  		if ( envNode && envNode.isLightingNode ) {

  			materialLightsNode.push( envNode );

  		}

  		const lightMapNode = this.setupLightMap( builder );

  		if ( lightMapNode && lightMapNode.isLightingNode ) {

  			materialLightsNode.push( lightMapNode );

  		}

  		if ( this.aoNode !== null || builder.material.aoMap ) {

  			const aoNode = this.aoNode !== null ? this.aoNode : materialAO;

  			materialLightsNode.push( new AONode( aoNode ) );

  		}

  		let lightsN = this.lightsNode || builder.lightsNode;

  		if ( materialLightsNode.length > 0 ) {

  			lightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );

  		}

  		return lightsN;

  	}

  	/**
  	 * This method should be implemented by most derived materials
  	 * since it defines the material's lighting model.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {LightingModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		// Interface function.

  	}

  	/**
  	 * Setups the outgoing light node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The outgoing light node.
  	 */
  	setupLighting( builder ) {

  		const { material } = builder;
  		const { backdropNode, backdropAlphaNode, emissiveNode } = this;

  		// OUTGOING LIGHT

  		const lights = this.lights === true || this.lightsNode !== null;

  		const lightsNode = lights ? this.setupLights( builder ) : null;

  		let outgoingLightNode = this.setupOutgoingLight( builder );

  		if ( lightsNode && lightsNode.getScope().hasLights ) {

  			const lightingModel = this.setupLightingModel( builder ) || null;

  			outgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );

  		} else if ( backdropNode !== null ) {

  			outgoingLightNode = vec3( backdropAlphaNode !== null ? mix$2( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );

  		}

  		// EMISSIVE

  		if ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {

  			emissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );

  			outgoingLightNode = outgoingLightNode.add( emissive );

  		}

  		return outgoingLightNode;

  	}

  	/**
  	 * Setup the fog.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node<vec4>} outputNode - The existing output node.
  	 * @return {Node<vec4>} The output node.
  	 */
  	setupFog( builder, outputNode ) {

  		const fogNode = builder.fogNode;

  		if ( fogNode ) {

  			output.assign( outputNode );

  			outputNode = vec4( fogNode );

  		}

  		return outputNode;

  	}

  	/**
  	 * Setups premultiplied alpha.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node<vec4>} outputNode - The existing output node.
  	 * @return {Node<vec4>} The output node.
  	 */
  	setupPremultipliedAlpha( builder, outputNode ) {

  		return premultiplyAlpha( outputNode );

  	}

  	/**
  	 * Setups the output node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node<vec4>} outputNode - The existing output node.
  	 * @return {Node<vec4>} The output node.
  	 */
  	setupOutput( builder, outputNode ) {

  		// FOG

  		if ( this.fog === true ) {

  			outputNode = this.setupFog( builder, outputNode );

  		}

  		// PREMULTIPLIED ALPHA

  		if ( this.premultipliedAlpha === true ) {

  			outputNode = this.setupPremultipliedAlpha( builder, outputNode );

  		}

  		return outputNode;

  	}

  	/**
  	 * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
  	 * there is `MeshBasicNodeMaterial`. This utility method is intended for
  	 * defining all material properties of the classic type in the node type.
  	 *
  	 * @param {Material} material - The material to copy properties with their values to this node material.
  	 */
  	setDefaultValues( material ) {

  		// This approach is to reuse the native refreshUniforms*
  		// and turn available the use of features like transmission and environment in core

  		for ( const property in material ) {

  			const value = material[ property ];

  			if ( this[ property ] === undefined ) {

  				this[ property ] = value;

  				if ( value && value.clone ) this[ property ] = value.clone();

  			}

  		}

  		const descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );

  		for ( const key in descriptors ) {

  			if ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&
  			     descriptors[ key ].get !== undefined ) {

  				Object.defineProperty( this.constructor.prototype, key, descriptors[ key ] );

  			}

  		}

  	}

  	/**
  	 * Serializes this material to JSON.
  	 *
  	 * @param {?(Object|string)} meta - The meta information for serialization.
  	 * @return {Object} The serialized node.
  	 */
  	toJSON( meta ) {

  		const isRoot = ( meta === undefined || typeof meta === 'string' );

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {},
  				nodes: {}
  			};

  		}

  		const data = Material.prototype.toJSON.call( this, meta );
  		const nodeChildren = getNodeChildren( this );

  		data.inputNodes = {};

  		for ( const { property, childNode } of nodeChildren ) {

  			data.inputNodes[ property ] = childNode.toJSON( meta ).uuid;

  		}

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const nodes = extractFromCache( meta.nodes );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;
  			if ( nodes.length > 0 ) data.nodes = nodes;

  		}

  		return data;

  	}

  	/**
  	 * Copies the properties of the given node material to this instance.
  	 *
  	 * @param {NodeMaterial} source - The material to copy.
  	 * @return {NodeMaterial} A reference to this node material.
  	 */
  	copy( source ) {

  		this.lightsNode = source.lightsNode;
  		this.envNode = source.envNode;

  		this.colorNode = source.colorNode;
  		this.normalNode = source.normalNode;
  		this.opacityNode = source.opacityNode;
  		this.backdropNode = source.backdropNode;
  		this.backdropAlphaNode = source.backdropAlphaNode;
  		this.alphaTestNode = source.alphaTestNode;
  		this.maskNode = source.maskNode;

  		this.positionNode = source.positionNode;
  		this.geometryNode = source.geometryNode;

  		this.depthNode = source.depthNode;
  		this.receivedShadowPositionNode = source.receivedShadowPositionNode;
  		this.castShadowPositionNode = source.castShadowPositionNode;
  		this.receivedShadowNode = source.receivedShadowNode;
  		this.castShadowNode = source.castShadowNode;

  		this.outputNode = source.outputNode;
  		this.mrtNode = source.mrtNode;

  		this.fragmentNode = source.fragmentNode;
  		this.vertexNode = source.vertexNode;

  		return super.copy( source );

  	}

  }

  const _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();

  /**
   * Node material version of {@link LineBasicMaterial}.
   *
   * @augments NodeMaterial
   */
  class LineBasicNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'LineBasicNodeMaterial';

  	}

  	/**
  	 * Constructs a new line basic node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineBasicNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$d );

  		this.setValues( parameters );

  	}

  }

  const _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();

  /**
   * Node material version of  {@link LineDashedMaterial}.
   *
   * @augments NodeMaterial
   */
  class LineDashedNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'LineDashedNodeMaterial';

  	}

  	/**
  	 * Constructs a new line dashed node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineDashedNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$c );

  		/**
  		 * The dash offset.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.dashOffset = 0;

  		/**
  		 * The offset of dash materials is by default inferred from the `dashOffset`
  		 * property. This node property allows to overwrite the default
  		 * and define the offset with a node instead.
  		 *
  		 * If you don't want to overwrite the offset but modify the existing
  		 * value instead, use {@link materialLineDashOffset}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.offsetNode = null;

  		/**
  		 * The scale of dash materials is by default inferred from the `scale`
  		 * property. This node property allows to overwrite the default
  		 * and define the scale with a node instead.
  		 *
  		 * If you don't want to overwrite the scale but modify the existing
  		 * value instead, use {@link materialLineScale}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.dashScaleNode = null;

  		/**
  		 * The dash size of dash materials is by default inferred from the `dashSize`
  		 * property. This node property allows to overwrite the default
  		 * and define the dash size with a node instead.
  		 *
  		 * If you don't want to overwrite the dash size but modify the existing
  		 * value instead, use {@link materialLineDashSize}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.dashSizeNode = null;

  		/**
  		 * The gap size of dash materials is by default inferred from the `gapSize`
  		 * property. This node property allows to overwrite the default
  		 * and define the gap size with a node instead.
  		 *
  		 * If you don't want to overwrite the gap size but modify the existing
  		 * value instead, use {@link materialLineGapSize}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.gapSizeNode = null;

  		this.setValues( parameters );

  	}

  	/**
  	 * Setups the dash specific node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupVariants( /* builder */ ) {

  		const offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;
  		const dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;
  		const dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;
  		const gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;

  		dashSize.assign( dashSizeNode );
  		gapSize.assign( gapSizeNode );

  		const vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );
  		const vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;

  		vLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();

  	}

  }

  /**
   * Packs a direction vector into a color value.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} node - The direction to pack.
   * @return {Node<vec3>} The color.
   */
  const directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );

  const _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();

  /**
   * Node material version of {@link MeshNormalMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshNormalNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshNormalNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh normal node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshNormalNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$a );

  		this.setValues( parameters );

  	}

  	/**
  	 * Overwrites the default implementation by computing the diffuse color
  	 * based on the normal data.
  	 */
  	setupDiffuseColor() {

  		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

  		// By convention, a normal packed to RGB is in sRGB color space. Convert it to working color space.

  		diffuseColor.assign( colorSpaceToWorking( vec4( directionToColor( normalView ), opacityNode ), SRGBColorSpace ) );

  	}

  }

  /**
   * TSL function for creating an equirect uv node.
   *
   * Can be used to compute texture coordinates for projecting an
   * equirectangular texture onto a mesh for using it as the scene's
   * background.
   *
   * ```js
   * scene.backgroundNode = texture( equirectTexture, equirectUV() );
   * ```
   *
   * @tsl
   * @function
   * @param {?Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
   * @returns {Node<vec2>}
   */
  const equirectUV = /*@__PURE__*/ Fn( ( [ dir = positionWorldDirection ] ) => {

  	const u = dir.z.atan( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );
  	const v = dir.y.clamp( -1, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );

  	return vec2( u, v );

  } );

  // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

  /**
   * This class represents a cube render target. It is a special version
   * of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.
   *
   * @augments WebGLCubeRenderTarget
   */
  class CubeRenderTarget extends WebGLCubeRenderTarget {

  	/**
  	 * Constructs a new cube render target.
  	 *
  	 * @param {number} [size=1] - The size of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( size = 1, options = {} ) {

  		super( size, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCubeRenderTarget = true;

  	}

  	/**
  	 * Converts the given equirectangular texture to a cube map.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Texture} texture - The equirectangular texture.
  	 * @return {CubeRenderTarget} A reference to this cube render target.
  	 */
  	fromEquirectangularTexture( renderer, texture$1 ) {

  		const currentMinFilter = texture$1.minFilter;
  		const currentGenerateMipmaps = texture$1.generateMipmaps;

  		texture$1.generateMipmaps = true;

  		this.texture.type = texture$1.type;
  		this.texture.colorSpace = texture$1.colorSpace;

  		this.texture.generateMipmaps = texture$1.generateMipmaps;
  		this.texture.minFilter = texture$1.minFilter;
  		this.texture.magFilter = texture$1.magFilter;

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const uvNode = equirectUV( positionWorldDirection );

  		const material = new NodeMaterial();
  		material.colorNode = texture( texture$1, uvNode, 0 );
  		material.side = BackSide;
  		material.blending = NoBlending;

  		const mesh = new Mesh( geometry, material );

  		const scene = new Scene();
  		scene.add( mesh );

  		// Avoid blurred poles
  		if ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );

  		const currentMRT = renderer.getMRT();
  		renderer.setMRT( null );

  		camera.update( renderer, scene );

  		renderer.setMRT( currentMRT );

  		texture$1.minFilter = currentMinFilter;
  		texture$1.currentGenerateMipmaps = currentGenerateMipmaps;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  }

  const _cache$1 = new WeakMap();

  /**
   * This node can be used to automatically convert environment maps in the
   * equirectangular format into the cube map format.
   *
   * @augments TempNode
   */
  class CubeMapNode extends TempNode {

  	static get type() {

  		return 'CubeMapNode';

  	}

  	/**
  	 * Constructs a new cube map node.
  	 *
  	 * @param {Node} envNode - The node representing the environment map.
  	 */
  	constructor( envNode ) {

  		super( 'vec3' );

  		/**
  		 * The node representing the environment map.
  		 *
  		 * @type {Node}
  		 */
  		this.envNode = envNode;

  		/**
  		 * A reference to the internal cube texture.
  		 *
  		 * @private
  		 * @type {?CubeTexture}
  		 * @default null
  		 */
  		this._cubeTexture = null;

  		/**
  		 * A reference to the internal cube texture node.
  		 *
  		 * @private
  		 * @type {CubeTextureNode}
  		 */
  		this._cubeTextureNode = cubeTexture( null );

  		const defaultTexture = new CubeTexture();
  		defaultTexture.isRenderTargetTexture = true;

  		/**
  		 * A default cube texture that acts as a placeholder.
  		 * It is used when the conversion from equirectangular to cube
  		 * map has not finished yet for a given texture.
  		 *
  		 * @private
  		 * @type {CubeTexture}
  		 */
  		this._defaultTexture = defaultTexture;

  		/**
  		 * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
  		 * the texture once per render in its {@link CubeMapNode#updateBefore} method.
  		 *
  		 * @type {string}
  		 * @default 'render'
  		 */
  		this.updateBeforeType = NodeUpdateType.RENDER;

  	}

  	updateBefore( frame ) {

  		const { renderer, material } = frame;

  		const envNode = this.envNode;

  		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

  			const texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

  			if ( texture && texture.isTexture ) {

  				const mapping = texture.mapping;

  				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

  					// check for converted cubemap map

  					if ( _cache$1.has( texture ) ) {

  						const cubeMap = _cache$1.get( texture );

  						mapTextureMapping( cubeMap, texture.mapping );
  						this._cubeTexture = cubeMap;

  					} else {

  						// create cube map from equirectangular map

  						const image = texture.image;

  						if ( isEquirectangularMapReady$1( image ) ) {

  							const renderTarget = new CubeRenderTarget( image.height );
  							renderTarget.fromEquirectangularTexture( renderer, texture );

  							mapTextureMapping( renderTarget.texture, texture.mapping );
  							this._cubeTexture = renderTarget.texture;

  							_cache$1.set( texture, renderTarget.texture );

  							texture.addEventListener( 'dispose', onTextureDispose );

  						} else {

  							// default cube texture as fallback when equirectangular texture is not yet loaded

  							this._cubeTexture = this._defaultTexture;

  						}

  					}

  					//

  					this._cubeTextureNode.value = this._cubeTexture;

  				} else {

  					// envNode already refers to a cube map

  					this._cubeTextureNode = this.envNode;

  				}

  			}

  		}

  	}

  	setup( builder ) {

  		this.updateBefore( builder );

  		return this._cubeTextureNode;

  	}

  }

  /**
   * Returns true if the given equirectangular image has been fully loaded
   * and is ready for further processing.
   *
   * @private
   * @param {Image} image - The equirectangular image to check.
   * @return {boolean} Whether the image is ready or not.
   */
  function isEquirectangularMapReady$1( image ) {

  	if ( image === null || image === undefined ) return false;

  	return image.height > 0;

  }

  /**
   * This function is executed when `dispose()` is called on the equirectangular
   * texture. In this case, the generated cube map with its render target
   * is deleted as well.
   *
   * @private
   * @param {Object} event - The event object.
   */
  function onTextureDispose( event ) {

  	const texture = event.target;

  	texture.removeEventListener( 'dispose', onTextureDispose );

  	const renderTarget = _cache$1.get( texture );

  	if ( renderTarget !== undefined ) {

  		_cache$1.delete( texture );

  		renderTarget.dispose();

  	}

  }

  /**
   * This function makes sure the generated cube map uses the correct
   * texture mapping that corresponds to the equirectangular original.
   *
   * @private
   * @param {Texture} texture - The cube texture.
   * @param {number} mapping - The original texture mapping.
   */
  function mapTextureMapping( texture, mapping ) {

  	if ( mapping === EquirectangularReflectionMapping ) {

  		texture.mapping = CubeReflectionMapping;

  	} else if ( mapping === EquirectangularRefractionMapping ) {

  		texture.mapping = CubeRefractionMapping;

  	}

  }

  /**
   * TSL function for creating a cube map node.
   *
   * @tsl
   * @function
   * @param {Node} envNode - The node representing the environment map.
   * @returns {CubeMapNode}
   */
  const cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode ).setParameterLength( 1 );

  /**
   * Represents a basic model for Image-based lighting (IBL). The environment
   * is defined via environment maps in the equirectangular or cube map format.
   * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}
   * or {@link MeshPhongNodeMaterial}.
   *
   * @augments LightingNode
   */
  class BasicEnvironmentNode extends LightingNode {

  	static get type() {

  		return 'BasicEnvironmentNode';

  	}

  	/**
  	 * Constructs a new basic environment node.
  	 *
  	 * @param {Node} [envNode=null] - A node representing the environment.
  	 */
  	constructor( envNode = null ) {

  		super();

  		/**
  		 * A node representing the environment.
  		 *
  		 * @type {Node}
  		 * @default null
  		 */
  		this.envNode = envNode;

  	}

  	setup( builder ) {

  		// environment property is used in the finish() method of BasicLightingModel

  		builder.context.environment = cubeMapNode( this.envNode );

  	}

  }

  /**
   * A specific version of {@link IrradianceNode} that is only relevant
   * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it
   * requires a special scaling factor for the light map.
   *
   * @augments LightingNode
   */
  class BasicLightMapNode extends LightingNode {

  	static get type() {

  		return 'BasicLightMapNode';

  	}

  	/**
  	 * Constructs a new basic light map node.
  	 *
  	 * @param {?Node<vec3>} [lightMapNode=null] - The light map node.
  	 */
  	constructor( lightMapNode = null ) {

  		super();

  		/**
  		 * The light map node.
  		 *
  		 * @type {?Node<vec3>}
  		 */
  		this.lightMapNode = lightMapNode;

  	}

  	setup( builder ) {

  		// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel

  		const RECIPROCAL_PI = float( 1 / Math.PI );

  		builder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );

  	}

  }

  /**
   * Abstract class for implementing lighting models. The module defines
   * multiple methods that concrete lighting models can implement. These
   * methods are executed at different points during the light evaluation
   * process.
   */
  class LightingModel {

  	/**
  	 * This method is intended for setting up lighting model and context data
  	 * which are later used in the evaluation process.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	start( builder ) {

  		// lights ( direct )

  		builder.lightsNode.setupLights( builder, builder.lightsNode.getLightNodes( builder ) );

  		// indirect

  		this.indirect( builder );

  	}

  	/**
  	 * This method is intended for executing final tasks like final updates
  	 * to the outgoing light.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	finish( /*builder*/ ) { }

  	/**
  	 * This method is intended for implementing the direct light term and
  	 * executed during the build process of directional, point and spot light nodes.
  	 *
  	 * @abstract
  	 * @param {Object} lightData - The light data.
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	direct( /*lightData, builder*/ ) { }

  	/**
  	 * This method is intended for implementing the direct light term for
  	 * rect area light nodes.
  	 *
  	 * @abstract
  	 * @param {Object} lightData - The light data.
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	directRectArea( /*lightData, builder*/ ) {}

  	/**
  	 * This method is intended for implementing the indirect light term.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirect( /*builder*/ ) { }

  	/**
  	 * This method is intended for implementing the ambient occlusion term.
  	 * Unlike other methods, this method must be called manually by the lighting
  	 * model in its indirect term.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	ambientOcclusion( /*input, stack, builder*/ ) { }

  }

  /**
   * Represents the lighting model for unlit materials. The only light contribution
   * is baked indirect lighting modulated with ambient occlusion and the material's
   * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.
   *
   * @augments LightingModel
   */
  class BasicLightingModel extends LightingModel {

  	/**
  	 * Constructs a new basic lighting model.
  	 */
  	constructor() {

  		super();

  	}

  	/**
  	 * Implements the baked indirect lighting with its modulation.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirect( { context } ) {

  		const ambientOcclusion = context.ambientOcclusion;
  		const reflectedLight = context.reflectedLight;
  		const irradianceLightMap = context.irradianceLightMap;

  		reflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );

  		// accumulation (baked indirect lighting only)

  		if ( irradianceLightMap ) {

  			reflectedLight.indirectDiffuse.addAssign( irradianceLightMap );

  		} else {

  			reflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );

  		}

  		// modulation

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

  		reflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );

  	}

  	/**
  	 * Implements the environment mapping.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	finish( builder ) {

  		const { material, context } = builder;

  		const outgoingLight = context.outgoingLight;
  		const envNode = builder.context.environment;

  		if ( envNode ) {

  			switch ( material.combine ) {

  				case MultiplyOperation:
  					outgoingLight.rgb.assign( mix$2( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );
  					break;

  				case MixOperation:
  					outgoingLight.rgb.assign( mix$2( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );
  					break;

  				case AddOperation:
  					outgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );
  					break;

  				default:
  					console.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );
  					break;

  			}

  		}

  	}

  }

  const _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();

  /**
   * Node material version of {@link MeshBasicMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshBasicNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshBasicNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh basic node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshBasicNodeMaterial = true;

  		/**
  		 * Although the basic material is by definition unlit, we set
  		 * this property to `true` since we use a lighting model to compute
  		 * the outgoing light of the fragment shader.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.lights = true;

  		this.setDefaultValues( _defaultValues$9 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Basic materials are not affected by normal and bump maps so we
  	 * return by default {@link normalViewGeometry}.
  	 *
  	 * @return {Node<vec3>} The normal node.
  	 */
  	setupNormal() {

  		return directionToFaceDirection( normalViewGeometry ); // see #28839

  	}

  	/**
  	 * Overwritten since this type of material uses {@link BasicEnvironmentNode}
  	 * to implement the default environment mapping.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {?BasicEnvironmentNode<vec3>} The environment node.
  	 */
  	setupEnvironment( builder ) {

  		const envNode = super.setupEnvironment( builder );

  		return envNode ? new BasicEnvironmentNode( envNode ) : null;

  	}

  	/**
  	 * This method must be overwritten since light maps are evaluated
  	 * with a special scaling factor for basic materials.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {?BasicLightMapNode<vec3>} The light map node.
  	 */
  	setupLightMap( builder ) {

  		let node = null;

  		if ( builder.material.lightMap ) {

  			node = new BasicLightMapNode( materialLightMap );

  		}

  		return node;

  	}

  	/**
  	 * The material overwrites this method because `lights` is set to `true` but
  	 * we still want to return the diffuse color as the outgoing light.
  	 *
  	 * @return {Node<vec3>} The outgoing light node.
  	 */
  	setupOutgoingLight() {

  		return diffuseColor.rgb;

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {BasicLightingModel} The lighting model.
  	 */
  	setupLightingModel() {

  		return new BasicLightingModel();

  	}

  }

  const F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {

  	// Original approximation by Christophe Schlick '94
  	// float fresnel = pow( 1.0 - dotVH, 5.0 );

  	// Optimized variant (presented by Epic at SIGGRAPH '13)
  	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
  	const fresnel = dotVH.mul( -5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();

  	return f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );

  } ); // validated

  const BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {

  	return inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light

  } ); // validated

  const G_BlinnPhong_Implicit = () => float( 0.25 );

  const D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {

  	return shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );

  } );

  const BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

  	const halfDir = lightDirection.add( positionViewDirection ).normalize();

  	const dotNH = normalView.dot( halfDir ).clamp();
  	const dotVH = positionViewDirection.dot( halfDir ).clamp();

  	const F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );
  	const G = G_BlinnPhong_Implicit();
  	const D = D_BlinnPhong( { dotNH } );

  	return F.mul( G ).mul( D );

  } );

  /**
   * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.
   *
   * @augments BasicLightingModel
   */
  class PhongLightingModel extends BasicLightingModel {

  	/**
  	 * Constructs a new phong lighting model.
  	 *
  	 * @param {boolean} [specular=true] - Whether specular is supported or not.
  	 */
  	constructor( specular = true ) {

  		super();

  		/**
  		 * Whether specular is supported or not. Set this to `false` if you are
  		 * looking for a Lambert-like material meaning a material for non-shiny
  		 * surfaces, without specular highlights.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.specular = specular;

  	}

  	/**
  	 * Implements the direct lighting. The specular portion is optional an can be controlled
  	 * with the {@link PhongLightingModel#specular} flag.
  	 *
  	 * @param {Object} lightData - The light data.
  	 */
  	direct( { lightDirection, lightColor, reflectedLight } ) {

  		const dotNL = normalView.dot( lightDirection ).clamp();
  		const irradiance = dotNL.mul( lightColor );

  		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

  		if ( this.specular === true ) {

  			reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );

  		}

  	}

  	/**
  	 * Implements the indirect lighting.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirect( builder ) {

  		const { ambientOcclusion, irradiance, reflectedLight } = builder.context;

  		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

  	}

  }

  const _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();

  /**
   * Node material version of {@link MeshLambertMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshLambertNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshLambertNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh lambert node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshLambertNodeMaterial = true;

  		/**
  		 * Set to `true` because lambert materials react on lights.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.lights = true;

  		this.setDefaultValues( _defaultValues$8 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Overwritten since this type of material uses {@link BasicEnvironmentNode}
  	 * to implement the default environment mapping.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {?BasicEnvironmentNode<vec3>} The environment node.
  	 */
  	setupEnvironment( builder ) {

  		const envNode = super.setupEnvironment( builder );

  		return envNode ? new BasicEnvironmentNode( envNode ) : null;

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {PhongLightingModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		return new PhongLightingModel( false ); // ( specular ) -> force lambert

  	}

  }

  const _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();

  /**
   * Node material version of {@link MeshPhongMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshPhongNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshPhongNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh lambert node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshPhongNodeMaterial = true;

  		/**
  		 * Set to `true` because phong materials react on lights.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.lights = true;

  		/**
  		 * The shininess of phong materials is by default inferred from the `shininess`
  		 * property. This node property allows to overwrite the default
  		 * and define the shininess with a node instead.
  		 *
  		 * If you don't want to overwrite the shininess but modify the existing
  		 * value instead, use {@link materialShininess}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.shininessNode = null;

  		/**
  		 * The specular color of phong materials is by default inferred from the
  		 * `specular` property. This node property allows to overwrite the default
  		 * and define the specular color with a node instead.
  		 *
  		 * If you don't want to overwrite the specular color but modify the existing
  		 * value instead, use {@link materialSpecular}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.specularNode = null;

  		this.setDefaultValues( _defaultValues$7 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Overwritten since this type of material uses {@link BasicEnvironmentNode}
  	 * to implement the default environment mapping.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {?BasicEnvironmentNode<vec3>} The environment node.
  	 */
  	setupEnvironment( builder ) {

  		const envNode = super.setupEnvironment( builder );

  		return envNode ? new BasicEnvironmentNode( envNode ) : null;

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {PhongLightingModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		return new PhongLightingModel();

  	}

  	/**
  	 * Setups the phong specific node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupVariants( /*builder*/ ) {

  		// SHININESS

  		const shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )

  		shininess.assign( shininessNode );

  		// SPECULAR COLOR

  		const specularNode = this.specularNode || materialSpecular;

  		specularColor.assign( specularNode );

  	}

  	copy( source ) {

  		this.shininessNode = source.shininessNode;
  		this.specularNode = source.specularNode;

  		return super.copy( source );

  	}

  }

  const getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {

  	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

  		return float( 0 );

  	}

  	const dxy = normalViewGeometry.dFdx().abs().max( normalViewGeometry.dFdy().abs() );
  	const geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );

  	return geometryRoughness;

  } );

  const getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { roughness } = inputs;

  	const geometryRoughness = getGeometryRoughness();

  	let roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.
  	roughnessFactor = roughnessFactor.add( geometryRoughness );
  	roughnessFactor = roughnessFactor.min( 1.0 );

  	return roughnessFactor;

  } );

  // Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  const V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {

  	const a2 = alpha.pow2();

  	const gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );
  	const gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );

  	return div( 0.5, gv.add( gl ).max( EPSILON ) );

  } ).setLayout( {
  	name: 'V_GGX_SmithCorrelated',
  	type: 'float',
  	inputs: [
  		{ name: 'alpha', type: 'float' },
  		{ name: 'dotNL', type: 'float' },
  		{ name: 'dotNV', type: 'float' }
  	]
  } ); // validated

  // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

  const V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {

  	const gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );
  	const gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );
  	const v = div( 0.5, gv.add( gl ) );

  	return v.saturate();

  } ).setLayout( {
  	name: 'V_GGX_SmithCorrelated_Anisotropic',
  	type: 'float',
  	inputs: [
  		{ name: 'alphaT', type: 'float', qualifier: 'in' },
  		{ name: 'alphaB', type: 'float', qualifier: 'in' },
  		{ name: 'dotTV', type: 'float', qualifier: 'in' },
  		{ name: 'dotBV', type: 'float', qualifier: 'in' },
  		{ name: 'dotTL', type: 'float', qualifier: 'in' },
  		{ name: 'dotBL', type: 'float', qualifier: 'in' },
  		{ name: 'dotNV', type: 'float', qualifier: 'in' },
  		{ name: 'dotNL', type: 'float', qualifier: 'in' }
  	]
  } );

  // Microfacet Models for Refraction through Rough Surfaces - equation (33)
  // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
  // alpha is "roughness squared" in Disney’s reparameterization
  const D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {

  	const a2 = alpha.pow2();

  	const denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1

  	return a2.div( denom.pow2() ).mul( 1 / Math.PI );

  } ).setLayout( {
  	name: 'D_GGX',
  	type: 'float',
  	inputs: [
  		{ name: 'alpha', type: 'float' },
  		{ name: 'dotNH', type: 'float' }
  	]
  } ); // validated

  const RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );

  // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

  const D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {

  	const a2 = alphaT.mul( alphaB );
  	const v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );
  	const v2 = v.dot( v );
  	const w2 = a2.div( v2 );

  	return RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );

  } ).setLayout( {
  	name: 'D_GGX_Anisotropic',
  	type: 'float',
  	inputs: [
  		{ name: 'alphaT', type: 'float', qualifier: 'in' },
  		{ name: 'alphaB', type: 'float', qualifier: 'in' },
  		{ name: 'dotNH', type: 'float', qualifier: 'in' },
  		{ name: 'dotTH', type: 'float', qualifier: 'in' },
  		{ name: 'dotBH', type: 'float', qualifier: 'in' }
  	]
  } );

  // GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
  const BRDF_GGX = /*@__PURE__*/ Fn( ( { lightDirection, f0, f90, roughness, f, normalView: normalView$1 = normalView, USE_IRIDESCENCE, USE_ANISOTROPY } ) => {

  	const alpha = roughness.pow2(); // UE4's roughness

  	const halfDir = lightDirection.add( positionViewDirection ).normalize();

  	const dotNL = normalView$1.dot( lightDirection ).clamp();
  	const dotNV = normalView$1.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV
  	const dotNH = normalView$1.dot( halfDir ).clamp();
  	const dotVH = positionViewDirection.dot( halfDir ).clamp();

  	let F = F_Schlick( { f0, f90, dotVH } );
  	let V, D;

  	if ( defined( USE_IRIDESCENCE ) ) {

  		F = iridescence.mix( F, f );

  	}

  	if ( defined( USE_ANISOTROPY ) ) {

  		const dotTL = anisotropyT.dot( lightDirection );
  		const dotTV = anisotropyT.dot( positionViewDirection );
  		const dotTH = anisotropyT.dot( halfDir );
  		const dotBL = anisotropyB.dot( lightDirection );
  		const dotBV = anisotropyB.dot( positionViewDirection );
  		const dotBH = anisotropyB.dot( halfDir );

  		V = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );
  		D = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );

  	} else {

  		V = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );
  		D = D_GGX( { alpha, dotNH } );

  	}

  	return F.mul( V ).mul( D );

  } ); // validated

  // Analytical approximation of the DFG LUT, one half of the
  // split-sum approximation used in indirect specular lighting.
  // via 'environmentBRDF' from "Physically Based Shading on Mobile"
  // https://www.unrealengine.com/blog/physically-based-shading-on-mobile
  const DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {

  	const c0 = vec4( -1, -0.0275, -0.572, 0.022 );

  	const c1 = vec4( 1, 0.0425, 1.04, -0.04 );

  	const r = roughness.mul( c0 ).add( c1 );

  	const a004 = r.x.mul( r.x ).min( dotNV.mul( -9.28 ).exp2() ).mul( r.x ).add( r.y );

  	const fab = vec2( -1.04, 1.04 ).mul( a004 ).add( r.zw );

  	return fab;

  } ).setLayout( {
  	name: 'DFGApprox',
  	type: 'vec2',
  	inputs: [
  		{ name: 'roughness', type: 'float' },
  		{ name: 'dotNV', type: 'vec3' }
  	]
  } );

  const EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { dotNV, specularColor, specularF90, roughness } = inputs;

  	const fab = DFGApprox( { dotNV, roughness } );
  	return specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );

  } );

  const Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {

  	const x = dotVH.oneMinus().saturate();
  	const x2 = x.mul( x );
  	const x5 = x.mul( x2, x2 ).clamp( 0, .9999 );

  	return f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );

  } ).setLayout( {
  	name: 'Schlick_to_F0',
  	type: 'vec3',
  	inputs: [
  		{ name: 'f', type: 'vec3' },
  		{ name: 'f90', type: 'float' },
  		{ name: 'dotVH', type: 'float' }
  	]
  } );

  // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
  const D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {

  	const alpha = roughness.pow2();

  	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  	const invAlpha = float( 1.0 ).div( alpha );
  	const cos2h = dotNH.pow2();
  	const sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

  	return float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );

  } ).setLayout( {
  	name: 'D_Charlie',
  	type: 'float',
  	inputs: [
  		{ name: 'roughness', type: 'float' },
  		{ name: 'dotNH', type: 'float' }
  	]
  } );

  // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
  const V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {

  	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
  	return float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );

  } ).setLayout( {
  	name: 'V_Neubelt',
  	type: 'float',
  	inputs: [
  		{ name: 'dotNV', type: 'float' },
  		{ name: 'dotNL', type: 'float' }
  	]
  } );

  const BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

  	const halfDir = lightDirection.add( positionViewDirection ).normalize();

  	const dotNL = normalView.dot( lightDirection ).clamp();
  	const dotNV = normalView.dot( positionViewDirection ).clamp();
  	const dotNH = normalView.dot( halfDir ).clamp();

  	const D = D_Charlie( { roughness: sheenRoughness, dotNH } );
  	const V = V_Neubelt( { dotNV, dotNL } );

  	return sheen.mul( D ).mul( V );

  } );

  // Rect Area Light

  // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
  // by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
  // code: https://github.com/selfshadow/ltc_code/

  const LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {

  	const LUT_SIZE = 64.0;
  	const LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
  	const LUT_BIAS = 0.5 / LUT_SIZE;

  	const dotNV = N.dot( V ).saturate();

  	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
  	const uv = vec2( roughness, dotNV.oneMinus().sqrt() );

  	uv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );

  	return uv;

  } ).setLayout( {
  	name: 'LTC_Uv',
  	type: 'vec2',
  	inputs: [
  		{ name: 'N', type: 'vec3' },
  		{ name: 'V', type: 'vec3' },
  		{ name: 'roughness', type: 'float' }
  	]
  } );

  const LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {

  	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
  	// An approximation of the form factor of a horizon-clipped rectangle.

  	const l = f.length();

  	return max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );

  } ).setLayout( {
  	name: 'LTC_ClippedSphereFormFactor',
  	type: 'float',
  	inputs: [
  		{ name: 'f', type: 'vec3' }
  	]
  } );

  const LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {

  	const x = v1.dot( v2 );
  	const y = x.abs().toVar();

  	// rational polynomial approximation to theta / sin( theta ) / 2PI
  	const a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();
  	const b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();
  	const v = a.div( b );

  	const theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );

  	return v1.cross( v2 ).mul( theta_sintheta );

  } ).setLayout( {
  	name: 'LTC_EdgeVectorFormFactor',
  	type: 'vec3',
  	inputs: [
  		{ name: 'v1', type: 'vec3' },
  		{ name: 'v2', type: 'vec3' }
  	]
  } );

  const LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {

  	// bail if point is on back side of plane of light
  	// assumes ccw winding order of light vertices
  	const v1 = p1.sub( p0 ).toVar();
  	const v2 = p3.sub( p0 ).toVar();

  	const lightNormal = v1.cross( v2 );
  	const result = vec3().toVar();

  	If( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {

  		// construct orthonormal basis around N
  		const T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();
  		const T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system

  		// compute transform
  		const mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();

  		// transform rect
  		// & project rect onto sphere
  		const coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();
  		const coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();
  		const coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();
  		const coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();

  		// calculate vector form factor
  		const vectorFormFactor = vec3( 0 ).toVar();
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );

  		// adjust for horizon clipping
  		result.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );

  	} );

  	return result;

  } ).setLayout( {
  	name: 'LTC_Evaluate',
  	type: 'vec3',
  	inputs: [
  		{ name: 'N', type: 'vec3' },
  		{ name: 'V', type: 'vec3' },
  		{ name: 'P', type: 'vec3' },
  		{ name: 'mInv', type: 'mat3' },
  		{ name: 'p0', type: 'vec3' },
  		{ name: 'p1', type: 'vec3' },
  		{ name: 'p2', type: 'vec3' },
  		{ name: 'p3', type: 'vec3' }
  	]
  } );

  // Mipped Bicubic Texture Filtering by N8
  // https://www.shadertoy.com/view/Dl2SDW

  const bC = 1.0 / 6.0;

  const w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );

  const w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );

  const w2 = ( a ) => mul( bC, mul( a, mul( a, mul( -3, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );

  const w3 = ( a ) => mul( bC, pow( a, 3 ) );

  const g0 = ( a ) => w0( a ).add( w1( a ) );

  const g1 = ( a ) => w2( a ).add( w3( a ) );

  // h0 and h1 are the two offset functions
  const h0 = ( a ) => add( -1, w1( a ).div( w0( a ).add( w1( a ) ) ) );

  const h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );

  const bicubic = ( textureNode, texelSize, lod ) => {

  	const uv = textureNode.uvNode;
  	const uvScaled = mul( uv, texelSize.zw ).add( 0.5 );

  	const iuv = floor( uvScaled );
  	const fuv = fract( uvScaled );

  	const g0x = g0( fuv.x );
  	const g1x = g1( fuv.x );
  	const h0x = h0( fuv.x );
  	const h1x = h1( fuv.x );
  	const h0y = h0( fuv.y );
  	const h1y = h1( fuv.y );

  	const p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
  	const p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
  	const p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );
  	const p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );

  	const a = g0( fuv.y ).mul( add( g0x.mul( textureNode.sample( p0 ).level( lod ) ), g1x.mul( textureNode.sample( p1 ).level( lod ) ) ) );
  	const b = g1( fuv.y ).mul( add( g0x.mul( textureNode.sample( p2 ).level( lod ) ), g1x.mul( textureNode.sample( p3 ).level( lod ) ) ) );

  	return a.add( b );

  };

  /**
   * Applies mipped bicubic texture filtering to the given texture node.
   *
   * @tsl
   * @function
   * @param {TextureNode} textureNode - The texture node that should be filtered.
   * @param {Node<float>} lodNode - Defines the LOD to sample from.
   * @return {Node} The filtered texture sample.
   */
  const textureBicubicLevel = /*@__PURE__*/ Fn( ( [ textureNode, lodNode ] ) => {

  	const fLodSize = vec2( textureNode.size( int( lodNode ) ) );
  	const cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );
  	const fLodSizeInv = div( 1.0, fLodSize );
  	const cLodSizeInv = div( 1.0, cLodSize );
  	const fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );
  	const cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );

  	return fract( lodNode ).mix( fSample, cSample );

  } );

  //
  // Transmission
  //

  const getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {

  	// Direction of refracted light.
  	const refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );

  	// Compute rotation-independent scaling of the model matrix.
  	const modelScale = vec3(
  		length( modelMatrix[ 0 ].xyz ),
  		length( modelMatrix[ 1 ].xyz ),
  		length( modelMatrix[ 2 ].xyz )
  	);

  	// The thickness is specified in local space.
  	return normalize( refractionVector ).mul( thickness.mul( modelScale ) );

  } ).setLayout( {
  	name: 'getVolumeTransmissionRay',
  	type: 'vec3',
  	inputs: [
  		{ name: 'n', type: 'vec3' },
  		{ name: 'v', type: 'vec3' },
  		{ name: 'thickness', type: 'float' },
  		{ name: 'ior', type: 'float' },
  		{ name: 'modelMatrix', type: 'mat4' }
  	]
  } );

  const applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {

  	// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
  	// an IOR of 1.5 results in the default amount of microfacet refraction.
  	return roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );

  } ).setLayout( {
  	name: 'applyIorToRoughness',
  	type: 'float',
  	inputs: [
  		{ name: 'roughness', type: 'float' },
  		{ name: 'ior', type: 'float' }
  	]
  } );

  const viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();
  const viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();

  const getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {

  	const vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;

  	const transmissionSample = vTexture.sample( fragCoord );
  	//const transmissionSample = viewportMipTexture( fragCoord );

  	const lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );

  	return textureBicubicLevel( transmissionSample, lod );

  } );

  const volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {

  	If( attenuationDistance.notEqual( 0 ), () => {

  		// Compute light attenuation using Beer's law.
  		const attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );
  		const transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );

  		return transmittance;

  	} );

  	// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
  	return vec3( 1.0 );

  } ).setLayout( {
  	name: 'volumeAttenuation',
  	type: 'vec3',
  	inputs: [
  		{ name: 'transmissionDistance', type: 'float' },
  		{ name: 'attenuationColor', type: 'vec3' },
  		{ name: 'attenuationDistance', type: 'float' }
  	]
  } );

  const getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {

  	let transmittedLight, transmittance;

  	if ( dispersion ) {

  		transmittedLight = vec4().toVar();
  		transmittance = vec3().toVar();

  		const halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );
  		const iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );

  		Loop( { start: 0, end: 3 }, ( { i } ) => {

  			const ior = iors.element( i );

  			const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
  			const refractedRayExit = position.add( transmissionRay );

  			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
  			const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
  			const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
  			refractionCoords.addAssign( 1.0 );
  			refractionCoords.divAssign( 2.0 );
  			refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

  			// Sample framebuffer to get pixel the refracted ray hits.
  			const transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );

  			transmittedLight.element( i ).assign( transmissionSample.element( i ) );
  			transmittedLight.a.addAssign( transmissionSample.a );

  			transmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );

  		} );

  		transmittedLight.a.divAssign( 3.0 );

  	} else {

  		const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
  		const refractedRayExit = position.add( transmissionRay );

  		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
  		const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
  		const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
  		refractionCoords.addAssign( 1.0 );
  		refractionCoords.divAssign( 2.0 );
  		refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

  		// Sample framebuffer to get pixel the refracted ray hits.
  		transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
  		transmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );

  	}

  	const attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );
  	const dotNV = n.dot( v ).clamp();

  	// Get the specular component.
  	const F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness
  		dotNV,
  		specularColor,
  		specularF90,
  		roughness
  	} ) );

  	// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
  	// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
  	const transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );

  	return vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );

  } );

  //
  // Iridescence
  //

  // XYZ to linear-sRGB color space
  const XYZ_TO_REC709 = /*@__PURE__*/ mat3(
  	3.2404542, -0.969266, 0.0556434,
  	-1.5371385, 1.8760108, -0.2040259,
  	-0.4985314, 0.0415560, 1.0572252
  );

  // Assume air interface for top
  // Note: We don't handle the case fresnel0 == 1
  const Fresnel0ToIor = ( fresnel0 ) => {

  	const sqrtF0 = fresnel0.sqrt();
  	return vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );

  };

  // ior is a value between 1.0 and 3.0. 1.0 is air interface
  const IorToFresnel0 = ( transmittedIor, incidentIor ) => {

  	return transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();

  };

  // Fresnel equations for dielectric/dielectric interfaces.
  // Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
  // Evaluation XYZ sensitivity curves in Fourier space
  const evalSensitivity = ( OPD, shift ) => {

  	const phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );
  	const val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
  	const pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
  	const VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

  	const x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( -45282e5 ).exp() );

  	let xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );
  	xyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );

  	const rgb = XYZ_TO_REC709.mul( xyz );

  	return rgb;

  };

  const evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {

  	// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
  	const iridescenceIOR = mix$2( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
  	// Evaluate the cosTheta on the base layer (Snell law)
  	const sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );

  	// Handle TIR:
  	const cosTheta2Sq = sinTheta2Sq.oneMinus();

  	If( cosTheta2Sq.lessThan( 0 ), () => {

  		return vec3( 1.0 );

  	} );

  	const cosTheta2 = cosTheta2Sq.sqrt();

  	// First interface
  	const R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
  	const R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );
  	//const R21 = R12;
  	const T121 = R12.oneMinus();
  	const phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );
  	const phi21 = float( Math.PI ).sub( phi12 );

  	// Second interface
  	const baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0
  	const R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );
  	const R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );
  	const phi23 = vec3(
  		baseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
  		baseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
  		baseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )
  	);

  	// Phase shift
  	const OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );
  	const phi = vec3( phi21 ).add( phi23 );

  	// Compound terms
  	const R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );
  	const r123 = R123.sqrt();
  	const Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );

  	// Reflectance term for m = 0 (DC term amplitude)
  	const C0 = R12.add( Rs );
  	const I = C0.toVar();

  	// Reflectance term for m > 0 (pairs of diracs)
  	const Cm = Rs.sub( T121 ).toVar();

  	Loop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {

  		Cm.mulAssign( r123 );
  		const Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );
  		I.addAssign( Cm.mul( Sm ) );

  	} );

  	// Since out of gamut colors might be produced, negative color values are clamped to 0.
  	return I.max( vec3( 0.0 ) );

  } ).setLayout( {
  	name: 'evalIridescence',
  	type: 'vec3',
  	inputs: [
  		{ name: 'outsideIOR', type: 'float' },
  		{ name: 'eta2', type: 'float' },
  		{ name: 'cosTheta1', type: 'float' },
  		{ name: 'thinFilmThickness', type: 'float' },
  		{ name: 'baseF0', type: 'vec3' }
  	]
  } );

  //
  //	Sheen
  //

  // This is a curve-fit approximation to the "Charlie sheen" BRDF integrated over the hemisphere from
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
  // in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
  const IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {

  	const dotNV = normal.dot( viewDir ).saturate();

  	const r2 = roughness.pow2();

  	const a = select$1(
  		roughness.lessThan( 0.25 ),
  		float( -339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),
  		float( -8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )
  	);

  	const b = select$1(
  		roughness.lessThan( 0.25 ),
  		float( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),
  		float( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )
  	);

  	const DG = select$1( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );

  	return DG.mul( 1.0 / Math.PI ).saturate();

  } );

  const clearcoatF0 = vec3( 0.04 );
  const clearcoatF90 = float( 1 );


  /**
   * Represents the lighting model for a PBR material.
   *
   * @augments LightingModel
   */
  class PhysicalLightingModel extends LightingModel {

  	/**
  	 * Constructs a new physical lighting model.
  	 *
  	 * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
  	 * @param {boolean} [sheen=false] - Whether sheen is supported or not.
  	 * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
  	 * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
  	 * @param {boolean} [transmission=false] - Whether transmission is supported or not.
  	 * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
  	 */
  	constructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {

  		super();

  		/**
  		 * Whether clearcoat is supported or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clearcoat = clearcoat;

  		/**
  		 * Whether sheen is supported or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.sheen = sheen;

  		/**
  		 * Whether iridescence is supported or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.iridescence = iridescence;

  		/**
  		 * Whether anisotropy is supported or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.anisotropy = anisotropy;

  		/**
  		 * Whether transmission is supported or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.transmission = transmission;

  		/**
  		 * Whether dispersion is supported or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.dispersion = dispersion;

  		/**
  		 * The clear coat radiance.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.clearcoatRadiance = null;

  		/**
  		 * The clear coat specular direct.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.clearcoatSpecularDirect = null;

  		/**
  		 * The clear coat specular indirect.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.clearcoatSpecularIndirect = null;

  		/**
  		 * The sheen specular direct.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.sheenSpecularDirect = null;

  		/**
  		 * The sheen specular indirect.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.sheenSpecularIndirect = null;

  		/**
  		 * The iridescence Fresnel.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.iridescenceFresnel = null;

  		/**
  		 * The iridescence F0.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.iridescenceF0 = null;

  	}

  	/**
  	 * Depending on what features are requested, the method prepares certain node variables
  	 * which are later used for lighting computations.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	start( builder ) {

  		if ( this.clearcoat === true ) {

  			this.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );
  			this.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );
  			this.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );

  		}

  		if ( this.sheen === true ) {

  			this.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );
  			this.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );

  		}

  		if ( this.iridescence === true ) {

  			const dotNVi = normalView.dot( positionViewDirection ).clamp();

  			this.iridescenceFresnel = evalIridescence( {
  				outsideIOR: float( 1.0 ),
  				eta2: iridescenceIOR,
  				cosTheta1: dotNVi,
  				thinFilmThickness: iridescenceThickness,
  				baseF0: specularColor
  			} );

  			this.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );

  		}

  		if ( this.transmission === true ) {

  			const position = positionWorld;
  			const v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX
  			const n = normalWorld;

  			const context = builder.context;

  			context.backdrop = getIBLVolumeRefraction(
  				n,
  				v,
  				roughness,
  				diffuseColor,
  				specularColor,
  				specularF90, // specularF90
  				position, // positionWorld
  				modelWorldMatrix, // modelMatrix
  				cameraViewMatrix, // viewMatrix
  				cameraProjectionMatrix, // projMatrix
  				ior,
  				thickness,
  				attenuationColor,
  				attenuationDistance,
  				this.dispersion ? dispersion : null
  			);

  			context.backdropAlpha = transmission;

  			diffuseColor.a.mulAssign( mix$2( 1, context.backdrop.a, transmission ) );

  		}

  		super.start( builder );

  	}

  	// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  	// Approximates multi-scattering in order to preserve energy.
  	// http://www.jcgt.org/published/0008/01/03/

  	computeMultiscattering( singleScatter, multiScatter, specularF90 ) {

  		const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

  		const fab = DFGApprox( { roughness, dotNV } );

  		const Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;

  		const FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );

  		const Ess = fab.x.add( fab.y );
  		const Ems = Ess.oneMinus();

  		const Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21
  		const Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );

  		singleScatter.addAssign( FssEss );
  		multiScatter.addAssign( Fms.mul( Ems ) );

  	}

  	/**
  	 * Implements the direct light.
  	 *
  	 * @param {Object} lightData - The light data.
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	direct( { lightDirection, lightColor, reflectedLight } ) {

  		const dotNL = normalView.dot( lightDirection ).clamp();
  		const irradiance = dotNL.mul( lightColor );

  		if ( this.sheen === true ) {

  			this.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );

  		}

  		if ( this.clearcoat === true ) {

  			const dotNLcc = clearcoatNormalView.dot( lightDirection ).clamp();
  			const ccIrradiance = dotNLcc.mul( lightColor );

  			this.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: clearcoatNormalView } ) ) );

  		}

  		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

  		reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );

  	}

  	/**
  	 * This method is intended for implementing the direct light term for
  	 * rect area light nodes.
  	 *
  	 * @param {Object} input - The input data.
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	directRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {

  		const p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction
  		const p1 = lightPosition.sub( halfWidth ).sub( halfHeight );
  		const p2 = lightPosition.sub( halfWidth ).add( halfHeight );
  		const p3 = lightPosition.add( halfWidth ).add( halfHeight );

  		const N = normalView;
  		const V = positionViewDirection;
  		const P = positionView.toVar();

  		const uv = LTC_Uv( { N, V, roughness } );

  		const t1 = ltc_1.sample( uv ).toVar();
  		const t2 = ltc_2.sample( uv ).toVar();

  		const mInv = mat3(
  			vec3( t1.x, 0, t1.y ),
  			vec3( 0, 1, 0 ),
  			vec3( t1.z, 0, t1.w )
  		).toVar();

  		// LTC Fresnel Approximation by Stephen Hill
  		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
  		const fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();

  		reflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );

  		reflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );

  	}

  	/**
  	 * Implements the indirect lighting.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirect( builder ) {

  		this.indirectDiffuse( builder );
  		this.indirectSpecular( builder );
  		this.ambientOcclusion( builder );

  	}

  	/**
  	 * Implements the indirect diffuse term.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirectDiffuse( builder ) {

  		const { irradiance, reflectedLight } = builder.context;

  		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

  	}

  	/**
  	 * Implements the indirect specular term.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirectSpecular( builder ) {

  		const { radiance, iblIrradiance, reflectedLight } = builder.context;

  		if ( this.sheen === true ) {

  			this.sheenSpecularIndirect.addAssign( iblIrradiance.mul(
  				sheen,
  				IBLSheenBRDF( {
  					normal: normalView,
  					viewDir: positionViewDirection,
  					roughness: sheenRoughness
  				} )
  			) );

  		}

  		if ( this.clearcoat === true ) {

  			const dotNVcc = clearcoatNormalView.dot( positionViewDirection ).clamp();

  			const clearcoatEnv = EnvironmentBRDF( {
  				dotNV: dotNVcc,
  				specularColor: clearcoatF0,
  				specularF90: clearcoatF90,
  				roughness: clearcoatRoughness
  			} );

  			this.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );

  		}

  		// Both indirect specular and indirect diffuse light accumulate here

  		const singleScattering = vec3().toVar( 'singleScattering' );
  		const multiScattering = vec3().toVar( 'multiScattering' );
  		const cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );

  		this.computeMultiscattering( singleScattering, multiScattering, specularF90 );

  		const totalScattering = singleScattering.add( multiScattering );

  		const diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );

  		reflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );
  		reflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );

  		reflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );

  	}

  	/**
  	 * Implements the ambient occlusion term.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	ambientOcclusion( builder ) {

  		const { ambientOcclusion, reflectedLight } = builder.context;

  		const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

  		const aoNV = dotNV.add( ambientOcclusion );
  		const aoExp = roughness.mul( -16 ).oneMinus().negate().exp2();

  		const aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();

  		if ( this.clearcoat === true ) {

  			this.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );

  		}

  		if ( this.sheen === true ) {

  			this.sheenSpecularIndirect.mulAssign( ambientOcclusion );

  		}

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );
  		reflectedLight.indirectSpecular.mulAssign( aoNode );

  	}

  	/**
  	 * Used for final lighting accumulations depending on the requested features.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	finish( { context } ) {

  		const { outgoingLight } = context;

  		if ( this.clearcoat === true ) {

  			const dotNVcc = clearcoatNormalView.dot( positionViewDirection ).clamp();

  			const Fcc = F_Schlick( {
  				dotVH: dotNVcc,
  				f0: clearcoatF0,
  				f90: clearcoatF90
  			} );

  			const clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );

  			outgoingLight.assign( clearcoatLight );

  		}

  		if ( this.sheen === true ) {

  			const sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();
  			const sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );

  			outgoingLight.assign( sheenLight );

  		}

  	}

  }

  // These defines must match with PMREMGenerator

  const cubeUV_r0 = /*@__PURE__*/ float( 1.0 );
  const cubeUV_m0 = /*@__PURE__*/ float( -2 );
  const cubeUV_r1 = /*@__PURE__*/ float( 0.8 );
  const cubeUV_m1 = /*@__PURE__*/ float( -1 );
  const cubeUV_r4 = /*@__PURE__*/ float( 0.4 );
  const cubeUV_m4 = /*@__PURE__*/ float( 2.0 );
  const cubeUV_r5 = /*@__PURE__*/ float( 0.305 );
  const cubeUV_m5 = /*@__PURE__*/ float( 3.0 );
  const cubeUV_r6 = /*@__PURE__*/ float( 0.21 );
  const cubeUV_m6 = /*@__PURE__*/ float( 4.0 );

  const cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );
  const cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );

  // These shader functions convert between the UV coordinates of a single face of
  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for
  // sampling a textureCube (not generally normalized ).

  const getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {

  	const absDirection = vec3( abs( direction ) ).toVar();
  	const face = float( -1 ).toVar();

  	If( absDirection.x.greaterThan( absDirection.z ), () => {

  		If( absDirection.x.greaterThan( absDirection.y ), () => {

  			face.assign( select$1( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );

  		} ).Else( () => {

  			face.assign( select$1( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

  		} );

  	} ).Else( () => {

  		If( absDirection.z.greaterThan( absDirection.y ), () => {

  			face.assign( select$1( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );

  		} ).Else( () => {

  			face.assign( select$1( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

  		} );

  	} );

  	return face;

  } ).setLayout( {
  	name: 'getFace',
  	type: 'float',
  	inputs: [
  		{ name: 'direction', type: 'vec3' }
  	]
  } );

  // RH coordinate system; PMREM face-indexing convention
  const getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {

  	const uv = vec2().toVar();

  	If( face.equal( 0.0 ), () => {

  		uv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x

  	} ).ElseIf( face.equal( 1.0 ), () => {

  		uv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y

  	} ).ElseIf( face.equal( 2.0 ), () => {

  		uv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z

  	} ).ElseIf( face.equal( 3.0 ), () => {

  		uv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x

  	} ).ElseIf( face.equal( 4.0 ), () => {

  		uv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y

  	} ).Else( () => {

  		uv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z

  	} );

  	return mul( 0.5, uv.add( 1.0 ) );

  } ).setLayout( {
  	name: 'getUV',
  	type: 'vec2',
  	inputs: [
  		{ name: 'direction', type: 'vec3' },
  		{ name: 'face', type: 'float' }
  	]
  } );

  const roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {

  	const mip = float( 0.0 ).toVar();

  	If( roughness.greaterThanEqual( cubeUV_r1 ), () => {

  		mip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );

  	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {

  		mip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );

  	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {

  		mip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );

  	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {

  		mip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );

  	} ).Else( () => {

  		mip.assign( float( -2 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25

  	} );

  	return mip;

  } ).setLayout( {
  	name: 'roughnessToMip',
  	type: 'float',
  	inputs: [
  		{ name: 'roughness', type: 'float' }
  	]
  } );

  // RH coordinate system; PMREM face-indexing convention
  const getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {

  	const uv = uv_immutable.toVar();
  	uv.assign( mul( 2.0, uv ).sub( 1.0 ) );
  	const direction = vec3( uv, 1.0 ).toVar();

  	If( face.equal( 0.0 ), () => {

  		direction.assign( direction.zyx ); // ( 1, v, u ) pos x

  	} ).ElseIf( face.equal( 1.0 ), () => {

  		direction.assign( direction.xzy );
  		direction.xz.mulAssign( -1 ); // ( -u, 1, -v ) pos y

  	} ).ElseIf( face.equal( 2.0 ), () => {

  		direction.x.mulAssign( -1 ); // ( -u, v, 1 ) pos z

  	} ).ElseIf( face.equal( 3.0 ), () => {

  		direction.assign( direction.zyx );
  		direction.xz.mulAssign( -1 ); // ( -1, v, -u ) neg x

  	} ).ElseIf( face.equal( 4.0 ), () => {

  		direction.assign( direction.xzy );
  		direction.xy.mulAssign( -1 ); // ( -u, -1, v ) neg y

  	} ).ElseIf( face.equal( 5.0 ), () => {

  		direction.z.mulAssign( -1 ); // ( u, v, -1 ) neg zS

  	} );

  	return direction;

  } ).setLayout( {
  	name: 'getDirection',
  	type: 'vec3',
  	inputs: [
  		{ name: 'uv', type: 'vec2' },
  		{ name: 'face', type: 'float' }
  	]
  } );

  //

  const textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

  	const roughness = float( roughness_immutable );
  	const sampleDir = vec3( sampleDir_immutable );

  	const mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
  	const mipF = fract( mip );
  	const mipInt = floor( mip );
  	const color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

  	If( mipF.notEqual( 0.0 ), () => {

  		const color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

  		color0.assign( mix$2( color0, color1, mipF ) );

  	} );

  	return color0;

  } );

  const bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

  	const mipInt = float( mipInt_immutable ).toVar();
  	const direction = vec3( direction_immutable );
  	const face = float( getFace( direction ) ).toVar();
  	const filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();
  	mipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );
  	const faceSize = float( exp2( mipInt ) ).toVar();
  	const uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();

  	If( face.greaterThan( 2.0 ), () => {

  		uv.y.addAssign( faceSize );
  		face.subAssign( 3.0 );

  	} );

  	uv.x.addAssign( face.mul( faceSize ) );
  	uv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );
  	uv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );
  	uv.x.mulAssign( CUBEUV_TEXEL_WIDTH );
  	uv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );

  	return envMap.sample( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering

  } );

  const getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

  	const cosTheta = cos( theta );

  	// Rodrigues' axis-angle rotation
  	const sampleDirection = outputDirection.mul( cosTheta )
  		.add( axis.cross( outputDirection ).mul( sin( theta ) ) )
  		.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );

  	return bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );

  } );

  const blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

  	const axis = vec3( select$1( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();

  	If( axis.equal( vec3( 0.0 ) ), () => {

  		axis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );

  	} );

  	axis.assign( normalize( axis ) );

  	const gl_FragColor = vec3().toVar();
  	gl_FragColor.addAssign( weights.element( 0 ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

  	Loop( { start: int( 1 ), end: n }, ( { i } ) => {

  		If( i.greaterThanEqual( samples ), () => {

  			Break();

  		} );

  		const theta = float( dTheta.mul( float( i ) ) ).toVar();
  		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( -1 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );
  		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

  	} );

  	return vec4( gl_FragColor, 1 );

  } );

  const LOD_MIN = 4;

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  const MAX_SAMPLES = 20;

  const _flatCamera = /*@__PURE__*/ new OrthographicCamera( -1, 1, 1, -1, 0, 1 );
  const _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );
  const _clearColor$2 = /*@__PURE__*/ new Color();
  let _oldTarget = null;
  let _oldActiveCubeFace = 0;
  let _oldActiveMipmapLevel = 0;

  // Golden Ratio
  const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
  const INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  const _axisDirections = [
  	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
  	/*@__PURE__*/ new Vector3( -1, 1, -1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, -1 ),
  	/*@__PURE__*/ new Vector3( -1, 1, 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, 1 )
  ];

  const _origin = /*@__PURE__*/ new Vector3();

  // maps blur materials to their uniforms dictionary

  const _uniformsMap = new WeakMap();

  // WebGPU Face indices
  const _faceLib = [
  	3, 1, 5,
  	0, 4, 2
  ];

  const _direction = /*@__PURE__*/ getDirection( uv$1(), attribute( 'faceIndex' ) ).normalize();
  const _outputDirection = /*@__PURE__*/ vec3( _direction.x, _direction.y, _direction.z );

  /**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting:
   * {@link https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view}
  */
  class PMREMGenerator {

  	/**
  	 * Constructs a new PMREM generator.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 */
  	constructor( renderer ) {

  		this._renderer = renderer;
  		this._pingPongRenderTarget = null;

  		this._lodMax = 0;
  		this._cubeSize = 0;
  		this._lodPlanes = [];
  		this._sizeLods = [];
  		this._sigmas = [];
  		this._lodMeshes = [];

  		this._blurMaterial = null;
  		this._cubemapMaterial = null;
  		this._equirectMaterial = null;
  		this._backgroundBox = null;

  	}

  	get _hasInitialized() {

  		return this._renderer.hasInitialized();

  	}

  	/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety.
  	 *
  	 * @param {Scene} scene - The scene to be captured.
  	 * @param {number} [sigma=0] - The blur radius in radians.
  	 * @param {number} [near=0.1] - The near plane distance.
  	 * @param {number} [far=100] - The far plane distance.
  	 * @param {Object} [options={}] - The configuration options.
  	 * @param {number} [options.size=256] - The texture size of the PMREM.
  	 * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
  	 * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
  	 * @return {RenderTarget} The resulting PMREM.
  	 * @see {@link PMREMGenerator#fromSceneAsync}
  	 */
  	fromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {

  		const {
  			size = 256,
  			position = _origin,
  			renderTarget = null,
  		} = options;

  		this._setSize( size );

  		if ( this._hasInitialized === false ) {

  			console.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );

  			const cubeUVRenderTarget = renderTarget || this._allocateTarget();

  			options.renderTarget = cubeUVRenderTarget;

  			this.fromSceneAsync( scene, sigma, near, far, options );

  			return cubeUVRenderTarget;

  		}

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

  		const cubeUVRenderTarget = renderTarget || this._allocateTarget();
  		cubeUVRenderTarget.depthBuffer = true;

  		this._init( cubeUVRenderTarget );

  		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );

  		if ( sigma > 0 ) {

  			this._blur( cubeUVRenderTarget, 0, 0, sigma );

  		}

  		this._applyPMREM( cubeUVRenderTarget );

  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 *
  	 * @param {Scene} scene - The scene to be captured.
  	 * @param {number} [sigma=0] - The blur radius in radians.
  	 * @param {number} [near=0.1] - The near plane distance.
  	 * @param {number} [far=100] - The far plane distance.
  	 * @param {Object} [options={}] - The configuration options.
  	 * @param {number} [options.size=256] - The texture size of the PMREM.
  	 * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
  	 * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
  	 * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
  	 * @see {@link PMREMGenerator#fromScene}
  	 */
  	async fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {

  		if ( this._hasInitialized === false ) await this._renderer.init();

  		return this.fromScene( scene, sigma, near, far, options );

  	}

  	/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * or HDR. The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 *
  	 * @param {Texture} equirectangular - The equirectangular texture to be converted.
  	 * @param {?RenderTarget} [renderTarget=null] - The render target to use.
  	 * @return {RenderTarget} The resulting PMREM.
  	 * @see {@link PMREMGenerator#fromEquirectangularAsync}
  	 */
  	fromEquirectangular( equirectangular, renderTarget = null ) {

  		if ( this._hasInitialized === false ) {

  			console.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );

  			this._setSizeFromTexture( equirectangular );

  			const cubeUVRenderTarget = renderTarget || this._allocateTarget();

  			this.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );

  			return cubeUVRenderTarget;

  		}

  		return this._fromTexture( equirectangular, renderTarget );

  	}

  	/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * or HDR. The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 *
  	 * @param {Texture} equirectangular - The equirectangular texture to be converted.
  	 * @param {?RenderTarget} [renderTarget=null] - The render target to use.
  	 * @return {Promise<RenderTarget>} The resulting PMREM.
  	 * @see {@link PMREMGenerator#fromEquirectangular}
  	 */
  	async fromEquirectangularAsync( equirectangular, renderTarget = null ) {

  		if ( this._hasInitialized === false ) await this._renderer.init();

  		return this._fromTexture( equirectangular, renderTarget );

  	}

  	/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * or HDR. The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 *
  	 * @param {Texture} cubemap - The cubemap texture to be converted.
  	 * @param {?RenderTarget} [renderTarget=null] - The render target to use.
  	 * @return {RenderTarget} The resulting PMREM.
  	 * @see {@link PMREMGenerator#fromCubemapAsync}
  	 */
  	fromCubemap( cubemap, renderTarget = null ) {

  		if ( this._hasInitialized === false ) {

  			console.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );

  			this._setSizeFromTexture( cubemap );

  			const cubeUVRenderTarget = renderTarget || this._allocateTarget();

  			this.fromCubemapAsync( cubemap, renderTarget );

  			return cubeUVRenderTarget;

  		}

  		return this._fromTexture( cubemap, renderTarget );

  	}

  	/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * or HDR. The ideal input cube size is 256 x 256,
  	 * with the 256 x 256 cubemap output.
  	 *
  	 * @param {Texture} cubemap - The cubemap texture to be converted.
  	 * @param {?RenderTarget} [renderTarget=null] - The render target to use.
  	 * @return {Promise<RenderTarget>} The resulting PMREM.
  	 * @see {@link PMREMGenerator#fromCubemap}
  	 */
  	async fromCubemapAsync( cubemap, renderTarget = null ) {

  		if ( this._hasInitialized === false ) await this._renderer.init();

  		return this._fromTexture( cubemap, renderTarget );

  	}

  	/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 *
  	 * @returns {Promise}
  	 */
  	async compileCubemapShader() {

  		if ( this._cubemapMaterial === null ) {

  			this._cubemapMaterial = _getCubemapMaterial();
  			await this._compileMaterial( this._cubemapMaterial );

  		}

  	}

  	/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 *
  	 * @returns {Promise}
  	 */
  	async compileEquirectangularShader() {

  		if ( this._equirectMaterial === null ) {

  			this._equirectMaterial = _getEquirectMaterial();
  			await this._compileMaterial( this._equirectMaterial );

  		}

  	}

  	/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */
  	dispose() {

  		this._dispose();

  		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
  		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();
  		if ( this._backgroundBox !== null ) {

  			this._backgroundBox.geometry.dispose();
  			this._backgroundBox.material.dispose();

  		}

  	}

  	// private interface

  	_setSizeFromTexture( texture ) {

  		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

  			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

  		} else { // Equirectangular

  			this._setSize( texture.image.width / 4 );

  		}

  	}

  	_setSize( cubeSize ) {

  		this._lodMax = Math.floor( Math.log2( cubeSize ) );
  		this._cubeSize = Math.pow( 2, this._lodMax );

  	}

  	_dispose() {

  		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

  		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

  		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

  			this._lodPlanes[ i ].dispose();

  		}

  	}

  	_cleanup( outputTarget ) {

  		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
  		outputTarget.scissorTest = false;
  		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

  	}

  	_fromTexture( texture, renderTarget ) {

  		this._setSizeFromTexture( texture );

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

  		const cubeUVRenderTarget = renderTarget || this._allocateTarget();
  		this._init( cubeUVRenderTarget );
  		this._textureToCubeUV( texture, cubeUVRenderTarget );
  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	_allocateTarget() {

  		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
  		const height = 4 * this._cubeSize;

  		const cubeUVRenderTarget = _createRenderTarget( width, height );

  		return cubeUVRenderTarget;

  	}

  	_init( renderTarget ) {

  		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height ) {

  			if ( this._pingPongRenderTarget !== null ) {

  				this._dispose();

  			}

  			this._pingPongRenderTarget = _createRenderTarget( renderTarget.width, renderTarget.height );

  			const { _lodMax } = this;
  			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );

  			this._blurMaterial = _getBlurShader( _lodMax, renderTarget.width, renderTarget.height );

  		}

  	}

  	async _compileMaterial( material ) {

  		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
  		await this._renderer.compile( tmpMesh, _flatCamera );

  	}

  	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {

  		const cubeCamera = _cubeCamera;
  		cubeCamera.near = near;
  		cubeCamera.far = far;

  		// px, py, pz, nx, ny, nz
  		const upSign = [ 1, 1, 1, 1, -1, 1 ];
  		const forwardSign = [ 1, -1, 1, -1, 1, -1 ];

  		const renderer = this._renderer;

  		const originalAutoClear = renderer.autoClear;

  		renderer.getClearColor( _clearColor$2 );

  		renderer.autoClear = false;

  		let backgroundBox = this._backgroundBox;

  		if ( backgroundBox === null ) {

  			const backgroundMaterial = new MeshBasicMaterial( {
  				name: 'PMREM.Background',
  				side: BackSide,
  				depthWrite: false,
  				depthTest: false
  			} );

  			backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

  		}

  		let useSolidColor = false;
  		const background = scene.background;

  		if ( background ) {

  			if ( background.isColor ) {

  				backgroundBox.material.color.copy( background );
  				scene.background = null;
  				useSolidColor = true;

  			}

  		} else {

  			backgroundBox.material.color.copy( _clearColor$2 );
  			useSolidColor = true;

  		}

  		renderer.setRenderTarget( cubeUVRenderTarget );

  		renderer.clear();

  		if ( useSolidColor ) {

  			renderer.render( backgroundBox, cubeCamera );

  		}

  		for ( let i = 0; i < 6; i ++ ) {

  			const col = i % 3;

  			if ( col === 0 ) {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.position.set( position.x, position.y, position.z );
  				cubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );

  			} else if ( col === 1 ) {

  				cubeCamera.up.set( 0, 0, upSign[ i ] );
  				cubeCamera.position.set( position.x, position.y, position.z );
  				cubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );


  			} else {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.position.set( position.x, position.y, position.z );
  				cubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );


  			}

  			const size = this._cubeSize;

  			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

  			renderer.render( scene, cubeCamera );

  		}

  		renderer.autoClear = originalAutoClear;
  		scene.background = background;

  	}

  	_textureToCubeUV( texture, cubeUVRenderTarget ) {

  		const renderer = this._renderer;

  		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

  		if ( isCubeTexture ) {

  			if ( this._cubemapMaterial === null ) {

  				this._cubemapMaterial = _getCubemapMaterial( texture );

  			}

  		} else {

  			if ( this._equirectMaterial === null ) {

  				this._equirectMaterial = _getEquirectMaterial( texture );

  			}

  		}

  		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
  		material.fragmentNode.value = texture;

  		const mesh = this._lodMeshes[ 0 ];
  		mesh.material = material;

  		const size = this._cubeSize;

  		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

  		renderer.setRenderTarget( cubeUVRenderTarget );
  		renderer.render( mesh, _flatCamera );

  	}

  	_applyPMREM( cubeUVRenderTarget ) {

  		const renderer = this._renderer;
  		const autoClear = renderer.autoClear;
  		renderer.autoClear = false;
  		const n = this._lodPlanes.length;

  		for ( let i = 1; i < n; i ++ ) {

  			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

  			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

  			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

  		}

  		renderer.autoClear = autoClear;

  	}

  	/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 *
  	 * @private
  	 * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
  	 * @param {number} lodIn - The input level-of-detail.
  	 * @param {number} lodOut - The output level-of-detail.
  	 * @param {number} sigma - The blur radius in radians.
  	 * @param {Vector3} [poleAxis] - The pole axis.
  	 */
  	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

  		const pingPongRenderTarget = this._pingPongRenderTarget;

  		this._halfBlur(
  			cubeUVRenderTarget,
  			pingPongRenderTarget,
  			lodIn,
  			lodOut,
  			sigma,
  			'latitudinal',
  			poleAxis );

  		this._halfBlur(
  			pingPongRenderTarget,
  			cubeUVRenderTarget,
  			lodOut,
  			lodOut,
  			sigma,
  			'longitudinal',
  			poleAxis );

  	}

  	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

  		const renderer = this._renderer;
  		const blurMaterial = this._blurMaterial;

  		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

  			console.error( 'blur direction must be either latitudinal or longitudinal!' );

  		}

  		// Number of standard deviations at which to cut off the discrete approximation.
  		const STANDARD_DEVIATIONS = 3;

  		const blurMesh = this._lodMeshes[ lodOut ];
  		blurMesh.material = blurMaterial;

  		const blurUniforms = _uniformsMap.get( blurMaterial );

  		const pixels = this._sizeLods[ lodIn ] - 1;
  		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
  		const sigmaPixels = sigmaRadians / radiansPerPixel;
  		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

  		if ( samples > MAX_SAMPLES ) {

  			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

  		}

  		const weights = [];
  		let sum = 0;

  		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

  			const x = i / sigmaPixels;
  			const weight = Math.exp( - x * x / 2 );
  			weights.push( weight );

  			if ( i === 0 ) {

  				sum += weight;

  			} else if ( i < samples ) {

  				sum += 2 * weight;

  			}

  		}

  		for ( let i = 0; i < weights.length; i ++ ) {

  			weights[ i ] = weights[ i ] / sum;

  		}

  		targetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;

  		blurUniforms.envMap.value = targetIn.texture;
  		blurUniforms.samples.value = samples;
  		blurUniforms.weights.array = weights;
  		blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;

  		if ( poleAxis ) {

  			blurUniforms.poleAxis.value = poleAxis;

  		}

  		const { _lodMax } = this;
  		blurUniforms.dTheta.value = radiansPerPixel;
  		blurUniforms.mipInt.value = _lodMax - lodIn;

  		const outputSize = this._sizeLods[ lodOut ];
  		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
  		const y = 4 * ( this._cubeSize - outputSize );

  		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
  		renderer.setRenderTarget( targetOut );
  		renderer.render( blurMesh, _flatCamera );

  	}

  }

  function _createPlanes( lodMax ) {

  	const lodPlanes = [];
  	const sizeLods = [];
  	const sigmas = [];
  	const lodMeshes = [];

  	let lod = lodMax;

  	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  	for ( let i = 0; i < totalLods; i ++ ) {

  		const sizeLod = Math.pow( 2, lod );
  		sizeLods.push( sizeLod );
  		let sigma = 1.0 / sizeLod;

  		if ( i > lodMax - LOD_MIN ) {

  			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

  		} else if ( i === 0 ) {

  			sigma = 0;

  		}

  		sigmas.push( sigma );

  		const texelSize = 1.0 / ( sizeLod - 2 );
  		const min = - texelSize;
  		const max = 1 + texelSize;
  		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

  		const cubeFaces = 6;
  		const vertices = 6;
  		const positionSize = 3;
  		const uvSize = 2;
  		const faceIndexSize = 1;

  		const position = new Float32Array( positionSize * vertices * cubeFaces );
  		const uv = new Float32Array( uvSize * vertices * cubeFaces );
  		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

  		for ( let face = 0; face < cubeFaces; face ++ ) {

  			const x = ( face % 3 ) * 2 / 3 - 1;
  			const y = face > 2 ? 0 : -1;
  			const coordinates = [
  				x, y, 0,
  				x + 2 / 3, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y + 1, 0
  			];

  			const faceIdx = _faceLib[ face ];
  			position.set( coordinates, positionSize * vertices * faceIdx );
  			uv.set( uv1, uvSize * vertices * faceIdx );
  			const fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];
  			faceIndex.set( fill, faceIndexSize * vertices * faceIdx );

  		}

  		const planes = new BufferGeometry();
  		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
  		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
  		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
  		lodPlanes.push( planes );
  		lodMeshes.push( new Mesh( planes, null ) );

  		if ( lod > LOD_MIN ) {

  			lod --;

  		}

  	}

  	return { lodPlanes, sizeLods, sigmas, lodMeshes };

  }

  function _createRenderTarget( width, height ) {

  	const params = {
  		magFilter: LinearFilter,
  		minFilter: LinearFilter,
  		generateMipmaps: false,
  		type: HalfFloatType,
  		format: RGBAFormat,
  		colorSpace: LinearSRGBColorSpace,
  		//depthBuffer: false
  	};

  	const cubeUVRenderTarget = new RenderTarget( width, height, params );
  	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  	cubeUVRenderTarget.texture.isPMREMTexture = true;
  	cubeUVRenderTarget.scissorTest = true;
  	return cubeUVRenderTarget;

  }

  function _setViewport( target, x, y, width, height ) {

  	target.viewport.set( x, y, width, height );
  	target.scissor.set( x, y, width, height );

  }

  function _getMaterial( type ) {

  	const material = new NodeMaterial();
  	material.depthTest = false;
  	material.depthWrite = false;
  	material.blending = NoBlending;
  	material.name = `PMREM_${ type }`;

  	return material;

  }

  function _getBlurShader( lodMax, width, height ) {

  	const weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );
  	const poleAxis = uniform( new Vector3( 0, 1, 0 ) );
  	const dTheta = uniform( 0 );
  	const n = float( MAX_SAMPLES );
  	const latitudinal = uniform( 0 ); // false, bool
  	const samples = uniform( 1 ); // int
  	const envMap = texture( null );
  	const mipInt = uniform( 0 ); // int
  	const CUBEUV_TEXEL_WIDTH = float( 1 / width );
  	const CUBEUV_TEXEL_HEIGHT = float( 1 / height );
  	const CUBEUV_MAX_MIP = float( lodMax );

  	const materialUniforms = {
  		n,
  		latitudinal,
  		weights,
  		poleAxis,
  		outputDirection: _outputDirection,
  		dTheta,
  		samples,
  		envMap,
  		mipInt,
  		CUBEUV_TEXEL_WIDTH,
  		CUBEUV_TEXEL_HEIGHT,
  		CUBEUV_MAX_MIP
  	};

  	const material = _getMaterial( 'blur' );
  	material.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );

  	_uniformsMap.set( material, materialUniforms );

  	return material;

  }

  function _getCubemapMaterial( envTexture ) {

  	const material = _getMaterial( 'cubemap' );
  	material.fragmentNode = cubeTexture( envTexture, _outputDirection );

  	return material;

  }

  function _getEquirectMaterial( envTexture ) {

  	const material = _getMaterial( 'equirect' );
  	material.fragmentNode = texture( envTexture, equirectUV( _outputDirection ), 0 );

  	return material;

  }

  const _cache = new WeakMap();

  /**
   * Generates the cubeUV size based on the given image height.
   *
   * @private
   * @param {number} imageHeight - The image height.
   * @return {{texelWidth: number,texelHeight: number, maxMip: number}} The result object.
   */
  function _generateCubeUVSize( imageHeight ) {

  	const maxMip = Math.log2( imageHeight ) - 2;

  	const texelHeight = 1.0 / imageHeight;

  	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

  	return { texelWidth, texelHeight, maxMip };

  }

  /**
   * Generates a PMREM from the given texture.
   *
   * @private
   * @param {Texture} texture - The texture to create the PMREM for.
   * @param {Renderer} renderer - The renderer.
   * @param {PMREMGenerator} generator - The PMREM generator.
   * @return {?Texture} The PMREM.
   */
  function _getPMREMFromTexture( texture, renderer, generator ) {

  	const cache = _getCache( renderer );

  	let cacheTexture = cache.get( texture );

  	const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;

  	if ( pmremVersion !== texture.pmremVersion ) {

  		const image = texture.image;

  		if ( texture.isCubeTexture ) {

  			if ( isCubeMapReady( image ) ) {

  				cacheTexture = generator.fromCubemap( texture, cacheTexture );

  			} else {

  				return null;

  			}


  		} else {

  			if ( isEquirectangularMapReady( image ) ) {

  				cacheTexture = generator.fromEquirectangular( texture, cacheTexture );

  			} else {

  				return null;

  			}

  		}

  		cacheTexture.pmremVersion = texture.pmremVersion;

  		cache.set( texture, cacheTexture );

  	}

  	return cacheTexture.texture;

  }

  /**
   * Returns a cache that stores generated PMREMs for the respective textures.
   * A cache must be maintained per renderer since PMREMs are render target textures
   * which can't be shared across render contexts.
   *
   * @private
   * @param {Renderer} renderer - The renderer.
   * @return {WeakMap<Texture, Texture>} The PMREM cache.
   */
  function _getCache( renderer ) {

  	let rendererCache = _cache.get( renderer );

  	if ( rendererCache === undefined ) {

  		rendererCache = new WeakMap();
  		_cache.set( renderer, rendererCache );

  	}

  	return rendererCache;

  }

  /**
   * This node represents a PMREM which is a special type of preprocessed
   * environment map intended for PBR materials.
   *
   * ```js
   * const material = new MeshStandardNodeMaterial();
   * material.envNode = pmremTexture( envMap );
   * ```
   *
   * @augments TempNode
   */
  class PMREMNode extends TempNode {

  	static get type() {

  		return 'PMREMNode';

  	}

  	/**
  	 * Constructs a new function overloading node.
  	 *
  	 * @param {Texture} value - The input texture.
  	 * @param {Node<vec2>} [uvNode=null] - The uv node.
  	 * @param {Node<float>} [levelNode=null] - The level node.
  	 */
  	constructor( value, uvNode = null, levelNode = null ) {

  		super( 'vec3' );

  		/**
  		 * Reference to the input texture.
  		 *
  		 * @private
  		 * @type {Texture}
  		 */
  		this._value = value;

  		/**
  		 * Reference to the generated PMREM.
  		 *
  		 * @private
  		 * @type {Texture | null}
  		 * @default null
  		 */
  		this._pmrem = null;

  		/**
  		 *  The uv node.
  		 *
  		 * @type {Node<vec2>}
  		 */
  		this.uvNode = uvNode;

  		/**
  		 *  The level node.
  		 *
  		 * @type {Node<float>}
  		 */
  		this.levelNode = levelNode;

  		/**
  		 * Reference to a PMREM generator.
  		 *
  		 * @private
  		 * @type {?PMREMGenerator}
  		 * @default null
  		 */
  		this._generator = null;

  		const defaultTexture = new Texture();
  		defaultTexture.isRenderTargetTexture = true;

  		/**
  		 * The texture node holding the generated PMREM.
  		 *
  		 * @private
  		 * @type {TextureNode}
  		 */
  		this._texture = texture( defaultTexture );

  		/**
  		 * A uniform representing the PMREM's width.
  		 *
  		 * @private
  		 * @type {UniformNode<float>}
  		 */
  		this._width = uniform( 0 );

  		/**
  		 * A uniform representing the PMREM's height.
  		 *
  		 * @private
  		 * @type {UniformNode<float>}
  		 */
  		this._height = uniform( 0 );

  		/**
  		 * A uniform representing the PMREM's max Mip.
  		 *
  		 * @private
  		 * @type {UniformNode<float>}
  		 */
  		this._maxMip = uniform( 0 );

  		/**
  		 * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.
  		 *
  		 * @type {string}
  		 * @default 'render'
  		 */
  		this.updateBeforeType = NodeUpdateType.RENDER;

  	}

  	set value( value ) {

  		this._value = value;
  		this._pmrem = null;

  	}

  	/**
  	 * The node's texture value.
  	 *
  	 * @type {Texture}
  	 */
  	get value() {

  		return this._value;

  	}

  	/**
  	 * Uses the given PMREM texture to update internal values.
  	 *
  	 * @param {Texture} texture - The PMREM texture.
  	 */
  	updateFromTexture( texture ) {

  		const cubeUVSize = _generateCubeUVSize( texture.image.height );

  		this._texture.value = texture;
  		this._width.value = cubeUVSize.texelWidth;
  		this._height.value = cubeUVSize.texelHeight;
  		this._maxMip.value = cubeUVSize.maxMip;

  	}

  	updateBefore( frame ) {

  		let pmrem = this._pmrem;

  		const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
  		const texture = this._value;

  		if ( pmremVersion !== texture.pmremVersion ) {

  			if ( texture.isPMREMTexture === true ) {

  				pmrem = texture;

  			} else {

  				pmrem = _getPMREMFromTexture( texture, frame.renderer, this._generator );

  			}

  			if ( pmrem !== null ) {

  				this._pmrem = pmrem;

  				this.updateFromTexture( pmrem );

  			}

  		}

  	}

  	setup( builder ) {

  		if ( this._generator === null ) {

  			this._generator = new PMREMGenerator( builder.renderer );

  		}

  		this.updateBefore( builder );

  		//

  		let uvNode = this.uvNode;

  		if ( uvNode === null && builder.context.getUV ) {

  			uvNode = builder.context.getUV( this );

  		}

  		//

  		uvNode = materialEnvRotation.mul( vec3( uvNode.x, uvNode.y.negate(), uvNode.z ) );

  		//

  		let levelNode = this.levelNode;

  		if ( levelNode === null && builder.context.getTextureLevel ) {

  			levelNode = builder.context.getTextureLevel( this );

  		}

  		//

  		return textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );

  	}

  	dispose() {

  		super.dispose();

  		if ( this._generator !== null ) this._generator.dispose();

  	}

  }

  /**
   * Returns `true` if the given cube map image has been fully loaded.
   *
   * @private
   * @param {?Array<(Image|Object)>} [image] - The cube map image.
   * @return {boolean} Whether the given cube map is ready or not.
   */
  function isCubeMapReady( image ) {

  	if ( image === null || image === undefined ) return false;

  	let count = 0;
  	const length = 6;

  	for ( let i = 0; i < length; i ++ ) {

  		if ( image[ i ] !== undefined ) count ++;

  	}

  	return count === length;


  }

  /**
   * Returns `true` if the given equirectangular image has been fully loaded.
   *
   * @private
   * @param {(Image|Object)} image - The equirectangular image.
   * @return {boolean} Whether the given cube map is ready or not.
   */
  function isEquirectangularMapReady( image ) {

  	if ( image === null || image === undefined ) return false;

  	return image.height > 0;

  }

  /**
   * TSL function for creating a PMREM node.
   *
   * @tsl
   * @function
   * @param {Texture} value - The input texture.
   * @param {?Node<vec2>} [uvNode=null] - The uv node.
   * @param {?Node<float>} [levelNode=null] - The level node.
   * @returns {PMREMNode}
   */
  const pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode ).setParameterLength( 1, 3 );

  const _envNodeCache = new WeakMap();

  /**
   * Represents a physical model for Image-based lighting (IBL). The environment
   * is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.
   * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.
   *
   * @augments LightingNode
   */
  class EnvironmentNode extends LightingNode {

  	static get type() {

  		return 'EnvironmentNode';

  	}

  	/**
  	 * Constructs a new environment node.
  	 *
  	 * @param {Node} [envNode=null] - A node representing the environment.
  	 */
  	constructor( envNode = null ) {

  		super();

  		/**
  		 * A node representing the environment.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.envNode = envNode;

  	}

  	setup( builder ) {

  		const { material } = builder;

  		let envNode = this.envNode;

  		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

  			const value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

  			let cacheEnvNode = _envNodeCache.get( value );

  			if ( cacheEnvNode === undefined ) {

  				cacheEnvNode = pmremTexture( value );

  				_envNodeCache.set( value, cacheEnvNode );

  			}

  			envNode	= cacheEnvNode;

  		}

  		//

  		const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
  		const radianceNormalView = useAnisotropy ? bentNormalView : normalView;

  		const radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( materialEnvIntensity );
  		const irradiance = envNode.context( createIrradianceContext( normalWorld ) ).mul( Math.PI ).mul( materialEnvIntensity );

  		const isolateRadiance = cache( radiance );
  		const isolateIrradiance = cache( irradiance );

  		//

  		builder.context.radiance.addAssign( isolateRadiance );

  		builder.context.iblIrradiance.addAssign( isolateIrradiance );

  		//

  		const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;

  		if ( clearcoatRadiance ) {

  			const clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, clearcoatNormalView ) ).mul( materialEnvIntensity );
  			const isolateClearcoatRadiance = cache( clearcoatRadianceContext );

  			clearcoatRadiance.addAssign( isolateClearcoatRadiance );

  		}

  	}

  }

  const createRadianceContext = ( roughnessNode, normalViewNode ) => {

  	let reflectVec = null;

  	return {
  		getUV: () => {

  			if ( reflectVec === null ) {

  				reflectVec = positionViewDirection.negate().reflect( normalViewNode );

  				// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
  				reflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();

  				reflectVec = reflectVec.transformDirection( cameraViewMatrix );

  			}

  			return reflectVec;

  		},
  		getTextureLevel: () => {

  			return roughnessNode;

  		}
  	};

  };

  const createIrradianceContext = ( normalWorldNode ) => {

  	return {
  		getUV: () => {

  			return normalWorldNode;

  		},
  		getTextureLevel: () => {

  			return float( 1.0 );

  		}
  	};

  };

  const _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();

  /**
   * Node material version of {@link MeshStandardMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshStandardNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshStandardNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh standard node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshStandardNodeMaterial = true;

  		/**
  		 * Set to `true` because standard materials react on lights.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.lights = true;

  		/**
  		 * The emissive color of standard materials is by default inferred from the `emissive`,
  		 * `emissiveIntensity` and `emissiveMap` properties. This node property allows to
  		 * overwrite the default and define the emissive color with a node instead.
  		 *
  		 * If you don't want to overwrite the emissive color but modify the existing
  		 * value instead, use {@link materialEmissive}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.emissiveNode = null;

  		/**
  		 * The metalness of standard materials is by default inferred from the `metalness`,
  		 * and `metalnessMap` properties. This node property allows to
  		 * overwrite the default and define the metalness with a node instead.
  		 *
  		 * If you don't want to overwrite the metalness but modify the existing
  		 * value instead, use {@link materialMetalness}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.metalnessNode = null;

  		/**
  		 * The roughness of standard materials is by default inferred from the `roughness`,
  		 * and `roughnessMap` properties. This node property allows to
  		 * overwrite the default and define the roughness with a node instead.
  		 *
  		 * If you don't want to overwrite the roughness but modify the existing
  		 * value instead, use {@link materialRoughness}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.roughnessNode = null;

  		this.setDefaultValues( _defaultValues$6 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Overwritten since this type of material uses {@link EnvironmentNode}
  	 * to implement the PBR (PMREM based) environment mapping. Besides, the
  	 * method honors `Scene.environment`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {?EnvironmentNode<vec3>} The environment node.
  	 */
  	setupEnvironment( builder ) {

  		let envNode = super.setupEnvironment( builder );

  		if ( envNode === null && builder.environmentNode ) {

  			envNode = builder.environmentNode;

  		}

  		return envNode ? new EnvironmentNode( envNode ) : null;

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {PhysicalLightingModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		return new PhysicalLightingModel();

  	}

  	/**
  	 * Setups the specular related node variables.
  	 */
  	setupSpecular() {

  		const specularColorNode = mix$2( vec3( 0.04 ), diffuseColor.rgb, metalness );

  		specularColor.assign( specularColorNode );
  		specularF90.assign( 1.0 );

  	}

  	/**
  	 * Setups the standard specific node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupVariants() {

  		// METALNESS

  		const metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;

  		metalness.assign( metalnessNode );

  		// ROUGHNESS

  		let roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;
  		roughnessNode = getRoughness( { roughness: roughnessNode } );

  		roughness.assign( roughnessNode );

  		// SPECULAR COLOR

  		this.setupSpecular();

  		// DIFFUSE COLOR

  		diffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );

  	}

  	copy( source ) {

  		this.emissiveNode = source.emissiveNode;

  		this.metalnessNode = source.metalnessNode;
  		this.roughnessNode = source.roughnessNode;

  		return super.copy( source );

  	}

  }

  const _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();

  /**
   * Node material version of {@link MeshPhysicalMaterial}.
   *
   * @augments MeshStandardNodeMaterial
   */
  class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {

  	static get type() {

  		return 'MeshPhysicalNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh physical node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshPhysicalNodeMaterial = true;

  		/**
  		 * The clearcoat of physical materials is by default inferred from the `clearcoat`
  		 * and `clearcoatMap` properties. This node property allows to overwrite the default
  		 * and define the clearcoat with a node instead.
  		 *
  		 * If you don't want to overwrite the clearcoat but modify the existing
  		 * value instead, use {@link materialClearcoat}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.clearcoatNode = null;

  		/**
  		 * The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`
  		 * and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default
  		 * and define the clearcoat roughness with a node instead.
  		 *
  		 * If you don't want to overwrite the clearcoat roughness but modify the existing
  		 * value instead, use {@link materialClearcoatRoughness}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.clearcoatRoughnessNode = null;

  		/**
  		 * The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`
  		 * property. This node property allows to overwrite the default
  		 * and define the clearcoat normal with a node instead.
  		 *
  		 * If you don't want to overwrite the clearcoat normal but modify the existing
  		 * value instead, use {@link materialClearcoatNormal}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.clearcoatNormalNode = null;

  		/**
  		 * The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`
  		 * and `sheenColorMap` properties. This node property allows to overwrite the default
  		 * and define the sheen with a node instead.
  		 *
  		 * If you don't want to overwrite the sheen but modify the existing
  		 * value instead, use {@link materialSheen}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.sheenNode = null;

  		/**
  		 * The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and
  		 * `sheenRoughnessMap` properties. This node property allows to overwrite the default
  		 * and define the sheen roughness with a node instead.
  		 *
  		 * If you don't want to overwrite the sheen roughness but modify the existing
  		 * value instead, use {@link materialSheenRoughness}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.sheenRoughnessNode = null;

  		/**
  		 * The iridescence of physical materials is by default inferred from the `iridescence`
  		 * property. This node property allows to overwrite the default
  		 * and define the iridescence with a node instead.
  		 *
  		 * If you don't want to overwrite the iridescence but modify the existing
  		 * value instead, use {@link materialIridescence}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.iridescenceNode = null;

  		/**
  		 * The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`
  		 * property. This node property allows to overwrite the default
  		 * and define the iridescence IOR with a node instead.
  		 *
  		 * If you don't want to overwrite the iridescence IOR but modify the existing
  		 * value instead, use {@link materialIridescenceIOR}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.iridescenceIORNode = null;

  		/**
  		 * The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`
  		 * and `iridescenceThicknessMap` properties. This node property allows to overwrite the default
  		 * and define the iridescence thickness with a node instead.
  		 *
  		 * If you don't want to overwrite the iridescence thickness but modify the existing
  		 * value instead, use {@link materialIridescenceThickness}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.iridescenceThicknessNode = null;

  		/**
  		 * The specular intensity of physical materials is by default inferred from the `specularIntensity`
  		 * and `specularIntensityMap` properties. This node property allows to overwrite the default
  		 * and define the specular intensity with a node instead.
  		 *
  		 * If you don't want to overwrite the specular intensity but modify the existing
  		 * value instead, use {@link materialSpecularIntensity}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.specularIntensityNode = null;

  		/**
  		 * The specular color of physical materials is by default inferred from the `specularColor`
  		 * and `specularColorMap` properties. This node property allows to overwrite the default
  		 * and define the specular color with a node instead.
  		 *
  		 * If you don't want to overwrite the specular color but modify the existing
  		 * value instead, use {@link materialSpecularColor}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.specularColorNode = null;

  		/**
  		 * The ior of physical materials is by default inferred from the `ior`
  		 * property. This node property allows to overwrite the default
  		 * and define the ior with a node instead.
  		 *
  		 * If you don't want to overwrite the ior but modify the existing
  		 * value instead, use {@link materialIOR}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.iorNode = null;

  		/**
  		 * The transmission of physical materials is by default inferred from the `transmission` and
  		 * `transmissionMap` properties. This node property allows to overwrite the default
  		 * and define the transmission with a node instead.
  		 *
  		 * If you don't want to overwrite the transmission but modify the existing
  		 * value instead, use {@link materialTransmission}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.transmissionNode = null;

  		/**
  		 * The thickness of physical materials is by default inferred from the `thickness` and
  		 * `thicknessMap` properties. This node property allows to overwrite the default
  		 * and define the thickness with a node instead.
  		 *
  		 * If you don't want to overwrite the thickness but modify the existing
  		 * value instead, use {@link materialThickness}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.thicknessNode = null;

  		/**
  		 * The attenuation distance of physical materials is by default inferred from the
  		 * `attenuationDistance` property. This node property allows to overwrite the default
  		 * and define the attenuation distance with a node instead.
  		 *
  		 * If you don't want to overwrite the attenuation distance but modify the existing
  		 * value instead, use {@link materialAttenuationDistance}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.attenuationDistanceNode = null;

  		/**
  		 * The attenuation color of physical materials is by default inferred from the
  		 * `attenuationColor` property. This node property allows to overwrite the default
  		 * and define the attenuation color with a node instead.
  		 *
  		 * If you don't want to overwrite the attenuation color but modify the existing
  		 * value instead, use {@link materialAttenuationColor}.
  		 *
  		 * @type {?Node<vec3>}
  		 * @default null
  		 */
  		this.attenuationColorNode = null;

  		/**
  		 * The dispersion of physical materials is by default inferred from the
  		 * `dispersion` property. This node property allows to overwrite the default
  		 * and define the dispersion with a node instead.
  		 *
  		 * If you don't want to overwrite the dispersion but modify the existing
  		 * value instead, use {@link materialDispersion}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.dispersionNode = null;

  		/**
  		 * The anisotropy of physical materials is by default inferred from the
  		 * `anisotropy` property. This node property allows to overwrite the default
  		 * and define the anisotropy with a node instead.
  		 *
  		 * If you don't want to overwrite the anisotropy but modify the existing
  		 * value instead, use {@link materialAnisotropy}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.anisotropyNode = null;

  		this.setDefaultValues( _defaultValues$5 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Whether the lighting model should use clearcoat or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get useClearcoat() {

  		return this.clearcoat > 0 || this.clearcoatNode !== null;

  	}

  	/**
  	 * Whether the lighting model should use iridescence or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get useIridescence() {

  		return this.iridescence > 0 || this.iridescenceNode !== null;

  	}

  	/**
  	 * Whether the lighting model should use sheen or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get useSheen() {

  		return this.sheen > 0 || this.sheenNode !== null;

  	}

  	/**
  	 * Whether the lighting model should use anisotropy or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get useAnisotropy() {

  		return this.anisotropy > 0 || this.anisotropyNode !== null;

  	}

  	/**
  	 * Whether the lighting model should use transmission or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get useTransmission() {

  		return this.transmission > 0 || this.transmissionNode !== null;

  	}

  	/**
  	 * Whether the lighting model should use dispersion or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get useDispersion() {

  		return this.dispersion > 0 || this.dispersionNode !== null;

  	}

  	/**
  	 * Setups the specular related node variables.
  	 */
  	setupSpecular() {

  		const iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;

  		ior.assign( iorNode );
  		specularColor.assign( mix$2( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );
  		specularF90.assign( mix$2( materialSpecularIntensity, 1.0, metalness ) );

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {PhysicalLightingModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		return new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );

  	}

  	/**
  	 * Setups the physical specific node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupVariants( builder ) {

  		super.setupVariants( builder );

  		// CLEARCOAT

  		if ( this.useClearcoat ) {

  			const clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;
  			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;

  			clearcoat.assign( clearcoatNode );
  			clearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );

  		}

  		// SHEEN

  		if ( this.useSheen ) {

  			const sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;
  			const sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;

  			sheen.assign( sheenNode );
  			sheenRoughness.assign( sheenRoughnessNode );

  		}

  		// IRIDESCENCE

  		if ( this.useIridescence ) {

  			const iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;
  			const iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;
  			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;

  			iridescence.assign( iridescenceNode );
  			iridescenceIOR.assign( iridescenceIORNode );
  			iridescenceThickness.assign( iridescenceThicknessNode );

  		}

  		// ANISOTROPY

  		if ( this.useAnisotropy ) {

  			const anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();

  			anisotropy.assign( anisotropyV.length() );

  			If( anisotropy.equal( 0.0 ), () => {

  				anisotropyV.assign( vec2( 1.0, 0.0 ) );

  			} ).Else( () => {

  				anisotropyV.divAssign( vec2( anisotropy ) );
  				anisotropy.assign( anisotropy.saturate() );

  			} );

  			// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
  			alphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );

  			anisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );
  			anisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );

  		}

  		// TRANSMISSION

  		if ( this.useTransmission ) {

  			const transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;
  			const thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;
  			const attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;
  			const attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;

  			transmission.assign( transmissionNode );
  			thickness.assign( thicknessNode );
  			attenuationDistance.assign( attenuationDistanceNode );
  			attenuationColor.assign( attenuationColorNode );

  			if ( this.useDispersion ) {

  				const dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;

  				dispersion.assign( dispersionNode );

  			}

  		}

  	}

  	/**
  	 * Setups the clearcoat normal node.
  	 *
  	 * @return {Node<vec3>} The clearcoat normal.
  	 */
  	setupClearcoatNormal() {

  		return this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;

  	}

  	setup( builder ) {

  		builder.context.setupClearcoatNormal = () => subBuild( this.setupClearcoatNormal( builder ), 'NORMAL', 'vec3' );

  		super.setup( builder );

  	}

  	copy( source ) {

  		this.clearcoatNode = source.clearcoatNode;
  		this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
  		this.clearcoatNormalNode = source.clearcoatNormalNode;

  		this.sheenNode = source.sheenNode;
  		this.sheenRoughnessNode = source.sheenRoughnessNode;

  		this.iridescenceNode = source.iridescenceNode;
  		this.iridescenceIORNode = source.iridescenceIORNode;
  		this.iridescenceThicknessNode = source.iridescenceThicknessNode;

  		this.specularIntensityNode = source.specularIntensityNode;
  		this.specularColorNode = source.specularColorNode;

  		this.transmissionNode = source.transmissionNode;
  		this.thicknessNode = source.thicknessNode;
  		this.attenuationDistanceNode = source.attenuationDistanceNode;
  		this.attenuationColorNode = source.attenuationColorNode;
  		this.dispersionNode = source.dispersionNode;

  		this.anisotropyNode = source.anisotropyNode;

  		return super.copy( source );

  	}

  }

  const getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {

  	// dotNL will be from -1.0 to 1.0
  	const dotNL = normal.dot( lightDirection );
  	const coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );

  	if ( builder.material.gradientMap ) {

  		const gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );

  		return vec3( gradientMap.r );

  	} else {

  		const fw = coord.fwidth().mul( 0.5 );

  		return mix$2( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );

  	}

  } );

  /**
   * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.
   *
   * @augments LightingModel
   */
  class ToonLightingModel extends LightingModel {

  	/**
  	 * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
  	 * reduced to a small number of discrete shades to create a comic-like, flat look.
  	 *
  	 * @param {Object} lightData - The light data.
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	direct( { lightDirection, lightColor, reflectedLight }, builder ) {

  		const irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );

  		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

  	}

  	/**
  	 * Implements the indirect lighting.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	indirect( builder ) {

  		const { ambientOcclusion, irradiance, reflectedLight } = builder.context;

  		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

  	}

  }

  const _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();

  /**
   * Node material version of {@link MeshToonMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshToonNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshToonNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh toon node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshToonNodeMaterial = true;

  		/**
  		 * Set to `true` because toon materials react on lights.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.lights = true;

  		this.setDefaultValues( _defaultValues$4 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {ToonLightingModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		return new ToonLightingModel();

  	}

  }

  /**
   * TSL function for creating a matcap uv node.
   *
   * Can be used to compute texture coordinates for projecting a
   * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.
   *
   * @tsl
   * @function
   * @returns {Node<vec2>} The matcap UV coordinates.
   */
  const matcapUV = /*@__PURE__*/ Fn( () => {

  	const x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();
  	const y = positionViewDirection.cross( x );

  	return vec2( x.dot( normalView ), y.dot( normalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks

  } ).once( [ 'NORMAL', 'VERTEX' ] )().toVar( 'matcapUV' );

  const _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();

  /**
   * Node material version of {@link MeshMatcapMaterial}.
   *
   * @augments NodeMaterial
   */
  class MeshMatcapNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshMatcapNodeMaterial';

  	}

  	/**
  	 * Constructs a new mesh normal node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshMatcapNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$3 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Setups the matcap specific node variables.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupVariants( builder ) {

  		const uv = matcapUV;

  		let matcapColor;

  		if ( builder.material.matcap ) {

  			matcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );

  		} else {

  			matcapColor = vec3( mix$2( 0.2, 0.8, uv.y ) ); // default if matcap is missing

  		}

  		diffuseColor.rgb.mulAssign( matcapColor.rgb );

  	}

  }

  /**
   * Applies a rotation to the given position node.
   *
   * @augments TempNode
   */
  class RotateNode extends TempNode {

  	static get type() {

  		return 'RotateNode';

  	}

  	/**
  	 * Constructs a new rotate node.
  	 *
  	 * @param {Node} positionNode - The position node.
  	 * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
  	 * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
  	 */
  	constructor( positionNode, rotationNode ) {

  		super();

  		/**
  		 * The position node.
  		 *
  		 * @type {Node}
  		 */
  		this.positionNode = positionNode;

  		/**
  		 *  Represents the rotation that is applied to the position node.
  		 *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
  		 *
  		 * @type {Node}
  		 */
  		this.rotationNode = rotationNode;

  	}

  	/**
  	 * The type of the {@link RotateNode#positionNode} defines the node's type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node's type.
  	 */
  	getNodeType( builder ) {

  		return this.positionNode.getNodeType( builder );

  	}

  	setup( builder ) {

  		const { rotationNode, positionNode } = this;

  		const nodeType = this.getNodeType( builder );

  		if ( nodeType === 'vec2' ) {

  			const cosAngle = rotationNode.cos();
  			const sinAngle = rotationNode.sin();

  			const rotationMatrix = mat2(
  				cosAngle, sinAngle,
  				sinAngle.negate(), cosAngle
  			);

  			return rotationMatrix.mul( positionNode );

  		} else {

  			const rotation = rotationNode;
  			const rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
  			const rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
  			const rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );

  			return rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;

  		}

  	}

  }

  /**
   * TSL function for creating a rotate node.
   *
   * @tsl
   * @function
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   * @returns {RotateNode}
   */
  const rotate = /*@__PURE__*/ nodeProxy( RotateNode ).setParameterLength( 2 );

  const _defaultValues$2 = /*@__PURE__*/ new SpriteMaterial();

  /**
   * Node material version of {@link SpriteMaterial}.
   *
   * @augments NodeMaterial
   */
  class SpriteNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'SpriteNodeMaterial';

  	}

  	/**
  	 * Constructs a new sprite node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSpriteNodeMaterial = true;

  		this._useSizeAttenuation = true;

  		/**
  		 * This property makes it possible to define the position of the sprite with a
  		 * node. That can be useful when the material is used with instanced rendering
  		 * and node data are defined with an instanced attribute node:
  		 * ```js
  		 * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );
  		 * material.positionNode = instancedBufferAttribute( positionAttribute );
  		 * ```
  		 * Another possibility is to compute the instanced data with a compute shader:
  		 * ```js
  		 * const positionBuffer = instancedArray( particleCount, 'vec3' );
  		 * particleMaterial.positionNode = positionBuffer.toAttribute();
  		 * ```
  		 *
  		 * @type {?Node<vec2>}
  		 * @default null
  		 */
  		this.positionNode = null;

  		/**
  		 * The rotation of sprite materials is by default inferred from the `rotation`,
  		 * property. This node property allows to overwrite the default and define
  		 * the rotation with a node instead.
  		 *
  		 * If you don't want to overwrite the rotation but modify the existing
  		 * value instead, use {@link materialRotation}.
  		 *
  		 * @type {?Node<float>}
  		 * @default null
  		 */
  		this.rotationNode = null;

  		/**
  		 * This node property provides an additional way to scale sprites next to
  		 * `Object3D.scale`. The scale transformation based in `Object3D.scale`
  		 * is multiplied with the scale value of this node in the vertex shader.
  		 *
  		 * @type {?Node<vec2>}
  		 * @default null
  		 */
  		this.scaleNode = null;

  		/**
  		 * In Sprites, the transparent property is enabled by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.transparent = true;

  		this.setDefaultValues( _defaultValues$2 );

  		this.setValues( parameters );

  	}

  	/**
  	 * Setups the position node in view space. This method implements
  	 * the sprite specific vertex shader.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node<vec3>} The position in view space.
  	 */
  	setupPositionView( builder ) {

  		const { object, camera } = builder;

  		const sizeAttenuation = this.sizeAttenuation;

  		const { positionNode, rotationNode, scaleNode } = this;

  		const mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );

  		let scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );

  		if ( scaleNode !== null ) {

  			scale = scale.mul( vec2( scaleNode ) );

  		}

  		if ( sizeAttenuation === false ) {

  			if ( camera.isPerspectiveCamera ) {

  				scale = scale.mul( mvPosition.z.negate() );

  			} else {

  				const orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );
  				scale = scale.mul( orthoScale.mul( 2 ) );

  			}

  		}

  		let alignedPosition = positionGeometry.xy;

  		if ( object.center && object.center.isVector2 === true ) {

  			const center = reference$1( 'center', 'vec2', object );

  			alignedPosition = alignedPosition.sub( center.sub( 0.5 ) );

  		}

  		alignedPosition = alignedPosition.mul( scale );

  		const rotation = float( rotationNode || materialRotation );

  		const rotatedPosition = rotate( alignedPosition, rotation );

  		return vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );

  	}

  	copy( source ) {

  		this.positionNode = source.positionNode;
  		this.rotationNode = source.rotationNode;
  		this.scaleNode = source.scaleNode;

  		return super.copy( source );

  	}

  	/**
  	 * Whether to use size attenuation or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get sizeAttenuation() {

  		return this._useSizeAttenuation;

  	}

  	set sizeAttenuation( value ) {

  		if ( this._useSizeAttenuation !== value ) {

  			this._useSizeAttenuation = value;
  			this.needsUpdate = true;

  		}

  	}

  }

  const _defaultValues$1 = /*@__PURE__*/ new PointsMaterial();

  /**
   * Node material version of {@link PointsMaterial}.
   *
   * @augments SpriteNodeMaterial
   */
  class PointsNodeMaterial extends SpriteNodeMaterial {

  	static get type() {

  		return 'PointsNodeMaterial';

  	}

  	/**
  	 * Constructs a new points node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This node property provides an additional way to set the point size.
  		 *
  		 * @type {?Node<vec2>}
  		 * @default null
  		 */
  		this.sizeNode = null;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointsNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$1 );

  		this.setValues( parameters );

  	}

  	setupPositionView() {

  		const { positionNode } = this;

  		return modelViewMatrix.mul( vec3( positionNode || positionLocal ) ).xyz;

  	}

  	setupVertex( builder ) {

  		const mvp = super.setupVertex( builder );

  		// skip further processing if the material is not a node material

  		if ( builder.material.isNodeMaterial !== true ) {

  			return mvp;

  		}

  		// ndc space

  		const { rotationNode, scaleNode, sizeNode } = this;

  		const alignedPosition = positionGeometry.xy.toVar();
  		const aspect = viewport.z.div( viewport.w );

  		// rotation

  		if ( rotationNode && rotationNode.isNode ) {

  			const rotation = float( rotationNode );

  			alignedPosition.assign( rotate( alignedPosition, rotation ) );

  		}

  		// point size

  		let pointSize = sizeNode !== null ? vec2( sizeNode ) : materialPointSize;

  		if ( this.sizeAttenuation === true ) {

  			pointSize = pointSize.mul( pointSize.div( positionView.z.negate() ) );

  		}

  		// scale

  		if ( scaleNode && scaleNode.isNode ) {

  			pointSize = pointSize.mul( vec2( scaleNode ) );

  		}

  		alignedPosition.mulAssign( pointSize.mul( 2 ) );

  		alignedPosition.assign( alignedPosition.div( viewport.z ) );
  		alignedPosition.y.assign( alignedPosition.y.mul( aspect ) );

  		// back to clip space
  		alignedPosition.assign( alignedPosition.mul( mvp.w ) );

  		//clipPos.xy += offset;
  		mvp.addAssign( vec4( alignedPosition, 0, 0 ) );

  		return mvp;

  	}

  	/**
  	 * Whether alpha to coverage should be used or not.
  	 *
  	 * @type {boolean}
  	 * @default true
  	 */
  	get alphaToCoverage() {

  		return this._useAlphaToCoverage;

  	}

  	set alphaToCoverage( value ) {

  		if ( this._useAlphaToCoverage !== value ) {

  			this._useAlphaToCoverage = value;
  			this.needsUpdate = true;

  		}

  	}

  }

  /**
   * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.
   *
   * @augments LightingModel
   */
  class ShadowMaskModel extends LightingModel {

  	/**
  	 * Constructs a new shadow mask model.
  	 */
  	constructor() {

  		super();

  		/**
  		 * The shadow mask node.
  		 *
  		 * @type {Node}
  		 */
  		this.shadowNode = float( 1 ).toVar( 'shadowMask' );

  	}

  	/**
  	 * Only used to save the shadow mask.
  	 *
  	 * @param {Object} input - The input data.
  	 */
  	direct( { lightNode } ) {

  		if ( lightNode.shadowNode !== null ) {

  			this.shadowNode.mulAssign( lightNode.shadowNode );

  		}

  	}

  	/**
  	 * Uses the shadow mask to produce the final color.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	finish( { context } ) {

  		diffuseColor.a.mulAssign( this.shadowNode.oneMinus() );

  		context.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment

  	}

  }

  const _defaultValues = /*@__PURE__*/ new ShadowMaterial();

  /**
   * Node material version of {@link ShadowMaterial}.
   *
   * @augments NodeMaterial
   */
  class ShadowNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'ShadowNodeMaterial';

  	}

  	/**
  	 * Constructs a new shadow node material.
  	 *
  	 * @param {Object} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isShadowNodeMaterial = true;

  		/**
  		 * Set to `true` because so it's possible to implement
  		 * the shadow mask effect.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.lights = true;

  		/**
  		 * Overwritten since shadow materials are transparent
  		 * by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.transparent = true;

  		this.setDefaultValues( _defaultValues );

  		this.setValues( parameters );

  	}

  	/**
  	 * Setups the lighting model.
  	 *
  	 * @return {ShadowMaskModel} The lighting model.
  	 */
  	setupLightingModel( /*builder*/ ) {

  		return new ShadowMaskModel();

  	}

  }

  property( 'vec3' );
  property( 'vec3' );
  property( 'vec3' );

  /**
   * This module manages the internal animation loop of the renderer.
   *
   * @private
   */
  class Animation {

  	/**
  	 * Constructs a new animation loop management component.
  	 *
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 * @param {Info} info - Renderer component for managing metrics and monitoring data.
  	 */
  	constructor( nodes, info ) {

  		/**
  		 * Renderer component for managing nodes related logic.
  		 *
  		 * @type {Nodes}
  		 */
  		this.nodes = nodes;

  		/**
  		 * Renderer component for managing metrics and monitoring data.
  		 *
  		 * @type {Info}
  		 */
  		this.info = info;

  		/**
  		 * A reference to the context from `requestAnimationFrame()` can
  		 * be called (usually `window`).
  		 *
  		 * @type {?(Window|XRSession)}
  		 */
  		this._context = typeof self !== 'undefined' ? self : null;

  		/**
  		 * The user-defined animation loop.
  		 *
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._animationLoop = null;

  		/**
  		 * The requestId which is returned from the `requestAnimationFrame()` call.
  		 * Can be used to cancel the stop the animation loop.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this._requestId = null;

  	}

  	/**
  	 * Starts the internal animation loop.
  	 */
  	start() {

  		const update = ( time, xrFrame ) => {

  			this._requestId = this._context.requestAnimationFrame( update );

  			if ( this.info.autoReset === true ) this.info.reset();

  			this.nodes.nodeFrame.update();

  			this.info.frame = this.nodes.nodeFrame.frameId;

  			if ( this._animationLoop !== null ) this._animationLoop( time, xrFrame );

  		};

  		update();

  	}

  	/**
  	 * Stops the internal animation loop.
  	 */
  	stop() {

  		this._context.cancelAnimationFrame( this._requestId );

  		this._requestId = null;

  	}

  	/**
  	 * Returns the user-level animation loop.
  	 *
  	 * @return {?Function} The animation loop.
  	 */
  	getAnimationLoop() {

  		return this._animationLoop;

  	}

  	/**
  	 * Defines the user-level animation loop.
  	 *
  	 * @param {?Function} callback - The animation loop.
  	 */
  	setAnimationLoop( callback ) {

  		this._animationLoop = callback;

  	}

  	/**
  	 * Returns the animation context.
  	 *
  	 * @return {Window|XRSession} The animation context.
  	 */
  	getContext() {

  		return this._context;

  	}

  	/**
  	 * Defines the context in which `requestAnimationFrame()` is executed.
  	 *
  	 * @param {Window|XRSession} context - The context to set.
  	 */
  	setContext( context ) {

  		this._context = context;

  	}

  	/**
  	 * Frees all internal resources and stops the animation loop.
  	 */
  	dispose() {

  		this.stop();

  	}

  }

  /**
   * Data structure for the renderer. It allows defining values
   * with chained, hierarchical keys. Keys are meant to be
   * objects since the module internally works with Weak Maps
   * for performance reasons.
   *
   * @private
   */
  class ChainMap {

  	/**
  	 * Constructs a new Chain Map.
  	 */
  	constructor() {

  		/**
  		 * The root Weak Map.
  		 *
  		 * @type {WeakMap}
  		 */
  		this.weakMap = new WeakMap();

  	}

  	/**
  	 * Returns the value for the given array of keys.
  	 *
  	 * @param {Array<Object>} keys - List of keys.
  	 * @return {any} The value. Returns `undefined` if no value was found.
  	 */
  	get( keys ) {

  		let map = this.weakMap;

  		for ( let i = 0; i < keys.length - 1; i ++ ) {

  			map = map.get( keys[ i ] );

  			if ( map === undefined ) return undefined;

  		}

  		return map.get( keys[ keys.length - 1 ] );

  	}

  	/**
  	 * Sets the value for the given keys.
  	 *
  	 * @param {Array<Object>} keys - List of keys.
  	 * @param {any} value - The value to set.
  	 * @return {ChainMap} A reference to this Chain Map.
  	 */
  	set( keys, value ) {

  		let map = this.weakMap;

  		for ( let i = 0; i < keys.length - 1; i ++ ) {

  			const key = keys[ i ];

  			if ( map.has( key ) === false ) map.set( key, new WeakMap() );

  			map = map.get( key );

  		}

  		map.set( keys[ keys.length - 1 ], value );

  		return this;

  	}

  	/**
  	 * Deletes a value for the given keys.
  	 *
  	 * @param {Array<Object>} keys - The keys.
  	 * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
  	 */
  	delete( keys ) {

  		let map = this.weakMap;

  		for ( let i = 0; i < keys.length - 1; i ++ ) {

  			map = map.get( keys[ i ] );

  			if ( map === undefined ) return false;

  		}

  		return map.delete( keys[ keys.length - 1 ] );

  	}

  }

  let _id$9 = 0;

  function getKeys( obj ) {

  	const keys = Object.keys( obj );

  	let proto = Object.getPrototypeOf( obj );

  	while ( proto ) {

  		const descriptors = Object.getOwnPropertyDescriptors( proto );

  		for ( const key in descriptors ) {

  			if ( descriptors[ key ] !== undefined ) {

  				const descriptor = descriptors[ key ];

  				if ( descriptor && typeof descriptor.get === 'function' ) {

  					keys.push( key );

  				}

  			}

  		}

  		proto = Object.getPrototypeOf( proto );

  	}

  	return keys;

  }

  /**
   * A render object is the renderer's representation of single entity that gets drawn
   * with a draw command. There is no unique mapping of render objects to 3D objects in the
   * scene since render objects also depend from the used material, the current render context
   * and the current scene's lighting.
   *
   * In general, the basic process of the renderer is:
   *
   * - Analyze the 3D objects in the scene and generate render lists containing render items.
   * - Process the render lists by calling one or more render commands for each render item.
   * - For each render command, request a render object and perform the draw.
   *
   * The module provides an interface to get data required for the draw command like the actual
   * draw parameters or vertex buffers. It also holds a series of caching related methods since
   * creating render objects should only be done when necessary.
   *
   * @private
   */
  class RenderObject {

  	/**
  	 * Constructs a new render object.
  	 *
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 * @param {Geometries} geometries - Renderer component for managing geometries.
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the object should be rendered with.
  	 * @param {LightsNode} lightsNode - The lights node.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {ClippingContext} clippingContext - The clipping context.
  	 */
  	constructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {

  		this.id = _id$9 ++;

  		/**
  		 * Renderer component for managing nodes related logic.
  		 *
  		 * @type {Nodes}
  		 * @private
  		 */
  		this._nodes = nodes;

  		/**
  		 * Renderer component for managing geometries.
  		 *
  		 * @type {Geometries}
  		 * @private
  		 */
  		this._geometries = geometries;

  		/**
  		 * The renderer.
  		 *
  		 * @type {Renderer}
  		 */
  		this.renderer = renderer;

  		/**
  		 * The 3D object.
  		 *
  		 * @type {Object3D}
  		 */
  		this.object = object;

  		/**
  		 * The 3D object's material.
  		 *
  		 * @type {Material}
  		 */
  		this.material = material;

  		/**
  		 * The scene the 3D object belongs to.
  		 *
  		 * @type {Scene}
  		 */
  		this.scene = scene;

  		/**
  		 * The camera the 3D object should be rendered with.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * The lights node.
  		 *
  		 * @type {LightsNode}
  		 */
  		this.lightsNode = lightsNode;

  		/**
  		 * The render context.
  		 *
  		 * @type {RenderContext}
  		 */
  		this.context = renderContext;

  		/**
  		 * The 3D object's geometry.
  		 *
  		 * @type {BufferGeometry}
  		 */
  		this.geometry = object.geometry;

  		/**
  		 * The render object's version.
  		 *
  		 * @type {number}
  		 */
  		this.version = material.version;

  		/**
  		 * The draw range of the geometry.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.drawRange = null;

  		/**
  		 * An array holding the buffer attributes
  		 * of the render object. This entails attribute
  		 * definitions on geometry and node level.
  		 *
  		 * @type {?Array<BufferAttribute>}
  		 * @default null
  		 */
  		this.attributes = null;

  		/**
  		 * An object holding the version of the
  		 * attributes. The keys are the attribute names
  		 * and the values are the attribute versions.
  		 *
  		 * @type {?Object<string, number>}
  		 * @default null
  		 */
  		this.attributesId = null;

  		/**
  		 * A reference to a render pipeline the render
  		 * object is processed with.
  		 *
  		 * @type {RenderPipeline}
  		 * @default null
  		 */
  		this.pipeline = null;

  		/**
  		 * Only relevant for objects using
  		 * multiple materials. This represents a group entry
  		 * from the respective `BufferGeometry`.
  		 *
  		 * @type {?{start: number, count: number}}
  		 * @default null
  		 */
  		this.group = null;

  		/**
  		 * An array holding the vertex buffers which can
  		 * be buffer attributes but also interleaved buffers.
  		 *
  		 * @type {?Array<BufferAttribute|InterleavedBuffer>}
  		 * @default null
  		 */
  		this.vertexBuffers = null;

  		/**
  		 * The parameters for the draw command.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.drawParams = null;

  		/**
  		 * If this render object is used inside a render bundle,
  		 * this property points to the respective bundle group.
  		 *
  		 * @type {?BundleGroup}
  		 * @default null
  		 */
  		this.bundle = null;

  		/**
  		 * The clipping context.
  		 *
  		 * @type {ClippingContext}
  		 */
  		this.clippingContext = clippingContext;

  		/**
  		 * The clipping context's cache key.
  		 *
  		 * @type {string}
  		 */
  		this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';

  		/**
  		 * The initial node cache key.
  		 *
  		 * @type {number}
  		 */
  		this.initialNodesCacheKey = this.getDynamicCacheKey();

  		/**
  		 * The initial cache key.
  		 *
  		 * @type {number}
  		 */
  		this.initialCacheKey = this.getCacheKey();

  		/**
  		 * The node builder state.
  		 *
  		 * @type {?NodeBuilderState}
  		 * @private
  		 * @default null
  		 */
  		this._nodeBuilderState = null;

  		/**
  		 * An array of bindings.
  		 *
  		 * @type {?Array<BindGroup>}
  		 * @private
  		 * @default null
  		 */
  		this._bindings = null;

  		/**
  		 * Reference to the node material observer.
  		 *
  		 * @type {?NodeMaterialObserver}
  		 * @private
  		 * @default null
  		 */
  		this._monitor = null;

  		/**
  		 * An event listener which is defined by `RenderObjects`. It performs
  		 * clean up tasks when `dispose()` on this render object.
  		 *
  		 * @method
  		 */
  		this.onDispose = null;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRenderObject = true;

  		/**
  		 * An event listener which is executed when `dispose()` is called on
  		 * the material of this render object.
  		 *
  		 * @method
  		 */
  		this.onMaterialDispose = () => {

  			this.dispose();

  		};

  		/**
  		 * An event listener which is executed when `dispose()` is called on
  		 * the geometry of this render object.
  		 *
  		 * @method
  		 */
  		this.onGeometryDispose = () => {

  			// clear geometry cache attributes

  			this.attributes = null;
  			this.attributesId = null;

  		};

  		this.material.addEventListener( 'dispose', this.onMaterialDispose );
  		this.geometry.addEventListener( 'dispose', this.onGeometryDispose );

  	}

  	/**
  	 * Updates the clipping context.
  	 *
  	 * @param {ClippingContext} context - The clipping context to set.
  	 */
  	updateClipping( context ) {

  		this.clippingContext = context;

  	}

  	/**
  	 * Whether the clipping requires an update or not.
  	 *
  	 * @type {boolean}
  	 * @readonly
  	 */
  	get clippingNeedsUpdate() {

  		if ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;

  		this.clippingContextCacheKey = this.clippingContext.cacheKey;

  		return true;

  	}

  	/**
  	 * The number of clipping planes defined in context of hardware clipping.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get hardwareClippingPlanes() {

  		return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;

  	}

  	/**
  	 * Returns the node builder state of this render object.
  	 *
  	 * @return {NodeBuilderState} The node builder state.
  	 */
  	getNodeBuilderState() {

  		return this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );

  	}

  	/**
  	 * Returns the node material observer of this render object.
  	 *
  	 * @return {NodeMaterialObserver} The node material observer.
  	 */
  	getMonitor() {

  		return this._monitor || ( this._monitor = this.getNodeBuilderState().observer );

  	}

  	/**
  	 * Returns an array of bind groups of this render object.
  	 *
  	 * @return {Array<BindGroup>} The bindings.
  	 */
  	getBindings() {

  		return this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );

  	}

  	/**
  	 * Returns a binding group by group name of this render object.
  	 *
  	 * @param {string} name - The name of the binding group.
  	 * @return {?BindGroup} The bindings.
  	 */
  	getBindingGroup( name ) {

  		for ( const bindingGroup of this.getBindings() ) {

  			if ( bindingGroup.name === name ) {

  				return bindingGroup;

  			}

  		}

  	}

  	/**
  	 * Returns the index of the render object's geometry.
  	 *
  	 * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
  	 */
  	getIndex() {

  		return this._geometries.getIndex( this );

  	}

  	/**
  	 * Returns the indirect buffer attribute.
  	 *
  	 * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
  	 */
  	getIndirect() {

  		return this._geometries.getIndirect( this );

  	}

  	/**
  	 * Returns an array that acts as a key for identifying the render object in a chain map.
  	 *
  	 * @return {Array<Object>} An array with object references.
  	 */
  	getChainArray() {

  		return [ this.object, this.material, this.context, this.lightsNode ];

  	}

  	/**
  	 * This method is used when the geometry of a 3D object has been exchanged and the
  	 * respective render object now requires an update.
  	 *
  	 * @param {BufferGeometry} geometry - The geometry to set.
  	 */
  	setGeometry( geometry ) {

  		this.geometry = geometry;
  		this.attributes = null;
  		this.attributesId = null;

  	}

  	/**
  	 * Returns the buffer attributes of the render object. The returned array holds
  	 * attribute definitions on geometry and node level.
  	 *
  	 * @return {Array<BufferAttribute>} An array with buffer attributes.
  	 */
  	getAttributes() {

  		if ( this.attributes !== null ) return this.attributes;

  		const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
  		const geometry = this.geometry;

  		const attributes = [];
  		const vertexBuffers = new Set();

  		const attributesId = {};

  		for ( const nodeAttribute of nodeAttributes ) {

  			let attribute;

  			if ( nodeAttribute.node && nodeAttribute.node.attribute ) {

  				// node attribute
  				attribute = nodeAttribute.node.attribute;

  			} else {

  				// geometry attribute
  				attribute = geometry.getAttribute( nodeAttribute.name );

  				attributesId[ nodeAttribute.name ] = attribute.version;

  			}

  			if ( attribute === undefined ) continue;

  			attributes.push( attribute );

  			const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  			vertexBuffers.add( bufferAttribute );

  		}

  		this.attributes = attributes;
  		this.attributesId = attributesId;
  		this.vertexBuffers = Array.from( vertexBuffers.values() );

  		return attributes;

  	}

  	/**
  	 * Returns the vertex buffers of the render object.
  	 *
  	 * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
  	 */
  	getVertexBuffers() {

  		if ( this.vertexBuffers === null ) this.getAttributes();

  		return this.vertexBuffers;

  	}

  	/**
  	 * Returns the draw parameters for the render object.
  	 *
  	 * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
  	 */
  	getDrawParameters() {

  		const { object, material, geometry, group, drawRange } = this;

  		const drawParams = this.drawParams || ( this.drawParams = {
  			vertexCount: 0,
  			firstVertex: 0,
  			instanceCount: 0,
  			firstInstance: 0
  		} );

  		const index = this.getIndex();
  		const hasIndex = ( index !== null );

  		let instanceCount = 1;

  		if ( geometry.isInstancedBufferGeometry === true ) {

  			instanceCount = geometry.instanceCount;

  		} else if ( object.count !== undefined ) {

  			instanceCount = Math.max( 0, object.count );

  		}

  		if ( instanceCount === 0 ) return null;

  		drawParams.instanceCount = instanceCount;

  		if ( object.isBatchedMesh === true ) return drawParams;

  		let rangeFactor = 1;

  		if ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {

  			rangeFactor = 2;

  		}

  		let firstVertex = drawRange.start * rangeFactor;
  		let lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;

  		if ( group !== null ) {

  			firstVertex = Math.max( firstVertex, group.start * rangeFactor );
  			lastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );

  		}

  		const position = geometry.attributes.position;
  		let itemCount = Infinity;

  		if ( hasIndex ) {

  			itemCount = index.count;

  		} else if ( position !== undefined && position !== null ) {

  			itemCount = position.count;

  		}

  		firstVertex = Math.max( firstVertex, 0 );
  		lastVertex = Math.min( lastVertex, itemCount );

  		const count = lastVertex - firstVertex;

  		if ( count < 0 || count === Infinity ) return null;

  		drawParams.vertexCount = count;
  		drawParams.firstVertex = firstVertex;

  		return drawParams;

  	}

  	/**
  	 * Returns the render object's geometry cache key.
  	 *
  	 * The geometry cache key is part of the material cache key.
  	 *
  	 * @return {string} The geometry cache key.
  	 */
  	getGeometryCacheKey() {

  		const { geometry } = this;

  		let cacheKey = '';

  		for ( const name of Object.keys( geometry.attributes ).sort() ) {

  			const attribute = geometry.attributes[ name ];

  			cacheKey += name + ',';

  			if ( attribute.data ) cacheKey += attribute.data.stride + ',';
  			if ( attribute.offset ) cacheKey += attribute.offset + ',';
  			if ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';
  			if ( attribute.normalized ) cacheKey += 'n,';

  		}

  		// structural equality isn't sufficient for morph targets since the
  		// data are maintained in textures. only if the targets are all equal
  		// the texture and thus the instance of `MorphNode` can be shared.

  		for ( const name of Object.keys( geometry.morphAttributes ).sort() ) {

  			const targets = geometry.morphAttributes[ name ];

  			cacheKey += 'morph-' + name + ',';

  			for ( let i = 0, l = targets.length; i < l; i ++ ) {

  				const attribute = targets[ i ];

  				cacheKey += attribute.id + ',';

  			}

  		}

  		if ( geometry.index ) {

  			cacheKey += 'index,';

  		}

  		return cacheKey;

  	}

  	/**
  	 * Returns the render object's material cache key.
  	 *
  	 * The material cache key is part of the render object cache key.
  	 *
  	 * @return {number} The material cache key.
  	 */
  	getMaterialCacheKey() {

  		const { object, material } = this;

  		let cacheKey = material.customProgramCacheKey();

  		for ( const property of getKeys( material ) ) {

  			if ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;

  			const value = material[ property ];

  			let valueKey;

  			if ( value !== null ) {

  				// some material values require a formatting

  				const type = typeof value;

  				if ( type === 'number' ) {

  					valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc

  				} else if ( type === 'object' ) {

  					valueKey = '{';

  					if ( value.isTexture ) {

  						valueKey += value.mapping;

  					}

  					valueKey += '}';

  				} else {

  					valueKey = String( value );

  				}

  			} else {

  				valueKey = String( value );

  			}

  			cacheKey += /*property + ':' +*/ valueKey + ',';

  		}

  		cacheKey += this.clippingContextCacheKey + ',';

  		if ( object.geometry ) {

  			cacheKey += this.getGeometryCacheKey();

  		}

  		if ( object.skeleton ) {

  			cacheKey += object.skeleton.bones.length + ',';

  		}

  		if ( object.isBatchedMesh ) {

  			cacheKey += object._matricesTexture.uuid + ',';

  			if ( object._colorsTexture !== null ) {

  				cacheKey += object._colorsTexture.uuid + ',';

  			}

  		}

  		if ( object.count > 1 ) {

  			// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850

  			cacheKey += object.uuid + ',';

  		}

  		cacheKey += object.receiveShadow + ',';

  		return hashString( cacheKey );

  	}

  	/**
  	 * Whether the geometry requires an update or not.
  	 *
  	 * @type {boolean}
  	 * @readonly
  	 */
  	get needsGeometryUpdate() {

  		if ( this.geometry.id !== this.object.geometry.id ) return true;

  		if ( this.attributes !== null ) {

  			const attributesId = this.attributesId;

  			for ( const name in attributesId ) {

  				const attribute = this.geometry.getAttribute( name );

  				if ( attribute === undefined || attributesId[ name ] !== attribute.id ) {

  					return true;

  				}

  			}

  		}

  		return false;

  	}

  	/**
  	 * Whether the render object requires an update or not.
  	 *
  	 * Note: There are two distinct places where render objects are checked for an update.
  	 *
  	 * 1. In `RenderObjects.get()` which is executed when the render object is request. This
  	 * method checks the `needsUpdate` flag and recreates the render object if necessary.
  	 * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
  	 * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
  	 * a need for a refresh due to material, geometry or object related value changes.
  	 *
  	 * TODO: Investigate if it's possible to merge both steps so there is only a single place
  	 * that performs the 'needsUpdate' check.
  	 *
  	 * @type {boolean}
  	 * @readonly
  	 */
  	get needsUpdate() {

  		return /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );

  	}

  	/**
  	 * Returns the dynamic cache key which represents a key that is computed per draw command.
  	 *
  	 * @return {number} The cache key.
  	 */
  	getDynamicCacheKey() {

  		let cacheKey = 0;

  		// `Nodes.getCacheKey()` returns an environment cache key which is not relevant when
  		// the renderer is inside a shadow pass.

  		if ( this.material.isShadowPassMaterial !== true ) {

  			cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );

  		}

  		if ( this.camera.isArrayCamera ) {

  			cacheKey = hash$1( cacheKey, this.camera.cameras.length );

  		}

  		if ( this.object.receiveShadow ) {

  			cacheKey = hash$1( cacheKey, 1 );

  		}

  		return cacheKey;

  	}

  	/**
  	 * Returns the render object's cache key.
  	 *
  	 * @return {number} The cache key.
  	 */
  	getCacheKey() {

  		return this.getMaterialCacheKey() + this.getDynamicCacheKey();

  	}

  	/**
  	 * Frees internal resources.
  	 */
  	dispose() {

  		this.material.removeEventListener( 'dispose', this.onMaterialDispose );
  		this.geometry.removeEventListener( 'dispose', this.onGeometryDispose );

  		this.onDispose();

  	}

  }

  const _chainKeys$5 = [];

  /**
   * This module manages the render objects of the renderer.
   *
   * @private
   */
  class RenderObjects {

  	/**
  	 * Constructs a new render object management component.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 * @param {Geometries} geometries - Renderer component for managing geometries.
  	 * @param {Pipelines} pipelines - Renderer component for managing pipelines.
  	 * @param {Bindings} bindings - Renderer component for managing bindings.
  	 * @param {Info} info - Renderer component for managing metrics and monitoring data.
  	 */
  	constructor( renderer, nodes, geometries, pipelines, bindings, info ) {

  		/**
  		 * The renderer.
  		 *
  		 * @type {Renderer}
  		 */
  		this.renderer = renderer;

  		/**
  		 * Renderer component for managing nodes related logic.
  		 *
  		 * @type {Nodes}
  		 */
  		this.nodes = nodes;

  		/**
  		 * Renderer component for managing geometries.
  		 *
  		 * @type {Geometries}
  		 */
  		this.geometries = geometries;

  		/**
  		 * Renderer component for managing pipelines.
  		 *
  		 * @type {Pipelines}
  		 */
  		this.pipelines = pipelines;

  		/**
  		 * Renderer component for managing bindings.
  		 *
  		 * @type {Bindings}
  		 */
  		this.bindings = bindings;

  		/**
  		 * Renderer component for managing metrics and monitoring data.
  		 *
  		 * @type {Info}
  		 */
  		this.info = info;

  		/**
  		 * A dictionary that manages render contexts in chain maps
  		 * for each pass ID.
  		 *
  		 * @type {Object<string,ChainMap>}
  		 */
  		this.chainMaps = {};

  	}

  	/**
  	 * Returns a render object for the given object and state data.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the 3D object should be rendered with.
  	 * @param {LightsNode} lightsNode - The lights node.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {ClippingContext} clippingContext - The clipping context.
  	 * @param {string} [passId] - An optional ID for identifying the pass.
  	 * @return {RenderObject} The render object.
  	 */
  	get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

  		const chainMap = this.getChainMap( passId );

  		// reuse chainArray
  		_chainKeys$5[ 0 ] = object;
  		_chainKeys$5[ 1 ] = material;
  		_chainKeys$5[ 2 ] = renderContext;
  		_chainKeys$5[ 3 ] = lightsNode;

  		let renderObject = chainMap.get( _chainKeys$5 );

  		if ( renderObject === undefined ) {

  			renderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

  			chainMap.set( _chainKeys$5, renderObject );

  		} else {

  			renderObject.updateClipping( clippingContext );

  			if ( renderObject.needsGeometryUpdate ) {

  				renderObject.setGeometry( object.geometry );

  			}

  			if ( renderObject.version !== material.version || renderObject.needsUpdate ) {

  				if ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {

  					renderObject.dispose();

  					renderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

  				} else {

  					renderObject.version = material.version;

  				}

  			}

  		}

  		_chainKeys$5.length = 0;

  		return renderObject;

  	}

  	/**
  	 * Returns a chain map for the given pass ID.
  	 *
  	 * @param {string} [passId='default'] - The pass ID.
  	 * @return {ChainMap} The chain map.
  	 */
  	getChainMap( passId = 'default' ) {

  		return this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );

  	}

  	/**
  	 * Frees internal resources.
  	 */
  	dispose() {

  		this.chainMaps = {};

  	}

  	/**
  	 * Factory method for creating render objects with the given list of parameters.
  	 *
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 * @param {Geometries} geometries - Renderer component for managing geometries.
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Material} material - The object's material.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the object should be rendered with.
  	 * @param {LightsNode} lightsNode - The lights node.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {ClippingContext} clippingContext - The clipping context.
  	 * @param {string} [passId] - An optional ID for identifying the pass.
  	 * @return {RenderObject} The render object.
  	 */
  	createRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

  		const chainMap = this.getChainMap( passId );

  		const renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );

  		renderObject.onDispose = () => {

  			this.pipelines.delete( renderObject );
  			this.bindings.delete( renderObject );
  			this.nodes.delete( renderObject );

  			chainMap.delete( renderObject.getChainArray() );

  		};

  		return renderObject;

  	}


  }

  /**
   * Data structure for the renderer. It is intended to manage
   * data of objects in dictionaries.
   *
   * @private
   */
  class DataMap {

  	/**
  	 * Constructs a new data map.
  	 */
  	constructor() {

  		/**
  		 * `DataMap` internally uses a weak map
  		 * to manage its data.
  		 *
  		 * @type {WeakMap}
  		 */
  		this.data = new WeakMap();

  	}

  	/**
  	 * Returns the dictionary for the given object.
  	 *
  	 * @param {Object} object - The object.
  	 * @return {Object} The dictionary.
  	 */
  	get( object ) {

  		let map = this.data.get( object );

  		if ( map === undefined ) {

  			map = {};
  			this.data.set( object, map );

  		}

  		return map;

  	}

  	/**
  	 * Deletes the dictionary for the given object.
  	 *
  	 * @param {Object} object - The object.
  	 * @return {?Object} The deleted dictionary.
  	 */
  	delete( object ) {

  		let map = null;

  		if ( this.data.has( object ) ) {

  			map = this.data.get( object );

  			this.data.delete( object );

  		}

  		return map;

  	}

  	/**
  	 * Returns `true` if the given object has a dictionary defined.
  	 *
  	 * @param {Object} object - The object to test.
  	 * @return {boolean} Whether a dictionary is defined or not.
  	 */
  	has( object ) {

  		return this.data.has( object );

  	}

  	/**
  	 * Frees internal resources.
  	 */
  	dispose() {

  		this.data = new WeakMap();

  	}

  }

  const AttributeType = {
  	VERTEX: 1,
  	INDEX: 2,
  	STORAGE: 3,
  	INDIRECT: 4
  };

  // size of a chunk in bytes (STD140 layout)

  const GPU_CHUNK_BYTES = 16;

  // @TODO: Move to src/constants.js

  const BlendColorFactor = 211;
  const OneMinusBlendColorFactor = 212;

  /**
   * This renderer module manages geometry attributes.
   *
   * @private
   * @augments DataMap
   */
  class Attributes extends DataMap {

  	/**
  	 * Constructs a new attribute management component.
  	 *
  	 * @param {Backend} backend - The renderer's backend.
  	 */
  	constructor( backend ) {

  		super();

  		/**
  		 * The renderer's backend.
  		 *
  		 * @type {Backend}
  		 */
  		this.backend = backend;

  	}

  	/**
  	 * Deletes the data for the given attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The attribute.
  	 * @return {Object|null} The deleted attribute data.
  	 */
  	delete( attribute ) {

  		const attributeData = super.delete( attribute );

  		if ( attributeData !== null ) {

  			this.backend.destroyAttribute( attribute );

  		}

  		return attributeData;

  	}

  	/**
  	 * Updates the given attribute. This method creates attribute buffers
  	 * for new attributes and updates data for existing ones.
  	 *
  	 * @param {BufferAttribute} attribute - The attribute to update.
  	 * @param {number} type - The attribute type.
  	 */
  	update( attribute, type ) {

  		const data = this.get( attribute );

  		if ( data.version === undefined ) {

  			if ( type === AttributeType.VERTEX ) {

  				this.backend.createAttribute( attribute );

  			} else if ( type === AttributeType.INDEX ) {

  				this.backend.createIndexAttribute( attribute );

  			} else if ( type === AttributeType.STORAGE ) {

  				this.backend.createStorageAttribute( attribute );

  			} else if ( type === AttributeType.INDIRECT ) {

  				this.backend.createIndirectStorageAttribute( attribute );

  			}

  			data.version = this._getBufferAttribute( attribute ).version;

  		} else {

  			const bufferAttribute = this._getBufferAttribute( attribute );

  			if ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {

  				this.backend.updateAttribute( attribute );

  				data.version = bufferAttribute.version;

  			}

  		}

  	}

  	/**
  	 * Utility method for handling interleaved buffer attributes correctly.
  	 * To process them, their `InterleavedBuffer` is returned.
  	 *
  	 * @param {BufferAttribute} attribute - The attribute.
  	 * @return {BufferAttribute|InterleavedBuffer}
  	 */
  	_getBufferAttribute( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return attribute;

  	}

  }

  /**
   * Returns the wireframe version for the given geometry.
   *
   * @private
   * @function
   * @param {BufferGeometry} geometry - The geometry.
   * @return {number} The version.
   */
  function getWireframeVersion( geometry ) {

  	return ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;

  }

  /**
   * Returns a wireframe index attribute for the given geometry.
   *
   * @private
   * @function
   * @param {BufferGeometry} geometry - The geometry.
   * @return {BufferAttribute} The wireframe index attribute.
   */
  function getWireframeIndex( geometry ) {

  	const indices = [];

  	const geometryIndex = geometry.index;
  	const geometryPosition = geometry.attributes.position;

  	if ( geometryIndex !== null ) {

  		const array = geometryIndex.array;

  		for ( let i = 0, l = array.length; i < l; i += 3 ) {

  			const a = array[ i + 0 ];
  			const b = array[ i + 1 ];
  			const c = array[ i + 2 ];

  			indices.push( a, b, b, c, c, a );

  		}

  	} else {

  		const array = geometryPosition.array;

  		for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  			const a = i + 0;
  			const b = i + 1;
  			const c = i + 2;

  			indices.push( a, b, b, c, c, a );

  		}

  	}

  	const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
  	attribute.version = getWireframeVersion( geometry );

  	return attribute;

  }

  /**
   * This renderer module manages geometries.
   *
   * @private
   * @augments DataMap
   */
  class Geometries extends DataMap {

  	/**
  	 * Constructs a new geometry management component.
  	 *
  	 * @param {Attributes} attributes - Renderer component for managing attributes.
  	 * @param {Info} info - Renderer component for managing metrics and monitoring data.
  	 */
  	constructor( attributes, info ) {

  		super();

  		/**
  		 * Renderer component for managing attributes.
  		 *
  		 * @type {Attributes}
  		 */
  		this.attributes = attributes;

  		/**
  		 * Renderer component for managing metrics and monitoring data.
  		 *
  		 * @type {Info}
  		 */
  		this.info = info;

  		/**
  		 * Weak Map for managing attributes for wireframe rendering.
  		 *
  		 * @type {WeakMap<BufferGeometry,BufferAttribute>}
  		 */
  		this.wireframes = new WeakMap();

  		/**
  		 * This Weak Map is used to make sure buffer attributes are
  		 * updated only once per render call.
  		 *
  		 * @type {WeakMap<BufferAttribute,number>}
  		 */
  		this.attributeCall = new WeakMap();

  	}

  	/**
  	 * Returns `true` if the given render object has an initialized geometry.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether if the given render object has an initialized geometry or not.
  	 */
  	has( renderObject ) {

  		const geometry = renderObject.geometry;

  		return super.has( geometry ) && this.get( geometry ).initialized === true;

  	}

  	/**
  	 * Prepares the geometry of the given render object for rendering.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateForRender( renderObject ) {

  		if ( this.has( renderObject ) === false ) this.initGeometry( renderObject );

  		this.updateAttributes( renderObject );

  	}

  	/**
  	 * Initializes the geometry of the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	initGeometry( renderObject ) {

  		const geometry = renderObject.geometry;
  		const geometryData = this.get( geometry );

  		geometryData.initialized = true;

  		this.info.memory.geometries ++;

  		const onDispose = () => {

  			this.info.memory.geometries --;

  			const index = geometry.index;
  			const geometryAttributes = renderObject.getAttributes();

  			if ( index !== null ) {

  				this.attributes.delete( index );

  			}

  			for ( const geometryAttribute of geometryAttributes ) {

  				this.attributes.delete( geometryAttribute );

  			}

  			const wireframeAttribute = this.wireframes.get( geometry );

  			if ( wireframeAttribute !== undefined ) {

  				this.attributes.delete( wireframeAttribute );

  			}

  			geometry.removeEventListener( 'dispose', onDispose );

  		};

  		geometry.addEventListener( 'dispose', onDispose );

  	}

  	/**
  	 * Updates the geometry attributes of the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateAttributes( renderObject ) {

  		// attributes

  		const attributes = renderObject.getAttributes();

  		for ( const attribute of attributes ) {

  			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

  				this.updateAttribute( attribute, AttributeType.STORAGE );

  			} else {

  				this.updateAttribute( attribute, AttributeType.VERTEX );

  			}

  		}

  		// indexes

  		const index = this.getIndex( renderObject );

  		if ( index !== null ) {

  			this.updateAttribute( index, AttributeType.INDEX );

  		}

  		// indirect

  		const indirect = renderObject.geometry.indirect;

  		if ( indirect !== null ) {

  			this.updateAttribute( indirect, AttributeType.INDIRECT );

  		}

  	}

  	/**
  	 * Updates the given attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The attribute to update.
  	 * @param {number} type - The attribute type.
  	 */
  	updateAttribute( attribute, type ) {

  		const callId = this.info.render.calls;

  		if ( ! attribute.isInterleavedBufferAttribute ) {

  			if ( this.attributeCall.get( attribute ) !== callId ) {

  				this.attributes.update( attribute, type );

  				this.attributeCall.set( attribute, callId );

  			}

  		} else {

  			if ( this.attributeCall.get( attribute ) === undefined ) {

  				this.attributes.update( attribute, type );

  				this.attributeCall.set( attribute, callId );

  			} else if ( this.attributeCall.get( attribute.data ) !== callId ) {

  				this.attributes.update( attribute, type );

  				this.attributeCall.set( attribute.data, callId );

  				this.attributeCall.set( attribute, callId );

  			}

  		}

  	}

  	/**
  	 * Returns the indirect buffer attribute of the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
  	 */
  	getIndirect( renderObject ) {

  		return renderObject.geometry.indirect;

  	}

  	/**
  	 * Returns the index of the given render object's geometry. This is implemented
  	 * in a method to return a wireframe index if necessary.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
  	 */
  	getIndex( renderObject ) {

  		const { geometry, material } = renderObject;

  		let index = geometry.index;

  		if ( material.wireframe === true ) {

  			const wireframes = this.wireframes;

  			let wireframeAttribute = wireframes.get( geometry );

  			if ( wireframeAttribute === undefined ) {

  				wireframeAttribute = getWireframeIndex( geometry );

  				wireframes.set( geometry, wireframeAttribute );

  			} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {

  				this.attributes.delete( wireframeAttribute );

  				wireframeAttribute = getWireframeIndex( geometry );

  				wireframes.set( geometry, wireframeAttribute );

  			}

  			index = wireframeAttribute;

  		}

  		return index;

  	}

  }

  /**
   * This renderer module provides a series of statistical information
   * about the GPU memory and the rendering process. Useful for debugging
   * and monitoring.
   */
  class Info {

  	/**
  	 * Constructs a new info component.
  	 */
  	constructor() {

  		/**
  		 * Whether frame related metrics should automatically
  		 * be resetted or not. This property should be set to `false`
  		 * by apps which manage their own animation loop. They must
  		 * then call `renderer.info.reset()` once per frame manually.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoReset = true;

  		/**
  		 * The current frame ID. This ID is managed
  		 * by `NodeFrame`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.frame = 0;

  		/**
  		 * The number of render calls since the
  		 * app has been started.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.calls = 0;

  		/**
  		 * Render related metrics.
  		 *
  		 * @type {Object}
  		 * @readonly
  		 * @property {number} calls - The number of render calls since the app has been started.
  		 * @property {number} frameCalls - The number of render calls of the current frame.
  		 * @property {number} drawCalls - The number of draw calls of the current frame.
  		 * @property {number} triangles - The number of rendered triangle primitives of the current frame.
  		 * @property {number} points - The number of rendered point primitives of the current frame.
  		 * @property {number} lines - The number of rendered line primitives of the current frame.
  		 * @property {number} timestamp - The timestamp of the frame when using `renderer.renderAsync()`.
  		 */
  		this.render = {
  			calls: 0,
  			frameCalls: 0,
  			drawCalls: 0,
  			triangles: 0,
  			points: 0,
  			lines: 0,
  			timestamp: 0,
  		};

  		/**
  		 * Compute related metrics.
  		 *
  		 * @type {Object}
  		 * @readonly
  		 * @property {number} calls - The number of compute calls since the app has been started.
  		 * @property {number} frameCalls - The number of compute calls of the current frame.
  		 * @property {number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.
  		 */
  		this.compute = {
  			calls: 0,
  			frameCalls: 0,
  			timestamp: 0
  		};

  		/**
  		 * Memory related metrics.
  		 *
  		 * @type {Object}
  		 * @readonly
  		 * @property {number} geometries - The number of active geometries.
  		 * @property {number} frameCalls - The number of active textures.
  		 */
  		this.memory = {
  			geometries: 0,
  			textures: 0
  		};

  	}

  	/**
  	 * This method should be executed per draw call and updates the corresponding metrics.
  	 *
  	 * @param {Object3D} object - The 3D object that is going to be rendered.
  	 * @param {number} count - The vertex or index count.
  	 * @param {number} instanceCount - The instance count.
  	 */
  	update( object, count, instanceCount ) {

  		this.render.drawCalls ++;

  		if ( object.isMesh || object.isSprite ) {

  			this.render.triangles += instanceCount * ( count / 3 );

  		} else if ( object.isPoints ) {

  			this.render.points += instanceCount * count;

  		} else if ( object.isLineSegments ) {

  			this.render.lines += instanceCount * ( count / 2 );

  		} else if ( object.isLine ) {

  			this.render.lines += instanceCount * ( count - 1 );

  		} else {

  			console.error( 'THREE.WebGPUInfo: Unknown object type.' );

  		}

  	}

  	/**
  	 * Resets frame related metrics.
  	 */
  	reset() {

  		this.render.drawCalls = 0;
  		this.render.frameCalls = 0;
  		this.compute.frameCalls = 0;

  		this.render.triangles = 0;
  		this.render.points = 0;
  		this.render.lines = 0;


  	}

  	/**
  	 * Performs a complete reset of the object.
  	 */
  	dispose() {

  		this.reset();

  		this.calls = 0;

  		this.render.calls = 0;
  		this.compute.calls = 0;

  		this.render.timestamp = 0;
  		this.compute.timestamp = 0;
  		this.memory.geometries = 0;
  		this.memory.textures = 0;

  	}

  }

  /**
   * Abstract class for representing pipelines.
   *
   * @private
   * @abstract
   */
  class Pipeline {

  	/**
  	 * Constructs a new pipeline.
  	 *
  	 * @param {string} cacheKey - The pipeline's cache key.
  	 */
  	constructor( cacheKey ) {

  		/**
  		 * The pipeline's cache key.
  		 *
  		 * @type {string}
  		 */
  		this.cacheKey = cacheKey;

  		/**
  		 * How often the pipeline is currently in use.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.usedTimes = 0;

  	}

  }

  /**
   * Class for representing render pipelines.
   *
   * @private
   * @augments Pipeline
   */
  class RenderPipeline extends Pipeline {

  	/**
  	 * Constructs a new render pipeline.
  	 *
  	 * @param {string} cacheKey - The pipeline's cache key.
  	 * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
  	 * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
  	 */
  	constructor( cacheKey, vertexProgram, fragmentProgram ) {

  		super( cacheKey );

  		/**
  		 * The pipeline's vertex shader.
  		 *
  		 * @type {ProgrammableStage}
  		 */
  		this.vertexProgram = vertexProgram;

  		/**
  		 * The pipeline's fragment shader.
  		 *
  		 * @type {ProgrammableStage}
  		 */
  		this.fragmentProgram = fragmentProgram;

  	}

  }

  /**
   * Class for representing compute pipelines.
   *
   * @private
   * @augments Pipeline
   */
  class ComputePipeline extends Pipeline {

  	/**
  	 * Constructs a new render pipeline.
  	 *
  	 * @param {string} cacheKey - The pipeline's cache key.
  	 * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
  	 */
  	constructor( cacheKey, computeProgram ) {

  		super( cacheKey );

  		/**
  		 * The pipeline's compute shader.
  		 *
  		 * @type {ProgrammableStage}
  		 */
  		this.computeProgram = computeProgram;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isComputePipeline = true;

  	}

  }

  let _id$8 = 0;

  /**
   * Class for representing programmable stages which are vertex,
   * fragment or compute shaders. Unlike fixed-function states (like blending),
   * they represent the programmable part of a pipeline.
   *
   * @private
   */
  class ProgrammableStage {

  	/**
  	 * Constructs a new programmable stage.
  	 *
  	 * @param {string} code - The shader code.
  	 * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
  	 * @param {string} name - The name of the shader.
  	 * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
  	 * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
  	 */
  	constructor( code, stage, name, transforms = null, attributes = null ) {

  		/**
  		 * The id of the programmable stage.
  		 *
  		 * @type {number}
  		 */
  		this.id = _id$8 ++;

  		/**
  		 * The shader code.
  		 *
  		 * @type {string}
  		 */
  		this.code = code;

  		/**
  		 * The type of stage.
  		 *
  		 * @type {string}
  		 */
  		this.stage = stage;

  		/**
  		 * The name of the stage.
  		 * This is used for debugging purposes.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
  		 *
  		 * @type {?Array<Object>}
  		 */
  		this.transforms = transforms;

  		/**
  		 * The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
  		 *
  		 * @type {?Array<Object>}
  		 */
  		this.attributes = attributes;

  		/**
  		 * How often the programmable stage is currently in use.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.usedTimes = 0;

  	}

  }

  /**
   * This renderer module manages the pipelines of the renderer.
   *
   * @private
   * @augments DataMap
   */
  class Pipelines extends DataMap {

  	/**
  	 * Constructs a new pipeline management component.
  	 *
  	 * @param {Backend} backend - The renderer's backend.
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 */
  	constructor( backend, nodes ) {

  		super();

  		/**
  		 * The renderer's backend.
  		 *
  		 * @type {Backend}
  		 */
  		this.backend = backend;

  		/**
  		 * Renderer component for managing nodes related logic.
  		 *
  		 * @type {Nodes}
  		 */
  		this.nodes = nodes;

  		/**
  		 * A references to the bindings management component.
  		 * This reference will be set inside the `Bindings`
  		 * constructor.
  		 *
  		 * @type {?Bindings}
  		 * @default null
  		 */
  		this.bindings = null;

  		/**
  		 * Internal cache for maintaining pipelines.
  		 * The key of the map is a cache key, the value the pipeline.
  		 *
  		 * @type {Map<string,Pipeline>}
  		 */
  		this.caches = new Map();

  		/**
  		 * This dictionary maintains for each shader stage type (vertex,
  		 * fragment and compute) the programmable stage objects which
  		 * represent the actual shader code.
  		 *
  		 * @type {Object<string,Map>}
  		 */
  		this.programs = {
  			vertex: new Map(),
  			fragment: new Map(),
  			compute: new Map()
  		};

  	}

  	/**
  	 * Returns a compute pipeline for the given compute node.
  	 *
  	 * @param {Node} computeNode - The compute node.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 * @return {ComputePipeline} The compute pipeline.
  	 */
  	getForCompute( computeNode, bindings ) {

  		const { backend } = this;

  		const data = this.get( computeNode );

  		if ( this._needsComputeUpdate( computeNode ) ) {

  			const previousPipeline = data.pipeline;

  			if ( previousPipeline ) {

  				previousPipeline.usedTimes --;
  				previousPipeline.computeProgram.usedTimes --;

  			}

  			// get shader

  			const nodeBuilderState = this.nodes.getForCompute( computeNode );

  			// programmable stage

  			let stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );

  			if ( stageCompute === undefined ) {

  				if ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );

  				stageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );
  				this.programs.compute.set( nodeBuilderState.computeShader, stageCompute );

  				backend.createProgram( stageCompute );

  			}

  			// determine compute pipeline

  			const cacheKey = this._getComputeCacheKey( computeNode, stageCompute );

  			let pipeline = this.caches.get( cacheKey );

  			if ( pipeline === undefined ) {

  				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

  				pipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );

  			}

  			// keep track of all used times

  			pipeline.usedTimes ++;
  			stageCompute.usedTimes ++;

  			//

  			data.version = computeNode.version;
  			data.pipeline = pipeline;

  		}

  		return data.pipeline;

  	}

  	/**
  	 * Returns a render pipeline for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
  	 * @return {RenderPipeline} The render pipeline.
  	 */
  	getForRender( renderObject, promises = null ) {

  		const { backend } = this;

  		const data = this.get( renderObject );

  		if ( this._needsRenderUpdate( renderObject ) ) {

  			const previousPipeline = data.pipeline;

  			if ( previousPipeline ) {

  				previousPipeline.usedTimes --;
  				previousPipeline.vertexProgram.usedTimes --;
  				previousPipeline.fragmentProgram.usedTimes --;

  			}

  			// get shader

  			const nodeBuilderState = renderObject.getNodeBuilderState();

  			const name = renderObject.material ? renderObject.material.name : '';

  			// programmable stages

  			let stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );

  			if ( stageVertex === undefined ) {

  				if ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );

  				stageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex', name );
  				this.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );

  				backend.createProgram( stageVertex );

  			}

  			let stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );

  			if ( stageFragment === undefined ) {

  				if ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );

  				stageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment', name );
  				this.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );

  				backend.createProgram( stageFragment );

  			}

  			// determine render pipeline

  			const cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

  			let pipeline = this.caches.get( cacheKey );

  			if ( pipeline === undefined ) {

  				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

  				pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );

  			} else {

  				renderObject.pipeline = pipeline;

  			}

  			// keep track of all used times

  			pipeline.usedTimes ++;
  			stageVertex.usedTimes ++;
  			stageFragment.usedTimes ++;

  			//

  			data.pipeline = pipeline;

  		}

  		return data.pipeline;

  	}

  	/**
  	 * Deletes the pipeline for the given render object.
  	 *
  	 * @param {RenderObject} object - The render object.
  	 * @return {?Object} The deleted dictionary.
  	 */
  	delete( object ) {

  		const pipeline = this.get( object ).pipeline;

  		if ( pipeline ) {

  			// pipeline

  			pipeline.usedTimes --;

  			if ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );

  			// programs

  			if ( pipeline.isComputePipeline ) {

  				pipeline.computeProgram.usedTimes --;

  				if ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );

  			} else {

  				pipeline.fragmentProgram.usedTimes --;
  				pipeline.vertexProgram.usedTimes --;

  				if ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );
  				if ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );

  			}

  		}

  		return super.delete( object );

  	}

  	/**
  	 * Frees internal resources.
  	 */
  	dispose() {

  		super.dispose();

  		this.caches = new Map();
  		this.programs = {
  			vertex: new Map(),
  			fragment: new Map(),
  			compute: new Map()
  		};

  	}

  	/**
  	 * Updates the pipeline for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateForRender( renderObject ) {

  		this.getForRender( renderObject );

  	}

  	/**
  	 * Returns a compute pipeline for the given parameters.
  	 *
  	 * @private
  	 * @param {Node} computeNode - The compute node.
  	 * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
  	 * @param {string} cacheKey - The cache key.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 * @return {ComputePipeline} The compute pipeline.
  	 */
  	_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {

  		// check for existing pipeline

  		cacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );

  		let pipeline = this.caches.get( cacheKey );

  		if ( pipeline === undefined ) {

  			pipeline = new ComputePipeline( cacheKey, stageCompute );

  			this.caches.set( cacheKey, pipeline );

  			this.backend.createComputePipeline( pipeline, bindings );

  		}

  		return pipeline;

  	}

  	/**
  	 * Returns a render pipeline for the given parameters.
  	 *
  	 * @private
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
  	 * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
  	 * @param {string} cacheKey - The cache key.
  	 * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
  	 * @return {ComputePipeline} The compute pipeline.
  	 */
  	_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {

  		// check for existing pipeline

  		cacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

  		let pipeline = this.caches.get( cacheKey );

  		if ( pipeline === undefined ) {

  			pipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );

  			this.caches.set( cacheKey, pipeline );

  			renderObject.pipeline = pipeline;

  			// The `promises` array is `null` by default and only set to an empty array when
  			// `Renderer.compileAsync()` is used. The next call actually fills the array with
  			// pending promises that resolve when the render pipelines are ready for rendering.

  			this.backend.createRenderPipeline( renderObject, promises );

  		}

  		return pipeline;

  	}

  	/**
  	 * Computes a cache key representing a compute pipeline.
  	 *
  	 * @private
  	 * @param {Node} computeNode - The compute node.
  	 * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
  	 * @return {string} The cache key.
  	 */
  	_getComputeCacheKey( computeNode, stageCompute ) {

  		return computeNode.id + ',' + stageCompute.id;

  	}

  	/**
  	 * Computes a cache key representing a render pipeline.
  	 *
  	 * @private
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
  	 * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
  	 * @return {string} The cache key.
  	 */
  	_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {

  		return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );

  	}

  	/**
  	 * Releases the given pipeline.
  	 *
  	 * @private
  	 * @param {Pipeline} pipeline - The pipeline to release.
  	 */
  	_releasePipeline( pipeline ) {

  		this.caches.delete( pipeline.cacheKey );

  	}

  	/**
  	 * Releases the shader program.
  	 *
  	 * @private
  	 * @param {Object} program - The shader program to release.
  	 */
  	_releaseProgram( program ) {

  		const code = program.code;
  		const stage = program.stage;

  		this.programs[ stage ].delete( code );

  	}

  	/**
  	 * Returns `true` if the compute pipeline for the given compute node requires an update.
  	 *
  	 * @private
  	 * @param {Node} computeNode - The compute node.
  	 * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
  	 */
  	_needsComputeUpdate( computeNode ) {

  		const data = this.get( computeNode );

  		return data.pipeline === undefined || data.version !== computeNode.version;

  	}

  	/**
  	 * Returns `true` if the render pipeline for the given render object requires an update.
  	 *
  	 * @private
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the render object for the given render object requires an update or not.
  	 */
  	_needsRenderUpdate( renderObject ) {

  		const data = this.get( renderObject );

  		return data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );

  	}

  }

  /**
   * This renderer module manages the bindings of the renderer.
   *
   * @private
   * @augments DataMap
   */
  class Bindings extends DataMap {

  	/**
  	 * Constructs a new bindings management component.
  	 *
  	 * @param {Backend} backend - The renderer's backend.
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 * @param {Textures} textures - Renderer component for managing textures.
  	 * @param {Attributes} attributes - Renderer component for managing attributes.
  	 * @param {Pipelines} pipelines - Renderer component for managing pipelines.
  	 * @param {Info} info - Renderer component for managing metrics and monitoring data.
  	 */
  	constructor( backend, nodes, textures, attributes, pipelines, info ) {

  		super();

  		/**
  		 * The renderer's backend.
  		 *
  		 * @type {Backend}
  		 */
  		this.backend = backend;

  		/**
  		 * Renderer component for managing textures.
  		 *
  		 * @type {Textures}
  		 */
  		this.textures = textures;

  		/**
  		 * Renderer component for managing pipelines.
  		 *
  		 * @type {Pipelines}
  		 */
  		this.pipelines = pipelines;

  		/**
  		 * Renderer component for managing attributes.
  		 *
  		 * @type {Attributes}
  		 */
  		this.attributes = attributes;

  		/**
  		 * Renderer component for managing nodes related logic.
  		 *
  		 * @type {Nodes}
  		 */
  		this.nodes = nodes;

  		/**
  		 * Renderer component for managing metrics and monitoring data.
  		 *
  		 * @type {Info}
  		 */
  		this.info = info;

  		this.pipelines.bindings = this; // assign bindings to pipelines

  	}

  	/**
  	 * Returns the bind groups for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {Array<BindGroup>} The bind groups.
  	 */
  	getForRender( renderObject ) {

  		const bindings = renderObject.getBindings();

  		for ( const bindGroup of bindings ) {

  			const groupData = this.get( bindGroup );

  			if ( groupData.bindGroup === undefined ) {

  				// each object defines an array of bindings (ubos, textures, samplers etc.)

  				this._init( bindGroup );

  				this.backend.createBindings( bindGroup, bindings, 0 );

  				groupData.bindGroup = bindGroup;

  			}

  		}

  		return bindings;

  	}

  	/**
  	 * Returns the bind groups for the given compute node.
  	 *
  	 * @param {Node} computeNode - The compute node.
  	 * @return {Array<BindGroup>} The bind groups.
  	 */
  	getForCompute( computeNode ) {

  		const bindings = this.nodes.getForCompute( computeNode ).bindings;

  		for ( const bindGroup of bindings ) {

  			const groupData = this.get( bindGroup );

  			if ( groupData.bindGroup === undefined ) {

  				this._init( bindGroup );

  				this.backend.createBindings( bindGroup, bindings, 0 );

  				groupData.bindGroup = bindGroup;

  			}

  		}

  		return bindings;

  	}

  	/**
  	 * Updates the bindings for the given compute node.
  	 *
  	 * @param {Node} computeNode - The compute node.
  	 */
  	updateForCompute( computeNode ) {

  		this._updateBindings( this.getForCompute( computeNode ) );

  	}

  	/**
  	 * Updates the bindings for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateForRender( renderObject ) {

  		this._updateBindings( this.getForRender( renderObject ) );

  	}

  	/**
  	 * Updates the given array of bindings.
  	 *
  	 * @param {Array<BindGroup>} bindings - The bind groups.
  	 */
  	_updateBindings( bindings ) {

  		for ( const bindGroup of bindings ) {

  			this._update( bindGroup, bindings );

  		}

  	}

  	/**
  	 * Initializes the given bind group.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group to initialize.
  	 */
  	_init( bindGroup ) {

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isSampledTexture ) {

  				this.textures.updateTexture( binding.texture );

  			} else if ( binding.isStorageBuffer ) {

  				const attribute = binding.attribute;
  				const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;

  				this.attributes.update( attribute, attributeType );

  			}

  		}

  	}

  	/**
  	 * Updates the given bind group.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group to update.
  	 * @param {Array<BindGroup>} bindings - The bind groups.
  	 */
  	_update( bindGroup, bindings ) {

  		const { backend } = this;

  		let needsBindingsUpdate = false;
  		let cacheBindings = true;
  		let cacheIndex = 0;
  		let version = 0;

  		// iterate over all bindings and check if buffer updates or a new binding group is required

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isNodeUniformsGroup ) {

  				const updated = this.nodes.updateGroup( binding );

  				// every uniforms group is a uniform buffer. So if no update is required,
  				// we move one with the next binding. Otherwise the next if block will update the group.

  				if ( updated === false ) continue;

  			}

  			if ( binding.isStorageBuffer ) {

  				const attribute = binding.attribute;
  				const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;

  				this.attributes.update( attribute, attributeType );


  			}

  			if ( binding.isUniformBuffer ) {

  				const updated = binding.update();

  				if ( updated ) {

  					backend.updateBinding( binding );

  				}

  			} else if ( binding.isSampler ) {

  				binding.update();

  			} else if ( binding.isSampledTexture ) {

  				const texturesTextureData = this.textures.get( binding.texture );

  				if ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;

  				const updated = binding.update();

  				const texture = binding.texture;

  				if ( updated ) {

  					this.textures.updateTexture( texture );

  				}

  				const textureData = backend.get( texture );

  				if ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {

  					cacheBindings = false;

  				} else {

  					cacheIndex = cacheIndex * 10 + texture.id;
  					version += texture.version;

  				}

  				if ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {

  					// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
  					console.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );

  					this.textures.updateTexture( texture );
  					needsBindingsUpdate = true;

  				}

  				if ( texture.isStorageTexture === true ) {

  					const textureData = this.get( texture );

  					if ( binding.store === true ) {

  						textureData.needsMipmap = true;

  					} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {

  						this.backend.generateMipmaps( texture );

  						textureData.needsMipmap = false;

  					}

  				}

  			}

  		}

  		if ( needsBindingsUpdate === true ) {

  			this.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );

  		}

  	}

  }

  /**
   * Default sorting function for opaque render items.
   *
   * @private
   * @function
   * @param {Object} a - The first render item.
   * @param {Object} b - The second render item.
   * @return {number} A numeric value which defines the sort order.
   */
  function painterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  /**
   * Default sorting function for transparent render items.
   *
   * @private
   * @function
   * @param {Object} a - The first render item.
   * @param {Object} b - The second render item.
   * @return {number} A numeric value which defines the sort order.
   */
  function reversePainterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  /**
   * Returns `true` if the given transparent material requires a double pass.
   *
   * @private
   * @function
   * @param {Material} material - The transparent material.
   * @return {boolean} Whether the given material requires a double pass or not.
   */
  function needsDoublePass( material ) {

  	const hasTransmission = material.transmission > 0 || material.transmissionNode;

  	return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;

  }

  /**
   * When the renderer analyzes the scene at the beginning of a render call,
   * it stores 3D object for further processing in render lists. Depending on the
   * properties of a 3D objects (like their transformation or material state), the
   * objects are maintained in ordered lists for the actual rendering.
   *
   * Render lists are unique per scene and camera combination.
   *
   * @private
   * @augments Pipeline
   */
  class RenderList {

  	/**
  	 * Constructs a render list.
  	 *
  	 * @param {Lighting} lighting - The lighting management component.
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera the scene is rendered with.
  	 */
  	constructor( lighting, scene, camera ) {

  		/**
  		 * 3D objects are transformed into render items and stored in this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.renderItems = [];

  		/**
  		 * The current render items index.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.renderItemsIndex = 0;

  		/**
  		 * A list with opaque render items.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.opaque = [];

  		/**
  		 * A list with transparent render items which require
  		 * double pass rendering (e.g. transmissive objects).
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.transparentDoublePass = [];

  		/**
  		 * A list with transparent render items.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.transparent = [];

  		/**
  		 * A list with transparent render bundle data.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.bundles = [];

  		/**
  		 * The render list's lights node. This node is later
  		 * relevant for the actual analytical light nodes which
  		 * compute the scene's lighting in the shader.
  		 *
  		 * @type {LightsNode}
  		 */
  		this.lightsNode = lighting.getNode( scene, camera );

  		/**
  		 * The scene's lights stored in an array. This array
  		 * is used to setup the lights node.
  		 *
  		 * @type {Array<Light>}
  		 */
  		this.lightsArray = [];

  		/**
  		 * The scene.
  		 *
  		 * @type {Scene}
  		 */
  		this.scene = scene;

  		/**
  		 * The camera the scene is rendered with.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * How many objects perform occlusion query tests.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.occlusionQueryCount = 0;

  	}

  	/**
  	 * This method is called right at the beginning of a render call
  	 * before the scene is analyzed. It prepares the internal data
  	 * structures for the upcoming render lists generation.
  	 *
  	 * @return {RenderList} A reference to this render list.
  	 */
  	begin() {

  		this.renderItemsIndex = 0;

  		this.opaque.length = 0;
  		this.transparentDoublePass.length = 0;
  		this.transparent.length = 0;
  		this.bundles.length = 0;

  		this.lightsArray.length = 0;

  		this.occlusionQueryCount = 0;

  		return this;

  	}

  	/**
  	 * Returns a render item for the giving render item state. The state is defined
  	 * by a series of object-related parameters.
  	 *
  	 * The method avoids object creation by holding render items and reusing them in
  	 * subsequent render calls (just with different property values).
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {number} groupOrder - The current group order.
  	 * @param {number} z - Th 3D object's depth value (z value in clip space).
  	 * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {ClippingContext} clippingContext - The current clipping context.
  	 * @return {Object} The render item.
  	 */
  	getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {

  		let renderItem = this.renderItems[ this.renderItemsIndex ];

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				groupOrder: groupOrder,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group,
  				clippingContext: clippingContext
  			};

  			this.renderItems[ this.renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.groupOrder = groupOrder;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;
  			renderItem.clippingContext = clippingContext;

  		}

  		this.renderItemsIndex ++;

  		return renderItem;

  	}

  	/**
  	 * Pushes the given object as a render item to the internal render lists.
  	 * The selected lists depend on the object properties.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {number} groupOrder - The current group order.
  	 * @param {number} z - Th 3D object's depth value (z value in clip space).
  	 * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {ClippingContext} clippingContext - The current clipping context.
  	 */
  	push( object, geometry, material, groupOrder, z, group, clippingContext ) {

  		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

  		if ( object.occlusionTest === true ) this.occlusionQueryCount ++;

  		if ( material.transparent === true || material.transmission > 0 ) {

  			if ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );

  			this.transparent.push( renderItem );

  		} else {

  			this.opaque.push( renderItem );

  		}

  	}

  	/**
  	 * Inserts the given object as a render item at the start of the internal render lists.
  	 * The selected lists depend on the object properties.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {number} groupOrder - The current group order.
  	 * @param {number} z - Th 3D object's depth value (z value in clip space).
  	 * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {ClippingContext} clippingContext - The current clipping context.
  	 */
  	unshift( object, geometry, material, groupOrder, z, group, clippingContext ) {

  		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

  		if ( material.transparent === true || material.transmission > 0 ) {

  			if ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );

  			this.transparent.unshift( renderItem );

  		} else {

  			this.opaque.unshift( renderItem );

  		}

  	}

  	/**
  	 * Pushes render bundle group data into the render list.
  	 *
  	 * @param {Object} group - Bundle group data.
  	 */
  	pushBundle( group ) {

  		this.bundles.push( group );

  	}

  	/**
  	 * Pushes a light into the render list.
  	 *
  	 * @param {Light} light - The light.
  	 */
  	pushLight( light ) {

  		this.lightsArray.push( light );

  	}

  	/**
  	 * Sorts the internal render lists.
  	 *
  	 * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
  	 * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
  	 */
  	sort( customOpaqueSort, customTransparentSort ) {

  		if ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );
  		if ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );
  		if ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );

  	}

  	/**
  	 * This method performs finalizing tasks right after the render lists
  	 * have been generated.
  	 */
  	finish() {

  		// update lights

  		this.lightsNode.setLights( this.lightsArray );

  		// Clear references from inactive renderItems in the list

  		for ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {

  			const renderItem = this.renderItems[ i ];

  			if ( renderItem.id === null ) break;

  			renderItem.id = null;
  			renderItem.object = null;
  			renderItem.geometry = null;
  			renderItem.material = null;
  			renderItem.groupOrder = null;
  			renderItem.renderOrder = null;
  			renderItem.z = null;
  			renderItem.group = null;
  			renderItem.clippingContext = null;

  		}

  	}

  }

  const _chainKeys$4 = [];

  /**
   * This renderer module manages the render lists which are unique
   * per scene and camera combination.
   *
   * @private
   */
  class RenderLists {

  	/**
  	 * Constructs a render lists management component.
  	 *
  	 * @param {Lighting} lighting - The lighting management component.
  	 */
  	constructor( lighting ) {

  		/**
  		 * The lighting management component.
  		 *
  		 * @type {Lighting}
  		 */
  		this.lighting = lighting;

  		/**
  		 * The internal chain map which holds the render lists.
  		 *
  		 * @type {ChainMap}
  		 */
  		this.lists = new ChainMap();

  	}

  	/**
  	 * Returns a render list for the given scene and camera.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera.
  	 * @return {RenderList} The render list.
  	 */
  	get( scene, camera ) {

  		const lists = this.lists;

  		_chainKeys$4[ 0 ] = scene;
  		_chainKeys$4[ 1 ] = camera;

  		let list = lists.get( _chainKeys$4 );

  		if ( list === undefined ) {

  			list = new RenderList( this.lighting, scene, camera );
  			lists.set( _chainKeys$4, list );

  		}

  		_chainKeys$4.length = 0;

  		return list;

  	}

  	/**
  	 * Frees all internal resources.
  	 */
  	dispose() {

  		this.lists = new ChainMap();

  	}

  }

  let _id$7 = 0;

  /**
   * Any render or compute command is executed in a specific context that defines
   * the state of the renderer and its backend. Typical examples for such context
   * data are the current clear values or data from the active framebuffer. This
   * module is used to represent these contexts as objects.
   *
   * @private
   */
  class RenderContext {

  	/**
  	 * Constructs a new render context.
  	 */
  	constructor() {

  		/**
  		 * The context's ID.
  		 *
  		 * @type {number}
  		 */
  		this.id = _id$7 ++;

  		/**
  		 * Whether the current active framebuffer has a color attachment.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.color = true;

  		/**
  		 * Whether the color attachment should be cleared or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.clearColor = true;

  		/**
  		 * The clear color value.
  		 *
  		 * @type {Object}
  		 * @default true
  		 */
  		this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };

  		/**
  		 * Whether the current active framebuffer has a depth attachment.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depth = true;

  		/**
  		 * Whether the depth attachment should be cleared or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.clearDepth = true;

  		/**
  		 * The clear depth value.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.clearDepthValue = 1;

  		/**
  		 * Whether the current active framebuffer has a stencil attachment.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.stencil = false;

  		/**
  		 * Whether the stencil attachment should be cleared or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.clearStencil = true;

  		/**
  		 * The clear stencil value.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.clearStencilValue = 1;

  		/**
  		 * By default the viewport encloses the entire framebuffer If a smaller
  		 * viewport is manually defined, this property is to `true` by the renderer.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.viewport = false;

  		/**
  		 * The viewport value. This value is in physical pixels meaning it incorporates
  		 * the renderer's pixel ratio. The viewport property of render targets or
  		 * the renderer is in logical pixels.
  		 *
  		 * @type {Vector4}
  		 */
  		this.viewportValue = new Vector4();

  		/**
  		 * When the scissor test is active and scissor rectangle smaller than the
  		 * framebuffers dimensions, this property is to `true` by the renderer.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.scissor = false;

  		/**
  		 * The scissor rectangle.
  		 *
  		 * @type {Vector4}
  		 */
  		this.scissorValue = new Vector4();

  		/**
  		 * The active render target.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.renderTarget = null;

  		/**
  		 * The textures of the active render target.
  		 * `null` when no render target is set.
  		 *
  		 * @type {?Array<Texture>}
  		 * @default null
  		 */
  		this.textures = null;

  		/**
  		 * The depth texture of the active render target.
  		 * `null` when no render target is set.
  		 *
  		 * @type {?DepthTexture}
  		 * @default null
  		 */
  		this.depthTexture = null;

  		/**
  		 * The active cube face.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.activeCubeFace = 0;

  		/**
  		 * The active mipmap level.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.activeMipmapLevel = 0;

  		/**
  		 * The number of MSAA samples. This value is always `1` when
  		 * MSAA isn't used.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.sampleCount = 1;

  		/**
  		 * The active render target's width in physical pixels.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.width = 0;

  		/**
  		 * The active render target's height in physical pixels.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.height = 0;

  		/**
  		 * The occlusion query count.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.occlusionQueryCount = 0;

  		/**
  		 * The current clipping context.
  		 *
  		 * @type {?ClippingContext}
  		 * @default null
  		 */
  		this.clippingContext = null;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRenderContext = true;

  	}

  	/**
  	 * Returns the cache key of this render context.
  	 *
  	 * @return {number} The cache key.
  	 */
  	getCacheKey() {

  		return getCacheKey( this );

  	}

  }

  /**
   * Computes a cache key for the given render context. This key
   * should identify the render target state so it is possible to
   * configure the correct attachments in the respective backend.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The cache key.
   */
  function getCacheKey( renderContext ) {

  	const { textures, activeCubeFace } = renderContext;

  	const values = [ activeCubeFace ];

  	for ( const texture of textures ) {

  		values.push( texture.id );

  	}

  	return hashArray( values );

  }

  const _chainKeys$3 = [];
  const _defaultScene = /*@__PURE__*/ new Scene();
  const _defaultCamera = /*@__PURE__*/ new Camera();

  /**
   * This module manages the render contexts of the renderer.
   *
   * @private
   */
  class RenderContexts {

  	/**
  	 * Constructs a new render context management component.
  	 */
  	constructor() {

  		/**
  		 * A dictionary that manages render contexts in chain maps
  		 * for each attachment state.
  		 *
  		 * @type {Object<string,ChainMap>}
  		 */
  		this.chainMaps = {};

  	}

  	/**
  	 * Returns a render context for the given scene, camera and render target.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {?RenderTarget} [renderTarget=null] - The active render target.
  	 * @return {RenderContext} The render context.
  	 */
  	get( scene, camera, renderTarget = null ) {

  		_chainKeys$3[ 0 ] = scene;
  		_chainKeys$3[ 1 ] = camera;

  		let attachmentState;

  		if ( renderTarget === null ) {

  			attachmentState = 'default';

  		} else {

  			const format = renderTarget.texture.format;
  			const count = renderTarget.textures.length;

  			attachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;

  		}

  		const chainMap = this._getChainMap( attachmentState );

  		let renderState = chainMap.get( _chainKeys$3 );

  		if ( renderState === undefined ) {

  			renderState = new RenderContext();

  			chainMap.set( _chainKeys$3, renderState );

  		}

  		_chainKeys$3.length = 0;

  		if ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

  		return renderState;

  	}

  	/**
  	 * Returns a render context intended for clear operations.
  	 *
  	 * @param {?RenderTarget} [renderTarget=null] - The active render target.
  	 * @return {RenderContext} The render context.
  	 */
  	getForClear( renderTarget = null ) {

  		return this.get( _defaultScene, _defaultCamera, renderTarget );

  	}

  	/**
  	 * Returns a chain map for the given attachment state.
  	 *
  	 * @private
  	 * @param {string} attachmentState - The attachment state.
  	 * @return {ChainMap} The chain map.
  	 */
  	_getChainMap( attachmentState ) {

  		return this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );

  	}

  	/**
  	 * Frees internal resources.
  	 */
  	dispose() {

  		this.chainMaps = {};

  	}

  }

  const _size$3 = /*@__PURE__*/ new Vector3();

  /**
   * This module manages the textures of the renderer.
   *
   * @private
   * @augments DataMap
   */
  class Textures extends DataMap {

  	/**
  	 * Constructs a new texture management component.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Backend} backend - The renderer's backend.
  	 * @param {Info} info - Renderer component for managing metrics and monitoring data.
  	 */
  	constructor( renderer, backend, info ) {

  		super();

  		/**
  		 * The renderer.
  		 *
  		 * @type {Renderer}
  		 */
  		this.renderer = renderer;

  		/**
  		 * The backend.
  		 *
  		 * @type {Backend}
  		 */
  		this.backend = backend;

  		/**
  		 * Renderer component for managing metrics and monitoring data.
  		 *
  		 * @type {Info}
  		 */
  		this.info = info;

  	}

  	/**
  	 * Updates the given render target. Based on the given render target configuration,
  	 * it updates the texture states representing the attachments of the framebuffer.
  	 *
  	 * @param {RenderTarget} renderTarget - The render target to update.
  	 * @param {number} [activeMipmapLevel=0] - The active mipmap level.
  	 */
  	updateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {

  		const renderTargetData = this.get( renderTarget );

  		const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
  		const depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );

  		const textures = renderTarget.textures;

  		const size = this.getSize( textures[ 0 ] );

  		const mipWidth = size.width >> activeMipmapLevel;
  		const mipHeight = size.height >> activeMipmapLevel;

  		let depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];
  		const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;

  		let textureNeedsUpdate = false;

  		if ( depthTexture === undefined && useDepthTexture ) {

  			depthTexture = new DepthTexture();

  			depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
  			depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType
  			depthTexture.image.width = mipWidth;
  			depthTexture.image.height = mipHeight;
  			depthTexture.image.depth = size.depth;
  			depthTexture.isArrayTexture = renderTarget.multiview === true && size.depth > 1;

  			depthTextureMips[ activeMipmapLevel ] = depthTexture;

  		}

  		if ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {

  			textureNeedsUpdate = true;

  			if ( depthTexture ) {

  				depthTexture.needsUpdate = true;
  				depthTexture.image.width = mipWidth;
  				depthTexture.image.height = mipHeight;
  				depthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;

  			}

  		}

  		renderTargetData.width = size.width;
  		renderTargetData.height = size.height;
  		renderTargetData.textures = textures;
  		renderTargetData.depthTexture = depthTexture || null;
  		renderTargetData.depth = renderTarget.depthBuffer;
  		renderTargetData.stencil = renderTarget.stencilBuffer;
  		renderTargetData.renderTarget = renderTarget;

  		if ( renderTargetData.sampleCount !== sampleCount ) {

  			textureNeedsUpdate = true;

  			if ( depthTexture ) {

  				depthTexture.needsUpdate = true;

  			}

  			renderTargetData.sampleCount = sampleCount;

  		}

  		//


  		const options = { sampleCount };

  		// XR render targets require no texture updates

  		if ( renderTarget.isXRRenderTarget !== true ) {

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				if ( textureNeedsUpdate ) texture.needsUpdate = true;

  				this.updateTexture( texture, options );

  			}

  			if ( depthTexture ) {

  				this.updateTexture( depthTexture, options );

  			}

  		}

  		// dispose handler

  		if ( renderTargetData.initialized !== true ) {

  			renderTargetData.initialized = true;

  			// dispose

  			const onDispose = () => {

  				renderTarget.removeEventListener( 'dispose', onDispose );

  				for ( let i = 0; i < textures.length; i ++ ) {

  					this._destroyTexture( textures[ i ] );

  				}

  				if ( depthTexture ) {

  					this._destroyTexture( depthTexture );

  				}

  				this.delete( renderTarget );

  			};

  			renderTarget.addEventListener( 'dispose', onDispose );

  		}

  	}

  	/**
  	 * Updates the given texture. Depending on the texture state, this method
  	 * triggers the upload of texture data to the GPU memory. If the texture data are
  	 * not yet ready for the upload, it uses default texture data for as a placeholder.
  	 *
  	 * @param {Texture} texture - The texture to update.
  	 * @param {Object} [options={}] - The options.
  	 */
  	updateTexture( texture, options = {} ) {

  		const textureData = this.get( texture );
  		if ( textureData.initialized === true && textureData.version === texture.version ) return;

  		const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
  		const backend = this.backend;

  		if ( isRenderTarget && textureData.initialized === true ) {

  			// it's an update

  			backend.destroySampler( texture );
  			backend.destroyTexture( texture );

  		}

  		//

  		if ( texture.isFramebufferTexture ) {

  			const renderTarget = this.renderer.getRenderTarget();

  			if ( renderTarget ) {

  				texture.type = renderTarget.texture.type;

  			} else {

  				texture.type = UnsignedByteType;

  			}

  		}

  		//

  		const { width, height, depth } = this.getSize( texture );

  		options.width = width;
  		options.height = height;
  		options.depth = depth;
  		options.needsMipmaps = this.needsMipmaps( texture );
  		options.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;

  		//

  		if ( isRenderTarget || texture.isStorageTexture === true ) {

  			backend.createSampler( texture );
  			backend.createTexture( texture, options );

  			textureData.generation = texture.version;

  		} else {

  			const needsCreate = textureData.initialized !== true;

  			if ( needsCreate ) backend.createSampler( texture );

  			if ( texture.version > 0 ) {

  				const image = texture.image;

  				if ( image === undefined ) {

  					console.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );

  				} else if ( image.complete === false ) {

  					console.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );

  				} else {

  					if ( texture.images ) {

  						const images = [];

  						for ( const image of texture.images ) {

  							images.push( image );

  						}

  						options.images = images;

  					} else {

  						options.image = image;

  					}

  					if ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {

  						backend.createTexture( texture, options );

  						textureData.isDefaultTexture = false;
  						textureData.generation = texture.version;

  					}

  					if ( texture.source.dataReady === true ) backend.updateTexture( texture, options );

  					if ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );

  				}

  			} else {

  				// async update

  				backend.createDefaultTexture( texture );

  				textureData.isDefaultTexture = true;
  				textureData.generation = texture.version;

  			}

  		}

  		// dispose handler

  		if ( textureData.initialized !== true ) {

  			textureData.initialized = true;
  			textureData.generation = texture.version;

  			//

  			this.info.memory.textures ++;

  			// dispose

  			const onDispose = () => {

  				texture.removeEventListener( 'dispose', onDispose );

  				this._destroyTexture( texture );

  			};

  			texture.addEventListener( 'dispose', onDispose );

  		}

  		//

  		textureData.version = texture.version;

  	}

  	/**
  	 * Computes the size of the given texture and writes the result
  	 * into the target vector. This vector is also returned by the
  	 * method.
  	 *
  	 * If no texture data are available for the compute yet, the method
  	 * returns default size values.
  	 *
  	 * @param {Texture} texture - The texture to compute the size for.
  	 * @param {Vector3} target - The target vector.
  	 * @return {Vector3} The target vector.
  	 */
  	getSize( texture, target = _size$3 ) {

  		let image = texture.images ? texture.images[ 0 ] : texture.image;

  		if ( image ) {

  			if ( image.image !== undefined ) image = image.image;

  			target.width = image.width || 1;
  			target.height = image.height || 1;
  			target.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );

  		} else {

  			target.width = target.height = target.depth = 1;

  		}

  		return target;

  	}

  	/**
  	 * Computes the number of mipmap levels for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {number} width - The texture's width.
  	 * @param {number} height - The texture's height.
  	 * @return {number} The number of mipmap levels.
  	 */
  	getMipLevels( texture, width, height ) {

  		let mipLevelCount;

  		if ( texture.isCompressedTexture ) {

  			if ( texture.mipmaps ) {

  				mipLevelCount = texture.mipmaps.length;

  			} else {

  				mipLevelCount = 1;

  			}

  		} else {

  			mipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;

  		}

  		return mipLevelCount;

  	}

  	/**
  	 * Returns `true` if the given texture requires mipmaps.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {boolean} Whether mipmaps are required or not.
  	 */
  	needsMipmaps( texture ) {

  		return texture.isCompressedTexture === true || texture.generateMipmaps;

  	}

  	/**
  	 * Frees internal resource when the given texture isn't
  	 * required anymore.
  	 *
  	 * @param {Texture} texture - The texture to destroy.
  	 */
  	_destroyTexture( texture ) {

  		if ( this.has( texture ) === true ) {

  			this.backend.destroySampler( texture );
  			this.backend.destroyTexture( texture );

  			this.delete( texture );

  			this.info.memory.textures --;

  		}

  	}

  }

  /**
   * A four-component version of {@link Color} which is internally
   * used by the renderer to represents clear color with alpha as
   * one object.
   *
   * @private
   * @augments Color
   */
  class Color4 extends Color {

  	/**
  	 * Constructs a new four-component color.
  	 * You can also pass a single THREE.Color, hex or
  	 * string argument to this constructor.
  	 *
  	 * @param {number|string} [r=1] - The red value.
  	 * @param {number} [g=1] - The green value.
  	 * @param {number} [b=1] - The blue value.
  	 * @param {number} [a=1] - The alpha value.
  	 */
  	constructor( r, g, b, a = 1 ) {

  		super( r, g, b );

  		this.a = a;

  	}

  	/**
  	 * Overwrites the default to honor alpha.
  	 * You can also pass a single THREE.Color, hex or
  	 * string argument to this method.
  	 *
  	 * @param {number|string|Color} r - The red value.
  	 * @param {number} g - The green value.
  	 * @param {number} b - The blue value.
  	 * @param {number} [a=1] - The alpha value.
  	 * @return {Color4} A reference to this object.
  	 */
  	set( r, g, b, a = 1 ) {

  		this.a = a;

  		return super.set( r, g, b );

  	}

  	/**
  	 * Overwrites the default to honor alpha.
  	 *
  	 * @param {Color4} color - The color to copy.
  	 * @return {Color4} A reference to this object.
  	 */
  	copy( color ) {

  		if ( color.a !== undefined ) this.a = color.a;

  		return super.copy( color );

  	}

  	/**
  	 * Overwrites the default to honor alpha.
  	 *
  	 * @return {Color4} The cloned color.
  	 */
  	clone() {

  		return new this.constructor( this.r, this.g, this.b, this.a );

  	}

  }

  /**
   * Special version of {@link PropertyNode} which is used for parameters.
   *
   * @augments PropertyNode
   */
  class ParameterNode extends PropertyNode {

  	static get type() {

  		return 'ParameterNode';

  	}

  	/**
  	 * Constructs a new parameter node.
  	 *
  	 * @param {string} nodeType - The type of the node.
  	 * @param {?string} [name=null] - The name of the parameter in the shader.
  	 */
  	constructor( nodeType, name = null ) {

  		super( nodeType, name );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isParameterNode = true;

  	}

  	getHash() {

  		return this.uuid;

  	}

  	generate() {

  		return this.name;

  	}

  }

  /**
   * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
   * They are usually needed in cases like `If`, `Else`.
   *
   * @augments Node
   */
  class StackNode extends Node {

  	static get type() {

  		return 'StackNode';

  	}

  	/**
  	 * Constructs a new stack node.
  	 *
  	 * @param {?StackNode} [parent=null] - The parent stack node.
  	 */
  	constructor( parent = null ) {

  		super();

  		/**
  		 * List of nodes.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.nodes = [];

  		/**
  		 * The output node.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.outputNode = null;

  		/**
  		 * The parent stack node.
  		 *
  		 * @type {?StackNode}
  		 * @default null
  		 */
  		this.parent = parent;

  		/**
  		 * The current conditional node.
  		 *
  		 * @private
  		 * @type {ConditionalNode}
  		 * @default null
  		 */
  		this._currentCond = null;

  		/**
  		 * The expression node. Only
  		 * relevant for Switch/Case.
  		 *
  		 * @private
  		 * @type {Node}
  		 * @default null
  		 */
  		this._expressionNode = null;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isStackNode = true;

  	}

  	getNodeType( builder ) {

  		return this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';

  	}

  	getMemberType( builder, name ) {

  		return this.outputNode ? this.outputNode.getMemberType( builder, name ) : 'void';

  	}

  	/**
  	 * Adds a node to this stack.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	add( node ) {

  		this.nodes.push( node );

  		return this;

  	}

  	/**
  	 * Represent an `if` statement in TSL.
  	 *
  	 * @param {Node} boolNode - Represents the condition.
  	 * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	If( boolNode, method ) {

  		const methodNode = new ShaderNode( method );
  		this._currentCond = select$1( boolNode, methodNode );

  		return this.add( this._currentCond );

  	}

  	/**
  	 * Represent an `elseif` statement in TSL.
  	 *
  	 * @param {Node} boolNode - Represents the condition.
  	 * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	ElseIf( boolNode, method ) {

  		const methodNode = new ShaderNode( method );
  		const ifNode = select$1( boolNode, methodNode );

  		this._currentCond.elseNode = ifNode;
  		this._currentCond = ifNode;

  		return this;

  	}

  	/**
  	 * Represent an `else` statement in TSL.
  	 *
  	 * @param {Function} method - TSL code which is executed in the `else` case.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	Else( method ) {

  		this._currentCond.elseNode = new ShaderNode( method );

  		return this;

  	}

  	/**
  	 * Represents a `switch` statement in TSL.
  	 *
  	 * @param {any} expression - Represents the expression.
  	 * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	Switch( expression ) {

  		this._expressionNode = nodeObject( expression );

  		return this;

  	}

  	/**
  	 * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
  	 * The last parameter must be the callback method that should be executed in the `true` case.
  	 *
  	 * @param {...any} params - The values of the `Case()` statement as well as the callback method.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	Case( ...params ) {

  		const caseNodes = [];

  		// extract case nodes from the parameter list

  		if ( params.length >= 2 ) {

  			for ( let i = 0; i < params.length - 1; i ++ ) {

  				caseNodes.push( this._expressionNode.equal( nodeObject( params[ i ] ) ) );

  			}

  		} else {

  			throw new Error( 'TSL: Invalid parameter length. Case() requires at least two parameters.' );

  		}

  		// extract method

  		const method = params[ params.length - 1 ];
  		const methodNode = new ShaderNode( method );

  		// chain multiple cases when using Case( 1, 2, 3, () => {} )

  		let caseNode = caseNodes[ 0 ];

  		for ( let i = 1; i < caseNodes.length; i ++ ) {

  			caseNode = caseNode.or( caseNodes[ i ] );

  		}

  		// build condition

  		const condNode = select$1( caseNode, methodNode );

  		if ( this._currentCond === null ) {

  			this._currentCond = condNode;

  			return this.add( this._currentCond );

  		} else {

  			this._currentCond.elseNode = condNode;
  			this._currentCond = condNode;

  			return this;

  		}

  	}

  	/**
  	 * Represents the default code block of a Switch/Case statement.
  	 *
  	 * @param {Function} method - TSL code which is executed in the `else` case.
  	 * @return {StackNode} A reference to this stack node.
  	 */
  	Default( method ) {

  		this.Else( method );

  		return this;

  	}

  	build( builder, ...params ) {

  		const previousBuildStack = builder.currentStack;
  		const previousStack = getCurrentStack();

  		setCurrentStack( this );

  		builder.currentStack = this;

  		const buildStage = builder.buildStage;

  		for ( const node of this.nodes ) {

  			if ( buildStage === 'setup' ) {

  				node.build( builder );

  			} else if ( buildStage === 'analyze' ) {

  				node.build( builder, this );

  			} else if ( buildStage === 'generate' ) {

  				const stages = builder.getDataFromNode( node, 'any' ).stages;
  				const parents = stages && stages[ builder.shaderStage ];

  				if ( node.isVarNode && parents && parents.length === 1 && parents[ 0 ] && parents[ 0 ].isStackNode ) {

  					continue; // skip var nodes that are only used in .toVarying()

  				}

  				node.build( builder, 'void' );

  			}

  		}

  		const result = this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );

  		setCurrentStack( previousStack );

  		builder.currentStack = previousBuildStack;

  		return result;

  	}

  }

  /**
   * TSL function for creating a stack node.
   *
   * @tsl
   * @function
   * @param {?StackNode} [parent=null] - The parent stack node.
   * @returns {StackNode}
   */
  const stack = /*@__PURE__*/ nodeProxy( StackNode ).setParameterLength( 0, 1 );

  new Plane();
  new Vector3();
  new Vector3();
  new Vector3();
  new Matrix4();
  new Vector3( 0, 0, -1 );
  new Vector4();

  new Vector3();
  new Vector3();
  new Vector4();

  new Vector2();

  const _defaultRT = new RenderTarget();
  screenUV.flipX();

  _defaultRT.depthTexture = new DepthTexture( 1, 1 );

  const _camera$1 = /*@__PURE__*/ new OrthographicCamera( -1, 1, 1, -1, 0, 1 );

  /**
   * The purpose of this special geometry is to fill the entire viewport with a single triangle.
   *
   * Reference: {@link https://github.com/mrdoob/three.js/pull/21358}
   *
   * @private
   * @augments BufferGeometry
   */
  class QuadGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new quad geometry.
  	 *
  	 * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
  	 */
  	constructor( flipY = false ) {

  		super();

  		const uv = flipY === false ? [ 0, -1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];

  		this.setAttribute( 'position', new Float32BufferAttribute( [ -1, 3, 0, -1, -1, 0, 3, -1, 0 ], 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );

  	}

  }

  const _geometry$1 = /*@__PURE__*/ new QuadGeometry();


  /**
   * This module is a helper for passes which need to render a full
   * screen effect which is quite common in context of post processing.
   *
   * The intended usage is to reuse a single quad mesh for rendering
   * subsequent passes by just reassigning the `material` reference.
   *
   * Note: This module can only be used with `WebGPURenderer`.
   *
   * @augments Mesh
   */
  class QuadMesh extends Mesh {

  	/**
  	 * Constructs a new quad mesh.
  	 *
  	 * @param {?Material} [material=null] - The material to render the quad mesh with.
  	 */
  	constructor( material = null ) {

  		super( _geometry$1, material );

  		/**
  		 * The camera to render the quad mesh with.
  		 *
  		 * @type {OrthographicCamera}
  		 * @readonly
  		 */
  		this.camera = _camera$1;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isQuadMesh = true;

  	}

  	/**
  	 * Async version of `render()`.
  	 *
  	 * @async
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {Promise} A Promise that resolves when the render has been finished.
  	 */
  	async renderAsync( renderer ) {

  		return renderer.renderAsync( this, _camera$1 );

  	}

  	/**
  	 * Renders the quad mesh
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 */
  	render( renderer ) {

  		renderer.render( this, _camera$1 );

  	}

  }

  const _e1 = /*@__PURE__*/ new Euler();
  const _m1 = /*@__PURE__*/ new Matrix4();

  /**
   * This module allows access to a collection of scene properties. The following predefined TSL objects
   * are available for easier use:
   *
   * - `backgroundBlurriness`: A node that represents the scene's background blurriness.
   * - `backgroundIntensity`: A node that represents the scene's background intensity.
   * - `backgroundRotation`: A node that represents the scene's background rotation.
   *
   * @augments Node
   */
  class SceneNode extends Node {

  	static get type() {

  		return 'SceneNode';

  	}

  	/**
  	 * Constructs a new scene node.
  	 *
  	 * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
  	 * @param {?Scene} [scene=null] - A reference to the scene.
  	 */
  	constructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {

  		super();

  		/**
  		 * The scope defines the type of scene property that is accessed.
  		 *
  		 * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}
  		 */
  		this.scope = scope;

  		/**
  		 * A reference to the scene that is going to be accessed.
  		 *
  		 * @type {?Scene}
  		 * @default null
  		 */
  		this.scene = scene;

  	}

  	/**
  	 * Depending on the scope, the method returns a different type of node that represents
  	 * the respective scene property.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Node} The output node.
  	 */
  	setup( builder ) {

  		const scope = this.scope;
  		const scene = this.scene !== null ? this.scene : builder.scene;

  		let output;

  		if ( scope === SceneNode.BACKGROUND_BLURRINESS ) {

  			output = reference( 'backgroundBlurriness', 'float', scene );

  		} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {

  			output = reference( 'backgroundIntensity', 'float', scene );

  		} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {

  			output = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {

  				const background = scene.background;

  				if ( background !== null && background.isTexture && background.mapping !== UVMapping ) {

  					_e1.copy( scene.backgroundRotation );

  					// accommodate left-handed frame
  					_e1.x *= -1; _e1.y *= -1; _e1.z *= -1;

  					_m1.makeRotationFromEuler( _e1 );

  				} else {

  					_m1.identity();

  				}

  				return _m1;

  			} );

  		} else {

  			console.error( 'THREE.SceneNode: Unknown scope:', scope );

  		}

  		return output;

  	}

  }

  SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
  SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';
  SceneNode.BACKGROUND_ROTATION = 'backgroundRotation';

  /**
   * TSL object that represents the scene's background blurriness.
   *
   * @tsl
   * @type {SceneNode}
   */
  const backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );

  /**
   * TSL object that represents the scene's background intensity.
   *
   * @tsl
   * @type {SceneNode}
   */
  const backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );

  /**
   * TSL object that represents the scene's background rotation.
   *
   * @tsl
   * @type {SceneNode}
   */
  const backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );

  const normal = Fn( ( { texture, uv } ) => {

  	const epsilon = 0.0001;

  	const ret = vec3().toVar();

  	If( uv.x.lessThan( epsilon ), () => {

  		ret.assign( vec3( 1, 0, 0 ) );

  	} ).ElseIf( uv.y.lessThan( epsilon ), () => {

  		ret.assign( vec3( 0, 1, 0 ) );

  	} ).ElseIf( uv.z.lessThan( epsilon ), () => {

  		ret.assign( vec3( 0, 0, 1 ) );

  	} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {

  		ret.assign( vec3( -1, 0, 0 ) );

  	} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {

  		ret.assign( vec3( 0, -1, 0 ) );

  	} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {

  		ret.assign( vec3( 0, 0, -1 ) );

  	} ).Else( () => {

  		const step = 0.01;

  		const x = texture.sample( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );
  		const y = texture.sample( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );
  		const z = texture.sample( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, 0.0, step ) ) ).r );

  		ret.assign( vec3( x, y, z ) );

  	} );

  	return ret.normalize();

  } );

  /**
   * This type of uniform node represents a 3D texture.
   *
   * @augments TextureNode
   */
  class Texture3DNode extends TextureNode {

  	static get type() {

  		return 'Texture3DNode';

  	}

  	/**
  	 * Constructs a new 3D texture node.
  	 *
  	 * @param {Data3DTexture} value - The 3D texture.
  	 * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
  	 * @param {?Node<int>} [levelNode=null] - The level node.
  	 */
  	constructor( value, uvNode = null, levelNode = null ) {

  		super( value, uvNode, levelNode );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isTexture3DNode = true;

  	}

  	/**
  	 * Overwrites the default implementation to return a fixed value `'texture3D'`.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( /*builder*/ ) {

  		return 'texture3D';

  	}

  	/**
  	 * Returns a default uv node which is in context of 3D textures a three-dimensional
  	 * uv node.
  	 *
  	 * @return {Node<vec3>} The default uv node.
  	 */
  	getDefaultUV() {

  		return vec3( 0.5, 0.5, 0.5 );

  	}

  	/**
  	 * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
  	 * for 3D textures. The uv transformation matrix is not applied to 3D textures.
  	 *
  	 * @param {boolean} value - The update toggle.
  	 */
  	setUpdateMatrix( /*value*/ ) { } // Ignore .updateMatrix for 3d TextureNode

  	/**
  	 * Overwrites the default implementation to return the unmodified uv node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node} uvNode - The uv node to setup.
  	 * @return {Node} The unmodified uv node.
  	 */
  	setupUV( builder, uvNode ) {

  		const texture = this.value;

  		if ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true ) ) {

  			if ( this.sampler ) {

  				uvNode = uvNode.flipY();

  			} else {

  				uvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );

  			}

  		}

  		return uvNode;

  	}

  	/**
  	 * Generates the uv code snippet.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @param {Node} uvNode - The uv node to generate code for.
  	 * @return {string} The generated code snippet.
  	 */
  	generateUV( builder, uvNode ) {

  		return uvNode.build( builder, 'vec3' );

  	}

  	/**
  	 * TODO.
  	 *
  	 * @param {Node<vec3>} uvNode - The uv node .
  	 * @return {Node<vec3>} TODO.
  	 */
  	normal( uvNode ) {

  		return normal( { texture: this, uv: uvNode } );

  	}

  }

  /**
   * TSL function for creating a 3D texture node.
   *
   * @tsl
   * @function
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @returns {Texture3DNode}
   */
  const texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode ).setParameterLength( 1, 3 );

  const _size = /*@__PURE__*/ new Vector2();

  /**
   * Represents the texture of a pass node.
   *
   * @augments TextureNode
   */
  class PassTextureNode extends TextureNode {

  	static get type() {

  		return 'PassTextureNode';

  	}

  	/**
  	 * Constructs a new pass texture node.
  	 *
  	 * @param {PassNode} passNode - The pass node.
  	 * @param {Texture} texture - The output texture.
  	 */
  	constructor( passNode, texture ) {

  		super( texture );

  		/**
  		 * A reference to the pass node.
  		 *
  		 * @type {PassNode}
  		 */
  		this.passNode = passNode;

  		this.setUpdateMatrix( false );

  	}

  	setup( builder ) {

  		if ( builder.object.isQuadMesh ) this.passNode.build( builder );

  		return super.setup( builder );

  	}

  	clone() {

  		return new this.constructor( this.passNode, this.value );

  	}

  }

  /**
   * An extension of `PassTextureNode` which allows to manage more than one
   * internal texture. Relevant for the `getPreviousTexture()` related API.
   *
   * @augments PassTextureNode
   */
  class PassMultipleTextureNode extends PassTextureNode {

  	static get type() {

  		return 'PassMultipleTextureNode';

  	}

  	/**
  	 * Constructs a new pass texture node.
  	 *
  	 * @param {PassNode} passNode - The pass node.
  	 * @param {string} textureName - The output texture name.
  	 * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
  	 */
  	constructor( passNode, textureName, previousTexture = false ) {

  		// null is passed to the super call since this class does not
  		// use an external texture for rendering pass data into. Instead
  		// the texture is managed by the pass node itself

  		super( passNode, null );

  		/**
  		 * The output texture name.
  		 *
  		 * @type {string}
  		 */
  		this.textureName = textureName;

  		/**
  		 * Whether previous frame data should be used or not.
  		 *
  		 * @type {boolean}
  		 */
  		this.previousTexture = previousTexture;

  	}

  	/**
  	 * Updates the texture reference of this node.
  	 */
  	updateTexture() {

  		this.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );

  	}

  	setup( builder ) {

  		this.updateTexture();

  		return super.setup( builder );

  	}

  	clone() {

  		const newNode = new this.constructor( this.passNode, this.textureName, this.previousTexture );
  		newNode.uvNode = this.uvNode;
  		newNode.levelNode = this.levelNode;
  		newNode.biasNode = this.biasNode;
  		newNode.sampler = this.sampler;
  		newNode.depthNode = this.depthNode;
  		newNode.compareNode = this.compareNode;
  		newNode.gradNode = this.gradNode;

  		return newNode;

  	}

  }

  /**
   * Represents a render pass (sometimes called beauty pass) in context of post processing.
   * This pass produces a render for the given scene and camera and can provide multiple outputs
   * via MRT for further processing.
   *
   * ```js
   * const postProcessing = new PostProcessing( renderer );
   *
   * const scenePass = pass( scene, camera );
   *
   * postProcessing.outputNode = scenePass;
   * ```
   *
   * @augments TempNode
   */
  class PassNode extends TempNode {

  	static get type() {

  		return 'PassNode';

  	}

  	/**
  	 * Constructs a new pass node.
  	 *
  	 * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
  	 * @param {Scene} scene - A reference to the scene.
  	 * @param {Camera} camera - A reference to the camera.
  	 * @param {Object} options - Options for the internal render target.
  	 */
  	constructor( scope, scene, camera, options = {} ) {

  		super( 'vec4' );

  		/**
  		 * The scope of the pass. The scope determines whether the node outputs color or depth.
  		 *
  		 * @type {('color'|'depth')}
  		 */
  		this.scope = scope;

  		/**
  		 * A reference to the scene.
  		 *
  		 * @type {Scene}
  		 */
  		this.scene = scene;

  		/**
  		 * A reference to the camera.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * Options for the internal render target.
  		 *
  		 * @type {Object}
  		 */
  		this.options = options;

  		/**
  		 * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._pixelRatio = 1;

  		/**
  		 * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._width = 1;

  		/**
  		 * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._height = 1;

  		const depthTexture = new DepthTexture();
  		depthTexture.isRenderTargetTexture = true;
  		//depthTexture.type = FloatType;
  		depthTexture.name = 'depth';

  		const renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );
  		renderTarget.texture.name = 'output';
  		renderTarget.depthTexture = depthTexture;

  		/**
  		 * The pass's render target.
  		 *
  		 * @type {RenderTarget}
  		 */
  		this.renderTarget = renderTarget;

  		/**
  		 * A dictionary holding the internal result textures.
  		 *
  		 * @private
  		 * @type {Object<string, Texture>}
  		 */
  		this._textures = {
  			output: renderTarget.texture,
  			depth: depthTexture
  		};

  		/**
  		 * A dictionary holding the internal texture nodes.
  		 *
  		 * @private
  		 * @type {Object<string, TextureNode>}
  		 */
  		this._textureNodes = {};

  		/**
  		 * A dictionary holding the internal depth nodes.
  		 *
  		 * @private
  		 * @type {Object}
  		 */
  		this._linearDepthNodes = {};

  		/**
  		 * A dictionary holding the internal viewZ nodes.
  		 *
  		 * @private
  		 * @type {Object}
  		 */
  		this._viewZNodes = {};

  		/**
  		 * A dictionary holding the texture data of the previous frame.
  		 * Used for computing velocity/motion vectors.
  		 *
  		 * @private
  		 * @type {Object<string, Texture>}
  		 */
  		this._previousTextures = {};

  		/**
  		 * A dictionary holding the texture nodes of the previous frame.
  		 * Used for computing velocity/motion vectors.
  		 *
  		 * @private
  		 * @type {Object<string, TextureNode>}
  		 */
  		this._previousTextureNodes = {};

  		/**
  		 * The `near` property of the camera as a uniform.
  		 *
  		 * @private
  		 * @type {UniformNode}
  		 */
  		this._cameraNear = uniform( 0 );

  		/**
  		 * The `far` property of the camera as a uniform.
  		 *
  		 * @private
  		 * @type {UniformNode}
  		 */
  		this._cameraFar = uniform( 0 );

  		/**
  		 * A MRT node configuring the MRT settings.
  		 *
  		 * @private
  		 * @type {?MRTNode}
  		 * @default null
  		 */
  		this._mrt = null;

  		this._layers = null;

  		this._resolution = 1;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPassNode = true;

  		/**
  		 * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
  		 * scene once per frame in its {@link PassNode#updateBefore} method.
  		 *
  		 * @type {string}
  		 * @default 'frame'
  		 */
  		this.updateBeforeType = NodeUpdateType.FRAME;

  		/**
  		 * This flag is used for global cache.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  	}

  	/**
  	 * Sets the resolution for the pass.
  	 * The resolution is a factor that is multiplied with the renderer's width and height.
  	 *
  	 * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
  	 * @return {PassNode} A reference to this pass.
  	 */
  	setResolution( resolution ) {

  		this._resolution = resolution;

  		return this;

  	}

  	/**
  	 * Gets the current resolution of the pass.
  	 *
  	 * @return {number} The current resolution. A value of `1` means full resolution.
  	 * @default 1
  	 */
  	getResolution() {

  		return this._resolution;

  	}

  	setLayers( layers ) {

  		this._layers = layers;

  		return this;

  	}

  	getLayers() {

  		return this._layers;

  	}

  	/**
  	 * Sets the given MRT node to setup MRT for this pass.
  	 *
  	 * @param {MRTNode} mrt - The MRT object.
  	 * @return {PassNode} A reference to this pass.
  	 */
  	setMRT( mrt ) {

  		this._mrt = mrt;

  		return this;

  	}

  	/**
  	 * Returns the current MRT node.
  	 *
  	 * @return {MRTNode} The current MRT node.
  	 */
  	getMRT() {

  		return this._mrt;

  	}

  	/**
  	 * Returns the texture for the given output name.
  	 *
  	 * @param {string} name - The output name to get the texture for.
  	 * @return {Texture} The texture.
  	 */
  	getTexture( name ) {

  		let texture = this._textures[ name ];

  		if ( texture === undefined ) {

  			const refTexture = this.renderTarget.texture;

  			texture = refTexture.clone();
  			texture.name = name;

  			this._textures[ name ] = texture;

  			this.renderTarget.textures.push( texture );

  		}

  		return texture;

  	}

  	/**
  	 * Returns the texture holding the data of the previous frame for the given output name.
  	 *
  	 * @param {string} name - The output name to get the texture for.
  	 * @return {Texture} The texture holding the data of the previous frame.
  	 */
  	getPreviousTexture( name ) {

  		let texture = this._previousTextures[ name ];

  		if ( texture === undefined ) {

  			texture = this.getTexture( name ).clone();

  			this._previousTextures[ name ] = texture;

  		}

  		return texture;

  	}

  	/**
  	 * Switches current and previous textures for the given output name.
  	 *
  	 * @param {string} name - The output name.
  	 */
  	toggleTexture( name ) {

  		const prevTexture = this._previousTextures[ name ];

  		if ( prevTexture !== undefined ) {

  			const texture = this._textures[ name ];

  			const index = this.renderTarget.textures.indexOf( texture );
  			this.renderTarget.textures[ index ] = prevTexture;

  			this._textures[ name ] = prevTexture;
  			this._previousTextures[ name ] = texture;

  			this._textureNodes[ name ].updateTexture();
  			this._previousTextureNodes[ name ].updateTexture();

  		}

  	}

  	/**
  	 * Returns the texture node for the given output name.
  	 *
  	 * @param {string} [name='output'] - The output name to get the texture node for.
  	 * @return {TextureNode} The texture node.
  	 */
  	getTextureNode( name = 'output' ) {

  		let textureNode = this._textureNodes[ name ];

  		if ( textureNode === undefined ) {

  			textureNode = nodeObject( new PassMultipleTextureNode( this, name ) );
  			textureNode.updateTexture();
  			this._textureNodes[ name ] = textureNode;

  		}

  		return textureNode;

  	}

  	/**
  	 * Returns the previous texture node for the given output name.
  	 *
  	 * @param {string} [name='output'] - The output name to get the previous texture node for.
  	 * @return {TextureNode} The previous texture node.
  	 */
  	getPreviousTextureNode( name = 'output' ) {

  		let textureNode = this._previousTextureNodes[ name ];

  		if ( textureNode === undefined ) {

  			if ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );

  			textureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );
  			textureNode.updateTexture();
  			this._previousTextureNodes[ name ] = textureNode;

  		}

  		return textureNode;

  	}

  	/**
  	 * Returns a viewZ node of this pass.
  	 *
  	 * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
  	 * @return {Node} The viewZ node.
  	 */
  	getViewZNode( name = 'depth' ) {

  		let viewZNode = this._viewZNodes[ name ];

  		if ( viewZNode === undefined ) {

  			const cameraNear = this._cameraNear;
  			const cameraFar = this._cameraFar;

  			this._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );

  		}

  		return viewZNode;

  	}

  	/**
  	 * Returns a linear depth node of this pass.
  	 *
  	 * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
  	 * @return {Node} The linear depth node.
  	 */
  	getLinearDepthNode( name = 'depth' ) {

  		let linearDepthNode = this._linearDepthNodes[ name ];

  		if ( linearDepthNode === undefined ) {

  			const cameraNear = this._cameraNear;
  			const cameraFar = this._cameraFar;
  			const viewZNode = this.getViewZNode( name );

  			// TODO: just if ( builder.camera.isPerspectiveCamera )

  			this._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );

  		}

  		return linearDepthNode;

  	}

  	setup( { renderer } ) {

  		this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;

  		this.renderTarget.texture.type = renderer.getColorBufferType();

  		return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();

  	}

  	updateBefore( frame ) {

  		const { renderer } = frame;
  		const { scene } = this;

  		let camera;
  		let pixelRatio;

  		const outputRenderTarget = renderer.getOutputRenderTarget();

  		if ( outputRenderTarget && outputRenderTarget.isXRRenderTarget === true ) {

  			pixelRatio = 1;
  			camera = renderer.xr.getCamera();

  			renderer.xr.updateCamera( camera );

  			_size.set( outputRenderTarget.width, outputRenderTarget.height );

  		} else {

  			camera = this.camera;
  			pixelRatio = renderer.getPixelRatio();

  			renderer.getSize( _size );

  		}

  		this._pixelRatio = pixelRatio;

  		this.setSize( _size.width, _size.height );

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentMRT = renderer.getMRT();
  		const currentMask = camera.layers.mask;

  		this._cameraNear.value = camera.near;
  		this._cameraFar.value = camera.far;

  		if ( this._layers !== null ) {

  			camera.layers.mask = this._layers.mask;

  		}

  		for ( const name in this._previousTextures ) {

  			this.toggleTexture( name );

  		}

  		renderer.setRenderTarget( this.renderTarget );
  		renderer.setMRT( this._mrt );

  		renderer.render( scene, camera );

  		renderer.setRenderTarget( currentRenderTarget );
  		renderer.setMRT( currentMRT );

  		camera.layers.mask = currentMask;

  	}

  	/**
  	 * Sets the size of the pass's render target. Honors the pixel ratio.
  	 *
  	 * @param {number} width - The width to set.
  	 * @param {number} height - The height to set.
  	 */
  	setSize( width, height ) {

  		this._width = width;
  		this._height = height;

  		const effectiveWidth = this._width * this._pixelRatio * this._resolution;
  		const effectiveHeight = this._height * this._pixelRatio * this._resolution;

  		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

  	}

  	/**
  	 * Sets the pixel ratio the pass's render target and updates the size.
  	 *
  	 * @param {number} pixelRatio - The pixel ratio to set.
  	 */
  	setPixelRatio( pixelRatio ) {

  		this._pixelRatio = pixelRatio;

  		this.setSize( this._width, this._height );

  	}

  	/**
  	 * Frees internal resources. Should be called when the node is no longer in use.
  	 */
  	dispose() {

  		this.renderTarget.dispose();

  	}


  }

  /**
   * @static
   * @type {'color'}
   * @default 'color'
   */
  PassNode.COLOR = 'color';

  /**
   * @static
   * @type {'depth'}
   * @default 'depth'
   */
  PassNode.DEPTH = 'depth';

  /**
   * Linear tone mapping, exposure only.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  const linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	return color.mul( exposure ).clamp();

  } ).setLayout( {
  	name: 'linearToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  /**
   * Reinhard tone mapping.
   *
   * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  const reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	color = color.mul( exposure );

  	return color.div( color.add( 1.0 ) ).clamp();

  } ).setLayout( {
  	name: 'reinhardToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  /**
   * Cineon tone mapping.
   *
   * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  const cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	// filmic operator by Jim Hejl and Richard Burgess-Dawson
  	color = color.mul( exposure );
  	color = color.sub( 0.004 ).max( 0.0 );

  	const a = color.mul( color.mul( 6.2 ).add( 0.5 ) );
  	const b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );

  	return a.div( b ).pow( 2.2 );

  } ).setLayout( {
  	name: 'cineonToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  // source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

  const RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	const a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );
  	const b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );

  	return a.div( b );

  } );

  /**
   * ACESFilmic tone mapping.
   *
   * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  const acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
  	const ACESInputMat = mat3(
  		0.59719, 0.35458, 0.04823,
  		0.07600, 0.90834, 0.01566,
  		0.02840, 0.13383, 0.83777
  	);

  	// ODT_SAT => XYZ => D60_2_D65 => sRGB
  	const ACESOutputMat = mat3(
  		1.60475, -0.53108, -0.07367,
  		-0.10208, 1.10813, -605e-5,
  		-327e-5, -0.07276, 1.07602
  	);

  	color = color.mul( exposure ).div( 0.6 );

  	color = ACESInputMat.mul( color );

  	// Apply RRT and ODT
  	color = RRTAndODTFit( color );

  	color = ACESOutputMat.mul( color );

  	// Clamp to [0, 1]
  	return color.clamp();

  } ).setLayout( {
  	name: 'acesFilmicToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  const LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, -0.1246, -0.0182 ), vec3( -0.5876, 1.1329, -0.1006 ), vec3( -0.0728, -83e-4, 1.1187 ) );
  const LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );

  const agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

  	const x = vec3( x_immutable ).toVar();
  	const x2 = vec3( x.mul( x ) ).toVar();
  	const x4 = vec3( x2.mul( x2 ) ).toVar();

  	return float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );

  } );

  /**
   * AgX tone mapping.
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  const agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	const colortone = vec3( color ).toVar();
  	const AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );
  	const AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, -0.1413297634984383, -0.14132976349843826 ), vec3( -0.11060664309660323, 1.157823702216272, -0.11060664309660294 ), vec3( -0.016493938717834573, -0.016493938717834257, 1.2519364065950405 ) );
  	const AgxMinEv = float( -12.47393 );
  	const AgxMaxEv = float( 4.026069 );
  	colortone.mulAssign( exposure );
  	colortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );
  	colortone.assign( AgXInsetMatrix.mul( colortone ) );
  	colortone.assign( max$1( colortone, 1e-10 ) );
  	colortone.assign( log2( colortone ) );
  	colortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );
  	colortone.assign( clamp( colortone, 0.0, 1.0 ) );
  	colortone.assign( agxDefaultContrastApprox( colortone ) );
  	colortone.assign( AgXOutsetMatrix.mul( colortone ) );
  	colortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );
  	colortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );
  	colortone.assign( clamp( colortone, 0.0, 1.0 ) );

  	return colortone;

  } ).setLayout( {
  	name: 'agxToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  /**
   * Neutral tone mapping.
   *
   * Reference: {@link https://modelviewer.dev/examples/tone-mapping}
   *
   * @tsl
   * @function
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  const neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	const StartCompression = float( 0.8 - 0.04 );
  	const Desaturation = float( 0.15 );

  	color = color.mul( exposure );

  	const x = min$1( color.r, min$1( color.g, color.b ) );
  	const offset = select$1( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );

  	color.subAssign( offset );

  	const peak = max$1( color.r, max$1( color.g, color.b ) );

  	If( peak.lessThan( StartCompression ), () => {

  		return color;

  	} );

  	const d = sub( 1, StartCompression );
  	const newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );
  	color.mulAssign( newPeak.div( peak ) );
  	const g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );

  	return mix$2( color, vec3( newPeak ), g );

  } ).setLayout( {
  	name: 'neutralToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  /**
   * This class represents native code sections. It is the base
   * class for modules like {@link FunctionNode} which allows to implement
   * functions with native shader languages.
   *
   * @augments Node
   */
  class CodeNode extends Node {

  	static get type() {

  		return 'CodeNode';

  	}

  	/**
  	 * Constructs a new code node.
  	 *
  	 * @param {string} [code=''] - The native code.
  	 * @param {Array<Node>} [includes=[]] - An array of includes.
  	 * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
  	 */
  	constructor( code = '', includes = [], language = '' ) {

  		super( 'code' );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCodeNode = true;

  		/**
  		 * This flag is used for global cache.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  		/**
  		 * The native code.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.code = code;

  		/**
  		 * An array of includes
  		 *
  		 * @type {Array<Node>}
  		 * @default []
  		 */
  		this.includes = includes;

  		/**
  		 * The used language.
  		 *
  		 * @type {('js'|'wgsl'|'glsl')}
  		 * @default ''
  		 */
  		this.language = language;

  	}

  	/**
  	 * Sets the includes of this code node.
  	 *
  	 * @param {Array<Node>} includes - The includes to set.
  	 * @return {CodeNode} A reference to this node.
  	 */
  	setIncludes( includes ) {

  		this.includes = includes;

  		return this;

  	}

  	/**
  	 * Returns the includes of this code node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Array<Node>} The includes.
  	 */
  	getIncludes( /*builder*/ ) {

  		return this.includes;

  	}

  	generate( builder ) {

  		const includes = this.getIncludes( builder );

  		for ( const include of includes ) {

  			include.build( builder );

  		}

  		const nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );
  		nodeCode.code = this.code;

  		return nodeCode.code;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.code = this.code;
  		data.language = this.language;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.code = data.code;
  		this.language = data.language;

  	}

  }

  /**
   * This class represents a native shader function. It can be used to implement
   * certain aspects of a node material with native shader code. There are two predefined
   * TSL functions for easier usage.
   *
   * - `wgslFn`: Creates a WGSL function node.
   * - `glslFn`: Creates a GLSL function node.
   *
   * A basic example with one include looks like so:
   *
   * ```js
   * const desaturateWGSLFn = wgslFn( `
   *	fn desaturate( color:vec3<f32> ) -> vec3<f32> {
   *		let lum = vec3<f32>( 0.299, 0.587, 0.114 );
   *		return vec3<f32>( dot( lum, color ) );
   *	}`
   *);
   * const someWGSLFn = wgslFn( `
   *	fn someFn( color:vec3<f32> ) -> vec3<f32> {
   * 		return desaturate( color );
   * 	}
   * `, [ desaturateWGSLFn ] );
   * material.colorNode = someWGSLFn( { color: texture( map ) } );
   *```
   * @augments CodeNode
   */
  class FunctionNode extends CodeNode {

  	static get type() {

  		return 'FunctionNode';

  	}

  	/**
  	 * Constructs a new function node.
  	 *
  	 * @param {string} [code=''] - The native code.
  	 * @param {Array<Node>} [includes=[]] - An array of includes.
  	 * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
  	 */
  	constructor( code = '', includes = [], language = '' ) {

  		super( code, includes, language );

  	}

  	getNodeType( builder ) {

  		return this.getNodeFunction( builder ).type;

  	}

  	/**
  	 * Returns the inputs of this function node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {Array<NodeFunctionInput>} The inputs.
  	 */
  	getInputs( builder ) {

  		return this.getNodeFunction( builder ).inputs;

  	}

  	/**
  	 * Returns the node function for this function node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {NodeFunction} The node function.
  	 */
  	getNodeFunction( builder ) {

  		const nodeData = builder.getDataFromNode( this );

  		let nodeFunction = nodeData.nodeFunction;

  		if ( nodeFunction === undefined ) {

  			nodeFunction = builder.parser.parseFunction( this.code );

  			nodeData.nodeFunction = nodeFunction;

  		}

  		return nodeFunction;

  	}

  	generate( builder, output ) {

  		super.generate( builder );

  		const nodeFunction = this.getNodeFunction( builder );

  		const name = nodeFunction.name;
  		const type = nodeFunction.type;

  		const nodeCode = builder.getCodeFromNode( this, type );

  		if ( name !== '' ) {

  			// use a custom property name

  			nodeCode.name = name;

  		}

  		const propertyName = builder.getPropertyName( nodeCode );

  		const code = this.getNodeFunction( builder ).getCode( propertyName );

  		nodeCode.code = code + '\n';

  		if ( output === 'property' ) {

  			return propertyName;

  		} else {

  			return builder.format( `${ propertyName }()`, type, output );

  		}

  	}

  }

  /**
   * Returns a node that represents the `z` coordinate in view space
   * for the current fragment. It's a different representation of the
   * default depth value.
   *
   * This value can be part of a computation that defines how the fog
   * density increases when moving away from the camera.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The viewZ node.
   */
  function getViewZNode( builder ) {

  	let viewZ;

  	const getViewZ = builder.context.getViewZ;

  	if ( getViewZ !== undefined ) {

  		viewZ = getViewZ( this );

  	}

  	return ( viewZ || positionView.z ).negate();

  }

  /**
   * Constructs a new range factor node.
   *
   * @tsl
   * @function
   * @param {Node} near - Defines the near value.
   * @param {Node} far - Defines the far value.
   */
  const rangeFogFactor = Fn( ( [ near, far ], builder ) => {

  	const viewZ = getViewZNode( builder );

  	return smoothstep( near, far, viewZ );

  } );

  /**
   * Represents an exponential squared fog. This type of fog gives
   * a clear view near the camera and a faster than exponentially
   * densening fog farther from the camera.
   *
   * @tsl
   * @function
   * @param {Node} density - Defines the fog density.
   */
  const densityFogFactor = Fn( ( [ density ], builder ) => {

  	const viewZ = getViewZNode( builder );

  	return density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();

  } );

  /**
   * This class can be used to configure a fog for the scene.
   * Nodes of this type are assigned to `Scene.fogNode`.
   *
   * @tsl
   * @function
   * @param {Node} color - Defines the color of the fog.
   * @param {Node} factor - Defines how the fog is factored in the scene.
   */
  const fog = Fn( ( [ color, factor ] ) => {

  	return vec4( factor.toFloat().mix( output.rgb, color.toVec3() ), output.a );

  } );

  /**
   * Represents a GPU control barrier that synchronizes compute operations within a given scope.
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments Node
   */
  class BarrierNode extends Node {

  	/**
  	 * Constructs a new barrier node.
  	 *
  	 * @param {string} scope - The scope defines the behavior of the node.
  	 */
  	constructor( scope ) {

  		super();

  		this.scope = scope;

  	}

  	generate( builder ) {

  		const { scope } = this;
  		const { renderer } = builder;

  		if ( renderer.backend.isWebGLBackend === true ) {

  			builder.addFlowCode( `\t// ${scope}Barrier \n` );

  		} else {

  			builder.addLineFlowCode( `${scope}Barrier()`, this );

  		}

  	}

  }

  /**
   * TSL function for creating a barrier node.
   *
   * @tsl
   * @function
   * @param {string} scope - The scope defines the behavior of the node..
   * @returns {BarrierNode}
   */
  nodeProxy( BarrierNode );

  /**
   * `AtomicFunctionNode` represents any function that can operate on atomic variable types
   * within a shader. In an atomic function, any modification to an atomic variable will
   * occur as an indivisible step with a defined order relative to other modifications.
   * Accordingly, even if multiple atomic functions are modifying an atomic variable at once
   * atomic operations will not interfere with each other.
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments Node
   */
  class AtomicFunctionNode extends Node {

  	static get type() {

  		return 'AtomicFunctionNode';

  	}

  	/**
  	 * Constructs a new atomic function node.
  	 *
  	 * @param {string} method - The signature of the atomic function to construct.
  	 * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
  	 * @param {Node} valueNode - The value that mutates the atomic variable.
  	 */
  	constructor( method, pointerNode, valueNode ) {

  		super( 'uint' );

  		/**
  		 * The signature of the atomic function to construct.
  		 *
  		 * @type {string}
  		 */
  		this.method = method;

  		/**
  		 * An atomic variable or element of an atomic buffer.
  		 *
  		 * @type {Node}
  		 */
  		this.pointerNode = pointerNode;

  		/**
  		 * A value that modifies the atomic variable.
  		 *
  		 * @type {Node}
  		 */
  		this.valueNode = valueNode;

  		/**
  		 * Creates a list of the parents for this node for detecting if the node needs to return a value.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.parents = true;

  	}

  	/**
  	 * Overwrites the default implementation to return the type of
  	 * the pointer node.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The input type.
  	 */
  	getInputType( builder ) {

  		return this.pointerNode.getNodeType( builder );

  	}

  	/**
  	 * Overwritten since the node type is inferred from the input type.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 * @return {string} The node type.
  	 */
  	getNodeType( builder ) {

  		return this.getInputType( builder );

  	}

  	generate( builder ) {

  		const properties = builder.getNodeProperties( this );
  		const parents = properties.parents;

  		const method = this.method;

  		const type = this.getNodeType( builder );
  		const inputType = this.getInputType( builder );

  		const a = this.pointerNode;
  		const b = this.valueNode;

  		const params = [];

  		params.push( `&${ a.build( builder, inputType ) }` );

  		if ( b !== null ) {

  			params.push( b.build( builder, inputType ) );


  		}

  		const methodSnippet = `${ builder.getMethod( method, type ) }( ${ params.join( ', ' ) } )`;
  		const isVoid = parents.length === 1 && parents[ 0 ].isStackNode === true;

  		if ( isVoid ) {

  			builder.addLineFlowCode( methodSnippet, this );

  		} else {

  			if ( properties.constNode === undefined ) {

  				properties.constNode = expression( methodSnippet, type ).toConst();

  			}

  			return properties.constNode.build( builder );

  		}

  	}

  }

  AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
  AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
  AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
  AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
  AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
  AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
  AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
  AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
  AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';

  /**
   * TSL function for creating an atomic function node.
   *
   * @tsl
   * @function
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @returns {AtomicFunctionNode}
   */
  nodeProxy( AtomicFunctionNode );

  let uniformsLib;

  function getLightData( light ) {

  	uniformsLib = uniformsLib || new WeakMap();

  	let uniforms = uniformsLib.get( light );

  	if ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );

  	return uniforms;

  }

  /**
   * TSL function for getting a shadow matrix uniform node for the given light.
   *
   * @tsl
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<mat4>} The shadow matrix uniform node.
   */
  function lightShadowMatrix( light ) {

  	const data = getLightData( light );

  	return data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => {

  		if ( light.castShadow !== true || frame.renderer.shadowMap.enabled === false ) {

  			light.shadow.updateMatrices( light );

  		}

  		return light.shadow.matrix;

  	} ) );

  }

  /**
   * TSL function for getting projected uv coordinates for the given light.
   * Relevant when using maps with spot lights.
   *
   * @tsl
   * @function
   * @param {Light} light -The light source.
   * @param {Node<vec3>} [position=positionWorld] -The position to project.
   * @returns {Node<vec3>} The projected uvs.
   */
  function lightProjectionUV( light, position = positionWorld ) {

  	const spotLightCoord = lightShadowMatrix( light ).mul( position );
  	const projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );

  	return projectionUV;

  }

  /**
   * TSL function for getting the position in world space for the given light.
   *
   * @tsl
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<vec3>} The light's position in world space.
   */
  function lightPosition( light ) {

  	const data = getLightData( light );

  	return data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );

  }

  /**
   * TSL function for getting the light target position in world space for the given light.
   *
   * @tsl
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<vec3>} The light target position in world space.
   */
  function lightTargetPosition( light ) {

  	const data = getLightData( light );

  	return data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );

  }

  /**
   * TSL function for getting the position in view space for the given light.
   *
   * @tsl
   * @function
   * @param {Light} light - The light source.
   * @returns {UniformNode<vec3>} The light's position in view space.
   */
  function lightViewPosition( light ) {

  	const data = getLightData( light );

  	return data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {

  		self.value = self.value || new Vector3();
  		self.value.setFromMatrixPosition( light.matrixWorld );

  		self.value.applyMatrix4( camera.matrixWorldInverse );

  	} ) );

  }

  /**
   * TSL function for getting the light target direction for the given light.
   *
   * @tsl
   * @function
   * @param {Light} light -The light source.
   * @returns {Node<vec3>} The light's target direction.
   */
  const lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );

  const sortLights = ( lights ) => {

  	return lights.sort( ( a, b ) => a.id - b.id );

  };

  const getLightNodeById = ( id, lightNodes ) => {

  	for ( const lightNode of lightNodes ) {

  		if ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {

  			return lightNode;

  		}

  	}

  	return null;

  };

  const _lightsNodeRef = /*@__PURE__*/ new WeakMap();
  const _hashData = [];

  /**
   * This node represents the scene's lighting and manages the lighting model's life cycle
   * for the current build 3D object. It is responsible for computing the total outgoing
   * light in a given lighting context.
   *
   * @augments Node
   */
  class LightsNode extends Node {

  	static get type() {

  		return 'LightsNode';

  	}

  	/**
  	 * Constructs a new lights node.
  	 */
  	constructor() {

  		super( 'vec3' );

  		/**
  		 * A node representing the total diffuse light.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.totalDiffuseNode = property( 'vec3', 'totalDiffuse' );

  		/**
  		 * A node representing the total specular light.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.totalSpecularNode = property( 'vec3', 'totalSpecular' );

  		/**
  		 * A node representing the outgoing light.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.outgoingLightNode = property( 'vec3', 'outgoingLight' );

  		/**
  		 * An array representing the lights in the scene.
  		 *
  		 * @private
  		 * @type {Array<Light>}
  		 */
  		this._lights = [];

  		/**
  		 * For each light in the scene, this node will create a
  		 * corresponding light node.
  		 *
  		 * @private
  		 * @type {?Array<LightingNode>}
  		 * @default null
  		 */
  		this._lightNodes = null;

  		/**
  		 * A hash for identifying the current light nodes setup.
  		 *
  		 * @private
  		 * @type {?string}
  		 * @default null
  		 */
  		this._lightNodesHash = null;

  		/**
  		 * `LightsNode` sets this property to `true` by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.global = true;

  	}

  	/**
  	 * Overwrites the default {@link Node#customCacheKey} implementation by including
  	 * light data into the cache key.
  	 *
  	 * @return {number} The custom cache key.
  	 */
  	customCacheKey() {

  		const lights = this._lights;

  		for ( let i = 0; i < lights.length; i ++ ) {

  			const light = lights[ i ];

  			_hashData.push( light.id );
  			_hashData.push( light.castShadow ? 1 : 0 );

  			if ( light.isSpotLight === true ) {

  				const hashMap = ( light.map !== null ) ? light.map.id : -1;
  				const hashColorNode = ( light.colorNode ) ? light.colorNode.getCacheKey() : -1;

  				_hashData.push( hashMap, hashColorNode );

  			}

  		}

  		const cacheKey = hashArray( _hashData );

  		_hashData.length = 0;

  		return cacheKey;

  	}

  	/**
  	 * Computes a hash value for identifying the current light nodes setup.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @return {string} The computed hash.
  	 */
  	getHash( builder ) {

  		if ( this._lightNodesHash === null ) {

  			if ( this._lightNodes === null ) this.setupLightsNode( builder );

  			const hash = [];

  			for ( const lightNode of this._lightNodes ) {

  				hash.push( lightNode.getSelf().getHash() );

  			}

  			this._lightNodesHash = 'lights-' + hash.join( ',' );

  		}

  		return this._lightNodesHash;

  	}

  	analyze( builder ) {

  		const properties = builder.getNodeProperties( this );

  		for ( const node of properties.nodes ) {

  			node.build( builder );

  		}

  		properties.outputNode.build( builder );

  	}

  	/**
  	 * Creates lighting nodes for each scene light. This makes it possible to further
  	 * process lights in the node system.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 */
  	setupLightsNode( builder ) {

  		const lightNodes = [];

  		const previousLightNodes = this._lightNodes;

  		const lights = sortLights( this._lights );
  		const nodeLibrary = builder.renderer.library;

  		for ( const light of lights ) {

  			if ( light.isNode ) {

  				lightNodes.push( nodeObject( light ) );

  			} else {

  				let lightNode = null;

  				if ( previousLightNodes !== null ) {

  					lightNode = getLightNodeById( light.id, previousLightNodes ); // reuse existing light node

  				}

  				if ( lightNode === null ) {

  					// find the corresponding node type for a given light

  					const lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );

  					if ( lightNodeClass === null ) {

  						console.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );
  						continue;

  					}

  					let lightNode = null;

  					if ( ! _lightsNodeRef.has( light ) ) {

  						lightNode = nodeObject( new lightNodeClass( light ) );
  						_lightsNodeRef.set( light, lightNode );

  					} else {

  						lightNode = _lightsNodeRef.get( light );

  					}

  					lightNodes.push( lightNode );

  				}

  			}

  		}

  		this._lightNodes = lightNodes;

  	}

  	/**
  	 * Sets up a direct light in the lighting model.
  	 *
  	 * @param {Object} builder - The builder object containing the context and stack.
  	 * @param {Object} lightNode - The light node.
  	 * @param {Object} lightData - The light object containing color and direction properties.
  	 */
  	setupDirectLight( builder, lightNode, lightData ) {

  		const { lightingModel, reflectedLight } = builder.context;

  		lightingModel.direct( {
  			...lightData,
  			lightNode,
  			reflectedLight
  		}, builder );

  	}

  	setupDirectRectAreaLight( builder, lightNode, lightData ) {

  		const { lightingModel, reflectedLight } = builder.context;

  		lightingModel.directRectArea( {
  			...lightData,
  			lightNode,
  			reflectedLight
  		}, builder );

  	}

  	/**
  	 * Setups the internal lights by building all respective
  	 * light nodes.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
  	 */
  	setupLights( builder, lightNodes ) {

  		for ( const lightNode of lightNodes ) {

  			lightNode.build( builder );

  		}

  	}

  	getLightNodes( builder ) {

  		if ( this._lightNodes === null ) this.setupLightsNode( builder );

  		return this._lightNodes;

  	}

  	/**
  	 * The implementation makes sure that for each light in the scene
  	 * there is a corresponding light node. By building the light nodes
  	 * and evaluating the lighting model the outgoing light is computed.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @return {Node<vec3>} A node representing the outgoing light.
  	 */
  	setup( builder ) {

  		const currentLightsNode = builder.lightsNode;

  		builder.lightsNode = this;

  		//

  		let outgoingLightNode = this.outgoingLightNode;

  		const context = builder.context;
  		const lightingModel = context.lightingModel;

  		const properties = builder.getNodeProperties( this );

  		if ( lightingModel ) {

  			const { totalDiffuseNode, totalSpecularNode } = this;

  			context.outgoingLight = outgoingLightNode;

  			const stack = builder.addStack();

  			//

  			properties.nodes = stack.nodes;

  			//

  			lightingModel.start( builder );

  			//

  			const { backdrop, backdropAlpha } = context;
  			const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;

  			let totalDiffuse = directDiffuse.add( indirectDiffuse );

  			if ( backdrop !== null ) {

  				if ( backdropAlpha !== null ) {

  					totalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );

  				} else {

  					totalDiffuse = vec3( backdrop );

  				}

  				context.material.transparent = true;

  			}

  			totalDiffuseNode.assign( totalDiffuse );
  			totalSpecularNode.assign( directSpecular.add( indirectSpecular ) );

  			outgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );

  			//

  			lightingModel.finish( builder );

  			//

  			outgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );

  		} else {

  			properties.nodes = [];

  		}

  		//

  		builder.lightsNode = currentLightsNode;

  		return outgoingLightNode;

  	}

  	/**
  	 * Configures this node with an array of lights.
  	 *
  	 * @param {Array<Light>} lights - An array of lights.
  	 * @return {LightsNode} A reference to this node.
  	 */
  	setLights( lights ) {

  		this._lights = lights;

  		this._lightNodes = null;
  		this._lightNodesHash = null;

  		return this;

  	}

  	/**
  	 * Returns an array of the scene's lights.
  	 *
  	 * @return {Array<Light>} The scene's lights.
  	 */
  	getLights() {

  		return this._lights;

  	}

  	/**
  	 * Whether the scene has lights or not.
  	 *
  	 * @type {boolean}
  	 */
  	get hasLights() {

  		return this._lights.length > 0;

  	}

  }

  /**
   * Base class for all shadow nodes.
   *
   * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
   * Lighting nodes might share the same shadow node type or use specific ones depending on
   * their requirements.
   *
   * @augments Node
   */
  class ShadowBaseNode extends Node {

  	static get type() {

  		return 'ShadowBaseNode';

  	}

  	/**
  	 * Constructs a new shadow base node.
  	 *
  	 * @param {Light} light - The shadow casting light.
  	 */
  	constructor( light ) {

  		super();

  		/**
  		 * The shadow casting light.
  		 *
  		 * @type {Light}
  		 */
  		this.light = light;

  		/**
  		 * Overwritten since shadows are updated by default per render.
  		 *
  		 * @type {string}
  		 * @default 'render'
  		 */
  		this.updateBeforeType = NodeUpdateType.RENDER;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isShadowBaseNode = true;

  	}

  	/**
  	 * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
  	 *
  	 * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
  	 */
  	setupShadowPosition( { context, material } ) {

  		// Use assign inside an Fn()

  		shadowPositionWorld.assign( material.receivedShadowPositionNode || context.shadowPositionWorld || positionWorld );

  	}

  }

  /**
   * TSL object that represents the vertex position in world space during the shadow pass.
   *
   * @tsl
   * @type {Node<vec3>}
   */
  const shadowPositionWorld = /*@__PURE__*/ property( 'vec3', 'shadowPositionWorld' );

  /**
   * Saves the state of the given renderer and stores it into the given state object.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function saveRendererState( renderer, state = {} ) {

  	state.toneMapping = renderer.toneMapping;
  	state.toneMappingExposure = renderer.toneMappingExposure;
  	state.outputColorSpace = renderer.outputColorSpace;
  	state.renderTarget = renderer.getRenderTarget();
  	state.activeCubeFace = renderer.getActiveCubeFace();
  	state.activeMipmapLevel = renderer.getActiveMipmapLevel();
  	state.renderObjectFunction = renderer.getRenderObjectFunction();
  	state.pixelRatio = renderer.getPixelRatio();
  	state.mrt = renderer.getMRT();
  	state.clearColor = renderer.getClearColor( state.clearColor || new Color() );
  	state.clearAlpha = renderer.getClearAlpha();
  	state.autoClear = renderer.autoClear;
  	state.scissorTest = renderer.getScissorTest();

  	return state;

  }

  /**
   * Saves the state of the given renderer and stores it into the given state object.
   * Besides, the function also resets the state of the renderer to its default values.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function resetRendererState( renderer, state ) {

  	state = saveRendererState( renderer, state );

  	renderer.setMRT( null );
  	renderer.setRenderObjectFunction( null );
  	renderer.setClearColor( 0x000000, 1 );
  	renderer.autoClear = true;

  	return state;

  }

  /**
   * Restores the state of the given renderer from the given state object.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Object} state - The state to restore.
   */
  function restoreRendererState( renderer, state ) {

  	renderer.toneMapping = state.toneMapping;
  	renderer.toneMappingExposure = state.toneMappingExposure;
  	renderer.outputColorSpace = state.outputColorSpace;
  	renderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );
  	renderer.setRenderObjectFunction( state.renderObjectFunction );
  	renderer.setPixelRatio( state.pixelRatio );
  	renderer.setMRT( state.mrt );
  	renderer.setClearColor( state.clearColor, state.clearAlpha );
  	renderer.autoClear = state.autoClear;
  	renderer.setScissorTest( state.scissorTest );

  }

  /**
   * Saves the state of the given scene and stores it into the given state object.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function saveSceneState( scene, state = {} ) {

  	state.background = scene.background;
  	state.backgroundNode = scene.backgroundNode;
  	state.overrideMaterial = scene.overrideMaterial;

  	return state;

  }

  /**
   * Saves the state of the given scene and stores it into the given state object.
   * Besides, the function also resets the state of the scene to its default values.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function resetSceneState( scene, state ) {

  	state = saveSceneState( scene, state );

  	scene.background = null;
  	scene.backgroundNode = null;
  	scene.overrideMaterial = null;

  	return state;

  }

  /**
   * Restores the state of the given scene from the given state object.
   *
   * @function
   * @param {Scene} scene - The scene.
   * @param {Object} state - The state to restore.
   */
  function restoreSceneState( scene, state ) {

  	scene.background = state.background;
  	scene.backgroundNode = state.backgroundNode;
  	scene.overrideMaterial = state.overrideMaterial;

  }

  /**
   * Saves the state of the given renderer and scene and stores it into the given state object.
   * Besides, the function also resets the state of the renderer and scene to its default values.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function resetRendererAndSceneState( renderer, scene, state ) {

  	state = resetRendererState( renderer, state );
  	state = resetSceneState( scene, state );

  	return state;

  }

  /**
   * Restores the state of the given renderer and scene from the given state object.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Object} state - The state to restore.
   */
  function restoreRendererAndSceneState( renderer, scene, state ) {

  	restoreRendererState( renderer, state );
  	restoreSceneState( scene, state );

  }

  const shadowMaterialLib = /*@__PURE__*/ new WeakMap();

  /**
   * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
   * with a binary `[0,1]` result.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @return {Node<float>} The filtering result.
   */
  const BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, depthLayer } ) => {

  	let basic = texture( depthTexture, shadowCoord.xy ).label( 't_basic' );

  	if ( depthTexture.isArrayTexture ) {

  		basic = basic.depth( depthLayer );

  	}

  	return basic.compare( shadowCoord.z );

  } );

  /**
   * A shadow filtering function performing PCF filtering.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The filtering result.
   */
  const PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow, depthLayer } ) => {

  	const depthCompare = ( uv, compare ) => {

  		let depth = texture( depthTexture, uv );

  		if ( depthTexture.isArrayTexture ) {

  			depth = depth.depth( depthLayer );

  		}

  		return depth.compare( compare );

  	};

  	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );
  	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );

  	const texelSize = vec2( 1 ).div( mapSize );
  	const dx0 = texelSize.x.negate().mul( radius );
  	const dy0 = texelSize.y.negate().mul( radius );
  	const dx1 = texelSize.x.mul( radius );
  	const dy1 = texelSize.y.mul( radius );
  	const dx2 = dx0.div( 2 );
  	const dy2 = dy0.div( 2 );
  	const dx3 = dx1.div( 2 );
  	const dy3 = dy1.div( 2 );

  	return add(
  		depthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy, shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )
  	).mul( 1 / 17 );

  } );

  /**
   * A shadow filtering function performing PCF soft filtering.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The filtering result.
   */
  const PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow, depthLayer } ) => {

  	const depthCompare = ( uv, compare ) => {

  		let depth = texture( depthTexture, uv );

  		if ( depthTexture.isArrayTexture ) {

  			depth = depth.depth( depthLayer );

  		}

  		return depth.compare( compare );

  	};


  	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

  	const texelSize = vec2( 1 ).div( mapSize );
  	const dx = texelSize.x;
  	const dy = texelSize.y;

  	const uv = shadowCoord.xy;
  	const f = fract( uv.mul( mapSize ).add( 0.5 ) );
  	uv.subAssign( f.mul( texelSize ) );

  	return add(
  		depthCompare( uv, shadowCoord.z ),
  		depthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),
  		depthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),
  		depthCompare( uv.add( texelSize ), shadowCoord.z ),
  		mix$2(
  			depthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),
  			f.x
  		),
  		mix$2(
  			depthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),
  			f.x
  		),
  		mix$2(
  			depthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),
  			f.y
  		),
  		mix$2(
  			depthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),
  			f.y
  		),
  		mix$2(
  			mix$2(
  				depthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),
  				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),
  				f.x
  			),
  			mix$2(
  				depthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),
  				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),
  				f.x
  			),
  			f.y
  		)
  	).mul( 1 / 9 );

  } );

  /**
   * A shadow filtering function performing VSM filtering.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @return {Node<float>} The filtering result.
   */
  const VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, depthLayer } ) => {

  	const occlusion = float( 1 ).toVar();

  	let distribution = texture( depthTexture ).sample( shadowCoord.xy );

  	if ( depthTexture.isArrayTexture ) {

  		distribution = distribution.depth( depthLayer );

  	}

  	distribution = distribution.rg;

  	const hardShadow = step( shadowCoord.z, distribution.x );

  	If( hardShadow.notEqual( float( 1.0 ) ), () => {

  		const distance = shadowCoord.z.sub( distribution.x );
  		const variance = max$1( 0, distribution.y.mul( distribution.y ) );
  		let softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality
  		softnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );
  		occlusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );

  	} );

  	return occlusion;

  } );

  //

  const linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {

  	let dist = positionWorld.sub( position ).length();
  	dist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );
  	dist = dist.saturate(); // clamp to [ 0, 1 ]

  	return dist;

  } );

  const linearShadowDistance = ( light ) => {

  	const camera = light.shadow.camera;

  	const nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );
  	const farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );

  	const referencePosition = objectPosition( light );

  	return linearDistance( referencePosition, nearDistance, farDistance );

  };

  /**
   * Retrieves or creates a shadow material for the given light source.
   *
   * This function checks if a shadow material already exists for the provided light.
   * If not, it creates a new `NodeMaterial` configured for shadow rendering and stores it
   * in the `shadowMaterialLib` for future use.
   *
   * @param {Light} light - The light source for which the shadow material is needed.
   *                         If the light is a point light, a depth node is calculated
   *                         using the linear shadow distance.
   * @returns {NodeMaterial} The shadow material associated with the given light.
   */
  const getShadowMaterial = ( light ) => {

  	let material = shadowMaterialLib.get( light );

  	if ( material === undefined ) {

  		const depthNode = light.isPointLight ? linearShadowDistance( light ) : null;

  		material = new NodeMaterial();
  		material.colorNode = vec4( 0, 0, 0, 1 );
  		material.depthNode = depthNode;
  		material.isShadowPassMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode
  		material.name = 'ShadowMaterial';
  		material.fog = false;

  		shadowMaterialLib.set( light, material );

  	}

  	return material;

  };

  //

  const _shadowRenderObjectLibrary = /*@__PURE__*/ new ChainMap();
  const _shadowRenderObjectKeys = [];

  /**
   * Creates a function to render shadow objects in a scene.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {LightShadow} shadow - The light shadow object containing shadow properties.
   * @param {number} shadowType - The type of shadow map (e.g., BasicShadowMap).
   * @param {boolean} useVelocity - Whether to use velocity data for rendering.
   * @return {Function} A function that renders shadow objects.
   *
   * The returned function has the following parameters:
   * @param {Object3D} object - The 3D object to render.
   * @param {Scene} scene - The scene containing the object.
   * @param {Camera} _camera - The camera used for rendering.
   * @param {BufferGeometry} geometry - The geometry of the object.
   * @param {Material} material - The material of the object.
   * @param {Group} group - The group the object belongs to.
   * @param {...any} params - Additional parameters for rendering.
   */
  const getShadowRenderObjectFunction = ( renderer, shadow, shadowType, useVelocity ) => {

  	_shadowRenderObjectKeys[ 0 ] = renderer;
  	_shadowRenderObjectKeys[ 1 ] = shadow;

  	let renderObjectFunction = _shadowRenderObjectLibrary.get( _shadowRenderObjectKeys );

  	if ( renderObjectFunction === undefined || ( renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity ) ) {

  		renderObjectFunction = ( object, scene, _camera, geometry, material, group, ...params ) => {

  			if ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {

  				if ( useVelocity ) {

  					getDataFromObject( object ).useVelocity = true;

  				}

  				object.onBeforeShadow( renderer, object, _camera, shadow.camera, geometry, scene.overrideMaterial, group );

  				renderer.renderObject( object, scene, _camera, geometry, material, group, ...params );

  				object.onAfterShadow( renderer, object, _camera, shadow.camera, geometry, scene.overrideMaterial, group );

  			}

  		};

  		renderObjectFunction.shadowType = shadowType;
  		renderObjectFunction.useVelocity = useVelocity;

  		_shadowRenderObjectLibrary.set( _shadowRenderObjectKeys, renderObjectFunction );

  	}

  	_shadowRenderObjectKeys[ 0 ] = null;
  	_shadowRenderObjectKeys[ 1 ] = null;

  	return renderObjectFunction;

  };

  /**
   * Represents the shader code for the first VSM render pass.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {Node<float>} inputs.samples - The number of samples
   * @param {Node<float>} inputs.radius - The radius.
   * @param {Node<float>} inputs.size - The size.
   * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.
   * @return {Node<vec2>} The VSM output.
   */
  const VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass, depthLayer } ) => {

  	const mean = float( 0 ).toVar( 'meanVertical' );
  	const squaredMean = float( 0 ).toVar( 'squareMeanVertical' );

  	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
  	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( -1 ) );

  	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

  		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

  		let depth = shadowPass.sample( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) );

  		if ( shadowPass.value.isArrayTexture ) {

  			depth = depth.depth( depthLayer );

  		}

  		depth = depth.x;

  		mean.addAssign( depth );
  		squaredMean.addAssign( depth.mul( depth ) );

  	} );

  	mean.divAssign( samples );
  	squaredMean.divAssign( samples );

  	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
  	return vec2( mean, std_dev );

  } );

  /**
   * Represents the shader code for the second VSM render pass.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {Node<float>} inputs.samples - The number of samples
   * @param {Node<float>} inputs.radius - The radius.
   * @param {Node<float>} inputs.size - The size.
   * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.
   * @return {Node<vec2>} The VSM output.
   */
  const VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass, depthLayer } ) => {

  	const mean = float( 0 ).toVar( 'meanHorizontal' );
  	const squaredMean = float( 0 ).toVar( 'squareMeanHorizontal' );

  	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
  	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( -1 ) );

  	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

  		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

  		let distribution = shadowPass.sample( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );

  		if ( shadowPass.value.isArrayTexture ) {

  			distribution = distribution.depth( depthLayer );

  		}

  		mean.addAssign( distribution.x );
  		squaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );

  	} );

  	mean.divAssign( samples );
  	squaredMean.divAssign( samples );

  	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
  	return vec2( mean, std_dev );

  } );

  const _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];

  //

  let _rendererState;
  const _quadMesh = /*@__PURE__*/ new QuadMesh();

  /**
   * Represents the default shadow implementation for lighting nodes.
   *
   * @augments ShadowBaseNode
   */
  class ShadowNode extends ShadowBaseNode {

  	static get type() {

  		return 'ShadowNode';

  	}

  	/**
  	 * Constructs a new shadow node.
  	 *
  	 * @param {Light} light - The shadow casting light.
  	 * @param {?LightShadow} [shadow=null] - An optional light shadow.
  	 */
  	constructor( light, shadow = null ) {

  		super( light );

  		/**
  		 * The light shadow which defines the properties light's
  		 * shadow.
  		 *
  		 * @type {?LightShadow}
  		 * @default null
  		 */
  		this.shadow = shadow || light.shadow;

  		/**
  		 * A reference to the shadow map which is a render target.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.shadowMap = null;

  		/**
  		 * Only relevant for VSM shadows. Render target for the
  		 * first VSM render pass.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.vsmShadowMapVertical = null;

  		/**
  		 * Only relevant for VSM shadows. Render target for the
  		 * second VSM render pass.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.vsmShadowMapHorizontal = null;

  		/**
  		 * Only relevant for VSM shadows. Node material which
  		 * is used to render the first VSM pass.
  		 *
  		 * @type {?NodeMaterial}
  		 * @default null
  		 */
  		this.vsmMaterialVertical = null;

  		/**
  		 * Only relevant for VSM shadows. Node material which
  		 * is used to render the second VSM pass.
  		 *
  		 * @type {?NodeMaterial}
  		 * @default null
  		 */
  		this.vsmMaterialHorizontal = null;

  		/**
  		 * A reference to the output node which defines the
  		 * final result of this shadow node.
  		 *
  		 * @type {?Node}
  		 * @private
  		 * @default null
  		 */
  		this._node = null;

  		this._cameraFrameId = new WeakMap();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isShadowNode = true;

  		/**
  		 * This index can be used when overriding setupRenderTarget with a RenderTarget Array to specify the depth layer.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default true
  		 */
  		this.depthLayer = 0;

  	}

  	/**
  	 * Setups the shadow filtering.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @param {Object} inputs - A configuration object that defines the shadow filtering.
  	 * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
  	 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
  	 * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
  	 * @param {LightShadow} inputs.shadow - The light shadow.
  	 * @return {Node<float>} The result node of the shadow filtering.
  	 */
  	setupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow, depthLayer } ) {

  		const frustumTest = shadowCoord.x.greaterThanEqual( 0 )
  			.and( shadowCoord.x.lessThanEqual( 1 ) )
  			.and( shadowCoord.y.greaterThanEqual( 0 ) )
  			.and( shadowCoord.y.lessThanEqual( 1 ) )
  			.and( shadowCoord.z.lessThanEqual( 1 ) );

  		const shadowNode = filterFn( { depthTexture, shadowCoord, shadow, depthLayer } );

  		return frustumTest.select( shadowNode, float( 1 ) );

  	}

  	/**
  	 * Setups the shadow coordinates.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
  	 * @return {Node<vec3>} The shadow coordinates.
  	 */
  	setupShadowCoord( builder, shadowPosition ) {

  		const { shadow } = this;
  		const { renderer } = builder;

  		const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );

  		let shadowCoord = shadowPosition;
  		let coordZ;

  		if ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {

  			shadowCoord = shadowCoord.xyz.div( shadowCoord.w );

  			coordZ = shadowCoord.z;

  			if ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {

  				coordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]

  			}

  		} else {

  			const w = shadowCoord.w;
  			shadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z

  			// The normally available "cameraNear" and "cameraFar" nodes cannot be used here because they do not get
  			// updated to use the shadow camera. So, we have to declare our own "local" ones here.
  			// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?
  			const cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );
  			const cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );

  			coordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );

  		}

  		shadowCoord = vec3(
  			shadowCoord.x,
  			shadowCoord.y.oneMinus(), // follow webgpu standards
  			coordZ.add( bias )
  		);

  		return shadowCoord;

  	}

  	/**
  	 * Returns the shadow filtering function for the given shadow type.
  	 *
  	 * @param {number} type - The shadow type.
  	 * @return {Function} The filtering function.
  	 */
  	getShadowFilterFn( type ) {

  		return _shadowFilterLib[ type ];

  	}


  	setupRenderTarget( shadow, builder ) {

  		const depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );
  		depthTexture.name = 'ShadowDepthTexture';
  		depthTexture.compareFunction = LessCompare;

  		const shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );
  		shadowMap.texture.name = 'ShadowMap';
  		shadowMap.texture.type = shadow.mapType;
  		shadowMap.depthTexture = depthTexture;

  		return { shadowMap, depthTexture };

  	}

  	/**
  	 * Setups the shadow output node.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @return {Node<vec3>} The shadow output node.
  	 */
  	setupShadow( builder ) {

  		const { renderer } = builder;

  		const { light, shadow } = this;

  		const shadowMapType = renderer.shadowMap.type;

  		const { depthTexture, shadowMap } = this.setupRenderTarget( shadow, builder );

  		shadow.camera.updateProjectionMatrix();

  		// VSM

  		if ( shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true ) {

  			depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()

  			if ( shadowMap.depth > 1 ) {

  				if ( ! shadowMap._vsmShadowMapVertical ) {

  					shadowMap._vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false } );
  					shadowMap._vsmShadowMapVertical.texture.name = 'VSMVertical';

  				}

  				this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;

  				if ( ! shadowMap._vsmShadowMapHorizontal ) {

  					shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false } );
  					shadowMap._vsmShadowMapHorizontal.texture.name = 'VSMHorizontal';

  				}

  				this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;

  			} else {

  				this.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false } );
  				this.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false } );

  			}


  			let shadowPassVertical = texture( depthTexture );

  			if ( depthTexture.isArrayTexture ) {

  				shadowPassVertical = shadowPassVertical.depth( this.depthLayer );

  			}

  			let shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );

  			if ( depthTexture.isArrayTexture ) {

  				shadowPassHorizontal = shadowPassHorizontal.depth( this.depthLayer );

  			}

  			const samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );
  			const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
  			const size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

  			let material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );
  			material.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical, depthLayer: this.depthLayer } ).context( builder.getSharedContext() );
  			material.name = 'VSMVertical';

  			material = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );
  			material.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer } ).context( builder.getSharedContext() );
  			material.name = 'VSMHorizontal';

  		}

  		//

  		const shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );
  		const normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );

  		const shadowPosition = lightShadowMatrix( light ).mul( shadowPositionWorld.add( normalWorld.mul( normalBias ) ) );
  		const shadowCoord = this.setupShadowCoord( builder, shadowPosition );

  		//

  		const filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;

  		if ( filterFn === null ) {

  			throw new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );

  		}

  		const shadowDepthTexture = ( shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true ) ? this.vsmShadowMapHorizontal.texture : depthTexture;

  		const shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow, depthLayer: this.depthLayer } );

  		let shadowColor = texture( shadowMap.texture, shadowCoord );

  		if ( depthTexture.isArrayTexture ) {

  			shadowColor = shadowColor.depth( this.depthLayer );

  		}

  		const shadowOutput = mix$2( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();

  		this.shadowMap = shadowMap;
  		this.shadow.map = shadowMap;

  		return shadowOutput;

  	}

  	/**
  	 * The implementation performs the setup of the output node. An output is only
  	 * produces if shadow mapping is globally enabled in the renderer.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @return {ShaderCallNodeInternal} The output node.
  	 */
  	setup( builder ) {

  		if ( builder.renderer.shadowMap.enabled === false ) return;

  		return Fn( () => {

  			let node = this._node;

  			this.setupShadowPosition( builder );

  			if ( node === null ) {

  				this._node = node = this.setupShadow( builder );

  			}

  			if ( builder.material.shadowNode ) { // @deprecated, r171

  				console.warn( 'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.' );

  			}

  			if ( builder.material.receivedShadowNode ) {

  				node = builder.material.receivedShadowNode( node );

  			}

  			return node;

  		} )();

  	}

  	/**
  	 * Renders the shadow. The logic of this function could be included
  	 * into {@link ShadowNode#updateShadow} however more specialized shadow
  	 * nodes might require a custom shadow map rendering. By having a
  	 * dedicated method, it's easier to overwrite the default behavior.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	renderShadow( frame ) {

  		const { shadow, shadowMap, light } = this;
  		const { renderer, scene } = frame;

  		shadow.updateMatrices( light );

  		shadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height, shadowMap.depth );

  		renderer.render( scene, shadow.camera );

  	}

  	/**
  	 * Updates the shadow.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	updateShadow( frame ) {

  		const { shadowMap, light, shadow } = this;
  		const { renderer, scene, camera } = frame;

  		const shadowType = renderer.shadowMap.type;

  		const depthVersion = shadowMap.depthTexture.version;
  		this._depthVersionCached = depthVersion;

  		const _shadowCameraLayer = shadow.camera.layers.mask;

  		if ( ( shadow.camera.layers.mask & 0xFFFFFFFE ) === 0 ) {

  			shadow.camera.layers.mask = camera.layers.mask;

  		}

  		const currentRenderObjectFunction = renderer.getRenderObjectFunction();

  		const currentMRT = renderer.getMRT();
  		const useVelocity = currentMRT ? currentMRT.has( 'velocity' ) : false;

  		_rendererState = resetRendererAndSceneState( renderer, scene, _rendererState );

  		scene.overrideMaterial = getShadowMaterial( light );

  		renderer.setRenderObjectFunction( getShadowRenderObjectFunction( renderer, shadow, shadowType, useVelocity ) );

  		renderer.setClearColor( 0x000000, 0 );

  		renderer.setRenderTarget( shadowMap );

  		this.renderShadow( frame );

  		renderer.setRenderObjectFunction( currentRenderObjectFunction );

  		// vsm blur pass

  		if ( shadowType === VSMShadowMap && shadow.isPointLightShadow !== true ) {

  			this.vsmPass( renderer );

  		}

  		shadow.camera.layers.mask = _shadowCameraLayer;

  		restoreRendererAndSceneState( renderer, scene, _rendererState );

  	}

  	/**
  	 * For VSM additional render passes are required.
  	 *
  	 * @param {Renderer} renderer - A reference to the current renderer.
  	 */
  	vsmPass( renderer ) {

  		const { shadow } = this;

  		const depth = this.shadowMap.depth;
  		this.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height, depth );
  		this.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height, depth );

  		renderer.setRenderTarget( this.vsmShadowMapVertical );
  		_quadMesh.material = this.vsmMaterialVertical;
  		_quadMesh.render( renderer );

  		renderer.setRenderTarget( this.vsmShadowMapHorizontal );
  		_quadMesh.material = this.vsmMaterialHorizontal;
  		_quadMesh.render( renderer );

  	}

  	/**
  	 * Frees the internal resources of this shadow node.
  	 */
  	dispose() {

  		this.shadowMap.dispose();
  		this.shadowMap = null;

  		if ( this.vsmShadowMapVertical !== null ) {

  			this.vsmShadowMapVertical.dispose();
  			this.vsmShadowMapVertical = null;

  			this.vsmMaterialVertical.dispose();
  			this.vsmMaterialVertical = null;

  		}

  		if ( this.vsmShadowMapHorizontal !== null ) {

  			this.vsmShadowMapHorizontal.dispose();
  			this.vsmShadowMapHorizontal = null;

  			this.vsmMaterialHorizontal.dispose();
  			this.vsmMaterialHorizontal = null;

  		}

  		super.dispose();

  	}

  	/**
  	 * The implementation performs the update of the shadow map if necessary.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	updateBefore( frame ) {

  		const { shadow } = this;

  		let needsUpdate = shadow.needsUpdate || shadow.autoUpdate;

  		if ( needsUpdate ) {

  			if ( this._cameraFrameId[ frame.camera ] === frame.frameId ) {

  				needsUpdate = false;

  			}

  			this._cameraFrameId[ frame.camera ] = frame.frameId;

  		}

  		if ( needsUpdate ) {

  			this.updateShadow( frame );

  			if ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {

  				shadow.needsUpdate = false;

  			}

  		}

  	}

  }

  /**
   * TSL function for creating an instance of `ShadowNode`.
   *
   * @tsl
   * @function
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow] - The light shadow.
   * @return {ShadowNode} The created shadow node.
   */
  const shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );

  const _clearColor$1 = /*@__PURE__*/ new Color();

  // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
  // vector suitable for 2D texture mapping. This code uses the following layout for the
  // 2D texture:
  //
  // xzXZ
  //  y Y
  //
  // Y - Positive y direction
  // y - Negative y direction
  // X - Positive x direction
  // x - Negative x direction
  // Z - Positive z direction
  // z - Negative z direction
  //
  // Source and test bed:
  // https://gist.github.com/tschw/da10c43c467ce8afd0c4

  const cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {

  	const v = pos.toVar();

  	// Number of texels to avoid at the edge of each square

  	const absV = abs( v );

  	// Intersect unit cube

  	const scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );
  	absV.mulAssign( scaleToCube );

  	// Apply scale to avoid seams

  	// two texels less per square (one texel will do for NEAREST)
  	v.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );

  	// Unwrap

  	// space: -1 ... 1 range for each square
  	//
  	// #X##		dim    := ( 4 , 2 )
  	//  # #		center := ( 1 , 1 )

  	const planar = vec2( v.xy ).toVar();

  	const almostATexel = texelSizeY.mul( 1.5 );
  	const almostOne = almostATexel.oneMinus();

  	If( absV.z.greaterThanEqual( almostOne ), () => {

  		If( v.z.greaterThan( 0.0 ), () => {

  			planar.x.assign( sub( 4.0, v.x ) );

  		} );

  	} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {

  		const signX = sign( v.x );
  		planar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );

  	} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {

  		const signY = sign( v.y );
  		planar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );
  		planar.y.assign( v.z.mul( signY ).sub( 2.0 ) );

  	} );

  	// Transform to UV space

  	// scale := 0.5 / dim
  	// translate := ( center + 0.5 ) / dim
  	return vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();

  } ).setLayout( {
  	name: 'cubeToUV',
  	type: 'vec2',
  	inputs: [
  		{ name: 'pos', type: 'vec3' },
  		{ name: 'texelSizeY', type: 'float' }
  	]
  } );

  const BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {

  	return texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );

  } );

  const PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {

  	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
  	const offset = vec2( -1, 1.0 ).mul( radius ).mul( texelSize.y );

  	return texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )
  		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )
  		.mul( 1.0 / 9.0 );

  } );

  const pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {

  	// for point lights, the uniform @vShadowCoord is re-purposed to hold
  	// the vector from the light to the world-space position of the fragment.
  	const lightToPosition = shadowCoord.xyz.toVar();
  	const lightToPositionLength = lightToPosition.length();

  	const cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );
  	const cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );
  	const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );
  	const mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );

  	const result = float( 1.0 ).toVar();

  	If( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {

  		// dp = normalized distance from light to fragment position
  		const dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?
  		dp.addAssign( bias );

  		// bd3D = base direction 3D
  		const bd3D = lightToPosition.normalize();
  		const texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );

  		// percentage-closer filtering
  		result.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );

  	} );

  	return result;

  } );

  const _viewport = /*@__PURE__*/ new Vector4();
  const _viewportSize = /*@__PURE__*/ new Vector2();
  const _shadowMapSize = /*@__PURE__*/ new Vector2();


  /**
   * Represents the shadow implementation for point light nodes.
   *
   * @augments ShadowNode
   */
  class PointShadowNode extends ShadowNode {

  	static get type() {

  		return 'PointShadowNode';

  	}

  	/**
  	 * Constructs a new point shadow node.
  	 *
  	 * @param {PointLight} light - The shadow casting point light.
  	 * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
  	 */
  	constructor( light, shadow = null ) {

  		super( light, shadow );

  	}

  	/**
  	 * Overwrites the default implementation to return point light shadow specific
  	 * filtering functions.
  	 *
  	 * @param {number} type - The shadow type.
  	 * @return {Function} The filtering function.
  	 */
  	getShadowFilterFn( type ) {

  		return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;

  	}

  	/**
  	 * Overwrites the default implementation so the unaltered shadow position is used.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
  	 * @return {Node<vec3>} The shadow coordinates.
  	 */
  	setupShadowCoord( builder, shadowPosition ) {

  		return shadowPosition;

  	}

  	/**
  	 * Overwrites the default implementation to only use point light specific
  	 * shadow filter functions.
  	 *
  	 * @param {NodeBuilder} builder - A reference to the current node builder.
  	 * @param {Object} inputs - A configuration object that defines the shadow filtering.
  	 * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
  	 * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
  	 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
  	 * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
  	 * @param {LightShadow} inputs.shadow - The light shadow.
  	 * @return {Node<float>} The result node of the shadow filtering.
  	 */
  	setupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {

  		return pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );

  	}

  	/**
  	 * Overwrites the default implementation with point light specific
  	 * rendering code.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	renderShadow( frame ) {

  		const { shadow, shadowMap, light } = this;
  		const { renderer, scene } = frame;

  		const shadowFrameExtents = shadow.getFrameExtents();

  		_shadowMapSize.copy( shadow.mapSize );
  		_shadowMapSize.multiply( shadowFrameExtents );

  		shadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );

  		_viewportSize.copy( shadow.mapSize );

  		//

  		const previousAutoClear = renderer.autoClear;

  		const previousClearColor = renderer.getClearColor( _clearColor$1 );
  		const previousClearAlpha = renderer.getClearAlpha();

  		renderer.autoClear = false;
  		renderer.setClearColor( shadow.clearColor, shadow.clearAlpha );
  		renderer.clear();

  		const viewportCount = shadow.getViewportCount();

  		for ( let vp = 0; vp < viewportCount; vp ++ ) {

  			const viewport = shadow.getViewport( vp );

  			const x = _viewportSize.x * viewport.x;
  			const y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );

  			_viewport.set(
  				x,
  				y,
  				_viewportSize.x * viewport.z,
  				_viewportSize.y * viewport.w
  			);

  			shadowMap.viewport.copy( _viewport );

  			shadow.updateMatrices( light, vp );

  			renderer.render( scene, shadow.camera );

  		}

  		//

  		renderer.autoClear = previousAutoClear;
  		renderer.setClearColor( previousClearColor, previousClearAlpha );

  	}

  }

  /**
   * TSL function for creating an instance of `PointShadowNode`.
   *
   * @tsl
   * @function
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   * @return {PointShadowNode} The created point shadow node.
   */
  const pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );

  /**
   * Base class for analytic light nodes.
   *
   * @augments LightingNode
   */
  class AnalyticLightNode extends LightingNode {

  	static get type() {

  		return 'AnalyticLightNode';

  	}

  	/**
  	 * Constructs a new analytic light node.
  	 *
  	 * @param {?Light} [light=null] - The light source.
  	 */
  	constructor( light = null ) {

  		super();

  		/**
  		 * The light source.
  		 *
  		 * @type {?Light}
  		 * @default null
  		 */
  		this.light = light;

  		/**
  		 * The light's color value.
  		 *
  		 * @type {Color}
  		 */
  		this.color = new Color();

  		/**
  		 * The light's color node. Points to `colorNode` of the light source, if set. Otherwise
  		 * it creates a uniform node based on {@link AnalyticLightNode#color}.
  		 *
  		 * @type {Node}
  		 */
  		this.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );

  		/**
  		 * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.
  		 * The final color node is represented by a different node when using shadows.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.baseColorNode = null;

  		/**
  		 * Represents the light's shadow.
  		 *
  		 * @type {?ShadowNode}
     		 * @default null
  		 */
  		this.shadowNode = null;

  		/**
  		 * Represents the light's shadow color.
  		 *
  		 * @type {?Node}
     		 * @default null
  		 */
  		this.shadowColorNode = null;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isAnalyticLightNode = true;

  		/**
  		 * Overwritten since analytic light nodes are updated
  		 * once per frame.
  		 *
  		 * @type {string}
  		 * @default 'frame'
  		 */
  		this.updateType = NodeUpdateType.FRAME;

  	}

  	getHash() {

  		return this.light.uuid;

  	}

  	/**
  	 * Returns a node representing a direction vector which points from the current
  	 * position in view space to the light's position in view space.
  	 *
  	 * @param {NodeBuilder} builder - The builder object used for setting up the light.
  	 * @return {Node<vec3>} The light vector node.
  	 */
  	getLightVector( builder ) {

  		return lightViewPosition( this.light ).sub( builder.context.positionView || positionView );

  	}

  	/**
  	 * Sets up the direct lighting for the analytic light node.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The builder object used for setting up the light.
  	 * @return {Object|undefined} The direct light data (color and direction).
  	 */
  	setupDirect( /*builder*/ ) { }

  	/**
  	 * Sets up the direct rect area lighting for the analytic light node.
  	 *
  	 * @abstract
  	 * @param {NodeBuilder} builder - The builder object used for setting up the light.
  	 * @return {Object|undefined} The direct rect area light data.
  	 */
  	setupDirectRectArea( /*builder*/ ) { }

  	/**
  	 * Setups the shadow node for this light. The method exists so concrete light classes
  	 * can setup different types of shadow nodes.
  	 *
  	 * @return {ShadowNode} The created shadow node.
  	 */
  	setupShadowNode() {

  		return shadow( this.light );

  	}

  	/**
  	 * Setups the shadow for this light. This method is only executed if the light
  	 * cast shadows and the current build object receives shadows. It incorporates
  	 * shadows into the lighting computation.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setupShadow( builder ) {

  		const { renderer } = builder;

  		if ( renderer.shadowMap.enabled === false ) return;

  		let shadowColorNode = this.shadowColorNode;

  		if ( shadowColorNode === null ) {

  			const customShadowNode = this.light.shadow.shadowNode;

  			let shadowNode;

  			if ( customShadowNode !== undefined ) {

  				shadowNode = nodeObject( customShadowNode );

  			} else {

  				shadowNode = this.setupShadowNode();

  			}

  			this.shadowNode = shadowNode;

  			this.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );

  			this.baseColorNode = this.colorNode;

  		}

  		//

  		this.colorNode = shadowColorNode;

  	}

  	/**
  	 * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
  	 * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
  	 * invocate the respective interface methods.
  	 *
  	 * @param {NodeBuilder} builder - The current node builder.
  	 */
  	setup( builder ) {

  		this.colorNode = this.baseColorNode || this.colorNode;

  		if ( this.light.castShadow ) {

  			if ( builder.object.receiveShadow ) {

  				this.setupShadow( builder );

  			}

  		} else if ( this.shadowNode !== null ) {

  			this.shadowNode.dispose();
  			this.shadowNode = null;
  			this.shadowColorNode = null;

  		}

  		const directLightData = this.setupDirect( builder );
  		const directRectAreaLightData = this.setupDirectRectArea( builder );

  		if ( directLightData ) {

  			builder.lightsNode.setupDirectLight( builder, this, directLightData );

  		}

  		if ( directRectAreaLightData ) {

  			builder.lightsNode.setupDirectRectAreaLight( builder, this, directRectAreaLightData );

  		}

  	}

  	/**
  	 * The update method is used to update light uniforms per frame.
  	 * Potentially overwritten in concrete light nodes to update light
  	 * specific uniforms.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( /*frame*/ ) {

  		const { light } = this;

  		this.color.copy( light.color ).multiplyScalar( light.intensity );

  	}

  }

  /**
   * Represents a `discard` shader operation in TSL.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.
   * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.
   * @param {Node<float>} inputs.decayExponent - The light's decay exponent.
   * @return {Node<float>} The distance falloff.
   */
  const getDistanceAttenuation = /*@__PURE__*/ Fn( ( { lightDistance, cutoffDistance, decayExponent } ) => {

  	// based upon Frostbite 3 Moving to Physically-based Rendering
  	// page 32, equation 26: E[window1]
  	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  	const distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();

  	return cutoffDistance.greaterThan( 0 ).select(
  		distanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),
  		distanceFalloff
  	);

  } ); // validated

  const directPointLight = ( { color, lightVector, cutoffDistance, decayExponent } ) => {

  	const lightDirection = lightVector.normalize();
  	const lightDistance = lightVector.length();

  	const attenuation = getDistanceAttenuation( {
  		lightDistance,
  		cutoffDistance,
  		decayExponent
  	} );

  	const lightColor = color.mul( attenuation );

  	return { lightDirection, lightColor };

  };

  /**
   * Module for representing point lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  class PointLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'PointLightNode';

  	}

  	/**
  	 * Constructs a new point light node.
  	 *
  	 * @param {?PointLight} [light=null] - The point light source.
  	 */
  	constructor( light = null ) {

  		super( light );

  		/**
  		 * Uniform node representing the cutoff distance.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );

  		/**
  		 * Uniform node representing the decay exponent.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.decayExponentNode = uniform( 2 ).setGroup( renderGroup );

  	}

  	/**
  	 * Overwritten to updated point light specific uniforms.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( frame ) {

  		const { light } = this;

  		super.update( frame );

  		this.cutoffDistanceNode.value = light.distance;
  		this.decayExponentNode.value = light.decay;

  	}

  	/**
  	 * Overwritten to setup point light specific shadow.
  	 *
  	 * @return {PointShadowNode}
  	 */
  	setupShadowNode() {

  		return pointShadow( this.light );

  	}

  	setupDirect( builder ) {

  		return directPointLight( {
  			color: this.colorNode,
  			lightVector: this.getLightVector( builder ),
  			cutoffDistance: this.cutoffDistanceNode,
  			decayExponent: this.decayExponentNode
  		} );

  	}

  }

  /**
   * Generates a circle based on the uv coordinates.
   *
   * @tsl
   * @function
   * @param {Node<vec2>} coord - The uv to generate the circle.
   * @return {Node<float>} The circle shape.
   */
  Fn( ( [ coord = uv$1() ], { renderer, material } ) => {

  	const len2 = lengthSq( coord.mul( 2 ).sub( 1 ) );

  	let alpha;

  	if ( material.alphaToCoverage && renderer.samples > 1 ) {

  		const dlen = float( len2.fwidth() ).toVar();

  		alpha = smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus();

  	} else {

  		alpha = select$1( len2.greaterThan( 1.0 ), 0, 1 );

  	}

  	return alpha;

  } );

  const getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {

  	// normal is assumed to have unit length

  	const x = normal.x, y = normal.y, z = normal.z;

  	// band 0
  	let result = shCoefficients.element( 0 ).mul( 0.886227 );

  	// band 1
  	result = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );
  	result = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );
  	result = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );

  	// band 2
  	result = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );
  	result = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );
  	result = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );
  	result = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );
  	result = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );

  	return result;

  } );

  const _clearColor = /*@__PURE__*/ new Color4();

  /**
   * This renderer module manages the background.
   *
   * @private
   * @augments DataMap
   */
  class Background extends DataMap {

  	/**
  	 * Constructs a new background management component.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Nodes} nodes - Renderer component for managing nodes related logic.
  	 */
  	constructor( renderer, nodes ) {

  		super();

  		/**
  		 * The renderer.
  		 *
  		 * @type {Renderer}
  		 */
  		this.renderer = renderer;

  		/**
  		 * Renderer component for managing nodes related logic.
  		 *
  		 * @type {Nodes}
  		 */
  		this.nodes = nodes;

  	}

  	/**
  	 * Updates the background for the given scene. Depending on how `Scene.background`
  	 * or `Scene.backgroundNode` are configured, this method might configure a simple clear
  	 * or add a mesh to the render list for rendering the background as a textured plane
  	 * or skybox.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @param {RenderList} renderList - The current render list.
  	 * @param {RenderContext} renderContext - The current render context.
  	 */
  	update( scene, renderList, renderContext ) {

  		const renderer = this.renderer;
  		const background = this.nodes.getBackgroundNode( scene ) || scene.background;

  		let forceClear = false;

  		if ( background === null ) {

  			// no background settings, use clear color configuration from the renderer

  			renderer._clearColor.getRGB( _clearColor );
  			_clearColor.a = renderer._clearColor.a;

  		} else if ( background.isColor === true ) {

  			// background is an opaque color

  			background.getRGB( _clearColor );
  			_clearColor.a = 1;

  			forceClear = true;

  		} else if ( background.isNode === true ) {

  			const sceneData = this.get( scene );
  			const backgroundNode = background;

  			_clearColor.copy( renderer._clearColor );

  			let backgroundMesh = sceneData.backgroundMesh;

  			if ( backgroundMesh === undefined ) {

  				const backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {
  					// @TODO: Add Texture2D support using node context
  					getUV: () => backgroundRotation.mul( normalWorldGeometry ),
  					getTextureLevel: () => backgroundBlurriness
  				} );

  				let viewProj = modelViewProjection;
  				viewProj = viewProj.setZ( viewProj.w );

  				const nodeMaterial = new NodeMaterial();
  				nodeMaterial.name = 'Background.material';
  				nodeMaterial.side = BackSide;
  				nodeMaterial.depthTest = false;
  				nodeMaterial.depthWrite = false;
  				nodeMaterial.allowOverride = false;
  				nodeMaterial.fog = false;
  				nodeMaterial.lights = false;
  				nodeMaterial.vertexNode = viewProj;
  				nodeMaterial.colorNode = backgroundMeshNode;

  				sceneData.backgroundMeshNode = backgroundMeshNode;
  				sceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );
  				backgroundMesh.frustumCulled = false;
  				backgroundMesh.name = 'Background.mesh';

  				backgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					this.matrixWorld.copyPosition( camera.matrixWorld );

  				};

  				function onBackgroundDispose() {

  					background.removeEventListener( 'dispose', onBackgroundDispose );

  					backgroundMesh.material.dispose();
  					backgroundMesh.geometry.dispose();

  				}

  				background.addEventListener( 'dispose', onBackgroundDispose );

  			}

  			const backgroundCacheKey = backgroundNode.getCacheKey();

  			if ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {

  				sceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );
  				sceneData.backgroundMeshNode.needsUpdate = true;

  				backgroundMesh.material.needsUpdate = true;

  				sceneData.backgroundCacheKey = backgroundCacheKey;

  			}

  			renderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );

  		} else {

  			console.error( 'THREE.Renderer: Unsupported background configuration.', background );

  		}

  		//

  		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

  		if ( environmentBlendMode === 'additive' ) {

  			_clearColor.set( 0, 0, 0, 1 );

  		} else if ( environmentBlendMode === 'alpha-blend' ) {

  			_clearColor.set( 0, 0, 0, 0 );

  		}

  		//

  		if ( renderer.autoClear === true || forceClear === true ) {

  			const clearColorValue = renderContext.clearColorValue;

  			clearColorValue.r = _clearColor.r;
  			clearColorValue.g = _clearColor.g;
  			clearColorValue.b = _clearColor.b;
  			clearColorValue.a = _clearColor.a;

  			// premultiply alpha

  			if ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {

  				clearColorValue.r *= clearColorValue.a;
  				clearColorValue.g *= clearColorValue.a;
  				clearColorValue.b *= clearColorValue.a;

  			}

  			//

  			renderContext.depthClearValue = renderer._clearDepth;
  			renderContext.stencilClearValue = renderer._clearStencil;

  			renderContext.clearColor = renderer.autoClearColor === true;
  			renderContext.clearDepth = renderer.autoClearDepth === true;
  			renderContext.clearStencil = renderer.autoClearStencil === true;

  		} else {

  			renderContext.clearColor = false;
  			renderContext.clearDepth = false;
  			renderContext.clearStencil = false;

  		}

  	}

  }

  let _id$6 = 0;

  /**
   * A bind group represents a collection of bindings and thus a collection
   * or resources. Bind groups are assigned to pipelines to provide them
   * with the required resources (like uniform buffers or textures).
   *
   * @private
   */
  class BindGroup {

  	/**
  	 * Constructs a new bind group.
  	 *
  	 * @param {string} name - The bind group's name.
  	 * @param {Array<Binding>} bindings - An array of bindings.
  	 * @param {number} index - The group index.
  	 * @param {Array<Binding>} bindingsReference - An array of reference bindings.
  	 */
  	constructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {

  		/**
  		 * The bind group's name.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * An array of bindings.
  		 *
  		 * @type {Array<Binding>}
  		 */
  		this.bindings = bindings;

  		/**
  		 * The group index.
  		 *
  		 * @type {number}
  		 */
  		this.index = index;

  		/**
  		 * An array of reference bindings.
  		 *
  		 * @type {Array<Binding>}
  		 */
  		this.bindingsReference = bindingsReference;

  		/**
  		 * The group's ID.
  		 *
  		 * @type {number}
  		 */
  		this.id = _id$6 ++;

  	}

  }

  /**
   * This module represents the state of a node builder after it was
   * used to build the nodes for a render object. The state holds the
   * results of the build for further processing in the renderer.
   *
   * Render objects with identical cache keys share the same node builder state.
   *
   * @private
   */
  class NodeBuilderState {

  	/**
  	 * Constructs a new node builder state.
  	 *
  	 * @param {string} vertexShader - The native vertex shader code.
  	 * @param {string} fragmentShader - The native fragment shader code.
  	 * @param {string} computeShader - The native compute shader code.
  	 * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
  	 * @param {Array<BindGroup>} bindings - An array of bind groups.
  	 * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
  	 * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
  	 * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
  	 * @param {NodeMaterialObserver} observer - A node material observer.
  	 * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
  	 */
  	constructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = [] ) {

  		/**
  		 * The native vertex shader code.
  		 *
  		 * @type {string}
  		 */
  		this.vertexShader = vertexShader;

  		/**
  		 * The native fragment shader code.
  		 *
  		 * @type {string}
  		 */
  		this.fragmentShader = fragmentShader;

  		/**
  		 * The native compute shader code.
  		 *
  		 * @type {string}
  		 */
  		this.computeShader = computeShader;

  		/**
  		 * An array with transform attribute objects.
  		 * Only relevant when using compute shaders with WebGL 2.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.transforms = transforms;

  		/**
  		 * An array of node attributes representing
  		 * the attributes of the shaders.
  		 *
  		 * @type {Array<NodeAttribute>}
  		 */
  		this.nodeAttributes = nodeAttributes;

  		/**
  		 * An array of bind groups representing the uniform or storage
  		 * buffers, texture or samplers of the shader.
  		 *
  		 * @type {Array<BindGroup>}
  		 */
  		this.bindings = bindings;

  		/**
  		 * An array of nodes that implement their `update()` method.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.updateNodes = updateNodes;

  		/**
  		 * An array of nodes that implement their `updateBefore()` method.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.updateBeforeNodes = updateBeforeNodes;

  		/**
  		 * An array of nodes that implement their `updateAfter()` method.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.updateAfterNodes = updateAfterNodes;

  		/**
  		 * A node material observer.
  		 *
  		 * @type {NodeMaterialObserver}
  		 */
  		this.observer = observer;

  		/**
  		 * How often this state is used by render objects.
  		 *
  		 * @type {number}
  		 */
  		this.usedTimes = 0;

  	}

  	/**
  	 * This method is used to create a array of bind groups based
  	 * on the existing bind groups of this state. Shared groups are
  	 * not cloned.
  	 *
  	 * @return {Array<BindGroup>} A array of bind groups.
  	 */
  	createBindings() {

  		const bindings = [];

  		for ( const instanceGroup of this.bindings ) {

  			const shared = instanceGroup.bindings[ 0 ].groupNode.shared; // All bindings in the group must have the same groupNode.

  			if ( shared !== true ) {

  				const bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );
  				bindings.push( bindingsGroup );

  				for ( const instanceBinding of instanceGroup.bindings ) {

  					bindingsGroup.bindings.push( instanceBinding.clone() );

  				}

  			} else {

  				bindings.push( instanceGroup );

  			}

  		}

  		return bindings;

  	}

  }

  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader attributes that are going to be generated
   * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}
   * and {@link NodeBuilder#bufferAttributes} for this purpose.
   */
  class NodeAttribute {

  	/**
  	 * Constructs a new node attribute.
  	 *
  	 * @param {string} name - The name of the attribute.
  	 * @param {string} type - The type of the attribute.
  	 * @param {?Node} node - An optional reference to the node.
  	 */
  	constructor( name, type, node = null ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNodeAttribute = true;

  		/**
  		 * The name of the attribute.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The type of the attribute.
  		 *
  		 * @type {string}
  		 */
  		this.type = type;

  		/**
  		 * An optional reference to the node.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.node = node;

  	}

  }

  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader uniforms that are going to be generated
   * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
   * for this purpose.
   */
  class NodeUniform {

  	/**
  	 * Constructs a new node uniform.
  	 *
  	 * @param {string} name - The name of the uniform.
  	 * @param {string} type - The type of the uniform.
  	 * @param {UniformNode} node - An reference to the node.
  	 */
  	constructor( name, type, node ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNodeUniform = true;

  		/**
  		 * The name of the uniform.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The type of the uniform.
  		 *
  		 * @type {string}
  		 */
  		this.type = type;

  		/**
  		 * An reference to the node.
  		 *
  		 * @type {UniformNode}
  		 */
  		this.node = node.getSelf();

  	}

  	/**
  	 * The value of the uniform node.
  	 *
  	 * @type {any}
  	 */
  	get value() {

  		return this.node.value;

  	}

  	set value( val ) {

  		this.node.value = val;

  	}

  	/**
  	 * The id of the uniform node.
  	 *
  	 * @type {number}
  	 */
  	get id() {

  		return this.node.id;

  	}

  	/**
  	 * The uniform node's group.
  	 *
  	 * @type {UniformGroupNode}
  	 */
  	get groupNode() {

  		return this.node.groupNode;

  	}

  }

  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader variables that are going to be generated
   * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for
   * this purpose.
   */
  class NodeVar {

  	/**
  	 * Constructs a new node variable.
  	 *
  	 * @param {string} name - The name of the variable.
  	 * @param {string} type - The type of the variable.
  	 * @param {boolean} [readOnly=false] - The read-only flag.
  	 * @param {?number} [count=null] - The size.
  	 */
  	constructor( name, type, readOnly = false, count = null ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNodeVar = true;

  		/**
  		 * The name of the variable.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The type of the variable.
  		 *
  		 * @type {string}
  		 */
  		this.type = type;

  		/**
  		 *  The read-only flag.
  		 *
  		 * @type {boolean}
  		 */
  		this.readOnly = readOnly;

  		/**
  		 * The size.
  		 *
  		 * @type {?number}
  		 */
  		this.count = count;

  	}

  }

  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader varyings that are going to be generated
   * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for
   * this purpose.
   *
   * @augments NodeVar
   */
  class NodeVarying extends NodeVar {

  	/**
  	 * Constructs a new node varying.
  	 *
  	 * @param {string} name - The name of the varying.
  	 * @param {string} type - The type of the varying.
  	 * @param {?string} interpolationType - The interpolation type of the varying.
  	 * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
  	 */
  	constructor( name, type, interpolationType = null, interpolationSampling = null ) {

  		super( name, type );

  		/**
  		 * Whether this varying requires interpolation or not. This property can be used
  		 * to check if the varying can be optimized for a variable.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.needsInterpolation = false;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNodeVarying = true;

  		/**
  		 * The interpolation type of the varying data.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.interpolationType = interpolationType;

  		/**
  		 * The interpolation sampling type of varying data.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.interpolationSampling = interpolationSampling;

  	}

  }

  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent user-defined, native shader code portions that are going to be
   * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}
   * for this purpose.
   */
  class NodeCode {

  	/**
  	 * Constructs a new code node.
  	 *
  	 * @param {string} name - The name of the code.
  	 * @param {string} type - The node type.
  	 * @param {string} [code=''] - The native shader code.
  	 */
  	constructor( name, type, code = '' ) {

  		/**
  		 * The name of the code.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The node type.
  		 *
  		 * @type {string}
  		 */
  		this.type = type;

  		/**
  		 * The native shader code.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.code = code;

  		Object.defineProperty( this, 'isNodeCode', { value: true } );

  	}

  }

  let _id$5 = 0;

  /**
   * This utility class is used in {@link NodeBuilder} as an internal
   * cache data structure for node data.
   */
  class NodeCache {

  	/**
  	 * Constructs a new node cache.
  	 *
  	 * @param {?NodeCache} parent - A reference to a parent cache.
  	 */
  	constructor( parent = null ) {

  		/**
  		 * The id of the cache.
  		 *
  		 * @type {number}
  		 * @readonly
  		 */
  		this.id = _id$5 ++;

  		/**
  		 * A weak map for managing node data.
  		 *
  		 * @type {WeakMap<Node, Object>}
  		 */
  		this.nodesData = new WeakMap();

  		/**
  		 * Reference to a parent node cache.
  		 *
  		 * @type {?NodeCache}
  		 * @default null
  		 */
  		this.parent = parent;

  	}

  	/**
  	 * Returns the data for the given node.
  	 *
  	 * @param {Node} node - The node.
  	 * @return {?Object} The data for the node.
  	 */
  	getData( node ) {

  		let data = this.nodesData.get( node );

  		if ( data === undefined && this.parent !== null ) {

  			data = this.parent.getData( node );

  		}

  		return data;

  	}

  	/**
  	 * Sets the data for a given node.
  	 *
  	 * @param {Node} node - The node.
  	 * @param {Object} data - The data that should be cached.
  	 */
  	setData( node, data ) {

  		this.nodesData.set( node, data );

  	}

  }

  class StructType {

  	constructor( name, members ) {

  		this.name = name;
  		this.members = members;
  		this.output = false;

  	}

  }

  /**
   * Abstract base class for uniforms.
   *
   * @abstract
   * @private
   */
  class Uniform {

  	/**
  	 * Constructs a new uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {any} value - The uniform's value.
  	 */
  	constructor( name, value ) {

  		/**
  		 * The uniform's name.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The uniform's value.
  		 *
  		 * @type {any}
  		 */
  		this.value = value;

  		/**
  		 * Used to build the uniform buffer according to the STD140 layout.
  		 * Derived uniforms will set this property to a data type specific
  		 * value.
  		 *
  		 * @type {number}
  		 */
  		this.boundary = 0;

  		/**
  		 * The item size. Derived uniforms will set this property to a data
  		 * type specific value.
  		 *
  		 * @type {number}
  		 */
  		this.itemSize = 0;

  		/**
  		 * This property is set by {@link UniformsGroup} and marks
  		 * the start position in the uniform buffer.
  		 *
  		 * @type {number}
  		 */
  		this.offset = 0;

  	}

  	/**
  	 * Sets the uniform's value.
  	 *
  	 * @param {any} value - The value to set.
  	 */
  	setValue( value ) {

  		this.value = value;

  	}

  	/**
  	 * Returns the uniform's value.
  	 *
  	 * @return {any} The value.
  	 */
  	getValue() {

  		return this.value;

  	}

  }

  /**
   * Represents a Number uniform.
   *
   * @private
   * @augments Uniform
   */
  class NumberUniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {number} value - The uniform's value.
  	 */
  	constructor( name, value = 0 ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNumberUniform = true;

  		this.boundary = 4;
  		this.itemSize = 1;

  	}

  }

  /**
   * Represents a Vector2 uniform.
   *
   * @private
   * @augments Uniform
   */
  class Vector2Uniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Vector2} value - The uniform's value.
  	 */
  	constructor( name, value = new Vector2() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isVector2Uniform = true;

  		this.boundary = 8;
  		this.itemSize = 2;

  	}

  }

  /**
   * Represents a Vector3 uniform.
   *
   * @private
   * @augments Uniform
   */
  class Vector3Uniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Vector3} value - The uniform's value.
  	 */
  	constructor( name, value = new Vector3() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isVector3Uniform = true;

  		this.boundary = 16;
  		this.itemSize = 3;

  	}

  }

  /**
   * Represents a Vector4 uniform.
   *
   * @private
   * @augments Uniform
   */
  class Vector4Uniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Vector4} value - The uniform's value.
  	 */
  	constructor( name, value = new Vector4() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isVector4Uniform = true;

  		this.boundary = 16;
  		this.itemSize = 4;

  	}

  }

  /**
   * Represents a Color uniform.
   *
   * @private
   * @augments Uniform
   */
  class ColorUniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Color} value - The uniform's value.
  	 */
  	constructor( name, value = new Color() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isColorUniform = true;

  		this.boundary = 16;
  		this.itemSize = 3;

  	}

  }

  /**
   * Represents a Matrix2 uniform.
   *
   * @private
   * @augments Uniform
   */
  class Matrix2Uniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Matrix2} value - The uniform's value.
  	 */
  	constructor( name, value = new Matrix2() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMatrix2Uniform = true;

  		this.boundary = 8;
  		this.itemSize = 4;

  	}

  }


  /**
   * Represents a Matrix3 uniform.
   *
   * @private
   * @augments Uniform
   */
  class Matrix3Uniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Matrix3} value - The uniform's value.
  	 */
  	constructor( name, value = new Matrix3() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMatrix3Uniform = true;

  		this.boundary = 48;
  		this.itemSize = 12;

  	}

  }

  /**
   * Represents a Matrix4 uniform.
   *
   * @private
   * @augments Uniform
   */
  class Matrix4Uniform extends Uniform {

  	/**
  	 * Constructs a new Number uniform.
  	 *
  	 * @param {string} name - The uniform's name.
  	 * @param {Matrix4} value - The uniform's value.
  	 */
  	constructor( name, value = new Matrix4() ) {

  		super( name, value );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMatrix4Uniform = true;

  		this.boundary = 64;
  		this.itemSize = 16;

  	}

  }

  /**
   * A special form of Number uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments NumberUniform
   */
  class NumberNodeUniform extends NumberUniform {

  	/**
  	 * Constructs a new node-based Number uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {number} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  /**
   * A special form of Vector2 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Vector2Uniform
   */
  class Vector2NodeUniform extends Vector2Uniform {

  	/**
  	 * Constructs a new node-based Vector2 uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Vector2} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  /**
   * A special form of Vector3 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Vector3Uniform
   */
  class Vector3NodeUniform extends Vector3Uniform {

  	/**
  	 * Constructs a new node-based Vector3 uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Vector3} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  /**
   * A special form of Vector4 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Vector4Uniform
   */
  class Vector4NodeUniform extends Vector4Uniform {

  	/**
  	 * Constructs a new node-based Vector4 uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Vector4} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  /**
   * A special form of Color uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments ColorUniform
   */
  class ColorNodeUniform extends ColorUniform {

  	/**
  	 * Constructs a new node-based Color uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Color} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }


  /**
   * A special form of Matrix2 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Matrix2Uniform
   */
  class Matrix2NodeUniform extends Matrix2Uniform {

  	/**
  	 * Constructs a new node-based Matrix2 uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Matrix2} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  /**
   * A special form of Matrix3 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Matrix3Uniform
   */
  class Matrix3NodeUniform extends Matrix3Uniform {

  	/**
  	 * Constructs a new node-based Matrix3 uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Matrix3} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  /**
   * A special form of Matrix4 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Matrix4Uniform
   */
  class Matrix4NodeUniform extends Matrix4Uniform {

  	/**
  	 * Constructs a new node-based Matrix4 uniform.
  	 *
  	 * @param {NodeUniform} nodeUniform - The node uniform.
  	 */
  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {NodeUniform}
  		 */
  		this.nodeUniform = nodeUniform;

  	}

  	/**
  	 * Overwritten to return the value of the node uniform.
  	 *
  	 * @return {Matrix4} The value.
  	 */
  	getValue() {

  		return this.nodeUniform.value;

  	}

  	/**
  	 * Returns the node uniform data type.
  	 *
  	 * @return {string} The data type.
  	 */
  	getType() {

  		return this.nodeUniform.type;

  	}

  }

  const rendererCache = new WeakMap();

  const typeFromArray = new Map( [
  	[ Int8Array, 'int' ],
  	[ Int16Array, 'int' ],
  	[ Int32Array, 'int' ],
  	[ Uint8Array, 'uint' ],
  	[ Uint16Array, 'uint' ],
  	[ Uint32Array, 'uint' ],
  	[ Float32Array, 'float' ]
  ] );

  const toFloat = ( value ) => {

  	if ( /e/g.test( value ) ) {

  		return String( value ).replace( /\+/g, '' );

  	} else {

  		value = Number( value );

  		return value + ( value % 1 ? '' : '.0' );

  	}

  };

  /**
   * Base class for builders which generate a shader program based
   * on a 3D object and its node material definition.
   */
  class NodeBuilder {

  	/**
  	 * Constructs a new node builder.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Renderer} renderer - The current renderer.
  	 * @param {NodeParser} parser - A reference to a node parser.
  	 */
  	constructor( object, renderer, parser ) {

  		/**
  		 * The 3D object.
  		 *
  		 * @type {Object3D}
  		 */
  		this.object = object;

  		/**
  		 * The material of the 3D object.
  		 *
  		 * @type {?Material}
  		 */
  		this.material = ( object && object.material ) || null;

  		/**
  		 * The geometry of the 3D object.
  		 *
  		 * @type {?BufferGeometry}
  		 */
  		this.geometry = ( object && object.geometry ) || null;

  		/**
  		 * The current renderer.
  		 *
  		 * @type {Renderer}
  		 */
  		this.renderer = renderer;

  		/**
  		 * A reference to a node parser.
  		 *
  		 * @type {NodeParser}
  		 */
  		this.parser = parser;

  		/**
  		 * The scene the 3D object belongs to.
  		 *
  		 * @type {?Scene}
  		 * @default null
  		 */
  		this.scene = null;

  		/**
  		 * The camera the 3D object is rendered with.
  		 *
  		 * @type {?Camera}
  		 * @default null
  		 */
  		this.camera = null;

  		/**
  		 * A list of all nodes the builder is processing
  		 * for this 3D object.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.nodes = [];

  		/**
  		 * A list of all sequential nodes.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.sequentialNodes = [];

  		/**
  		 * A list of all nodes which {@link Node#update} method should be executed.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.updateNodes = [];

  		/**
  		 * A list of all nodes which {@link Node#updateBefore} method should be executed.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.updateBeforeNodes = [];

  		/**
  		 * A list of all nodes which {@link Node#updateAfter} method should be executed.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.updateAfterNodes = [];

  		/**
  		 * A dictionary that assigns each node to a unique hash.
  		 *
  		 * @type {Object<number,Node>}
  		 */
  		this.hashNodes = {};

  		/**
  		 * A reference to a node material observer.
  		 *
  		 * @type {?NodeMaterialObserver}
  		 * @default null
  		 */
  		this.observer = null;

  		/**
  		 * A reference to the current lights node.
  		 *
  		 * @type {?LightsNode}
  		 * @default null
  		 */
  		this.lightsNode = null;

  		/**
  		 * A reference to the current environment node.
  		 *
  		 * @type {?Node}
  		 * @default null
  		 */
  		this.environmentNode = null;

  		/**
  		 * A reference to the current fog node.
  		 *
  		 * @type {?FogNode}
  		 * @default null
  		 */
  		this.fogNode = null;

  		/**
  		 * The current clipping context.
  		 *
  		 * @type {?ClippingContext}
  		 */
  		this.clippingContext = null;

  		/**
  		 * The generated vertex shader.
  		 *
  		 * @type {?string}
  		 */
  		this.vertexShader = null;

  		/**
  		 * The generated fragment shader.
  		 *
  		 * @type {?string}
  		 */
  		this.fragmentShader = null;

  		/**
  		 * The generated compute shader.
  		 *
  		 * @type {?string}
  		 */
  		this.computeShader = null;

  		/**
  		 * Nodes used in the primary flow of code generation.
  		 *
  		 * @type {Object<string,Array<Node>>}
  		 */
  		this.flowNodes = { vertex: [], fragment: [], compute: [] };

  		/**
  		 * Nodes code from `.flowNodes`.
  		 *
  		 * @type {Object<string,string>}
  		 */
  		this.flowCode = { vertex: '', fragment: '', compute: '' };

  		/**
  		 * This dictionary holds the node uniforms of the builder.
  		 * The uniforms are maintained in an array for each shader stage.
  		 *
  		 * @type {Object}
  		 */
  		this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };

  		/**
  		 * This dictionary holds the output structs of the builder.
  		 * The structs are maintained in an array for each shader stage.
  		 *
  		 * @type {Object}
  		 */
  		this.structs = { vertex: [], fragment: [], compute: [], index: 0 };

  		/**
  		 * This dictionary holds the bindings for each shader stage.
  		 *
  		 * @type {Object}
  		 */
  		this.bindings = { vertex: {}, fragment: {}, compute: {} };

  		/**
  		 * This dictionary maintains the binding indices per bind group.
  		 *
  		 * @type {Object}
  		 */
  		this.bindingsIndexes = {};

  		/**
  		 * Reference to the array of bind groups.
  		 *
  		 * @type {?Array<BindGroup>}
  		 */
  		this.bindGroups = null;

  		/**
  		 * This array holds the node attributes of this builder
  		 * created via {@link AttributeNode}.
  		 *
  		 * @type {Array<NodeAttribute>}
  		 */
  		this.attributes = [];

  		/**
  		 * This array holds the node attributes of this builder
  		 * created via {@link BufferAttributeNode}.
  		 *
  		 * @type {Array<NodeAttribute>}
  		 */
  		this.bufferAttributes = [];

  		/**
  		 * This array holds the node varyings of this builder.
  		 *
  		 * @type {Array<NodeVarying>}
  		 */
  		this.varyings = [];

  		/**
  		 * This dictionary holds the (native) node codes of this builder.
  		 * The codes are maintained in an array for each shader stage.
  		 *
  		 * @type {Object<string,Array<NodeCode>>}
  		 */
  		this.codes = {};

  		/**
  		 * This dictionary holds the node variables of this builder.
  		 * The variables are maintained in an array for each shader stage.
  		 * This dictionary is also used to count the number of variables
  		 * according to their type (const, vars).
  		 *
  		 * @type {Object<string,Array<NodeVar>|number>}
  		 */
  		this.vars = {};

  		/**
  		 * This dictionary holds the declarations for each shader stage.
  		 *
  		 * @type {Object}
  		 */
  		this.declarations = {};

  		/**
  		 * Current code flow.
  		 * All code generated in this stack will be stored in `.flow`.
  		 *
  		 * @type {{code: string}}
  		 */
  		this.flow = { code: '' };

  		/**
  		 * A chain of nodes.
  		 * Used to check recursive calls in node-graph.
  		 *
  		 * @type {Array<Node>}
  		 */
  		this.chaining = [];

  		/**
  		 * The current stack.
  		 * This reflects the current process in the code block hierarchy,
  		 * it is useful to know if the current process is inside a conditional for example.
  		 *
  		 * @type {StackNode}
  		 */
  		this.stack = stack();

  		/**
  		 * List of stack nodes.
  		 * The current stack hierarchy is stored in an array.
  		 *
  		 * @type {Array<StackNode>}
  		 */
  		this.stacks = [];

  		/**
  		 * A tab value. Used for shader string generation.
  		 *
  		 * @type {string}
  		 * @default '\t'
  		 */
  		this.tab = '\t';

  		/**
  		 * Reference to the current function node.
  		 *
  		 * @type {?FunctionNode}
  		 * @default null
  		 */
  		this.currentFunctionNode = null;

  		/**
  		 * The builder's context.
  		 *
  		 * @type {Object}
  		 */
  		this.context = {
  			material: this.material
  		};

  		/**
  		 * The builder's cache.
  		 *
  		 * @type {NodeCache}
  		 */
  		this.cache = new NodeCache();

  		/**
  		 * Since the {@link NodeBuilder#cache} might be temporarily
  		 * overwritten by other caches, this member retains the reference
  		 * to the builder's own cache.
  		 *
  		 * @type {NodeCache}
  		 * @default this.cache
  		 */
  		this.globalCache = this.cache;

  		this.flowsData = new WeakMap();

  		/**
  		 * The current shader stage.
  		 *
  		 * @type {?('vertex'|'fragment'|'compute'|'any')}
  		 */
  		this.shaderStage = null;

  		/**
  		 * The current build stage.
  		 *
  		 * @type {?('setup'|'analyze'|'generate')}
  		 */
  		this.buildStage = null;

  		/**
  		 * The sub-build layers.
  		 *
  		 * @type {Array<SubBuildNode>}
  		 * @default []
  		 */
  		this.subBuildLayers = [];

  		/**
  		 * The current stack of nodes.
  		 *
  		 * @type {?StackNode}
  		 * @default null
  		 */
  		this.currentStack = null;

  		/**
  		 * The current sub-build TSL function(Fn).
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.subBuildFn = null;

  	}

  	/**
  	 * Returns the bind groups of the current renderer.
  	 *
  	 * @return {ChainMap} The cache.
  	 */
  	getBindGroupsCache() {

  		let bindGroupsCache = rendererCache.get( this.renderer );

  		if ( bindGroupsCache === undefined ) {

  			bindGroupsCache = new ChainMap();

  			rendererCache.set( this.renderer, bindGroupsCache );

  		}

  		return bindGroupsCache;

  	}

  	/**
  	 * Factory method for creating an instance of {@link RenderTarget} with the given
  	 * dimensions and options.
  	 *
  	 * @param {number} width - The width of the render target.
  	 * @param {number} height - The height of the render target.
  	 * @param {Object} options - The options of the render target.
  	 * @return {RenderTarget} The render target.
  	 */
  	createRenderTarget( width, height, options ) {

  		return new RenderTarget( width, height, options );

  	}

  	/**
  	 * Factory method for creating an instance of {@link CubeRenderTarget} with the given
  	 * dimensions and options.
  	 *
  	 * @param {number} size - The size of the cube render target.
  	 * @param {Object} options - The options of the cube render target.
  	 * @return {CubeRenderTarget} The cube render target.
  	 */
  	createCubeRenderTarget( size, options ) {

  		return new CubeRenderTarget( size, options );

  	}

  	/**
  	 * Whether the given node is included in the internal array of nodes or not.
  	 *
  	 * @param {Node} node - The node to test.
  	 * @return {boolean} Whether the given node is included in the internal array of nodes or not.
  	 */
  	includes( node ) {

  		return this.nodes.includes( node );

  	}

  	/**
  	 * Returns the output struct name which is required by
  	 * {@link OutputStructNode}.
  	 *
  	 * @abstract
  	 * @return {string} The name of the output struct.
  	 */
  	getOutputStructName() {}

  	/**
  	 * Returns a bind group for the given group name and binding.
  	 *
  	 * @private
  	 * @param {string} groupName - The group name.
  	 * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
  	 * @return {BindGroup} The bind group
  	 */
  	_getBindGroup( groupName, bindings ) {

  		const bindGroupsCache = this.getBindGroupsCache();

  		//

  		const bindingsArray = [];

  		let sharedGroup = true;

  		for ( const binding of bindings ) {

  			bindingsArray.push( binding );

  			sharedGroup = sharedGroup && binding.groupNode.shared !== true;

  		}

  		//

  		let bindGroup;

  		if ( sharedGroup ) {

  			bindGroup = bindGroupsCache.get( bindingsArray );

  			if ( bindGroup === undefined ) {

  				bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

  				bindGroupsCache.set( bindingsArray, bindGroup );

  			}

  		} else {

  			bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

  		}

  		return bindGroup;

  	}

  	/**
  	 * Returns an array of node uniform groups for the given group name and shader stage.
  	 *
  	 * @param {string} groupName - The group name.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
  	 */
  	getBindGroupArray( groupName, shaderStage ) {

  		const bindings = this.bindings[ shaderStage ];

  		let bindGroup = bindings[ groupName ];

  		if ( bindGroup === undefined ) {

  			if ( this.bindingsIndexes[ groupName ] === undefined ) {

  				this.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };

  			}

  			bindings[ groupName ] = bindGroup = [];

  		}

  		return bindGroup;

  	}

  	/**
  	 * Returns a list bindings of all shader stages separated by groups.
  	 *
  	 * @return {Array<BindGroup>} The list of bindings.
  	 */
  	getBindings() {

  		let bindingsGroups = this.bindGroups;

  		if ( bindingsGroups === null ) {

  			const groups = {};
  			const bindings = this.bindings;

  			for ( const shaderStage of shaderStages ) {

  				for ( const groupName in bindings[ shaderStage ] ) {

  					const uniforms = bindings[ shaderStage ][ groupName ];

  					const groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );
  					groupUniforms.push( ...uniforms );

  				}

  			}

  			bindingsGroups = [];

  			for ( const groupName in groups ) {

  				const group = groups[ groupName ];

  				const bindingsGroup = this._getBindGroup( groupName, group );

  				bindingsGroups.push( bindingsGroup );

  			}

  			this.bindGroups = bindingsGroups;

  		}

  		return bindingsGroups;

  	}

  	/**
  	 * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
  	 */
  	sortBindingGroups() {

  		const bindingsGroups = this.getBindings();

  		bindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );

  		for ( let i = 0; i < bindingsGroups.length; i ++ ) {

  			const bindingGroup = bindingsGroups[ i ];
  			this.bindingsIndexes[ bindingGroup.name ].group = i;

  			bindingGroup.index = i;

  		}

  	}

  	/**
  	 * The builder maintains each node in a hash-based dictionary.
  	 * This method sets the given node (value) with the given hash (key) into this dictionary.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {number} hash - The hash of the node.
  	 */
  	setHashNode( node, hash ) {

  		this.hashNodes[ hash ] = node;

  	}

  	/**
  	 * Adds a node to this builder.
  	 *
  	 * @param {Node} node - The node to add.
  	 */
  	addNode( node ) {

  		if ( this.nodes.includes( node ) === false ) {

  			this.nodes.push( node );

  			this.setHashNode( node, node.getHash( this ) );

  		}

  	}

  	/**
  	 * It is used to add Nodes that will be used as FRAME and RENDER events,
  	 * and need to follow a certain sequence in the calls to work correctly.
  	 * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
  	 *
  	 * @param {Node} node - The node to add.
  	 */
  	addSequentialNode( node ) {

  		if ( this.sequentialNodes.includes( node ) === false ) {

  			this.sequentialNodes.push( node );

  		}

  	}

  	/**
  	 * Checks the update types of nodes
  	 */
  	buildUpdateNodes() {

  		for ( const node of this.nodes ) {

  			const updateType = node.getUpdateType();

  			if ( updateType !== NodeUpdateType.NONE ) {

  				this.updateNodes.push( node.getSelf() );

  			}

  		}

  		for ( const node of this.sequentialNodes ) {

  			const updateBeforeType = node.getUpdateBeforeType();
  			const updateAfterType = node.getUpdateAfterType();

  			if ( updateBeforeType !== NodeUpdateType.NONE ) {

  				this.updateBeforeNodes.push( node.getSelf() );

  			}

  			if ( updateAfterType !== NodeUpdateType.NONE ) {

  				this.updateAfterNodes.push( node.getSelf() );

  			}

  		}

  	}

  	/**
  	 * A reference the current node which is the
  	 * last node in the chain of nodes.
  	 *
  	 * @type {Node}
  	 */
  	get currentNode() {

  		return this.chaining[ this.chaining.length - 1 ];

  	}

  	/**
  	 * Whether the given texture is filtered or not.
  	 *
  	 * @param {Texture} texture - The texture to check.
  	 * @return {boolean} Whether the given texture is filtered or not.
  	 */
  	isFilteredTexture( texture ) {

  		return ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
  			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );

  	}

  	/**
  	 * Adds the given node to the internal node chain.
  	 * This is used to check recursive calls in node-graph.
  	 *
  	 * @param {Node} node - The node to add.
  	 */
  	addChain( node ) {

  		/*
  		if ( this.chaining.indexOf( node ) !== - 1 ) {

  			console.warn( 'Recursive node: ', node );

  		}
  		*/

  		this.chaining.push( node );

  	}

  	/**
  	 * Removes the given node from the internal node chain.
  	 *
  	 * @param {Node} node - The node to remove.
  	 */
  	removeChain( node ) {

  		const lastChain = this.chaining.pop();

  		if ( lastChain !== node ) {

  			throw new Error( 'NodeBuilder: Invalid node chaining!' );

  		}

  	}

  	/**
  	 * Returns the native shader method name for a given generic name. E.g.
  	 * the method name `textureDimensions` matches the WGSL name but must be
  	 * resolved to `textureSize` in GLSL.
  	 *
  	 * @abstract
  	 * @param {string} method - The method name to resolve.
  	 * @return {string} The resolved method name.
  	 */
  	getMethod( method ) {

  		return method;

  	}

  	/**
  	 * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
  	 *
  	 * @param {number} hash - The hash of the node.
  	 * @return {Node} The found node.
  	 */
  	getNodeFromHash( hash ) {

  		return this.hashNodes[ hash ];

  	}

  	/**
  	 * Adds the Node to a target flow so that it can generate code in the 'generate' process.
  	 *
  	 * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
  	 * @param {Node} node - The node to add.
  	 * @return {Node} The node.
  	 */
  	addFlow( shaderStage, node ) {

  		this.flowNodes[ shaderStage ].push( node );

  		return node;

  	}

  	/**
  	 * Sets builder's context.
  	 *
  	 * @param {Object} context - The context to set.
  	 */
  	setContext( context ) {

  		this.context = context;

  	}

  	/**
  	 * Returns the builder's current context.
  	 *
  	 * @return {Object} The builder's current context.
  	 */
  	getContext() {

  		return this.context;

  	}

  	/**
  	 * Gets a context used in shader construction that can be shared across different materials.
  	 * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
  	 *
  	 * @return {Object} The builder's current context without material.
  	 */
  	getSharedContext() {

  		({ ...this.context });

  		return this.context;

  	}

  	/**
  	 * Sets builder's cache.
  	 *
  	 * @param {NodeCache} cache - The cache to set.
  	 */
  	setCache( cache ) {

  		this.cache = cache;

  	}

  	/**
  	 * Returns the builder's current cache.
  	 *
  	 * @return {NodeCache} The builder's current cache.
  	 */
  	getCache() {

  		return this.cache;

  	}

  	/**
  	 * Returns a cache for the given node.
  	 *
  	 * @param {Node} node - The node.
  	 * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
  	 * @return {NodeCache} The cache.
  	 */
  	getCacheFromNode( node, parent = true ) {

  		const data = this.getDataFromNode( node );
  		if ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );

  		return data.cache;

  	}

  	/**
  	 * Whether the requested feature is available or not.
  	 *
  	 * @abstract
  	 * @param {string} name - The requested feature.
  	 * @return {boolean} Whether the requested feature is supported or not.
  	 */
  	isAvailable( /*name*/ ) {

  		return false;

  	}

  	/**
  	 * Returns the vertexIndex input variable as a native shader string.
  	 *
  	 * @abstract
  	 * @return {string} The instanceIndex shader string.
  	 */
  	getVertexIndex() {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the instanceIndex input variable as a native shader string.
  	 *
  	 * @abstract
  	 * @return {string} The instanceIndex shader string.
  	 */
  	getInstanceIndex() {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the drawIndex input variable as a native shader string.
  	 * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
  	 *
  	 * @abstract
  	 * @return {?string} The drawIndex shader string.
  	 */
  	getDrawIndex() {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the frontFacing input variable as a native shader string.
  	 *
  	 * @abstract
  	 * @return {string} The frontFacing shader string.
  	 */
  	getFrontFacing() {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the fragCoord input variable as a native shader string.
  	 *
  	 * @abstract
  	 * @return {string} The fragCoord shader string.
  	 */
  	getFragCoord() {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Whether to flip texture data along its vertical axis or not. WebGL needs
  	 * this method evaluate to `true`, WebGPU to `false`.
  	 *
  	 * @abstract
  	 * @return {boolean} Whether to flip texture data along its vertical axis or not.
  	 */
  	isFlipY() {

  		return false;

  	}

  	/**
  	 * Calling this method increases the usage count for the given node by one.
  	 *
  	 * @param {Node} node - The node to increase the usage count for.
  	 * @return {number} The updated usage count.
  	 */
  	increaseUsage( node ) {

  		const nodeData = this.getDataFromNode( node );
  		nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;

  		return nodeData.usageCount;

  	}

  	/**
  	 * Generates a texture sample shader string for the given texture data.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The texture property name.
  	 * @param {string} uvSnippet - Snippet defining the texture coordinates.
  	 * @return {string} The generated shader string.
  	 */
  	generateTexture( /* texture, textureProperty, uvSnippet */ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Generates a texture LOD shader string for the given texture data.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The texture property name.
  	 * @param {string} uvSnippet - Snippet defining the texture coordinates.
  	 * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
  	 * @param {string} levelSnippet - Snippet defining the mip level.
  	 * @return {string} The generated shader string.
  	 */
  	generateTextureLod( /* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Generates the array declaration string.
  	 *
  	 * @param {string} type - The type.
  	 * @param {?number} [count] - The count.
  	 * @return {string} The generated value as a shader string.
  	 */
  	generateArrayDeclaration( type, count ) {

  		return this.getType( type ) + '[ ' + count + ' ]';

  	}

  	/**
  	 * Generates the array shader string for the given type and value.
  	 *
  	 * @param {string} type - The type.
  	 * @param {?number} [count] - The count.
  	 * @param {?Array<Node>} [values=null] - The default values.
  	 * @return {string} The generated value as a shader string.
  	 */
  	generateArray( type, count, values = null ) {

  		let snippet = this.generateArrayDeclaration( type, count ) + '( ';

  		for ( let i = 0; i < count; i ++ ) {

  			const value = values ? values[ i ] : null;

  			if ( value !== null ) {

  				snippet += value.build( this, type );

  			} else {

  				snippet += this.generateConst( type );

  			}

  			if ( i < count - 1 ) snippet += ', ';

  		}

  		snippet += ' )';

  		return snippet;

  	}

  	/**
  	 * Generates the struct shader string.
  	 *
  	 * @param {string} type - The type.
  	 * @param {Array<Object>} [membersLayout] - The count.
  	 * @param {?Array<Node>} [values=null] - The default values.
  	 * @return {string} The generated value as a shader string.
  	 */
  	generateStruct( type, membersLayout, values = null ) {

  		const snippets = [];

  		for ( const member of membersLayout ) {

  			const { name, type } = member;

  			if ( values && values[ name ] && values[ name ].isNode ) {

  				snippets.push( values[ name ].build( this, type ) );

  			} else {

  				snippets.push( this.generateConst( type ) );

  			}

  		}

  		return type + '( ' + snippets.join( ', ' ) + ' )';

  	}


  	/**
  	 * Generates the shader string for the given type and value.
  	 *
  	 * @param {string} type - The type.
  	 * @param {?any} [value=null] - The value.
  	 * @return {string} The generated value as a shader string.
  	 */
  	generateConst( type, value = null ) {

  		if ( value === null ) {

  			if ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;
  			else if ( type === 'bool' ) value = false;
  			else if ( type === 'color' ) value = new Color();
  			else if ( type === 'vec2' ) value = new Vector2();
  			else if ( type === 'vec3' ) value = new Vector3();
  			else if ( type === 'vec4' ) value = new Vector4();

  		}

  		if ( type === 'float' ) return toFloat( value );
  		if ( type === 'int' ) return `${ Math.round( value ) }`;
  		if ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';
  		if ( type === 'bool' ) return value ? 'true' : 'false';
  		if ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;

  		const typeLength = this.getTypeLength( type );

  		const componentType = this.getComponentType( type );

  		const generateConst = value => this.generateConst( componentType, value );

  		if ( typeLength === 2 ) {

  			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;

  		} else if ( typeLength === 3 ) {

  			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;

  		} else if ( typeLength === 4 && type !== 'mat2' ) {

  			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;

  		} else if ( typeLength >= 4 && value && ( value.isMatrix2 || value.isMatrix3 || value.isMatrix4 ) ) {

  			return `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;

  		} else if ( typeLength > 4 ) {

  			return `${ this.getType( type ) }()`;

  		}

  		throw new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );

  	}

  	/**
  	 * It might be necessary to convert certain data types to different ones
  	 * so this method can be used to hide the conversion.
  	 *
  	 * @param {string} type - The type.
  	 * @return {string} The updated type.
  	 */
  	getType( type ) {

  		if ( type === 'color' ) return 'vec3';

  		return type;

  	}

  	/**
  	 * Whether the given attribute name is defined in the geometry or not.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @return {boolean} Whether the given attribute name is defined in the geometry.
  	 */
  	hasGeometryAttribute( name ) {

  		return this.geometry && this.geometry.getAttribute( name ) !== undefined;

  	}

  	/**
  	 * Returns a node attribute for the given name and type.
  	 *
  	 * @param {string} name - The attribute's name.
  	 * @param {string} type - The attribute's type.
  	 * @return {NodeAttribute} The node attribute.
  	 */
  	getAttribute( name, type ) {

  		const attributes = this.attributes;

  		// find attribute

  		for ( const attribute of attributes ) {

  			if ( attribute.name === name ) {

  				return attribute;

  			}

  		}

  		// create a new if no exist

  		const attribute = new NodeAttribute( name, type );

  		this.registerDeclaration( attribute );

  		attributes.push( attribute );

  		return attribute;

  	}

  	/**
  	 * Returns for the given node and shader stage the property name for the shader.
  	 *
  	 * @param {Node} node - The node.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {string} The property name.
  	 */
  	getPropertyName( node/*, shaderStage*/ ) {

  		return node.name;

  	}

  	/**
  	 * Whether the given type is a vector type or not.
  	 *
  	 * @param {string} type - The type to check.
  	 * @return {boolean} Whether the given type is a vector type or not.
  	 */
  	isVector( type ) {

  		return /vec\d/.test( type );

  	}

  	/**
  	 * Whether the given type is a matrix type or not.
  	 *
  	 * @param {string} type - The type to check.
  	 * @return {boolean} Whether the given type is a matrix type or not.
  	 */
  	isMatrix( type ) {

  		return /mat\d/.test( type );

  	}

  	/**
  	 * Whether the given type is a reference type or not.
  	 *
  	 * @param {string} type - The type to check.
  	 * @return {boolean} Whether the given type is a reference type or not.
  	 */
  	isReference( type ) {

  		return type === 'void' || type === 'property' || type === 'sampler' || type === 'samplerComparison' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';

  	}

  	/**
  	 * Checks if the given texture requires a manual conversion to the working color space.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture to check.
  	 * @return {boolean} Whether the given texture requires a conversion to working color space or not.
  	 */
  	needsToWorkingColorSpace( /*texture*/ ) {

  		return false;

  	}

  	/**
  	 * Returns the component type of a given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {string} The component type.
  	 */
  	getComponentTypeFromTexture( texture ) {

  		const type = texture.type;

  		if ( texture.isDataTexture ) {

  			if ( type === IntType ) return 'int';
  			if ( type === UnsignedIntType ) return 'uint';

  		}

  		return 'float';

  	}

  	/**
  	 * Returns the element type for a given type.
  	 *
  	 * @param {string} type - The type.
  	 * @return {string} The element type.
  	 */
  	getElementType( type ) {

  		if ( type === 'mat2' ) return 'vec2';
  		if ( type === 'mat3' ) return 'vec3';
  		if ( type === 'mat4' ) return 'vec4';

  		return this.getComponentType( type );

  	}

  	/**
  	 * Returns the component type for a given type.
  	 *
  	 * @param {string} type - The type.
  	 * @return {string} The component type.
  	 */
  	getComponentType( type ) {

  		type = this.getVectorType( type );

  		if ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;

  		const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );

  		if ( componentType === null ) return null;

  		if ( componentType[ 1 ] === 'b' ) return 'bool';
  		if ( componentType[ 1 ] === 'i' ) return 'int';
  		if ( componentType[ 1 ] === 'u' ) return 'uint';

  		return 'float';

  	}

  	/**
  	 * Returns the vector type for a given type.
  	 *
  	 * @param {string} type - The type.
  	 * @return {string} The vector type.
  	 */
  	getVectorType( type ) {

  		if ( type === 'color' ) return 'vec3';
  		if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';

  		return type;

  	}

  	/**
  	 * Returns the data type for the given the length and component type.
  	 *
  	 * @param {number} length - The length.
  	 * @param {string} [componentType='float'] - The component type.
  	 * @return {string} The type.
  	 */
  	getTypeFromLength( length, componentType = 'float' ) {

  		if ( length === 1 ) return componentType;

  		let baseType = getTypeFromLength( length );
  		const prefix = componentType === 'float' ? '' : componentType[ 0 ];

  		// fix edge case for mat2x2 being same size as vec4
  		if ( /mat2/.test( componentType ) === true ) {

  			baseType = baseType.replace( 'vec', 'mat' );

  		}

  		return prefix + baseType;

  	}

  	/**
  	 * Returns the type for a given typed array.
  	 *
  	 * @param {TypedArray} array - The typed array.
  	 * @return {string} The type.
  	 */
  	getTypeFromArray( array ) {

  		return typeFromArray.get( array.constructor );

  	}

  	/**
  	 * Returns the type is an integer type.
  	 *
  	 * @param {string} type - The type.
  	 * @return {boolean} Whether the type is an integer type or not.
  	 */
  	isInteger( type ) {

  		return /int|uint|(i|u)vec/.test( type );

  	}

  	/**
  	 * Returns the type for a given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 * @return {string} The type.
  	 */
  	getTypeFromAttribute( attribute ) {

  		let dataAttribute = attribute;

  		if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

  		const array = dataAttribute.array;
  		const itemSize = attribute.itemSize;
  		const normalized = attribute.normalized;

  		let arrayType;

  		if ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {

  			arrayType = this.getTypeFromArray( array );

  		}

  		return this.getTypeFromLength( itemSize, arrayType );

  	}

  	/**
  	 * Returns the length for the given data type.
  	 *
  	 * @param {string} type - The data type.
  	 * @return {number} The length.
  	 */
  	getTypeLength( type ) {

  		const vecType = this.getVectorType( type );
  		const vecNum = /vec([2-4])/.exec( vecType );

  		if ( vecNum !== null ) return Number( vecNum[ 1 ] );
  		if ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;
  		if ( /mat2/.test( type ) === true ) return 4;
  		if ( /mat3/.test( type ) === true ) return 9;
  		if ( /mat4/.test( type ) === true ) return 16;

  		return 0;

  	}

  	/**
  	 * Returns the vector type for a given matrix type.
  	 *
  	 * @param {string} type - The matrix type.
  	 * @return {string} The vector type.
  	 */
  	getVectorFromMatrix( type ) {

  		return type.replace( 'mat', 'vec' );

  	}

  	/**
  	 * For a given type this method changes the component type to the
  	 * given value. E.g. `vec4` should be changed to the new component type
  	 * `uint` which results in `uvec4`.
  	 *
  	 * @param {string} type - The type.
  	 * @param {string} newComponentType - The new component type.
  	 * @return {string} The new type.
  	 */
  	changeComponentType( type, newComponentType ) {

  		return this.getTypeFromLength( this.getTypeLength( type ), newComponentType );

  	}

  	/**
  	 * Returns the integer type pendant for the given type.
  	 *
  	 * @param {string} type - The type.
  	 * @return {string} The integer type.
  	 */
  	getIntegerType( type ) {

  		const componentType = this.getComponentType( type );

  		if ( componentType === 'int' || componentType === 'uint' ) return type;

  		return this.changeComponentType( type, 'int' );

  	}

  	/**
  	 * Adds a stack node to the internal stack.
  	 *
  	 * @return {StackNode} The added stack node.
  	 */
  	addStack() {

  		this.stack = stack( this.stack );

  		this.stacks.push( getCurrentStack() || this.stack );
  		setCurrentStack( this.stack );

  		return this.stack;

  	}

  	/**
  	 * Removes the last stack node from the internal stack.
  	 *
  	 * @return {StackNode} The removed stack node.
  	 */
  	removeStack() {

  		const lastStack = this.stack;
  		this.stack = lastStack.parent;

  		setCurrentStack( this.stacks.pop() );

  		return lastStack;

  	}

  	/**
  	 * The builder maintains (cached) data for each node during the building process. This method
  	 * can be used to get these data for a specific shader stage and cache.
  	 *
  	 * @param {Node} node - The node to get the data for.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
  	 * @param {?NodeCache} cache - An optional cache.
  	 * @return {Object} The node data.
  	 */
  	getDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {

  		cache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;

  		let nodeData = cache.getData( node );

  		if ( nodeData === undefined ) {

  			nodeData = {};

  			cache.setData( node, nodeData );

  		}

  		if ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};

  		//

  		let data = nodeData[ shaderStage ];

  		const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
  		const subBuild = this.getClosestSubBuild( subBuilds );

  		if ( subBuild ) {

  			if ( data.subBuildsCache === undefined ) data.subBuildsCache = {};

  			data = data.subBuildsCache[ subBuild ] || ( data.subBuildsCache[ subBuild ] = {} );
  			data.subBuilds = subBuilds;

  		}

  		return data;

  	}

  	/**
  	 * Returns the properties for the given node and shader stage.
  	 *
  	 * @param {Node} node - The node to get the properties for.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
  	 * @return {Object} The node properties.
  	 */
  	getNodeProperties( node, shaderStage = 'any' ) {

  		const nodeData = this.getDataFromNode( node, shaderStage );

  		return nodeData.properties || ( nodeData.properties = { outputNode: null } );

  	}

  	/**
  	 * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
  	 *
  	 * @param {BufferAttributeNode} node - The buffer attribute node.
  	 * @param {string} type - The node type.
  	 * @return {NodeAttribute} The node attribute.
  	 */
  	getBufferAttributeFromNode( node, type ) {

  		const nodeData = this.getDataFromNode( node );

  		let bufferAttribute = nodeData.bufferAttribute;

  		if ( bufferAttribute === undefined ) {

  			const index = this.uniforms.index ++;

  			bufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );

  			this.bufferAttributes.push( bufferAttribute );

  			nodeData.bufferAttribute = bufferAttribute;

  		}

  		return bufferAttribute;

  	}

  	/**
  	 * Returns an instance of {@link StructType} for the given output struct node.
  	 *
  	 * @param {OutputStructNode} node - The output struct node.
  	 * @param {Array<Object>} membersLayout - The output struct types.
  	 * @param {?string} [name=null] - The name of the struct.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
  	 * @return {StructType} The struct type attribute.
  	 */
  	getStructTypeFromNode( node, membersLayout, name = null, shaderStage = this.shaderStage ) {

  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		let structType = nodeData.structType;

  		if ( structType === undefined ) {

  			const index = this.structs.index ++;

  			if ( name === null ) name = 'StructType' + index;

  			structType = new StructType( name, membersLayout );

  			this.structs[ shaderStage ].push( structType );

  			nodeData.structType = structType;

  		}

  		return structType;

  	}

  	/**
  	 * Returns an instance of {@link StructType} for the given output struct node.
  	 *
  	 * @param {OutputStructNode} node - The output struct node.
  	 * @param {Array<Object>} membersLayout - The output struct types.
  	 * @return {StructType} The struct type attribute.
  	 */
  	getOutputStructTypeFromNode( node, membersLayout ) {

  		const structType = this.getStructTypeFromNode( node, membersLayout, 'OutputType', 'fragment' );
  		structType.output = true;

  		return structType;

  	}

  	/**
  	 * Returns an instance of {@link NodeUniform} for the given uniform node.
  	 *
  	 * @param {UniformNode} node - The uniform node.
  	 * @param {string} type - The uniform type.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
  	 * @param {?string} name - The name of the uniform.
  	 * @return {NodeUniform} The node uniform.
  	 */
  	getUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {

  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		let nodeUniform = nodeData.uniform;

  		if ( nodeUniform === undefined ) {

  			const index = this.uniforms.index ++;

  			nodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );

  			this.uniforms[ shaderStage ].push( nodeUniform );

  			this.registerDeclaration( nodeUniform );

  			nodeData.uniform = nodeUniform;

  		}

  		return nodeUniform;

  	}

  	/**
  	 * Returns the array length.
  	 *
  	 * @param {Node} node - The node.
  	 * @return {?number} The array length.
  	 */
  	getArrayCount( node ) {

  		let count = null;

  		if ( node.isArrayNode ) count = node.count;
  		else if ( node.isVarNode && node.node.isArrayNode ) count = node.node.count;

  		return count;

  	}

  	/**
  	 * Returns an instance of {@link NodeVar} for the given variable node.
  	 *
  	 * @param {VarNode} node - The variable node.
  	 * @param {?string} name - The variable's name.
  	 * @param {string} [type=node.getNodeType( this )] - The variable's type.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
  	 * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
  	 *
  	 * @return {NodeVar} The node variable.
  	 */
  	getVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage, readOnly = false ) {

  		const nodeData = this.getDataFromNode( node, shaderStage );
  		const subBuildVariable = this.getSubBuildProperty( 'variable', nodeData.subBuilds );

  		let nodeVar = nodeData[ subBuildVariable ];

  		if ( nodeVar === undefined ) {

  			const idNS = readOnly ? '_const' : '_var';

  			const vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );
  			const id = this.vars[ idNS ] || ( this.vars[ idNS ] = 0 );

  			if ( name === null ) {

  				name = ( readOnly ? 'nodeConst' : 'nodeVar' ) + id;

  				this.vars[ idNS ] ++;

  			}

  			//

  			if ( subBuildVariable !== 'variable' ) {

  				name = this.getSubBuildProperty( name, nodeData.subBuilds );

  			}

  			//

  			const count = this.getArrayCount( node );

  			nodeVar = new NodeVar( name, type, readOnly, count );

  			if ( ! readOnly ) {

  				vars.push( nodeVar );

  			}

  			this.registerDeclaration( nodeVar );

  			nodeData[ subBuildVariable ] = nodeVar;

  		}

  		return nodeVar;

  	}

  	/**
  	 * Returns whether a Node or its flow is deterministic, useful for use in `const`.
  	 *
  	 * @param {Node} node - The varying node.
  	 * @return {boolean} Returns true if deterministic.
  	 */
  	isDeterministic( node ) {

  		if ( node.isMathNode ) {

  			return this.isDeterministic( node.aNode ) &&
  				( node.bNode ? this.isDeterministic( node.bNode ) : true ) &&
  				( node.cNode ? this.isDeterministic( node.cNode ) : true );

  		} else if ( node.isOperatorNode ) {

  			return this.isDeterministic( node.aNode ) &&
  				( node.bNode ? this.isDeterministic( node.bNode ) : true );

  		} else if ( node.isArrayNode ) {

  			if ( node.values !== null ) {

  				for ( const n of node.values ) {

  					if ( ! this.isDeterministic( n ) ) {

  						return false;

  					}

  				}

  			}

  			return true;

  		} else if ( node.isConstNode ) {

  			return true;

  		}

  		return false;

  	}

  	/**
  	 * Returns an instance of {@link NodeVarying} for the given varying node.
  	 *
  	 * @param {(VaryingNode|PropertyNode)} node - The varying node.
  	 * @param {?string} name - The varying's name.
  	 * @param {string} [type=node.getNodeType( this )] - The varying's type.
  	 * @param {?string} interpolationType - The interpolation type of the varying.
  	 * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
  	 * @return {NodeVar} The node varying.
  	 */
  	getVaryingFromNode( node, name = null, type = node.getNodeType( this ), interpolationType = null, interpolationSampling = null ) {

  		const nodeData = this.getDataFromNode( node, 'any' );
  		const subBuildVarying = this.getSubBuildProperty( 'varying', nodeData.subBuilds );

  		let nodeVarying = nodeData[ subBuildVarying ];

  		if ( nodeVarying === undefined ) {

  			const varyings = this.varyings;
  			const index = varyings.length;

  			if ( name === null ) name = 'nodeVarying' + index;

  			//

  			if ( subBuildVarying !== 'varying' ) {

  				name = this.getSubBuildProperty( name, nodeData.subBuilds );

  			}

  			//

  			nodeVarying = new NodeVarying( name, type, interpolationType, interpolationSampling );

  			varyings.push( nodeVarying );

  			this.registerDeclaration( nodeVarying );

  			nodeData[ subBuildVarying ] = nodeVarying;

  		}

  		return nodeVarying;

  	}

  	/**
  	 * Registers a node declaration in the current shader stage.
  	 *
  	 * @param {Object} node - The node to be registered.
  	 */
  	registerDeclaration( node ) {

  		const shaderStage = this.shaderStage;
  		const declarations = this.declarations[ shaderStage ] || ( this.declarations[ shaderStage ] = {} );

  		const property = this.getPropertyName( node );

  		let index = 1;
  		let name = property;

  		// Automatically renames the property if the name is already in use.

  		while ( declarations[ name ] !== undefined ) {

  			name = property + '_' + index ++;

  		}

  		if ( index > 1 ) {

  			node.name = name;

  			console.warn( `THREE.TSL: Declaration name '${ property }' of '${ node.type }' already in use. Renamed to '${ name }'.` );

  		}

  		declarations[ name ] = node;

  	}

  	/**
  	 * Returns an instance of {@link NodeCode} for the given code node.
  	 *
  	 * @param {CodeNode} node - The code node.
  	 * @param {string} type - The node type.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
  	 * @return {NodeCode} The node code.
  	 */
  	getCodeFromNode( node, type, shaderStage = this.shaderStage ) {

  		const nodeData = this.getDataFromNode( node );

  		let nodeCode = nodeData.code;

  		if ( nodeCode === undefined ) {

  			const codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );
  			const index = codes.length;

  			nodeCode = new NodeCode( 'nodeCode' + index, type );

  			codes.push( nodeCode );

  			nodeData.code = nodeCode;

  		}

  		return nodeCode;

  	}

  	/**
  	 * Adds a code flow based on the code-block hierarchy.

  	 * This is used so that code-blocks like If,Else create their variables locally if the Node
  	 * is only used inside one of these conditionals in the current shader stage.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
  	 */
  	addFlowCodeHierarchy( node, nodeBlock ) {

  		const { flowCodes, flowCodeBlock } = this.getDataFromNode( node );

  		let needsFlowCode = true;
  		let nodeBlockHierarchy = nodeBlock;

  		while ( nodeBlockHierarchy ) {

  			if ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {

  				needsFlowCode = false;
  				break;

  			}

  			nodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;

  		}

  		if ( needsFlowCode ) {

  			for ( const flowCode of flowCodes ) {

  				this.addLineFlowCode( flowCode );

  			}

  		}

  	}

  	/**
  	 * Add a inline-code to the current flow code-block.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {string} code - The code to add.
  	 * @param {Node} nodeBlock - Current ConditionalNode
  	 */
  	addLineFlowCodeBlock( node, code, nodeBlock ) {

  		const nodeData = this.getDataFromNode( node );
  		const flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );
  		const codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );

  		flowCodes.push( code );
  		codeBlock.set( nodeBlock, true );

  	}

  	/**
  	 * Add a inline-code to the current flow.
  	 *
  	 * @param {string} code - The code to add.
  	 * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
  	 * @return {NodeBuilder} A reference to this node builder.
  	 */
  	addLineFlowCode( code, node = null ) {

  		if ( code === '' ) return this;

  		if ( node !== null && this.context.nodeBlock ) {

  			this.addLineFlowCodeBlock( node, code, this.context.nodeBlock );

  		}

  		code = this.tab + code;

  		if ( ! /;\s*$/.test( code ) ) {

  			code = code + ';\n';

  		}

  		this.flow.code += code;

  		return this;

  	}

  	/**
  	 * Adds a code to the current code flow.
  	 *
  	 * @param {string} code - Shader code.
  	 * @return {NodeBuilder} A reference to this node builder.
  	 */
  	addFlowCode( code ) {

  		this.flow.code += code;

  		return this;

  	}

  	/**
  	 * Add tab in the code that will be generated so that other snippets respect the current tabulation.
  	 * Typically used in codes with If,Else.
  	 *
  	 * @return {NodeBuilder} A reference to this node builder.
  	 */
  	addFlowTab() {

  		this.tab += '\t';

  		return this;

  	}

  	/**
  	 * Removes a tab.
  	 *
  	 * @return {NodeBuilder} A reference to this node builder.
  	 */
  	removeFlowTab() {

  		this.tab = this.tab.slice( 0, -1 );

  		return this;

  	}

  	/**
  	 * Gets the current flow data based on a Node.
  	 *
  	 * @param {Node} node - Node that the flow was started.
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {Object} The flow data.
  	 */
  	getFlowData( node/*, shaderStage*/ ) {

  		return this.flowsData.get( node );

  	}

  	/**
  	 * Executes the node flow based on a root node to generate the final shader code.
  	 *
  	 * @param {Node} node - The node to execute.
  	 * @return {Object} The code flow.
  	 */
  	flowNode( node ) {

  		const output = node.getNodeType( this );

  		const flowData = this.flowChildNode( node, output );

  		this.flowsData.set( node, flowData );

  		return flowData;

  	}

  	/**
  	 * Includes a node in the current function node.
  	 *
  	 * @param {Node} node - The node to include.
  	 * @returns {void}
  	 */
  	addInclude( node ) {

  		if ( this.currentFunctionNode !== null ) {

  			this.currentFunctionNode.includes.push( node );

  		}

  	}

  	/**
  	 * Returns the native shader operator name for a given generic name.
  	 * It is a similar type of method like {@link NodeBuilder#getMethod}.
  	 *
  	 * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
  	 * @return {FunctionNode} The build function node.
  	 */
  	buildFunctionNode( shaderNode ) {

  		const fn = new FunctionNode();

  		const previous = this.currentFunctionNode;

  		this.currentFunctionNode = fn;

  		fn.code = this.buildFunctionCode( shaderNode );

  		this.currentFunctionNode = previous;

  		return fn;

  	}

  	/**
  	 * Generates a code flow based on a TSL function: Fn().
  	 *
  	 * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
  	 * @return {Object}
  	 */
  	flowShaderNode( shaderNode ) {

  		const layout = shaderNode.layout;

  		const inputs = {
  			[ Symbol.iterator ]() {

  				let index = 0;
  				const values = Object.values( this );
  				return {
  					next: () => ( {
  						value: values[ index ],
  						done: index ++ >= values.length
  					} )
  				};

  			}
  		};

  		for ( const input of layout.inputs ) {

  			inputs[ input.name ] = new ParameterNode( input.type, input.name );

  		}

  		//

  		shaderNode.layout = null;

  		const callNode = shaderNode.call( inputs );
  		const flowData = this.flowStagesNode( callNode, layout.type );

  		shaderNode.layout = layout;

  		return flowData;

  	}

  	/**
  	 * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
  	 *
  	 * @param {Node} node - The node to execute.
  	 * @param {?string} output - Expected output type. For example 'vec3'.
  	 * @return {Object}
  	 */
  	flowStagesNode( node, output = null ) {

  		const previousFlow = this.flow;
  		const previousVars = this.vars;
  		const previousDeclarations = this.declarations;
  		const previousCache = this.cache;
  		const previousBuildStage = this.buildStage;
  		const previousStack = this.stack;

  		const flow = {
  			code: ''
  		};

  		this.flow = flow;
  		this.vars = {};
  		this.declarations = {};
  		this.cache = new NodeCache();
  		this.stack = stack();

  		for ( const buildStage of defaultBuildStages ) {

  			this.setBuildStage( buildStage );

  			flow.result = node.build( this, output );

  		}

  		flow.vars = this.getVars( this.shaderStage );

  		this.flow = previousFlow;
  		this.vars = previousVars;
  		this.declarations = previousDeclarations;
  		this.cache = previousCache;
  		this.stack = previousStack;

  		this.setBuildStage( previousBuildStage );

  		return flow;

  	}

  	/**
  	 * Returns the native shader operator name for a given generic name.
  	 * It is a similar type of method like {@link NodeBuilder#getMethod}.
  	 *
  	 * @abstract
  	 * @param {string} op - The operator name to resolve.
  	 * @return {?string} The resolved operator name.
  	 */
  	getFunctionOperator( /* op */ ) {

  		return null;

  	}

  	/**
  	 * Builds the given shader node.
  	 *
  	 * @abstract
  	 * @param {ShaderNodeInternal} shaderNode - The shader node.
  	 * @return {string} The function code.
  	 */
  	buildFunctionCode( /* shaderNode */ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Generates a code flow based on a child Node.
  	 *
  	 * @param {Node} node - The node to execute.
  	 * @param {?string} output - Expected output type. For example 'vec3'.
  	 * @return {Object} The code flow.
  	 */
  	flowChildNode( node, output = null ) {

  		const previousFlow = this.flow;

  		const flow = {
  			code: ''
  		};

  		this.flow = flow;

  		flow.result = node.build( this, output );

  		this.flow = previousFlow;

  		return flow;

  	}

  	/**
  	 * Executes a flow of code in a different stage.
  	 *
  	 * Some nodes like `varying()` have the ability to compute code in vertex-stage and
  	 * return the value in fragment-stage even if it is being executed in an input fragment.
  	 *
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @param {Node} node - The node to execute.
  	 * @param {?string} output - Expected output type. For example 'vec3'.
  	 * @param {?string} propertyName - The property name to assign the result.
  	 * @return {Object|Node|null} The code flow or node.build() result.
  	 */
  	flowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {

  		const previousTab = this.tab;
  		const previousCache = this.cache;
  		const previousShaderStage = this.shaderStage;
  		const previousContext = this.context;

  		this.setShaderStage( shaderStage );

  		const context = { ...this.context };
  		delete context.nodeBlock;

  		this.cache = this.globalCache;
  		this.tab = '\t';
  		this.context = context;

  		let result = null;

  		if ( this.buildStage === 'generate' ) {

  			const flowData = this.flowChildNode( node, output );

  			if ( propertyName !== null ) {

  				flowData.code += `${ this.tab + propertyName } = ${ flowData.result };\n`;

  			}

  			this.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;

  			result = flowData;

  		} else {

  			result = node.build( this );

  		}

  		this.setShaderStage( previousShaderStage );

  		this.cache = previousCache;
  		this.tab = previousTab;
  		this.context = previousContext;

  		return result;

  	}

  	/**
  	 * Returns an array holding all node attributes of this node builder.
  	 *
  	 * @return {Array<NodeAttribute>} The node attributes of this builder.
  	 */
  	getAttributesArray() {

  		return this.attributes.concat( this.bufferAttributes );

  	}

  	/**
  	 * Returns the attribute definitions as a shader string for the given shader stage.
  	 *
  	 * @abstract
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {string} The attribute code section.
  	 */
  	getAttributes( /*shaderStage*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the varying definitions as a shader string for the given shader stage.
  	 *
  	 * @abstract
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {string} The varying code section.
  	 */
  	getVaryings( /*shaderStage*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns a single variable definition as a shader string for the given variable type and name.
  	 *
  	 * @param {string} type - The variable's type.
  	 * @param {string} name - The variable's name.
  	 * @param {?number} [count=null] - The array length.
  	 * @return {string} The shader string.
  	 */
  	getVar( type, name, count = null ) {

  		return `${ count !== null ? this.generateArrayDeclaration( type, count ) : this.getType( type ) } ${ name }`;

  	}

  	/**
  	 * Returns the variable definitions as a shader string for the given shader stage.
  	 *
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {string} The variable code section.
  	 */
  	getVars( shaderStage ) {

  		let snippet = '';

  		const vars = this.vars[ shaderStage ];

  		if ( vars !== undefined ) {

  			for ( const variable of vars ) {

  				snippet += `${ this.getVar( variable.type, variable.name ) }; `;

  			}

  		}

  		return snippet;

  	}

  	/**
  	 * Returns the uniform definitions as a shader string for the given shader stage.
  	 *
  	 * @abstract
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {string} The uniform code section.
  	 */
  	getUniforms( /*shaderStage*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the native code definitions as a shader string for the given shader stage.
  	 *
  	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
  	 * @return {string} The native code section.
  	 */
  	getCodes( shaderStage ) {

  		const codes = this.codes[ shaderStage ];

  		let code = '';

  		if ( codes !== undefined ) {

  			for ( const nodeCode of codes ) {

  				code += nodeCode.code + '\n';

  			}

  		}

  		return code;

  	}

  	/**
  	 * Returns the hash of this node builder.
  	 *
  	 * @return {string} The hash.
  	 */
  	getHash() {

  		return this.vertexShader + this.fragmentShader + this.computeShader;

  	}

  	/**
  	 * Sets the current shader stage.
  	 *
  	 * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
  	 */
  	setShaderStage( shaderStage ) {

  		this.shaderStage = shaderStage;

  	}

  	/**
  	 * Returns the current shader stage.
  	 *
  	 * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
  	 */
  	getShaderStage() {

  		return this.shaderStage;

  	}

  	/**
  	 * Sets the current build stage.
  	 *
  	 * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
  	 */
  	setBuildStage( buildStage ) {

  		this.buildStage = buildStage;

  	}

  	/**
  	 * Returns the current build stage.
  	 *
  	 * @return {?('setup'|'analyze'|'generate')} The current build stage.
  	 */
  	getBuildStage() {

  		return this.buildStage;

  	}

  	/**
  	 * Controls the code build of the shader stages.
  	 *
  	 * @abstract
  	 */
  	buildCode() {

  		console.warn( 'Abstract function.' );

  	}

  	/**
  	 * Returns the current sub-build layer.
  	 *
  	 * @return {SubBuildNode} The current sub-build layers.
  	 */
  	get subBuild() {

  		return this.subBuildLayers[ this.subBuildLayers.length - 1 ] || null;

  	}

  	/**
  	 * Adds a sub-build layer to the node builder.
  	 *
  	 * @param {SubBuildNode} subBuild - The sub-build layer to add.
  	 */
  	addSubBuild( subBuild ) {

  		this.subBuildLayers.push( subBuild );

  	}

  	/**
  	 * Removes the last sub-build layer from the node builder.
  	 *
  	 * @return {SubBuildNode} The removed sub-build layer.
  	 */
  	removeSubBuild() {

  		return this.subBuildLayers.pop();

  	}

  	/**
  	 * Returns the closest sub-build layer for the given data.
  	 *
  	 * @param {Node|Set|Array} data - The data to get the closest sub-build layer from.
  	 * @return {?string} The closest sub-build name or null if none found.
  	 */
  	getClosestSubBuild( data ) {

  		let subBuilds;

  		if ( data && data.isNode ) {

  			if ( data.isShaderCallNodeInternal ) {

  				subBuilds = data.shaderNode.subBuilds;

  			} else if ( data.isStackNode ) {

  				subBuilds = [ data.subBuild ];

  			} else {

  				subBuilds = this.getDataFromNode( data, 'any' ).subBuilds;

  			}

  		} else if ( data instanceof Set ) {

  			subBuilds = [ ...data ];

  		} else {

  			subBuilds = data;

  		}

  		if ( ! subBuilds ) return null;

  		const subBuildLayers = this.subBuildLayers;

  		for ( let i = subBuilds.length - 1; i >= 0; i -- ) {

  			const subBuild = subBuilds[ i ];

  			if ( subBuildLayers.includes( subBuild ) ) {

  				return subBuild;

  			}

  		}

  		return null;

  	}


  	/**
  	 * Returns the output node of a sub-build layer.
  	 *
  	 * @param {Node} node - The node to get the output from.
  	 * @return {string} The output node name.
  	 */
  	getSubBuildOutput( node ) {

  		return this.getSubBuildProperty( 'outputNode', node );

  	}

  	/**
  	 * Returns the sub-build property name for the given property and node.
  	 *
  	 * @param {string} [property=''] - The property name.
  	 * @param {?Node} [node=null] - The node to get the sub-build from.
  	 * @return {string} The sub-build property name.
  	 */
  	getSubBuildProperty( property = '', node = null ) {

  		let subBuild;

  		if ( node !== null ) {

  			subBuild = this.getClosestSubBuild( node );

  		} else {

  			subBuild = this.subBuildFn;

  		}

  		let result;

  		if ( subBuild ) {

  			result = property ? ( subBuild + '_' + property ) : subBuild;

  		} else {

  			result = property;

  		}

  		return result;

  	}

  	/**
  	 * Central build method which controls the build for the given object.
  	 *
  	 * @return {NodeBuilder} A reference to this node builder.
  	 */
  	build() {

  		const { object, material, renderer } = this;

  		if ( material !== null ) {

  			let nodeMaterial = renderer.library.fromMaterial( material );

  			if ( nodeMaterial === null ) {

  				console.error( `NodeMaterial: Material "${ material.type }" is not compatible.` );

  				nodeMaterial = new NodeMaterial();

  			}

  			nodeMaterial.build( this );

  		} else {

  			this.addFlow( 'compute', object );

  		}

  		// setup() -> stage 1: create possible new nodes and returns an output reference node
  		// analyze()   -> stage 2: analyze nodes to possible optimization and validation
  		// generate()  -> stage 3: generate shader

  		for ( const buildStage of defaultBuildStages ) {

  			this.setBuildStage( buildStage );

  			if ( this.context.vertex && this.context.vertex.isNode ) {

  				this.flowNodeFromShaderStage( 'vertex', this.context.vertex );

  			}

  			for ( const shaderStage of shaderStages ) {

  				this.setShaderStage( shaderStage );

  				const flowNodes = this.flowNodes[ shaderStage ];

  				for ( const node of flowNodes ) {

  					if ( buildStage === 'generate' ) {

  						this.flowNode( node );

  					} else {

  						node.build( this );

  					}

  				}

  			}

  		}

  		this.setBuildStage( null );
  		this.setShaderStage( null );

  		// stage 4: build code for a specific output

  		this.buildCode();
  		this.buildUpdateNodes();

  		return this;

  	}

  	/**
  	 * Returns a uniform representation which is later used for UBO generation and rendering.
  	 *
  	 * @param {NodeUniform} uniformNode - The uniform node.
  	 * @param {string} type - The requested type.
  	 * @return {Uniform} The uniform.
  	 */
  	getNodeUniform( uniformNode, type ) {

  		if ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );
  		if ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );
  		if ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );
  		if ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );
  		if ( type === 'color' ) return new ColorNodeUniform( uniformNode );
  		if ( type === 'mat2' ) return new Matrix2NodeUniform( uniformNode );
  		if ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );
  		if ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );

  		throw new Error( `Uniform "${type}" not declared.` );

  	}

  	/**
  	 * Formats the given shader snippet from a given type into another one. E.g.
  	 * this method might be used to convert a simple float string `"1.0"` into a
  	 * `vec3` representation: `"vec3<f32>( 1.0 )"`.
  	 *
  	 * @param {string} snippet - The shader snippet.
  	 * @param {string} fromType - The source type.
  	 * @param {string} toType - The target type.
  	 * @return {string} The updated shader string.
  	 */
  	format( snippet, fromType, toType ) {

  		fromType = this.getVectorType( fromType );
  		toType = this.getVectorType( toType );

  		if ( fromType === toType || toType === null || this.isReference( toType ) ) {

  			return snippet;

  		}

  		const fromTypeLength = this.getTypeLength( fromType );
  		const toTypeLength = this.getTypeLength( toType );

  		if ( fromTypeLength === 16 && toTypeLength === 9 ) {

  			return `${ this.getType( toType ) }( ${ snippet }[ 0 ].xyz, ${ snippet }[ 1 ].xyz, ${ snippet }[ 2 ].xyz )`;

  		}

  		if ( fromTypeLength === 9 && toTypeLength === 4 ) {

  			return `${ this.getType( toType ) }( ${ snippet }[ 0 ].xy, ${ snippet }[ 1 ].xy )`;

  		}


  		if ( fromTypeLength > 4 ) { // fromType is matrix-like

  			// @TODO: ignore for now

  			return snippet;

  		}

  		if ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown

  			// @TODO: ignore for now

  			return snippet;

  		}

  		if ( fromTypeLength === toTypeLength ) {

  			return `${ this.getType( toType ) }( ${ snippet } )`;

  		}

  		if ( fromTypeLength > toTypeLength ) {

  			snippet = toType === 'bool' ? `all( ${ snippet } )` : `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`;

  			return this.format( snippet, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );

  		}

  		if ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like

  			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;

  		}

  		if ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like

  			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;

  		}

  		if ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like

  			// convert a number value to vector type, e.g:
  			// vec3( 1u ) -> vec3( float( 1u ) )

  			snippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;

  		}

  		return `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like

  	}

  	/**
  	 * Returns a signature with the engine's current revision.
  	 *
  	 * @return {string} The signature.
  	 */
  	getSignature() {

  		return `// Three.js r${ REVISION } - Node System\n`;

  	}

  	/**
  	 * Prevents the node builder from being used as an iterable in TSL.Fn(), avoiding potential runtime errors.
  	 */
  	*[ Symbol.iterator ]() { }

  }

  /**
   * Management class for updating nodes. The module tracks metrics like
   * the elapsed time, delta time, the render and frame ID to correctly
   * call the node update methods {@link Node#updateBefore}, {@link Node#update}
   * and {@link Node#updateAfter} depending on the node's configuration.
   */
  class NodeFrame {

  	/**
  	 * Constructs a new node fame.
  	 */
  	constructor() {

  		/**
  		 * The elapsed time in seconds.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.time = 0;

  		/**
  		 * The delta time in seconds.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.deltaTime = 0;

  		/**
  		 * The frame ID.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.frameId = 0;

  		/**
  		 * The render ID.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.renderId = 0;

  		/**
  		 * Used to control the {@link Node#update} call.
  		 *
  		 * @type {WeakMap<Node, Object>}
  		 */
  		this.updateMap = new WeakMap();

  		/**
  		 * Used to control the {@link Node#updateBefore} call.
  		 *
  		 * @type {WeakMap<Node, Object>}
  		 */
  		this.updateBeforeMap = new WeakMap();

  		/**
  		 * Used to control the {@link Node#updateAfter} call.
  		 *
  		 * @type {WeakMap<Node, Object>}
  		 */
  		this.updateAfterMap = new WeakMap();

  		/**
  		 * A reference to the current renderer.
  		 *
  		 * @type {?Renderer}
  		 * @default null
  		 */
  		this.renderer = null;

  		/**
  		 * A reference to the current material.
  		 *
  		 * @type {?Material}
  		 * @default null
  		 */
  		this.material = null;

  		/**
  		 * A reference to the current camera.
  		 *
  		 * @type {?Camera}
  		 * @default null
  		 */
  		this.camera = null;

  		/**
  		 * A reference to the current 3D object.
  		 *
  		 * @type {?Object3D}
  		 * @default null
  		 */
  		this.object = null;

  		/**
  		 * A reference to the current scene.
  		 *
  		 * @type {?Scene}
  		 * @default null
  		 */
  		this.scene = null;

  	}

  	/**
  	 * Returns a dictionary for a given node and update map which
  	 * is used to correctly call node update methods per frame or render.
  	 *
  	 * @private
  	 * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
  	 * @param {Node} nodeRef - The reference to the current node.
  	 * @return {Object<string,WeakMap>} The dictionary.
  	 */
  	_getMaps( referenceMap, nodeRef ) {

  		let maps = referenceMap.get( nodeRef );

  		if ( maps === undefined ) {

  			maps = {
  				renderMap: new WeakMap(),
  				frameMap: new WeakMap()
  			};

  			referenceMap.set( nodeRef, maps );

  		}

  		return maps;

  	}

  	/**
  	 * This method executes the {@link Node#updateBefore} for the given node.
  	 * It makes sure {@link Node#updateBeforeType} is honored meaning the update
  	 * is only executed once per frame, render or object depending on the update
  	 * type.
  	 *
  	 * @param {Node} node - The node that should be updated.
  	 */
  	updateBeforeNode( node ) {

  		const updateType = node.getUpdateBeforeType();
  		const reference = node.updateReference( this );

  		if ( updateType === NodeUpdateType.FRAME ) {

  			const { frameMap } = this._getMaps( this.updateBeforeMap, reference );

  			if ( frameMap.get( reference ) !== this.frameId ) {

  				if ( node.updateBefore( this ) !== false ) {

  					frameMap.set( reference, this.frameId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.RENDER ) {

  			const { renderMap } = this._getMaps( this.updateBeforeMap, reference );

  			if ( renderMap.get( reference ) !== this.renderId ) {

  				if ( node.updateBefore( this ) !== false ) {

  					renderMap.set( reference, this.renderId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.OBJECT ) {

  			node.updateBefore( this );

  		}

  	}

  	/**
  	 * This method executes the {@link Node#updateAfter} for the given node.
  	 * It makes sure {@link Node#updateAfterType} is honored meaning the update
  	 * is only executed once per frame, render or object depending on the update
  	 * type.
  	 *
  	 * @param {Node} node - The node that should be updated.
  	 */
  	updateAfterNode( node ) {

  		const updateType = node.getUpdateAfterType();
  		const reference = node.updateReference( this );

  		if ( updateType === NodeUpdateType.FRAME ) {

  			const { frameMap } = this._getMaps( this.updateAfterMap, reference );

  			if ( frameMap.get( reference ) !== this.frameId ) {

  				if ( node.updateAfter( this ) !== false ) {

  					frameMap.set( reference, this.frameId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.RENDER ) {

  			const { renderMap } = this._getMaps( this.updateAfterMap, reference );

  			if ( renderMap.get( reference ) !== this.renderId ) {

  				if ( node.updateAfter( this ) !== false ) {

  					renderMap.set( reference, this.renderId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.OBJECT ) {

  			node.updateAfter( this );

  		}

  	}

  	/**
  	 * This method executes the {@link Node#update} for the given node.
  	 * It makes sure {@link Node#updateType} is honored meaning the update
  	 * is only executed once per frame, render or object depending on the update
  	 * type.
  	 *
  	 * @param {Node} node - The node that should be updated.
  	 */
  	updateNode( node ) {

  		const updateType = node.getUpdateType();
  		const reference = node.updateReference( this );

  		if ( updateType === NodeUpdateType.FRAME ) {

  			const { frameMap } = this._getMaps( this.updateMap, reference );

  			if ( frameMap.get( reference ) !== this.frameId ) {

  				if ( node.update( this ) !== false ) {

  					frameMap.set( reference, this.frameId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.RENDER ) {

  			const { renderMap } = this._getMaps( this.updateMap, reference );

  			if ( renderMap.get( reference ) !== this.renderId ) {

  				if ( node.update( this ) !== false ) {

  					renderMap.set( reference, this.renderId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.OBJECT ) {

  			node.update( this );

  		}

  	}

  	/**
  	 * Updates the internal state of the node frame. This method is
  	 * called by the renderer in its internal animation loop.
  	 */
  	update() {

  		this.frameId ++;

  		if ( this.lastTime === undefined ) this.lastTime = performance.now();

  		this.deltaTime = ( performance.now() - this.lastTime ) / 1000;

  		this.lastTime = performance.now();

  		this.time += this.deltaTime;

  	}

  }

  /**
   * Describes the input of a {@link NodeFunction}.
   */
  class NodeFunctionInput {

  	/**
  	 * Constructs a new node function input.
  	 *
  	 * @param {string} type - The input type.
  	 * @param {string} name - The input name.
  	 * @param {?number} [count=null] - If the input is an Array, count will be the length.
  	 * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
  	 * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
  	 */
  	constructor( type, name, count = null, qualifier = '', isConst = false ) {

  		/**
  		 *  The input type.
  		 *
  		 * @type {string}
  		 */
  		this.type = type;

  		/**
  		 * The input name.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * If the input is an Array, count will be the length.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this.count = count;

  		/**
  		 *The parameter qualifier (only relevant for GLSL).
  		 *
  		 * @type {('in'|'out'|'inout')}
  		 * @default ''
  		 */
  		this.qualifier = qualifier;

  		/**
  		 * Whether the input uses a const qualifier or not (only relevant for GLSL).
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.isConst = isConst;

  	}

  }

  NodeFunctionInput.isNodeFunctionInput = true;

  /**
   * Module for representing directional lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  class DirectionalLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'DirectionalLightNode';

  	}

  	/**
  	 * Constructs a new directional light node.
  	 *
  	 * @param {?DirectionalLight} [light=null] - The directional light source.
  	 */
  	constructor( light = null ) {

  		super( light );

  	}

  	setupDirect() {

  		const lightColor = this.colorNode;
  		const lightDirection = lightTargetDirection( this.light );

  		return { lightDirection, lightColor };

  	}

  }

  const _matrix41 = /*@__PURE__*/ new Matrix4();
  const _matrix42 = /*@__PURE__*/ new Matrix4();

  let _ltcLib = null;

  /**
   * Module for representing rect area lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  class RectAreaLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'RectAreaLightNode';

  	}

  	/**
  	 * Constructs a new rect area light node.
  	 *
  	 * @param {?RectAreaLight} [light=null] - The rect area light source.
  	 */
  	constructor( light = null ) {

  		super( light );

  		/**
  		 * Uniform node representing the half height of the are light.
  		 *
  		 * @type {UniformNode<vec3>}
  		 */
  		this.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );

  		/**
  		 * Uniform node representing the half width of the are light.
  		 *
  		 * @type {UniformNode<vec3>}
  		 */
  		this.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );

  		/**
  		 * The `updateType` is set to `NodeUpdateType.RENDER` since the light
  		 * relies on `viewMatrix` which might vary per render call.
  		 *
  		 * @type {string}
  		 * @default 'render'
  		 */
  		this.updateType = NodeUpdateType.RENDER;

  	}

  	/**
  	 * Overwritten to updated rect area light specific uniforms.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( frame ) {

  		super.update( frame );

  		const { light } = this;

  		const viewMatrix = frame.camera.matrixWorldInverse;

  		_matrix42.identity();
  		_matrix41.copy( light.matrixWorld );
  		_matrix41.premultiply( viewMatrix );
  		_matrix42.extractRotation( _matrix41 );

  		this.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );
  		this.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );

  		this.halfWidth.value.applyMatrix4( _matrix42 );
  		this.halfHeight.value.applyMatrix4( _matrix42 );

  	}

  	setupDirectRectArea( builder ) {

  		let ltc_1, ltc_2;

  		if ( builder.isAvailable( 'float32Filterable' ) ) {

  			ltc_1 = texture( _ltcLib.LTC_FLOAT_1 );
  			ltc_2 = texture( _ltcLib.LTC_FLOAT_2 );

  		} else {

  			ltc_1 = texture( _ltcLib.LTC_HALF_1 );
  			ltc_2 = texture( _ltcLib.LTC_HALF_2 );

  		}

  		const { colorNode, light } = this;

  		const lightPosition = lightViewPosition( light );

  		return {
  			lightColor: colorNode,
  			lightPosition,
  			halfWidth: this.halfWidth,
  			halfHeight: this.halfHeight,
  			ltc_1,
  			ltc_2
  		};

  	}

  	/**
  	 * Used to configure the internal BRDF approximation texture data.
  	 *
  	 * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
  	 */
  	static setLTC( ltc ) {

  		_ltcLib = ltc;

  	}

  }

  /**
   * Module for representing spot lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  class SpotLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'SpotLightNode';

  	}

  	/**
  	 * Constructs a new spot light node.
  	 *
  	 * @param {?SpotLight} [light=null] - The spot light source.
  	 */
  	constructor( light = null ) {

  		super( light );

  		/**
  		 * Uniform node representing the cone cosine.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.coneCosNode = uniform( 0 ).setGroup( renderGroup );

  		/**
  		 * Uniform node representing the penumbra cosine.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );

  		/**
  		 * Uniform node representing the cutoff distance.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );

  		/**
  		 * Uniform node representing the decay exponent.
  		 *
  		 * @type {UniformNode<float>}
  		 */
  		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

  		/**
  		 * Uniform node representing the light color.
  		 *
  		 * @type {UniformNode<Color>}
  		 */
  		this.colorNode = uniform( this.color ).setGroup( renderGroup );

  	}

  	/**
  	 * Overwritten to updated spot light specific uniforms.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( frame ) {

  		super.update( frame );

  		const { light } = this;

  		this.coneCosNode.value = Math.cos( light.angle );
  		this.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );

  		this.cutoffDistanceNode.value = light.distance;
  		this.decayExponentNode.value = light.decay;

  	}

  	/**
  	 * Computes the spot attenuation for the given angle.
  	 *
  	 * @param {NodeBuilder} builder - The node builder.
  	 * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
  	 * @return {Node<float>} The spot attenuation.
  	 */
  	getSpotAttenuation( builder, angleCosine ) {

  		const { coneCosNode, penumbraCosNode } = this;

  		return smoothstep( coneCosNode, penumbraCosNode, angleCosine );

  	}

  	getLightCoord( builder ) {

  		const properties = builder.getNodeProperties( this );
  		let projectionUV = properties.projectionUV;

  		if ( projectionUV === undefined ) {

  			projectionUV = lightProjectionUV( this.light, builder.context.positionWorld );

  			properties.projectionUV = projectionUV;

  		}

  		return projectionUV;

  	}

  	setupDirect( builder ) {

  		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

  		const lightVector = this.getLightVector( builder );

  		const lightDirection = lightVector.normalize();
  		const angleCos = lightDirection.dot( lightTargetDirection( light ) );

  		const spotAttenuation = this.getSpotAttenuation( builder, angleCos );

  		const lightDistance = lightVector.length();

  		const lightAttenuation = getDistanceAttenuation( {
  			lightDistance,
  			cutoffDistance: cutoffDistanceNode,
  			decayExponent: decayExponentNode
  		} );

  		let lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );

  		let projected, lightCoord;

  		if ( light.colorNode ) {

  			lightCoord = this.getLightCoord( builder );
  			projected = light.colorNode( lightCoord );

  		} else if ( light.map ) {

  			lightCoord = this.getLightCoord( builder );
  			projected = texture( light.map, lightCoord.xy ).onRenderUpdate( () => light.map );

  		}

  		if ( projected ) {

  			const inSpotLightMap = lightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();

  			lightColor = inSpotLightMap.select( lightColor.mul( projected ), lightColor );

  		}

  		return { lightColor, lightDirection };

  	}

  }

  /**
   * An IES version of the default spot light node.
   *
   * @augments SpotLightNode
   */
  class IESSpotLightNode extends SpotLightNode {

  	static get type() {

  		return 'IESSpotLightNode';

  	}

  	/**
  	 * Overwrites the default implementation to compute an IES conform spot attenuation.
  	 *
  	 * @param {NodeBuilder} builder - The node builder.
  	 * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
  	 * @return {Node<float>} The spot attenuation.
  	 */
  	getSpotAttenuation( builder, angleCosine ) {

  		const iesMap = this.light.iesMap;

  		let spotAttenuation = null;

  		if ( iesMap && iesMap.isTexture === true ) {

  			const angle = angleCosine.acos().mul( 1.0 / Math.PI );

  			spotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;

  		} else {

  			spotAttenuation = super.getSpotAttenuation( angleCosine );

  		}

  		return spotAttenuation;

  	}

  }

  const sdBox = /*@__PURE__*/ Fn( ( [ p, b ] ) => {

  	const d = p.abs().sub( b );

  	return length( max$1( d, 0.0 ) ).add( min$1( max$1( d.x, d.y ), 0.0 ) );

  } );

  /**
   * An implementation of a projector light node.
   *
   * @augments SpotLightNode
   */
  class ProjectorLightNode extends SpotLightNode {

  	static get type() {

  		return 'ProjectorLightNode';

  	}

  	update( frame ) {

  		super.update( frame );

  		const light = this.light;

  		this.penumbraCosNode.value = Math.min( Math.cos( light.angle * ( 1 - light.penumbra ) ), .99999 );

  		if ( light.aspect === null ) {

  			let aspect = 1;

  			if ( light.map !== null ) {

  				aspect = light.map.width / light.map.height;

  			}

  			light.shadow.aspect = aspect;

  		} else {

  			light.shadow.aspect = light.aspect;

  		}

  	}

  	/**
  	 * Overwrites the default implementation to compute projection attenuation.
  	 *
  	 * @param {NodeBuilder} builder - The node builder.
  	 * @return {Node<float>} The spot attenuation.
  	 */
  	getSpotAttenuation( builder ) {

  		const penumbraCos = this.penumbraCosNode;
  		const spotLightCoord = this.getLightCoord( builder );
  		const coord = spotLightCoord.xyz.div( spotLightCoord.w );

  		const boxDist = sdBox( coord.xy.sub( vec2( 0.5 ) ), vec2( 0.5 ) );
  		const angleFactor = div( -1, sub( 1.0, acos( penumbraCos ) ).sub( 1.0 ) );
  		const attenuation = saturate$1( boxDist.mul( -2 ).mul( angleFactor ) );

  		return attenuation;

  	}

  }

  /**
   * Module for representing ambient lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  class AmbientLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'AmbientLightNode';

  	}

  	/**
  	 * Constructs a new ambient light node.
  	 *
  	 * @param {?AmbientLight} [light=null] - The ambient light source.
  	 */
  	constructor( light = null ) {

  		super( light );

  	}

  	setup( { context } ) {

  		context.irradiance.addAssign( this.colorNode );

  	}

  }

  /**
   * Module for representing hemisphere lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  class HemisphereLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'HemisphereLightNode';

  	}

  	/**
  	 * Constructs a new hemisphere light node.
  	 *
  	 * @param {?HemisphereLight} [light=null] - The hemisphere light source.
  	 */
  	constructor( light = null ) {

  		super( light );

  		/**
  		 * Uniform node representing the light's position.
  		 *
  		 * @type {UniformNode<vec3>}
  		 */
  		this.lightPositionNode = lightPosition( light );

  		/**
  		 * A node representing the light's direction.
  		 *
  		 * @type {Node<vec3>}
  		 */
  		this.lightDirectionNode = this.lightPositionNode.normalize();

  		/**
  		 * Uniform node representing the light's ground color.
  		 *
  		 * @type {UniformNode<vec3>}
  		 */
  		this.groundColorNode = uniform( new Color() ).setGroup( renderGroup );

  	}

  	/**
  	 * Overwritten to updated hemisphere light specific uniforms.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( frame ) {

  		const { light } = this;

  		super.update( frame );

  		this.lightPositionNode.object3d = light;

  		this.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );

  	}

  	setup( builder ) {

  		const { colorNode, groundColorNode, lightDirectionNode } = this;

  		const dotNL = normalWorld.dot( lightDirectionNode );
  		const hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );

  		const irradiance = mix$2( groundColorNode, colorNode, hemiDiffuseWeight );

  		builder.context.irradiance.addAssign( irradiance );

  	}

  }

  /**
   * Module for representing light probes as nodes.
   *
   * @augments AnalyticLightNode
   */
  class LightProbeNode extends AnalyticLightNode {

  	static get type() {

  		return 'LightProbeNode';

  	}

  	/**
  	 * Constructs a new light probe node.
  	 *
  	 * @param {?LightProbe} [light=null] - The light probe.
  	 */
  	constructor( light = null ) {

  		super( light );

  		const array = [];

  		for ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );

  		/**
  		 * Light probe represented as a uniform of spherical harmonics.
  		 *
  		 * @type {UniformArrayNode}
  		 */
  		this.lightProbe = uniformArray( array );

  	}

  	/**
  	 * Overwritten to updated light probe specific uniforms.
  	 *
  	 * @param {NodeFrame} frame - A reference to the current node frame.
  	 */
  	update( frame ) {

  		const { light } = this;

  		super.update( frame );

  		//

  		for ( let i = 0; i < 9; i ++ ) {

  			this.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );

  		}

  	}

  	setup( builder ) {

  		const irradiance = getShIrradianceAt( normalWorld, this.lightProbe );

  		builder.context.irradiance.addAssign( irradiance );

  	}

  }

  /**
   * Base class for node parsers. A derived parser must be implemented
   * for each supported native shader language.
   */
  class NodeParser {

  	/**
  	 * The method parses the given native code an returns a node function.
  	 *
  	 * @abstract
  	 * @param {string} source - The native shader code.
  	 * @return {NodeFunction} A node function.
  	 */
  	parseFunction( /*source*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  /**
   * Base class for node functions. A derived module must be implemented
   * for each supported native shader language. Similar to other `Node*` modules,
   * this class is only relevant during the building process and not used
   * in user-level code.
   */
  class NodeFunction {

  	/**
  	 * Constructs a new node function.
  	 *
  	 * @param {string} type - The node type. This type is the return type of the node function.
  	 * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
  	 * @param {string} [name=''] - The function's name.
  	 * @param {string} [precision=''] - The precision qualifier.
  	 */
  	constructor( type, inputs, name = '', precision = '' ) {

  		/**
  		 * The node type. This type is the return type of the node function.
  		 *
  		 * @type {string}
  		 */
  		this.type = type;

  		/**
  		 * The function's inputs.
  		 *
  		 * @type {Array<NodeFunctionInput>}
  		 */
  		this.inputs = inputs;

  		/**
  		 * The name of the uniform.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.name = name;

  		/**
  		 * The precision qualifier.
  		 *
  		 * @type {string}
  		 * @default ''
  		 */
  		this.precision = precision;

  	}

  	/**
  	 * This method returns the native code of the node function.
  	 *
  	 * @abstract
  	 * @param {string} name - The function's name.
  	 * @return {string} A shader code.
  	 */
  	getCode( /*name = this.name*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  NodeFunction.isNodeFunction = true;

  const declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
  const propertiesRegexp$1 = /[a-z_0-9]+/ig;

  const pragmaMain = '#pragma main';

  const parse$1 = ( source ) => {

  	source = source.trim();

  	const pragmaMainIndex = source.indexOf( pragmaMain );

  	const mainCode = pragmaMainIndex !== -1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;

  	const declaration = mainCode.match( declarationRegexp$1 );

  	if ( declaration !== null && declaration.length === 5 ) {

  		// tokenizer

  		const inputsCode = declaration[ 4 ];
  		const propsMatches = [];

  		let nameMatch = null;

  		while ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {

  			propsMatches.push( nameMatch );

  		}

  		// parser

  		const inputs = [];

  		let i = 0;

  		while ( i < propsMatches.length ) {

  			const isConst = propsMatches[ i ][ 0 ] === 'const';

  			if ( isConst === true ) {

  				i ++;

  			}

  			let qualifier = propsMatches[ i ][ 0 ];

  			if ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {

  				i ++;

  			} else {

  				qualifier = '';

  			}

  			const type = propsMatches[ i ++ ][ 0 ];

  			let count = Number.parseInt( propsMatches[ i ][ 0 ] );

  			if ( Number.isNaN( count ) === false ) i ++;
  			else count = null;

  			const name = propsMatches[ i ++ ][ 0 ];

  			inputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );

  		}

  		//

  		const blockCode = mainCode.substring( declaration[ 0 ].length );

  		const name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';
  		const type = declaration[ 2 ];

  		const precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';

  		const headerCode = pragmaMainIndex !== -1 ? source.slice( 0, pragmaMainIndex ) : '';

  		return {
  			type,
  			inputs,
  			name,
  			precision,
  			inputsCode,
  			blockCode,
  			headerCode
  		};

  	} else {

  		throw new Error( 'FunctionNode: Function is not a GLSL code.' );

  	}

  };

  /**
   * This class represents a GLSL node function.
   *
   * @augments NodeFunction
   */
  class GLSLNodeFunction extends NodeFunction {

  	/**
  	 * Constructs a new GLSL node function.
  	 *
  	 * @param {string} source - The GLSL source.
  	 */
  	constructor( source ) {

  		const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );

  		super( type, inputs, name, precision );

  		this.inputsCode = inputsCode;
  		this.blockCode = blockCode;
  		this.headerCode = headerCode;

  	}

  	/**
  	 * This method returns the GLSL code of the node function.
  	 *
  	 * @param {string} [name=this.name] - The function's name.
  	 * @return {string} The shader code.
  	 */
  	getCode( name = this.name ) {

  		let code;

  		const blockCode = this.blockCode;

  		if ( blockCode !== '' ) {

  			const { type, inputsCode, headerCode, precision } = this;

  			let declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;

  			if ( precision !== '' ) {

  				declarationCode = `${ precision } ${ declarationCode }`;

  			}

  			code = headerCode + declarationCode + blockCode;

  		} else {

  			// interface function

  			code = '';

  		}

  		return code;

  	}

  }

  /**
   * A GLSL node parser.
   *
   * @augments NodeParser
   */
  class GLSLNodeParser extends NodeParser {

  	/**
  	 * The method parses the given GLSL code an returns a node function.
  	 *
  	 * @param {string} source - The GLSL code.
  	 * @return {GLSLNodeFunction} A node function.
  	 */
  	parseFunction( source ) {

  		return new GLSLNodeFunction( source );

  	}

  }

  const _outputNodeMap = new WeakMap();
  const _chainKeys$2 = [];
  const _cacheKeyValues = [];

  /**
   * This renderer module manages node-related objects and is the
   * primary interface between the renderer and the node system.
   *
   * @private
   * @augments DataMap
   */
  class Nodes extends DataMap {

  	/**
  	 * Constructs a new nodes management component.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {Backend} backend - The renderer's backend.
  	 */
  	constructor( renderer, backend ) {

  		super();

  		/**
  		 * The renderer.
  		 *
  		 * @type {Renderer}
  		 */
  		this.renderer = renderer;

  		/**
  		 * The renderer's backend.
  		 *
  		 * @type {Backend}
  		 */
  		this.backend = backend;

  		/**
  		 * The node frame.
  		 *
  		 * @type {Renderer}
  		 */
  		this.nodeFrame = new NodeFrame();

  		/**
  		 * A cache for managing node builder states.
  		 *
  		 * @type {Map<number,NodeBuilderState>}
  		 */
  		this.nodeBuilderCache = new Map();

  		/**
  		 * A cache for managing data cache key data.
  		 *
  		 * @type {ChainMap}
  		 */
  		this.callHashCache = new ChainMap();

  		/**
  		 * A cache for managing node uniforms group data.
  		 *
  		 * @type {ChainMap}
  		 */
  		this.groupsData = new ChainMap();

  		/**
  		 * A cache for managing node objects of
  		 * scene properties like fog or environments.
  		 *
  		 * @type {Object<string,WeakMap>}
  		 */
  		this.cacheLib = {};

  	}

  	/**
  	 * Returns `true` if the given node uniforms group must be updated or not.
  	 *
  	 * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
  	 * @return {boolean} Whether the node uniforms group requires an update or not.
  	 */
  	updateGroup( nodeUniformsGroup ) {

  		const groupNode = nodeUniformsGroup.groupNode;
  		const name = groupNode.name;

  		// objectGroup is always updated

  		if ( name === objectGroup.name ) return true;

  		// renderGroup is updated once per render/compute call

  		if ( name === renderGroup.name ) {

  			const uniformsGroupData = this.get( nodeUniformsGroup );
  			const renderId = this.nodeFrame.renderId;

  			if ( uniformsGroupData.renderId !== renderId ) {

  				uniformsGroupData.renderId = renderId;

  				return true;

  			}

  			return false;

  		}

  		// frameGroup is updated once per frame

  		if ( name === frameGroup.name ) {

  			const uniformsGroupData = this.get( nodeUniformsGroup );
  			const frameId = this.nodeFrame.frameId;

  			if ( uniformsGroupData.frameId !== frameId ) {

  				uniformsGroupData.frameId = frameId;

  				return true;

  			}

  			return false;

  		}

  		// other groups are updated just when groupNode.needsUpdate is true

  		_chainKeys$2[ 0 ] = groupNode;
  		_chainKeys$2[ 1 ] = nodeUniformsGroup;

  		let groupData = this.groupsData.get( _chainKeys$2 );
  		if ( groupData === undefined ) this.groupsData.set( _chainKeys$2, groupData = {} );

  		_chainKeys$2.length = 0;

  		if ( groupData.version !== groupNode.version ) {

  			groupData.version = groupNode.version;

  			return true;

  		}

  		return false;

  	}

  	/**
  	 * Returns the cache key for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {number} The cache key.
  	 */
  	getForRenderCacheKey( renderObject ) {

  		return renderObject.initialCacheKey;

  	}

  	/**
  	 * Returns a node builder state for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {NodeBuilderState} The node builder state.
  	 */
  	getForRender( renderObject ) {

  		const renderObjectData = this.get( renderObject );

  		let nodeBuilderState = renderObjectData.nodeBuilderState;

  		if ( nodeBuilderState === undefined ) {

  			const { nodeBuilderCache } = this;

  			const cacheKey = this.getForRenderCacheKey( renderObject );

  			nodeBuilderState = nodeBuilderCache.get( cacheKey );

  			if ( nodeBuilderState === undefined ) {

  				const nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );
  				nodeBuilder.scene = renderObject.scene;
  				nodeBuilder.material = renderObject.material;
  				nodeBuilder.camera = renderObject.camera;
  				nodeBuilder.context.material = renderObject.material;
  				nodeBuilder.lightsNode = renderObject.lightsNode;
  				nodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );
  				nodeBuilder.fogNode = this.getFogNode( renderObject.scene );
  				nodeBuilder.clippingContext = renderObject.clippingContext;
  				if ( this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false ) {

  					nodeBuilder.enableMultiview();

  				}

  				nodeBuilder.build();

  				nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

  				nodeBuilderCache.set( cacheKey, nodeBuilderState );

  			}

  			nodeBuilderState.usedTimes ++;

  			renderObjectData.nodeBuilderState = nodeBuilderState;

  		}

  		return nodeBuilderState;

  	}

  	/**
  	 * Deletes the given object from the internal data map
  	 *
  	 * @param {any} object - The object to delete.
  	 * @return {?Object} The deleted dictionary.
  	 */
  	delete( object ) {

  		if ( object.isRenderObject ) {

  			const nodeBuilderState = this.get( object ).nodeBuilderState;
  			nodeBuilderState.usedTimes --;

  			if ( nodeBuilderState.usedTimes === 0 ) {

  				this.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );

  			}

  		}

  		return super.delete( object );

  	}

  	/**
  	 * Returns a node builder state for the given compute node.
  	 *
  	 * @param {Node} computeNode - The compute node.
  	 * @return {NodeBuilderState} The node builder state.
  	 */
  	getForCompute( computeNode ) {

  		const computeData = this.get( computeNode );

  		let nodeBuilderState = computeData.nodeBuilderState;

  		if ( nodeBuilderState === undefined ) {

  			const nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );
  			nodeBuilder.build();

  			nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

  			computeData.nodeBuilderState = nodeBuilderState;

  		}

  		return nodeBuilderState;

  	}

  	/**
  	 * Creates a node builder state for the given node builder.
  	 *
  	 * @private
  	 * @param {NodeBuilder} nodeBuilder - The node builder.
  	 * @return {NodeBuilderState} The node builder state.
  	 */
  	_createNodeBuilderState( nodeBuilder ) {

  		return new NodeBuilderState(
  			nodeBuilder.vertexShader,
  			nodeBuilder.fragmentShader,
  			nodeBuilder.computeShader,
  			nodeBuilder.getAttributesArray(),
  			nodeBuilder.getBindings(),
  			nodeBuilder.updateNodes,
  			nodeBuilder.updateBeforeNodes,
  			nodeBuilder.updateAfterNodes,
  			nodeBuilder.observer,
  			nodeBuilder.transforms
  		);

  	}

  	/**
  	 * Returns an environment node for the current configured
  	 * scene environment.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @return {Node} A node representing the current scene environment.
  	 */
  	getEnvironmentNode( scene ) {

  		this.updateEnvironment( scene );

  		let environmentNode = null;

  		if ( scene.environmentNode && scene.environmentNode.isNode ) {

  			environmentNode = scene.environmentNode;

  		} else {

  			const sceneData = this.get( scene );

  			if ( sceneData.environmentNode ) {

  				environmentNode = sceneData.environmentNode;

  			}

  		}

  		return environmentNode;

  	}

  	/**
  	 * Returns a background node for the current configured
  	 * scene background.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @return {Node} A node representing the current scene background.
  	 */
  	getBackgroundNode( scene ) {

  		this.updateBackground( scene );

  		let backgroundNode = null;

  		if ( scene.backgroundNode && scene.backgroundNode.isNode ) {

  			backgroundNode = scene.backgroundNode;

  		} else {

  			const sceneData = this.get( scene );

  			if ( sceneData.backgroundNode ) {

  				backgroundNode = sceneData.backgroundNode;

  			}

  		}

  		return backgroundNode;

  	}

  	/**
  	 * Returns a fog node for the current configured scene fog.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @return {Node} A node representing the current scene fog.
  	 */
  	getFogNode( scene ) {

  		this.updateFog( scene );

  		return scene.fogNode || this.get( scene ).fogNode || null;

  	}

  	/**
  	 * Returns a cache key for the given scene and lights node.
  	 * This key is used by `RenderObject` as a part of the dynamic
  	 * cache key (a key that must be checked every time the render
  	 * objects is drawn).
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @param {LightsNode} lightsNode - The lights node.
  	 * @return {number} The cache key.
  	 */
  	getCacheKey( scene, lightsNode ) {

  		_chainKeys$2[ 0 ] = scene;
  		_chainKeys$2[ 1 ] = lightsNode;

  		const callId = this.renderer.info.calls;

  		const cacheKeyData = this.callHashCache.get( _chainKeys$2 ) || {};

  		if ( cacheKeyData.callId !== callId ) {

  			const environmentNode = this.getEnvironmentNode( scene );
  			const fogNode = this.getFogNode( scene );

  			if ( lightsNode ) _cacheKeyValues.push( lightsNode.getCacheKey( true ) );
  			if ( environmentNode ) _cacheKeyValues.push( environmentNode.getCacheKey() );
  			if ( fogNode ) _cacheKeyValues.push( fogNode.getCacheKey() );

  			_cacheKeyValues.push( this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0 );
  			_cacheKeyValues.push( this.renderer.shadowMap.enabled ? 1 : 0 );

  			cacheKeyData.callId = callId;
  			cacheKeyData.cacheKey = hashArray( _cacheKeyValues );

  			this.callHashCache.set( _chainKeys$2, cacheKeyData );

  			_cacheKeyValues.length = 0;

  		}

  		_chainKeys$2.length = 0;

  		return cacheKeyData.cacheKey;

  	}

  	/**
  	 * A boolean that indicates whether tone mapping should be enabled
  	 * or not.
  	 *
  	 * @type {boolean}
  	 */
  	get isToneMappingState() {

  		return this.renderer.getRenderTarget() ? false : true;

  	}

  	/**
  	 * If a scene background is configured, this method makes sure to
  	 * represent the background with a corresponding node-based implementation.
  	 *
  	 * @param {Scene} scene - The scene.
  	 */
  	updateBackground( scene ) {

  		const sceneData = this.get( scene );
  		const background = scene.background;

  		if ( background ) {

  			const forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );

  			if ( sceneData.background !== background || forceUpdate ) {

  				const backgroundNode = this.getCacheNode( 'background', background, () => {

  					if ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {

  						if ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {

  							return pmremTexture( background );

  						} else {

  							let envMap;

  							if ( background.isCubeTexture === true ) {

  								envMap = cubeTexture( background );

  							} else {

  								envMap = texture( background );

  							}

  							return cubeMapNode( envMap );

  						}

  					} else if ( background.isTexture === true ) {

  						return texture( background, screenUV.flipY() ).setUpdateMatrix( true );

  					} else if ( background.isColor !== true ) {

  						console.error( 'WebGPUNodes: Unsupported background configuration.', background );

  					}

  				}, forceUpdate );

  				sceneData.backgroundNode = backgroundNode;
  				sceneData.background = background;
  				sceneData.backgroundBlurriness = scene.backgroundBlurriness;

  			}

  		} else if ( sceneData.backgroundNode ) {

  			delete sceneData.backgroundNode;
  			delete sceneData.background;

  		}

  	}

  	/**
  	 * This method is part of the caching of nodes which are used to represents the
  	 * scene's background, fog or environment.
  	 *
  	 * @param {string} type - The type of object to cache.
  	 * @param {Object} object - The object.
  	 * @param {Function} callback - A callback that produces a node representation for the given object.
  	 * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
  	 * @return {Node} The node representation.
  	 */
  	getCacheNode( type, object, callback, forceUpdate = false ) {

  		const nodeCache = this.cacheLib[ type ] || ( this.cacheLib[ type ] = new WeakMap() );

  		let node = nodeCache.get( object );

  		if ( node === undefined || forceUpdate ) {

  			node = callback();
  			nodeCache.set( object, node );

  		}

  		return node;

  	}

  	/**
  	 * If a scene fog is configured, this method makes sure to
  	 * represent the fog with a corresponding node-based implementation.
  	 *
  	 * @param {Scene} scene - The scene.
  	 */
  	updateFog( scene ) {

  		const sceneData = this.get( scene );
  		const sceneFog = scene.fog;

  		if ( sceneFog ) {

  			if ( sceneData.fog !== sceneFog ) {

  				const fogNode = this.getCacheNode( 'fog', sceneFog, () => {

  					if ( sceneFog.isFogExp2 ) {

  						const color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );
  						const density = reference( 'density', 'float', sceneFog ).setGroup( renderGroup );

  						return fog( color, densityFogFactor( density ) );

  					} else if ( sceneFog.isFog ) {

  						const color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );
  						const near = reference( 'near', 'float', sceneFog ).setGroup( renderGroup );
  						const far = reference( 'far', 'float', sceneFog ).setGroup( renderGroup );

  						return fog( color, rangeFogFactor( near, far ) );

  					} else {

  						console.error( 'THREE.Renderer: Unsupported fog configuration.', sceneFog );

  					}

  				} );

  				sceneData.fogNode = fogNode;
  				sceneData.fog = sceneFog;

  			}

  		} else {

  			delete sceneData.fogNode;
  			delete sceneData.fog;

  		}

  	}

  	/**
  	 * If a scene environment is configured, this method makes sure to
  	 * represent the environment with a corresponding node-based implementation.
  	 *
  	 * @param {Scene} scene - The scene.
  	 */
  	updateEnvironment( scene ) {

  		const sceneData = this.get( scene );
  		const environment = scene.environment;

  		if ( environment ) {

  			if ( sceneData.environment !== environment ) {

  				const environmentNode = this.getCacheNode( 'environment', environment, () => {

  					if ( environment.isCubeTexture === true ) {

  						return cubeTexture( environment );

  					} else if ( environment.isTexture === true ) {

  						return texture( environment );

  					} else {

  						console.error( 'Nodes: Unsupported environment configuration.', environment );

  					}

  				} );

  				sceneData.environmentNode = environmentNode;
  				sceneData.environment = environment;

  			}

  		} else if ( sceneData.environmentNode ) {

  			delete sceneData.environmentNode;
  			delete sceneData.environment;

  		}

  	}

  	getNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {

  		const nodeFrame = this.nodeFrame;
  		nodeFrame.renderer = renderer;
  		nodeFrame.scene = scene;
  		nodeFrame.object = object;
  		nodeFrame.camera = camera;
  		nodeFrame.material = material;

  		return nodeFrame;

  	}

  	getNodeFrameForRender( renderObject ) {

  		return this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );

  	}

  	/**
  	 * Returns the current output cache key.
  	 *
  	 * @return {string} The output cache key.
  	 */
  	getOutputCacheKey() {

  		const renderer = this.renderer;

  		return renderer.toneMapping + ',' + renderer.currentColorSpace + ',' + renderer.xr.isPresenting;

  	}

  	/**
  	 * Checks if the output configuration (tone mapping and color space) for
  	 * the given target has changed.
  	 *
  	 * @param {Texture} outputTarget - The output target.
  	 * @return {boolean} Whether the output configuration has changed or not.
  	 */
  	hasOutputChange( outputTarget ) {

  		const cacheKey = _outputNodeMap.get( outputTarget );

  		return cacheKey !== this.getOutputCacheKey();

  	}

  	/**
  	 * Returns a node that represents the output configuration (tone mapping and
  	 * color space) for the current target.
  	 *
  	 * @param {Texture} outputTarget - The output target.
  	 * @return {Node} The output node.
  	 */
  	getOutputNode( outputTarget ) {

  		const renderer = this.renderer;
  		const cacheKey = this.getOutputCacheKey();

  		const output = outputTarget.isArrayTexture ?
  			texture3D( outputTarget, vec3( screenUV, builtin( 'gl_ViewID_OVR' ) ) ).renderOutput( renderer.toneMapping, renderer.currentColorSpace ) :
  			texture( outputTarget, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );

  		_outputNodeMap.set( outputTarget, cacheKey );

  		return output;

  	}

  	/**
  	 * Triggers the call of `updateBefore()` methods
  	 * for all nodes of the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateBefore( renderObject ) {

  		const nodeBuilder = renderObject.getNodeBuilderState();

  		for ( const node of nodeBuilder.updateBeforeNodes ) {

  			// update frame state for each node

  			this.getNodeFrameForRender( renderObject ).updateBeforeNode( node );

  		}

  	}

  	/**
  	 * Triggers the call of `updateAfter()` methods
  	 * for all nodes of the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateAfter( renderObject ) {

  		const nodeBuilder = renderObject.getNodeBuilderState();

  		for ( const node of nodeBuilder.updateAfterNodes ) {

  			// update frame state for each node

  			this.getNodeFrameForRender( renderObject ).updateAfterNode( node );

  		}

  	}

  	/**
  	 * Triggers the call of `update()` methods
  	 * for all nodes of the given compute node.
  	 *
  	 * @param {Node} computeNode - The compute node.
  	 */
  	updateForCompute( computeNode ) {

  		const nodeFrame = this.getNodeFrame();
  		const nodeBuilder = this.getForCompute( computeNode );

  		for ( const node of nodeBuilder.updateNodes ) {

  			nodeFrame.updateNode( node );

  		}

  	}

  	/**
  	 * Triggers the call of `update()` methods
  	 * for all nodes of the given compute node.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 */
  	updateForRender( renderObject ) {

  		const nodeFrame = this.getNodeFrameForRender( renderObject );
  		const nodeBuilder = renderObject.getNodeBuilderState();

  		for ( const node of nodeBuilder.updateNodes ) {

  			nodeFrame.updateNode( node );

  		}

  	}

  	/**
  	 * Returns `true` if the given render object requires a refresh.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the given render object requires a refresh or not.
  	 */
  	needsRefresh( renderObject ) {

  		const nodeFrame = this.getNodeFrameForRender( renderObject );
  		const monitor = renderObject.getMonitor();

  		return monitor.needsRefresh( renderObject, nodeFrame );

  	}

  	/**
  	 * Frees the internal resources.
  	 */
  	dispose() {

  		super.dispose();

  		this.nodeFrame = new NodeFrame();
  		this.nodeBuilderCache = new Map();
  		this.cacheLib = {};

  	}

  }

  const _plane$1 = /*@__PURE__*/ new Plane();

  /**
   * Represents the state that is used to perform clipping via clipping planes.
   * There is a default clipping context for each render context. When the
   * scene holds instances of `ClippingGroup`, there will be a context for each
   * group.
   *
   * @private
   */
  class ClippingContext {

  	/**
  	 * Constructs a new clipping context.
  	 *
  	 * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
  	 */
  	constructor( parentContext = null ) {

  		/**
  		 * The clipping context's version.
  		 *
  		 * @type {number}
  		 * @readonly
  		 */
  		this.version = 0;

  		/**
  		 * Whether the intersection of the clipping planes is used to clip objects, rather than their union.
  		 *
  		 * @type {?boolean}
  		 * @default null
  		 */
  		this.clipIntersection = null;

  		/**
  		 * The clipping context's cache key.
  		 *
  		 * @type {string}
  		 */
  		this.cacheKey = '';

  		/**
  		 * Whether the shadow pass is active or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.shadowPass = false;

  		/**
  		 * The view normal matrix.
  		 *
  		 * @type {Matrix3}
  		 */
  		this.viewNormalMatrix = new Matrix3();

  		/**
  		 * Internal cache for maintaining clipping contexts.
  		 *
  		 * @type {WeakMap<ClippingGroup,ClippingContext>}
  		 */
  		this.clippingGroupContexts = new WeakMap();

  		/**
  		 * The intersection planes.
  		 *
  		 * @type {Array<Vector4>}
  		 */
  		this.intersectionPlanes = [];

  		/**
  		 * The intersection planes.
  		 *
  		 * @type {Array<Vector4>}
  		 */
  		this.unionPlanes = [];

  		/**
  		 * The version of the clipping context's parent context.
  		 *
  		 * @type {?number}
  		 * @readonly
  		 */
  		this.parentVersion = null;

  		if ( parentContext !== null ) {

  			this.viewNormalMatrix = parentContext.viewNormalMatrix;
  			this.clippingGroupContexts = parentContext.clippingGroupContexts;

  			this.shadowPass = parentContext.shadowPass;
  			this.viewMatrix = parentContext.viewMatrix;

  		}

  	}

  	/**
  	 * Projects the given source clipping planes and writes the result into the
  	 * destination array.
  	 *
  	 * @param {Array<Plane>} source - The source clipping planes.
  	 * @param {Array<Vector4>} destination - The destination.
  	 * @param {number} offset - The offset.
  	 */
  	projectPlanes( source, destination, offset ) {

  		const l = source.length;

  		for ( let i = 0; i < l; i ++ ) {

  			_plane$1.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );

  			const v = destination[ offset + i ];
  			const normal = _plane$1.normal;

  			v.x = - normal.x;
  			v.y = - normal.y;
  			v.z = - normal.z;
  			v.w = _plane$1.constant;

  		}

  	}

  	/**
  	 * Updates the root clipping context of a scene.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 */
  	updateGlobal( scene, camera ) {

  		this.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial );
  		this.viewMatrix = camera.matrixWorldInverse;

  		this.viewNormalMatrix.getNormalMatrix( this.viewMatrix );

  	}

  	/**
  	 * Updates the clipping context.
  	 *
  	 * @param {ClippingContext} parentContext - The parent context.
  	 * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
  	 */
  	update( parentContext, clippingGroup ) {

  		let update = false;

  		if ( parentContext.version !== this.parentVersion ) {

  			this.intersectionPlanes = Array.from( parentContext.intersectionPlanes );
  			this.unionPlanes = Array.from( parentContext.unionPlanes );
  			this.parentVersion = parentContext.version;

  		}

  		if ( this.clipIntersection !== clippingGroup.clipIntersection ) {

  			this.clipIntersection = clippingGroup.clipIntersection;

  			if ( this.clipIntersection ) {

  				this.unionPlanes.length = parentContext.unionPlanes.length;

  			} else {

  				this.intersectionPlanes.length = parentContext.intersectionPlanes.length;

  			}

  		}

  		const srcClippingPlanes = clippingGroup.clippingPlanes;
  		const l = srcClippingPlanes.length;

  		let dstClippingPlanes;
  		let offset;

  		if ( this.clipIntersection ) {

  			dstClippingPlanes = this.intersectionPlanes;
  			offset = parentContext.intersectionPlanes.length;

  		} else {

  			dstClippingPlanes = this.unionPlanes;
  			offset = parentContext.unionPlanes.length;

  		}

  		if ( dstClippingPlanes.length !== offset + l ) {

  			dstClippingPlanes.length = offset + l;

  			for ( let i = 0; i < l; i ++ ) {

  				dstClippingPlanes[ offset + i ] = new Vector4();

  			}

  			update = true;

  		}

  		this.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );

  		if ( update ) {

  			this.version ++;
  			this.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;

  		}

  	}

  	/**
  	 * Returns a clipping context for the given clipping group.
  	 *
  	 * @param {ClippingGroup} clippingGroup - The clipping group.
  	 * @return {ClippingContext} The clipping context.
  	 */
  	getGroupContext( clippingGroup ) {

  		if ( this.shadowPass && ! clippingGroup.clipShadows ) return this;

  		let context = this.clippingGroupContexts.get( clippingGroup );

  		if ( context === undefined ) {

  			context = new ClippingContext( this );
  			this.clippingGroupContexts.set( clippingGroup, context );

  		}

  		context.update( this, clippingGroup );

  		return context;

  	}

  	/**
  	 * The count of union clipping planes.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get unionClippingCount() {

  		return this.unionPlanes.length;

  	}

  }

  /**
   * This module is used to represent render bundles inside the renderer
   * for further processing.
   *
   * @private
   */
  class RenderBundle {

  	/**
  	 * Constructs a new bundle group.
  	 *
  	 * @param {BundleGroup} bundleGroup - The bundle group.
  	 * @param {Camera} camera - The camera the bundle group is rendered with.
  	 */
  	constructor( bundleGroup, camera ) {

  		this.bundleGroup = bundleGroup;
  		this.camera = camera;

  	}

  }

  const _chainKeys$1 = [];

  /**
   * This renderer module manages render bundles.
   *
   * @private
   */
  class RenderBundles {

  	/**
  	 * Constructs a new render bundle management component.
  	 */
  	constructor() {

  		/**
  		 * A chain map for maintaining the render bundles.
  		 *
  		 * @type {ChainMap}
  		 */
  		this.bundles = new ChainMap();

  	}

  	/**
  	 * Returns a render bundle for the given bundle group and camera.
  	 *
  	 * @param {BundleGroup} bundleGroup - The bundle group.
  	 * @param {Camera} camera - The camera the bundle group is rendered with.
  	 * @return {RenderBundle} The render bundle.
  	 */
  	get( bundleGroup, camera ) {

  		const bundles = this.bundles;

  		_chainKeys$1[ 0 ] = bundleGroup;
  		_chainKeys$1[ 1 ] = camera;

  		let bundle = bundles.get( _chainKeys$1 );

  		if ( bundle === undefined ) {

  			bundle = new RenderBundle( bundleGroup, camera );
  			bundles.set( _chainKeys$1, bundle );

  		}

  		_chainKeys$1.length = 0;

  		return bundle;

  	}

  	/**
  	 * Frees all internal resources.
  	 */
  	dispose() {

  		this.bundles = new ChainMap();

  	}

  }

  /**
   * The purpose of a node library is to assign node implementations
   * to existing library features. In `WebGPURenderer` lights, materials
   * which are not based on `NodeMaterial` as well as tone mapping techniques
   * are implemented with node-based modules.
   *
   * @private
   */
  class NodeLibrary {

  	/**
  	 * Constructs a new node library.
  	 */
  	constructor() {

  		/**
  		 * A weak map that maps lights to light nodes.
  		 *
  		 * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}
  		 */
  		this.lightNodes = new WeakMap();

  		/**
  		 * A map that maps materials to node materials.
  		 *
  		 * @type {Map<string,NodeMaterial.constructor>}
  		 */
  		this.materialNodes = new Map();

  		/**
  		 * A map that maps tone mapping techniques (constants)
  		 * to tone mapping node functions.
  		 *
  		 * @type {Map<number,Function>}
  		 */
  		this.toneMappingNodes = new Map();

  	}

  	/**
  	 * Returns a matching node material instance for the given material object.
  	 *
  	 * This method also assigns/copies the properties of the given material object
  	 * to the node material. This is done to make sure the current material
  	 * configuration carries over to the node version.
  	 *
  	 * @param {Material} material - A material.
  	 * @return {NodeMaterial} The corresponding node material.
  	 */
  	fromMaterial( material ) {

  		if ( material.isNodeMaterial ) return material;

  		let nodeMaterial = null;

  		const nodeMaterialClass = this.getMaterialNodeClass( material.type );

  		if ( nodeMaterialClass !== null ) {

  			nodeMaterial = new nodeMaterialClass();

  			for ( const key in material ) {

  				nodeMaterial[ key ] = material[ key ];

  			}

  		}

  		return nodeMaterial;

  	}

  	/**
  	 * Adds a tone mapping node function for a tone mapping technique (constant).
  	 *
  	 * @param {Function} toneMappingNode - The tone mapping node function.
  	 * @param {number} toneMapping - The tone mapping.
  	 */
  	addToneMapping( toneMappingNode, toneMapping ) {

  		this.addType( toneMappingNode, toneMapping, this.toneMappingNodes );

  	}

  	/**
  	 * Returns a tone mapping node function for a tone mapping technique (constant).
  	 *
  	 * @param {number} toneMapping - The tone mapping.
  	 * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
  	 */
  	getToneMappingFunction( toneMapping ) {

  		return this.toneMappingNodes.get( toneMapping ) || null;

  	}

  	/**
  	 * Returns a node material class definition for a material type.
  	 *
  	 * @param {string} materialType - The material type.
  	 * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
  	 */
  	getMaterialNodeClass( materialType ) {

  		return this.materialNodes.get( materialType ) || null;

  	}

  	/**
  	 * Adds a node material class definition for a given material type.
  	 *
  	 * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
  	 * @param {string} materialClassType - The material type.
  	 */
  	addMaterial( materialNodeClass, materialClassType ) {

  		this.addType( materialNodeClass, materialClassType, this.materialNodes );

  	}

  	/**
  	 * Returns a light node class definition for a light class definition.
  	 *
  	 * @param {Light.constructor} light - The light class definition.
  	 * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
  	 */
  	getLightNodeClass( light ) {

  		return this.lightNodes.get( light ) || null;

  	}

  	/**
  	 * Adds a light node class definition for a given light class definition.
  	 *
  	 * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
  	 * @param {Light.constructor} lightClass - The light class definition.
  	 */
  	addLight( lightNodeClass, lightClass ) {

  		this.addClass( lightNodeClass, lightClass, this.lightNodes );

  	}

  	/**
  	 * Adds a node class definition for the given type to the provided type library.
  	 *
  	 * @param {any} nodeClass - The node class definition.
  	 * @param {number|string} type - The object type.
  	 * @param {Map} library - The type library.
  	 */
  	addType( nodeClass, type, library ) {

  		if ( library.has( type ) ) {

  			console.warn( `Redefinition of node ${ type }` );
  			return;

  		}

  		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
  		if ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );

  		library.set( type, nodeClass );

  	}

  	/**
  	 * Adds a node class definition for the given class definition to the provided type library.
  	 *
  	 * @param {any} nodeClass - The node class definition.
  	 * @param {any} baseClass - The class definition.
  	 * @param {WeakMap} library - The type library.
  	 */
  	addClass( nodeClass, baseClass, library ) {

  		if ( library.has( baseClass ) ) {

  			console.warn( `Redefinition of node ${ baseClass.name }` );
  			return;

  		}

  		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
  		if ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );

  		library.set( baseClass, nodeClass );

  	}

  }

  const _defaultLights = /*@__PURE__*/ new LightsNode();
  const _chainKeys = [];

  /**
   * This renderer module manages the lights nodes which are unique
   * per scene and camera combination.
   *
   * The lights node itself is later configured in the render list
   * with the actual lights from the scene.
   *
   * @private
   * @augments ChainMap
   */
  class Lighting extends ChainMap {

  	/**
  	 * Constructs a lighting management component.
  	 */
  	constructor() {

  		super();

  	}

  	/**
  	 * Creates a new lights node for the given array of lights.
  	 *
  	 * @param {Array<Light>} lights - The render object.
  	 * @return {LightsNode} The lights node.
  	 */
  	createNode( lights = [] ) {

  		return new LightsNode().setLights( lights );

  	}

  	/**
  	 * Returns a lights node for the given scene and camera.
  	 *
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera.
  	 * @return {LightsNode} The lights node.
  	 */
  	getNode( scene, camera ) {

  		// ignore post-processing

  		if ( scene.isQuadMesh ) return _defaultLights;

  		_chainKeys[ 0 ] = scene;
  		_chainKeys[ 1 ] = camera;

  		let node = this.get( _chainKeys );

  		if ( node === undefined ) {

  			node = this.createNode();
  			this.set( _chainKeys, node );

  		}

  		_chainKeys.length = 0;

  		return node;

  	}

  }

  /**
   * A special type of render target that is used when rendering
   * with the WebXR Device API.
   *
   * @private
   * @augments RenderTarget
   */
  class XRRenderTarget extends RenderTarget {

  	/**
  	 * Constructs a new XR render target.
  	 *
  	 * @param {number} [width=1] - The width of the render target.
  	 * @param {number} [height=1] - The height of the render target.
  	 * @param {Object} [options={}] - The configuration options.
  	 */
  	constructor( width = 1, height = 1, options = {} ) {

  		super( width, height, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isXRRenderTarget = true;

  		/**
  		 * Whether the attachments of the render target
  		 * are defined by external textures. This flag is
  		 * set to `true` when using the WebXR Layers API.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @default false
  		 */
  		this._hasExternalTextures = false;

  		/**
  		 * Whether a depth buffer should automatically be allocated
  		 * for this XR render target or not.
  		 *
  		 * Allocating a depth buffer is the default behavior of XR render
  		 * targets. However, when using the WebXR Layers API, this flag
  		 * must be set to `false` when the `ignoreDepthValues` property of
  		 * the projection layers evaluates to `false`.
  		 *
  		 * Reference: {@link https://www.w3.org/TR/webxrlayers-1/#dom-xrprojectionlayer-ignoredepthvalues}.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @default true
  		 */
  		this._autoAllocateDepthBuffer = true;

  		/**
  		 * Whether this render target is associated with a XRWebGLLayer.
  		 *
  		 * A XRWebGLLayer points to an opaque framebuffer. Basically,
  		 * this means that you don't have access to its bound color,
  		 * stencil and depth buffers. We need to handle this framebuffer
  		 * differently since its textures are always bound.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @default false
  		 * */
  		this._isOpaqueFramebuffer = false;

  	}

  	copy( source ) {

  		super.copy( source );

  		this._hasExternalTextures = source._hasExternalTextures;
  		this._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;
  		this._isOpaqueFramebuffer = source._isOpaqueFramebuffer;

  		return this;

  	}


  }

  const _cameraLPos = /*@__PURE__*/ new Vector3();
  const _cameraRPos = /*@__PURE__*/ new Vector3();

  /**
   * The XR manager is built on top of the WebXR Device API to
   * manage XR sessions with `WebGPURenderer`.
   *
   * XR is currently only supported with a WebGL 2 backend.
   *
   * @augments EventDispatcher
   */
  class XRManager extends EventDispatcher {

  	/**
  	 * Constructs a new XR manager.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
  	 */
  	constructor( renderer, multiview = false ) {

  		super();

  		/**
  		 * This flag globally enables XR rendering.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.enabled = false;

  		/**
  		 * Whether the XR device is currently presenting or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 * @readonly
  		 */
  		this.isPresenting = false;

  		/**
  		 * Whether the XR camera should automatically be updated or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.cameraAutoUpdate = true;

  		/**
  		 * The renderer.
  		 *
  		 * @private
  		 * @type {Renderer}
  		 */
  		this._renderer = renderer;

  		// camera

  		/**
  		 * Represents the camera for the left eye.
  		 *
  		 * @private
  		 * @type {PerspectiveCamera}
  		 */
  		this._cameraL = new PerspectiveCamera();
  		this._cameraL.viewport = new Vector4();

  		/**
  		 * Represents the camera for the right eye.
  		 *
  		 * @private
  		 * @type {PerspectiveCamera}
  		 */
  		this._cameraR = new PerspectiveCamera();
  		this._cameraR.viewport = new Vector4();

  		/**
  		 * A list of cameras used for rendering the XR views.
  		 *
  		 * @private
  		 * @type {Array<Camera>}
  		 */
  		this._cameras = [ this._cameraL, this._cameraR ];

  		/**
  		 * The main XR camera.
  		 *
  		 * @private
  		 * @type {ArrayCamera}
  		 */
  		this._cameraXR = new ArrayCamera();

  		/**
  		 * The current near value of the XR camera.
  		 *
  		 * @private
  		 * @type {?number}
  		 * @default null
  		 */
  		this._currentDepthNear = null;

  		/**
  		 * The current far value of the XR camera.
  		 *
  		 * @private
  		 * @type {?number}
  		 * @default null
  		 */
  		this._currentDepthFar = null;

  		/**
  		 * A list of WebXR controllers requested by the application.
  		 *
  		 * @private
  		 * @type {Array<WebXRController>}
  		 */
  		this._controllers = [];

  		/**
  		 * A list of XR input source. Each input source belongs to
  		 * an instance of WebXRController.
  		 *
  		 * @private
  		 * @type {Array<XRInputSource?>}
  		 */
  		this._controllerInputSources = [];

  		/**
  		 * The XR render target that represents the rendering destination
  		 * during an active XR session.
  		 *
  		 * @private
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this._xrRenderTarget = null;

  		/**
  		 * An array holding all the non-projection layers
  		 *
  		 * @private
  		 * @type {Array<Object>}
  		 * @default []
  		 */
  		this._layers = [];

  		/**
  		 * Whether the device has support for all layer types.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this._supportsLayers = false;

  		this._frameBufferTargets = null;

  		/**
  		 * Helper function to create native WebXR Layer.
  		 *
  		 * @private
  		 * @type {Function}
  		 */
  		this._createXRLayer = createXRLayer.bind( this );

  		/**
  		* The current WebGL context.
  		*
  		* @private
  		* @type {?WebGL2RenderingContext}
  		* @default null
  		*/
  		this._gl = null;

  		/**
  		 * The current animation context.
  		 *
  		 * @private
  		 * @type {?Window}
  		 * @default null
  		 */
  		this._currentAnimationContext = null;

  		/**
  		 * The current animation loop.
  		 *
  		 * @private
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._currentAnimationLoop = null;

  		/**
  		 * The current pixel ratio.
  		 *
  		 * @private
  		 * @type {?number}
  		 * @default null
  		 */
  		this._currentPixelRatio = null;

  		/**
  		 * The current size of the renderer's canvas
  		 * in logical pixel unit.
  		 *
  		 * @private
  		 * @type {Vector2}
  		 */
  		this._currentSize = new Vector2();

  		/**
  		 * The default event listener for handling events inside a XR session.
  		 *
  		 * @private
  		 * @type {Function}
  		 */
  		this._onSessionEvent = onSessionEvent.bind( this );

  		/**
  		 * The event listener for handling the end of a XR session.
  		 *
  		 * @private
  		 * @type {Function}
  		 */
  		this._onSessionEnd = onSessionEnd.bind( this );

  		/**
  		 * The event listener for handling the `inputsourceschange` event.
  		 *
  		 * @private
  		 * @type {Function}
  		 */
  		this._onInputSourcesChange = onInputSourcesChange.bind( this );

  		/**
  		 * The animation loop which is used as a replacement for the default
  		 * animation loop of the application. It is only used when a XR session
  		 * is active.
  		 *
  		 * @private
  		 * @type {Function}
  		 */
  		this._onAnimationFrame = onAnimationFrame.bind( this );

  		/**
  		 * The current XR reference space.
  		 *
  		 * @private
  		 * @type {?XRReferenceSpace}
  		 * @default null
  		 */
  		this._referenceSpace = null;

  		/**
  		 * The current XR reference space type.
  		 *
  		 * @private
  		 * @type {XRReferenceSpaceType}
  		 * @default 'local-floor'
  		 */
  		this._referenceSpaceType = 'local-floor';

  		/**
  		 * A custom reference space defined by the application.
  		 *
  		 * @private
  		 * @type {?XRReferenceSpace}
  		 * @default null
  		 */
  		this._customReferenceSpace = null;

  		/**
  		 * The framebuffer scale factor.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._framebufferScaleFactor = 1;

  		/**
  		 * The foveation factor.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._foveation = 1.0;

  		/**
  		 * A reference to the current XR session.
  		 *
  		 * @private
  		 * @type {?XRSession}
  		 * @default null
  		 */
  		this._session = null;

  		/**
  		 * A reference to the current XR base layer.
  		 *
  		 * @private
  		 * @type {?XRWebGLLayer}
  		 * @default null
  		 */
  		this._glBaseLayer = null;

  		/**
  		 * A reference to the current XR binding.
  		 *
  		 * @private
  		 * @type {?XRWebGLBinding}
  		 * @default null
  		 */
  		this._glBinding = null;

  		/**
  		 * A reference to the current XR projection layer.
  		 *
  		 * @private
  		 * @type {?XRProjectionLayer}
  		 * @default null
  		 */
  		this._glProjLayer = null;

  		/**
  		 * A reference to the current XR frame.
  		 *
  		 * @private
  		 * @type {?XRFrame}
  		 * @default null
  		 */
  		this._xrFrame = null;

  		/**
  		 * Whether to use the WebXR Layers API or not.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @readonly
  		 */
  		this._useLayers = ( typeof XRWebGLBinding !== 'undefined' && 'createProjectionLayer' in XRWebGLBinding.prototype ); // eslint-disable-line compat/compat

  		/**
  		 * Whether the usage of multiview has been requested by the application or not.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @default false
  		 * @readonly
  		 */
  		this._useMultiviewIfPossible = multiview;

  		/**
  		 * Whether the usage of multiview is actually enabled. This flag only evaluates to `true`
  		 * if multiview has been requested by the application and the `OVR_multiview2` is available.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @readonly
  		 */
  		this._useMultiview = false;

  	}

  	/**
  	 * Returns an instance of `THREE.Group` that represents the transformation
  	 * of a XR controller in target ray space. The requested controller is defined
  	 * by the given index.
  	 *
  	 * @param {number} index - The index of the XR controller.
  	 * @return {Group} A group that represents the controller's transformation.
  	 */
  	getController( index ) {

  		const controller = this._getController( index );

  		return controller.getTargetRaySpace();

  	}

  	/**
  	 * Returns an instance of `THREE.Group` that represents the transformation
  	 * of a XR controller in grip space. The requested controller is defined
  	 * by the given index.
  	 *
  	 * @param {number} index - The index of the XR controller.
  	 * @return {Group} A group that represents the controller's transformation.
  	 */
  	getControllerGrip( index ) {

  		const controller = this._getController( index );

  		return controller.getGripSpace();

  	}

  	/**
  	 * Returns an instance of `THREE.Group` that represents the transformation
  	 * of a XR controller in hand space. The requested controller is defined
  	 * by the given index.
  	 *
  	 * @param {number} index - The index of the XR controller.
  	 * @return {Group} A group that represents the controller's transformation.
  	 */
  	getHand( index ) {

  		const controller = this._getController( index );

  		return controller.getHandSpace();

  	}

  	/**
  	 * Returns the foveation value.
  	 *
  	 * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
  	 */
  	getFoveation() {

  		if ( this._glProjLayer === null && this._glBaseLayer === null ) {

  			return undefined;

  		}

  		return this._foveation;

  	}

  	/**
  	 * Sets the foveation value.
  	 *
  	 * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
  	 * and `1` means maximum foveation (the edges render at lower resolution).
  	 */
  	setFoveation( foveation ) {

  		this._foveation = foveation;

  		if ( this._glProjLayer !== null ) {

  			this._glProjLayer.fixedFoveation = foveation;

  		}

  		if ( this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== undefined ) {

  			this._glBaseLayer.fixedFoveation = foveation;

  		}

  	}

  	/**
  	 * Returns the framebuffer scale factor.
  	 *
  	 * @return {number} The framebuffer scale factor.
  	 */
  	getFramebufferScaleFactor() {

  		return this._framebufferScaleFactor;

  	}

  	/**
  	 * Sets the framebuffer scale factor.
  	 *
  	 * This method can not be used during a XR session.
  	 *
  	 * @param {number} factor - The framebuffer scale factor.
  	 */
  	setFramebufferScaleFactor( factor ) {

  		this._framebufferScaleFactor = factor;

  		if ( this.isPresenting === true ) {

  			console.warn( 'THREE.XRManager: Cannot change framebuffer scale while presenting.' );

  		}

  	}

  	/**
  	 * Returns the reference space type.
  	 *
  	 * @return {XRReferenceSpaceType} The reference space type.
  	 */
  	getReferenceSpaceType() {

  		return this._referenceSpaceType;

  	}

  	/**
  	 * Sets the reference space type.
  	 *
  	 * This method can not be used during a XR session.
  	 *
  	 * @param {XRReferenceSpaceType} type - The reference space type.
  	 */
  	setReferenceSpaceType( type ) {

  		this._referenceSpaceType = type;

  		if ( this.isPresenting === true ) {

  			console.warn( 'THREE.XRManager: Cannot change reference space type while presenting.' );

  		}

  	}

  	/**
  	 * Returns the XR reference space.
  	 *
  	 * @return {XRReferenceSpace} The XR reference space.
  	 */
  	getReferenceSpace() {

  		return this._customReferenceSpace || this._referenceSpace;

  	}

  	/**
  	 * Sets a custom XR reference space.
  	 *
  	 * @param {XRReferenceSpace} space - The XR reference space.
  	 */
  	setReferenceSpace( space ) {

  		this._customReferenceSpace = space;

  	}

  	/**
  	 * Returns the XR camera.
  	 *
  	 * @return {ArrayCamera} The XR camera.
  	 */
  	getCamera() {

  		return this._cameraXR;

  	}

  	/**
  	 * Returns the environment blend mode from the current XR session.
  	 *
  	 * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
  	 */
  	getEnvironmentBlendMode() {

  		if ( this._session !== null ) {

  			return this._session.environmentBlendMode;

  		}

  	}

  	/**
  	 * Returns the current XR frame.
  	 *
  	 * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
  	 */
  	getFrame() {

  		return this._xrFrame;

  	}

  	/**
  	 * Returns `true` if the engine renders to a multiview target.
  	 *
  	 * @return {boolean} Whether the engine renders to a multiview render target or not.
  	 */
  	useMultiview() {

  		return this._useMultiview;

  	}

  	/**
  	 * This method can be used in XR applications to create a quadratic layer that presents a separate
  	 * rendered scene.
  	 *
  	 * @param {number} width - The width of the layer plane in world units.
  	 * @param {number} height - The height of the layer plane in world units.
  	 * @param {Vector3} translation - The position/translation of the layer plane in world units.
  	 * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
  	 * @param {number} pixelwidth - The width of the layer's render target in pixels.
  	 * @param {number} pixelheight - The height of the layer's render target in pixels.
  	 * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
  	 * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
  	 * @param {Object} [attributes={}] - Allows to configure the layer's render target.
  	 * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
  	 */
  	createQuadLayer( width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {} ) {

  		const geometry = new PlaneGeometry( width, height );
  		const renderTarget = new XRRenderTarget(
  			pixelwidth,
  			pixelheight,
  			{
  				format: RGBAFormat,
  				type: UnsignedByteType,
  				depthTexture: new DepthTexture(
  					pixelwidth,
  					pixelheight,
  					attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
  					undefined,
  					undefined,
  					undefined,
  					undefined,
  					undefined,
  					undefined,
  					attributes.stencil ? DepthStencilFormat : DepthFormat
  				),
  				stencilBuffer: attributes.stencil,
  				resolveDepthBuffer: false,
  				resolveStencilBuffer: false
  			} );

  		renderTarget._autoAllocateDepthBuffer = true;

  		const material = new MeshBasicMaterial( { color: 0xffffff, side: FrontSide } );
  		material.map = renderTarget.texture;
  		material.map.offset.y = 1;
  		material.map.repeat.y = -1;
  		const plane = new Mesh( geometry, material );
  		plane.position.copy( translation );
  		plane.quaternion.copy( quaternion );

  		const layer = {
  			type: 'quad',
  			width: width,
  			height: height,
  			translation: translation,
  			quaternion: quaternion,
  			pixelwidth: pixelwidth,
  			pixelheight: pixelheight,
  			plane: plane,
  			material: material,
  			rendercall: rendercall,
  			renderTarget: renderTarget };

  		this._layers.push( layer );

  		if ( this._session !== null ) {

  			layer.plane.material = new MeshBasicMaterial( { color: 0xffffff, side: FrontSide } );
  			layer.plane.material.blending = CustomBlending;
  			layer.plane.material.blendEquation = AddEquation;
  			layer.plane.material.blendSrc = ZeroFactor;
  			layer.plane.material.blendDst = ZeroFactor;

  			layer.xrlayer = this._createXRLayer( layer );

  			const xrlayers = this._session.renderState.layers;
  			xrlayers.unshift( layer.xrlayer );
  			this._session.updateRenderState( { layers: xrlayers } );

  		} else {

  			renderTarget.isXRRenderTarget = false;

  		}

  		return plane;

  	}

  	/**
  	 * This method can be used in XR applications to create a cylindrical layer that presents a separate
  	 * rendered scene.
  	 *
  	 * @param {number} radius - The radius of the cylinder in world units.
  	 * @param {number} centralAngle - The central angle of the cylinder in radians.
  	 * @param {number} aspectratio - The aspect ratio.
  	 * @param {Vector3} translation - The position/translation of the layer plane in world units.
  	 * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
  	 * @param {number} pixelwidth - The width of the layer's render target in pixels.
  	 * @param {number} pixelheight - The height of the layer's render target in pixels.
  	 * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
  	 * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
  	 * @param {Object} [attributes={}] - Allows to configure the layer's render target.
  	 * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
  	 */
  	createCylinderLayer( radius, centralAngle, aspectratio, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {} ) {

  		const geometry = new CylinderGeometry( radius, radius, radius * centralAngle / aspectratio, 64, 64, true, Math.PI - centralAngle / 2, centralAngle );
  		const renderTarget = new XRRenderTarget(
  			pixelwidth,
  			pixelheight,
  			{
  				format: RGBAFormat,
  				type: UnsignedByteType,
  				depthTexture: new DepthTexture(
  					pixelwidth,
  					pixelheight,
  					attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
  					undefined,
  					undefined,
  					undefined,
  					undefined,
  					undefined,
  					undefined,
  					attributes.stencil ? DepthStencilFormat : DepthFormat
  				),
  				stencilBuffer: attributes.stencil,
  				resolveDepthBuffer: false,
  				resolveStencilBuffer: false
  			} );

  		renderTarget._autoAllocateDepthBuffer = true;

  		const material = new MeshBasicMaterial( { color: 0xffffff, side: BackSide } );
  		material.map = renderTarget.texture;
  		material.map.offset.y = 1;
  		material.map.repeat.y = -1;
  		const plane = new Mesh( geometry, material );
  		plane.position.copy( translation );
  		plane.quaternion.copy( quaternion );

  		const layer = {
  			type: 'cylinder',
  			radius: radius,
  			centralAngle: centralAngle,
  			aspectratio: aspectratio,
  			translation: translation,
  			quaternion: quaternion,
  			pixelwidth: pixelwidth,
  			pixelheight: pixelheight,
  			plane: plane,
  			material: material,
  			rendercall: rendercall,
  			renderTarget: renderTarget };

  		this._layers.push( layer );

  		if ( this._session !== null ) {

  			layer.plane.material = new MeshBasicMaterial( { color: 0xffffff, side: BackSide } );
  			layer.plane.material.blending = CustomBlending;
  			layer.plane.material.blendEquation = AddEquation;
  			layer.plane.material.blendSrc = ZeroFactor;
  			layer.plane.material.blendDst = ZeroFactor;

  			layer.xrlayer = this._createXRLayer( layer );

  			const xrlayers = this._session.renderState.layers;
  			xrlayers.unshift( layer.xrlayer );
  			this._session.updateRenderState( { layers: xrlayers } );

  		} else {

  			renderTarget.isXRRenderTarget = false;

  		}

  		return plane;

  	}

  	/**
  	 * Renders the XR layers that have been previously added to the scene.
  	 *
  	 * This method is usually called in your animation loop before rendering
  	 * the actual scene via `renderer.render( scene, camera );`.
  	 */
  	renderLayers( ) {

  		const translationObject = new Vector3();
  		const quaternionObject = new Quaternion();
  		const renderer = this._renderer;

  		const wasPresenting = this.isPresenting;
  		const rendererOutputTarget = renderer.getOutputRenderTarget();
  		const rendererFramebufferTarget = renderer._frameBufferTarget;
  		this.isPresenting = false;

  		const rendererSize = new Vector2();
  		renderer.getSize( rendererSize );
  		const rendererQuad = renderer._quad;

  		for ( const layer of this._layers ) {

  			layer.renderTarget.isXRRenderTarget = this._session !== null;
  			layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;

  			if ( layer.renderTarget.isXRRenderTarget && this._supportsLayers ) {

  				layer.xrlayer.transform = new XRRigidTransform( layer.plane.getWorldPosition( translationObject ), layer.plane.getWorldQuaternion( quaternionObject ) );

  				const glSubImage = this._glBinding.getSubImage( layer.xrlayer, this._xrFrame );
  				renderer.backend.setXRRenderTargetTextures(
  					layer.renderTarget,
  					glSubImage.colorTexture,
  					undefined );

  				renderer._setXRLayerSize( layer.renderTarget.width, layer.renderTarget.height );
  				renderer.setOutputRenderTarget( layer.renderTarget );
  				renderer.setRenderTarget( null );
  				renderer._frameBufferTarget = null;

  				this._frameBufferTargets || ( this._frameBufferTargets = new WeakMap() );
  				const { frameBufferTarget, quad } = this._frameBufferTargets.get( layer.renderTarget ) || { frameBufferTarget: null, quad: null };
  				if ( ! frameBufferTarget ) {

  					renderer._quad = new QuadMesh( new NodeMaterial() );
  					this._frameBufferTargets.set( layer.renderTarget, { frameBufferTarget: renderer._getFrameBufferTarget(), quad: renderer._quad } );

  				} else {

  					renderer._frameBufferTarget = frameBufferTarget;
  					renderer._quad = quad;

  				}

  				layer.rendercall();

  				renderer._frameBufferTarget = null;

  			} else {

  				renderer.setRenderTarget( layer.renderTarget );
  				layer.rendercall();

  			}

  		}

  		renderer.setRenderTarget( null );
  		renderer.setOutputRenderTarget( rendererOutputTarget );
  		renderer._frameBufferTarget = rendererFramebufferTarget;
  		renderer._setXRLayerSize( rendererSize.x, rendererSize.y );
  		renderer._quad = rendererQuad;
  		this.isPresenting = wasPresenting;

  	}


  	/**
  	 * Returns the current XR session.
  	 *
  	 * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
  	 */
  	getSession() {

  		return this._session;

  	}

  	/**
  	 * After a XR session has been requested usually with one of the `*Button` modules, it
  	 * is injected into the renderer with this method. This method triggers the start of
  	 * the actual XR rendering.
  	 *
  	 * @async
  	 * @param {XRSession} session - The XR session to set.
  	 * @return {Promise} A Promise that resolves when the session has been set.
  	 */
  	async setSession( session ) {

  		const renderer = this._renderer;
  		const backend = renderer.backend;

  		this._gl = renderer.getContext();
  		const gl = this._gl;
  		const attributes = gl.getContextAttributes();

  		this._session = session;

  		if ( session !== null ) {

  			if ( backend.isWebGPUBackend === true ) throw new Error( 'THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.' );

  			session.addEventListener( 'select', this._onSessionEvent );
  			session.addEventListener( 'selectstart', this._onSessionEvent );
  			session.addEventListener( 'selectend', this._onSessionEvent );
  			session.addEventListener( 'squeeze', this._onSessionEvent );
  			session.addEventListener( 'squeezestart', this._onSessionEvent );
  			session.addEventListener( 'squeezeend', this._onSessionEvent );
  			session.addEventListener( 'end', this._onSessionEnd );
  			session.addEventListener( 'inputsourceschange', this._onInputSourcesChange );

  			await backend.makeXRCompatible();

  			this._currentPixelRatio = renderer.getPixelRatio();
  			renderer.getSize( this._currentSize );

  			this._currentAnimationContext = renderer._animation.getContext();
  			this._currentAnimationLoop = renderer._animation.getAnimationLoop();
  			renderer._animation.stop();

  			//

  			if ( this._useLayers === true ) {

  				// default path using XRWebGLBinding/XRProjectionLayer

  				let depthFormat = null;
  				let depthType = null;
  				let glDepthFormat = null;

  				if ( renderer.depth ) {

  					glDepthFormat = renderer.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
  					depthFormat = renderer.stencil ? DepthStencilFormat : DepthFormat;
  					depthType = renderer.stencil ? UnsignedInt248Type : UnsignedIntType;

  				}

  				const projectionlayerInit = {
  					colorFormat: gl.RGBA8,
  					depthFormat: glDepthFormat,
  					scaleFactor: this._framebufferScaleFactor,
  					clearOnAccess: false
  				};

  				if ( this._useMultiviewIfPossible && renderer.hasFeature( 'OVR_multiview2' ) ) {

  					projectionlayerInit.textureType = 'texture-array';
  					this._useMultiview = true;

  				}

  				const glBinding = new XRWebGLBinding( session, gl );
  				const glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );
  				const layersArray = [ glProjLayer ];

  				this._glBinding = glBinding;
  				this._glProjLayer = glProjLayer;

  				renderer.setPixelRatio( 1 );
  				renderer._setXRLayerSize( glProjLayer.textureWidth, glProjLayer.textureHeight );

  				const depth = this._useMultiview ? 2 : 1;
  				const depthTexture = new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat, depth );

  				this._xrRenderTarget = new XRRenderTarget(
  					glProjLayer.textureWidth,
  					glProjLayer.textureHeight,
  					{
  						format: RGBAFormat,
  						type: UnsignedByteType,
  						colorSpace: renderer.outputColorSpace,
  						depthTexture: depthTexture,
  						stencilBuffer: renderer.stencil,
  						samples: attributes.antialias ? 4 : 0,
  						resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false ),
  						resolveStencilBuffer: ( glProjLayer.ignoreDepthValues === false ),
  						depth: this._useMultiview ? 2 : 1,
  						multiview: this._useMultiview
  					} );

  				this._xrRenderTarget._hasExternalTextures = true;
  				this._xrRenderTarget.depth = this._useMultiview ? 2 : 1;

  				this._supportsLayers = session.enabledFeatures.includes( 'layers' );

  				this._referenceSpace = await session.requestReferenceSpace( this.getReferenceSpaceType() );

  				if ( this._supportsLayers ) {

  					// switch layers to native
  					for ( const layer of this._layers ) {

  						// change material so it "punches" out a hole to show the XR Layer.
  						layer.plane.material = new MeshBasicMaterial( { color: 0xffffff, side: layer.type === 'cylinder' ? BackSide : FrontSide } );
  						layer.plane.material.blending = CustomBlending;
  						layer.plane.material.blendEquation = AddEquation;
  						layer.plane.material.blendSrc = ZeroFactor;
  						layer.plane.material.blendDst = ZeroFactor;

  						layer.xrlayer = this._createXRLayer( layer );

  						layersArray.unshift( layer.xrlayer );

  					}

  				}

  				session.updateRenderState( { layers: layersArray } );

  			} else {

  				// fallback to XRWebGLLayer

  				const layerInit = {
  					antialias: renderer.samples > 0,
  					alpha: true,
  					depth: renderer.depth,
  					stencil: renderer.stencil,
  					framebufferScaleFactor: this.getFramebufferScaleFactor()
  				};

  				const glBaseLayer = new XRWebGLLayer( session, gl, layerInit );
  				this._glBaseLayer = glBaseLayer;

  				session.updateRenderState( { baseLayer: glBaseLayer } );

  				renderer.setPixelRatio( 1 );
  				renderer._setXRLayerSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight );

  				this._xrRenderTarget = new XRRenderTarget(
  					glBaseLayer.framebufferWidth,
  					glBaseLayer.framebufferHeight,
  					{
  						format: RGBAFormat,
  						type: UnsignedByteType,
  						colorSpace: renderer.outputColorSpace,
  						stencilBuffer: renderer.stencil,
  						resolveDepthBuffer: ( glBaseLayer.ignoreDepthValues === false ),
  						resolveStencilBuffer: ( glBaseLayer.ignoreDepthValues === false ),
  					}
  				);

  				this._xrRenderTarget._isOpaqueFramebuffer = true;
  				this._referenceSpace = await session.requestReferenceSpace( this.getReferenceSpaceType() );

  			}

  			//

  			this.setFoveation( this.getFoveation() );

  			renderer._animation.setAnimationLoop( this._onAnimationFrame );
  			renderer._animation.setContext( session );
  			renderer._animation.start();

  			this.isPresenting = true;

  			this.dispatchEvent( { type: 'sessionstart' } );

  		}

  	}

  	/**
  	 * This method is called by the renderer per frame and updates the XR camera
  	 * and it sub cameras based on the given camera. The given camera is the "user"
  	 * camera created on application level and used for non-XR rendering.
  	 *
  	 * @param {PerspectiveCamera} camera - The camera.
  	 */
  	updateCamera( camera ) {

  		const session = this._session;

  		if ( session === null ) return;

  		const depthNear = camera.near;
  		const depthFar = camera.far;

  		const cameraXR = this._cameraXR;
  		const cameraL = this._cameraL;
  		const cameraR = this._cameraR;

  		cameraXR.near = cameraR.near = cameraL.near = depthNear;
  		cameraXR.far = cameraR.far = cameraL.far = depthFar;
  		cameraXR.isMultiViewCamera = this._useMultiview;

  		if ( this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far ) {

  			// Note that the new renderState won't apply until the next frame. See #18320

  			session.updateRenderState( {
  				depthNear: cameraXR.near,
  				depthFar: cameraXR.far
  			} );

  			this._currentDepthNear = cameraXR.near;
  			this._currentDepthFar = cameraXR.far;

  		}

  		cameraL.layers.mask = camera.layers.mask | 0b010;
  		cameraR.layers.mask = camera.layers.mask | 0b100;
  		cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;

  		const parent = camera.parent;
  		const cameras = cameraXR.cameras;

  		updateCamera( cameraXR, parent );

  		for ( let i = 0; i < cameras.length; i ++ ) {

  			updateCamera( cameras[ i ], parent );

  		}

  		// update projection matrix for proper view frustum culling

  		if ( cameras.length === 2 ) {

  			setProjectionFromUnion( cameraXR, cameraL, cameraR );

  		} else {

  			// assume single camera setup (AR)

  			cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

  		}

  		// update user camera and its children

  		updateUserCamera( camera, cameraXR, parent );


  	}

  	/**
  	 * Returns a WebXR controller for the given controller index.
  	 *
  	 * @private
  	 * @param {number} index - The controller index.
  	 * @return {WebXRController} The XR controller.
  	 */
  	_getController( index ) {

  		let controller = this._controllers[ index ];

  		if ( controller === undefined ) {

  			controller = new WebXRController();
  			this._controllers[ index ] = controller;

  		}

  		return controller;

  	}

  }

  /**
   * Assumes 2 cameras that are parallel and share an X-axis, and that
   * the cameras' projection and world matrices have already been set.
   * And that near and far planes are identical for both cameras.
   * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
   *
   * @param {ArrayCamera} camera - The camera to update.
   * @param {PerspectiveCamera} cameraL - The left camera.
   * @param {PerspectiveCamera} cameraR - The right camera.
   */
  function setProjectionFromUnion( camera, cameraL, cameraR ) {

  	_cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
  	_cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

  	const ipd = _cameraLPos.distanceTo( _cameraRPos );

  	const projL = cameraL.projectionMatrix.elements;
  	const projR = cameraR.projectionMatrix.elements;

  	// VR systems will have identical far and near planes, and
  	// most likely identical top and bottom frustum extents.
  	// Use the left camera for these values.
  	const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
  	const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
  	const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
  	const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

  	const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
  	const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
  	const left = near * leftFov;
  	const right = near * rightFov;

  	// Calculate the new camera's position offset from the
  	// left camera. xOffset should be roughly half `ipd`.
  	const zOffset = ipd / ( - leftFov + rightFov );
  	const xOffset = zOffset * - leftFov;

  	// TODO: Better way to apply this offset?
  	cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
  	camera.translateX( xOffset );
  	camera.translateZ( zOffset );
  	camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
  	camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  	// Check if the projection uses an infinite far plane.
  	if ( projL[ 10 ] === -1 ) {

  		// Use the projection matrix from the left eye.
  		// The camera offset is sufficient to include the view volumes
  		// of both eyes (assuming symmetric projections).
  		camera.projectionMatrix.copy( cameraL.projectionMatrix );
  		camera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );

  	} else {

  		// Find the union of the frustum values of the cameras and scale
  		// the values so that the near plane's position does not change in world space,
  		// although must now be relative to the new union camera.
  		const near2 = near + zOffset;
  		const far2 = far + zOffset;
  		const left2 = left - xOffset;
  		const right2 = right + ( ipd - xOffset );
  		const top2 = topFov * far / far2 * near2;
  		const bottom2 = bottomFov * far / far2 * near2;

  		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
  		camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

  	}

  }

  /**
   * Updates the world matrices for the given camera based on the parent 3D object.
   *
   * @inner
   * @param {Camera} camera - The camera to update.
   * @param {Object3D} parent - The parent 3D object.
   */
  function updateCamera( camera, parent ) {

  	if ( parent === null ) {

  		camera.matrixWorld.copy( camera.matrix );

  	} else {

  		camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

  	}

  	camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  }

  /**
   * Updates the given camera with the transformation of the XR camera and parent object.
   *
   * @inner
   * @param {Camera} camera - The camera to update.
   * @param {ArrayCamera} cameraXR - The XR camera.
   * @param {Object3D} parent - The parent 3D object.
   */
  function updateUserCamera( camera, cameraXR, parent ) {

  	if ( parent === null ) {

  		camera.matrix.copy( cameraXR.matrixWorld );

  	} else {

  		camera.matrix.copy( parent.matrixWorld );
  		camera.matrix.invert();
  		camera.matrix.multiply( cameraXR.matrixWorld );

  	}

  	camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
  	camera.updateMatrixWorld( true );

  	camera.projectionMatrix.copy( cameraXR.projectionMatrix );
  	camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

  	if ( camera.isPerspectiveCamera ) {

  		camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
  		camera.zoom = 1;

  	}

  }

  function onSessionEvent( event ) {

  	const controllerIndex = this._controllerInputSources.indexOf( event.inputSource );

  	if ( controllerIndex === -1 ) {

  		return;

  	}

  	const controller = this._controllers[ controllerIndex ];

  	if ( controller !== undefined ) {

  		const referenceSpace = this.getReferenceSpace();

  		controller.update( event.inputSource, event.frame, referenceSpace );
  		controller.dispatchEvent( { type: event.type, data: event.inputSource } );

  	}

  }

  function onSessionEnd() {

  	const session = this._session;
  	const renderer = this._renderer;

  	session.removeEventListener( 'select', this._onSessionEvent );
  	session.removeEventListener( 'selectstart', this._onSessionEvent );
  	session.removeEventListener( 'selectend', this._onSessionEvent );
  	session.removeEventListener( 'squeeze', this._onSessionEvent );
  	session.removeEventListener( 'squeezestart', this._onSessionEvent );
  	session.removeEventListener( 'squeezeend', this._onSessionEvent );
  	session.removeEventListener( 'end', this._onSessionEnd );
  	session.removeEventListener( 'inputsourceschange', this._onInputSourcesChange );

  	for ( let i = 0; i < this._controllers.length; i ++ ) {

  		const inputSource = this._controllerInputSources[ i ];

  		if ( inputSource === null ) continue;

  		this._controllerInputSources[ i ] = null;

  		this._controllers[ i ].disconnect( inputSource );

  	}

  	this._currentDepthNear = null;
  	this._currentDepthFar = null;

  	// restore framebuffer/rendering state

  	renderer._resetXRState();

  	this._session = null;
  	this._xrRenderTarget = null;

  	// switch layers back to emulated
  	if ( this._supportsLayers === true ) {

  		for ( const layer of this._layers ) {

  			// Recreate layer render target to reset state
  			layer.renderTarget = new XRRenderTarget(
  				layer.pixelwidth,
  				layer.pixelheight,
  				{
  					format: RGBAFormat,
  					type: UnsignedByteType,
  					depthTexture: new DepthTexture(
  						layer.pixelwidth,
  						layer.pixelheight,
  						layer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType,
  						undefined,
  						undefined,
  						undefined,
  						undefined,
  						undefined,
  						undefined,
  						layer.stencilBuffer ? DepthStencilFormat : DepthFormat
  					),
  					stencilBuffer: layer.stencilBuffer,
  					resolveDepthBuffer: false,
  					resolveStencilBuffer: false
  				} );

  			layer.renderTarget.isXRRenderTarget = false;

  			layer.plane.material = layer.material;
  			layer.material.map = layer.renderTarget.texture;
  			layer.material.map.offset.y = 1;
  			layer.material.map.repeat.y = -1;
  			delete layer.xrlayer;

  		}

  	}

  	//

  	this.isPresenting = false;
  	this._useMultiview = false;

  	renderer._animation.stop();
  	renderer._animation.setAnimationLoop( this._currentAnimationLoop );
  	renderer._animation.setContext( this._currentAnimationContext );
  	renderer._animation.start();

  	renderer.setPixelRatio( this._currentPixelRatio );
  	renderer.setSize( this._currentSize.width, this._currentSize.height, false );

  	this.dispatchEvent( { type: 'sessionend' } );

  }

  function onInputSourcesChange( event ) {

  	const controllers = this._controllers;
  	const controllerInputSources = this._controllerInputSources;

  	// Notify disconnected

  	for ( let i = 0; i < event.removed.length; i ++ ) {

  		const inputSource = event.removed[ i ];
  		const index = controllerInputSources.indexOf( inputSource );

  		if ( index >= 0 ) {

  			controllerInputSources[ index ] = null;
  			controllers[ index ].disconnect( inputSource );

  		}

  	}

  	// Notify connected

  	for ( let i = 0; i < event.added.length; i ++ ) {

  		const inputSource = event.added[ i ];

  		let controllerIndex = controllerInputSources.indexOf( inputSource );

  		if ( controllerIndex === -1 ) {

  			// Assign input source a controller that currently has no input source

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				if ( i >= controllerInputSources.length ) {

  					controllerInputSources.push( inputSource );
  					controllerIndex = i;
  					break;

  				} else if ( controllerInputSources[ i ] === null ) {

  					controllerInputSources[ i ] = inputSource;
  					controllerIndex = i;
  					break;

  				}

  			}

  			// If all controllers do currently receive input we ignore new ones

  			if ( controllerIndex === -1 ) break;

  		}

  		const controller = controllers[ controllerIndex ];

  		if ( controller ) {

  			controller.connect( inputSource );

  		}

  	}

  }

  // Creation method for native WebXR layers
  function createXRLayer( layer ) {

  	if ( layer.type === 'quad' ) {

  		return this._glBinding.createQuadLayer( {
  			transform: new XRRigidTransform( layer.translation, layer.quaternion ),
  			width: layer.width / 2,
  			height: layer.height / 2,
  			space: this._referenceSpace,
  			viewPixelWidth: layer.pixelwidth,
  			viewPixelHeight: layer.pixelheight,
  			clearOnAccess: false
  		} );

  	} else {

  		return this._glBinding.createCylinderLayer( {
  			transform: new XRRigidTransform( layer.translation, layer.quaternion ),
  			radius: layer.radius,
  			centralAngle: layer.centralAngle,
  			aspectRatio: layer.aspectRatio,
  			space: this._referenceSpace,
  			viewPixelWidth: layer.pixelwidth,
  			viewPixelHeight: layer.pixelheight,
  			clearOnAccess: false
  		} );

  	}

  }

  // Animation Loop

  function onAnimationFrame( time, frame ) {

  	if ( frame === undefined ) return;

  	const cameraXR = this._cameraXR;
  	const renderer = this._renderer;
  	const backend = renderer.backend;

  	const glBaseLayer = this._glBaseLayer;

  	const referenceSpace = this.getReferenceSpace();
  	const pose = frame.getViewerPose( referenceSpace );

  	this._xrFrame = frame;

  	if ( pose !== null ) {

  		const views = pose.views;

  		if ( this._glBaseLayer !== null ) {

  			backend.setXRTarget( glBaseLayer.framebuffer );

  		}

  		let cameraXRNeedsUpdate = false;

  		// check if it's necessary to rebuild cameraXR's camera list

  		if ( views.length !== cameraXR.cameras.length ) {

  			cameraXR.cameras.length = 0;
  			cameraXRNeedsUpdate = true;

  		}

  		for ( let i = 0; i < views.length; i ++ ) {

  			const view = views[ i ];

  			let viewport;

  			if ( this._useLayers === true ) {

  				const glSubImage = this._glBinding.getViewSubImage( this._glProjLayer, view );
  				viewport = glSubImage.viewport;

  				// For side-by-side projection, we only produce a single texture for both eyes.
  				if ( i === 0 ) {

  					backend.setXRRenderTargetTextures(
  						this._xrRenderTarget,
  						glSubImage.colorTexture,
  						( this._glProjLayer.ignoreDepthValues && ! this._useMultiview ) ? undefined : glSubImage.depthStencilTexture
  					);

  				}

  			} else {

  				viewport = glBaseLayer.getViewport( view );

  			}

  			let camera = this._cameras[ i ];

  			if ( camera === undefined ) {

  				camera = new PerspectiveCamera();
  				camera.layers.enable( i );
  				camera.viewport = new Vector4();
  				this._cameras[ i ] = camera;

  			}

  			camera.matrix.fromArray( view.transform.matrix );
  			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
  			camera.projectionMatrix.fromArray( view.projectionMatrix );
  			camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
  			camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

  			if ( i === 0 ) {

  				cameraXR.matrix.copy( camera.matrix );
  				cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

  			}

  			if ( cameraXRNeedsUpdate === true ) {

  				cameraXR.cameras.push( camera );

  			}

  		}

  		renderer.setOutputRenderTarget( this._xrRenderTarget );

  	}

  	//

  	for ( let i = 0; i < this._controllers.length; i ++ ) {

  		const inputSource = this._controllerInputSources[ i ];
  		const controller = this._controllers[ i ];

  		if ( inputSource !== null && controller !== undefined ) {

  			controller.update( inputSource, frame, referenceSpace );

  		}

  	}

  	if ( this._currentAnimationLoop ) this._currentAnimationLoop( time, frame );

  	if ( frame.detectedPlanes ) {

  		this.dispatchEvent( { type: 'planesdetected', data: frame } );

  	}

  	this._xrFrame = null;

  }

  const _scene = /*@__PURE__*/ new Scene();
  const _drawingBufferSize$1 = /*@__PURE__*/ new Vector2();
  const _screen = /*@__PURE__*/ new Vector4();
  const _frustum = /*@__PURE__*/ new Frustum();
  const _frustumArray = /*@__PURE__*/ new FrustumArray();

  const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
  const _vector4 = /*@__PURE__*/ new Vector4();

  /**
   * Base class for renderers.
   */
  class Renderer {

  	/**
  	 * Renderer options.
  	 *
  	 * @typedef {Object} Renderer~Options
  	 * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
  	 * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
  	 * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
  	 * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
  	 * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
  	 * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
  	 * to overwrite the default.
  	 * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
  	 * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
  	 * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
  	 * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
  	 */

  	/**
  	 * Constructs a new renderer.
  	 *
  	 * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
  	 * @param {Renderer~Options} [parameters] - The configuration parameter.

  	 */
  	constructor( backend, parameters = {} ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRenderer = true;

  		//

  		const {
  			logarithmicDepthBuffer = false,
  			alpha = true,
  			depth = true,
  			stencil = false,
  			antialias = false,
  			samples = 0,
  			getFallback = null,
  			colorBufferType = HalfFloatType,
  			multiview = false
  		} = parameters;

  		/**
  		 * A reference to the canvas element the renderer is drawing to.
  		 * This value of this property will automatically be created by
  		 * the renderer.
  		 *
  		 * @type {HTMLCanvasElement|OffscreenCanvas}
  		 */
  		this.domElement = backend.getDomElement();

  		/**
  		 * A reference to the current backend.
  		 *
  		 * @type {Backend}
  		 */
  		this.backend = backend;

  		/**
  		 * The number of MSAA samples.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.samples = samples || ( antialias === true ) ? 4 : 0;

  		/**
  		 * Whether the renderer should automatically clear the current rendering target
  		 * before execute a `render()` call. The target can be the canvas (default framebuffer)
  		 * or the current bound render target (custom framebuffer).
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClear = true;

  		/**
  		 * When `autoClear` is set to `true`, this property defines whether the renderer
  		 * should clear the color buffer.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClearColor = true;

  		/**
  		 * When `autoClear` is set to `true`, this property defines whether the renderer
  		 * should clear the depth buffer.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClearDepth = true;

  		/**
  		 * When `autoClear` is set to `true`, this property defines whether the renderer
  		 * should clear the stencil buffer.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClearStencil = true;

  		/**
  		 * Whether the default framebuffer should be transparent or opaque.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.alpha = alpha;

  		/**
  		 * Whether logarithmic depth buffer is enabled or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.logarithmicDepthBuffer = logarithmicDepthBuffer;

  		/**
  		 * Defines the output color space of the renderer.
  		 *
  		 * @type {string}
  		 * @default SRGBColorSpace
  		 */
  		this.outputColorSpace = SRGBColorSpace;

  		/**
  		 * Defines the tone mapping of the renderer.
  		 *
  		 * @type {number}
  		 * @default NoToneMapping
  		 */
  		this.toneMapping = NoToneMapping;

  		/**
  		 * Defines the tone mapping exposure.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.toneMappingExposure = 1.0;

  		/**
  		 * Whether the renderer should sort its render lists or not.
  		 *
  		 * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.
  		 * By definition, sorting objects may not work in all cases. Depending on the needs of application,
  		 * it may be necessary to turn off sorting and use other methods to deal with transparency rendering
  		 * e.g. manually determining each object's rendering order.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.sortObjects = true;

  		/**
  		 * Whether the default framebuffer should have a depth buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depth = depth;

  		/**
  		 * Whether the default framebuffer should have a stencil buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.stencil = stencil;

  		/**
  		 * Holds a series of statistical information about the GPU memory
  		 * and the rendering process. Useful for debugging and monitoring.
  		 *
  		 * @type {Info}
  		 */
  		this.info = new Info();

  		/**
  		 * Stores override nodes for specific transformations or calculations.
  		 * These nodes can be used to replace default behavior in the rendering pipeline.
  		 *
  		 * @type {Object}
  		 * @property {?Node} modelViewMatrix - An override node for the model-view matrix.
  		 * @property {?Node} modelNormalViewMatrix - An override node for the model normal view matrix.
  		 */
  		this.overrideNodes = {
  			modelViewMatrix: null,
  			modelNormalViewMatrix: null
  		};

  		/**
  		 * The node library defines how certain library objects like materials, lights
  		 * or tone mapping functions are mapped to node types. This is required since
  		 * although instances of classes like `MeshBasicMaterial` or `PointLight` can
  		 * be part of the scene graph, they are internally represented as nodes for
  		 * further processing.
  		 *
  		 * @type {NodeLibrary}
  		 */
  		this.library = new NodeLibrary();

  		/**
  		 * A map-like data structure for managing lights.
  		 *
  		 * @type {Lighting}
  		 */
  		this.lighting = new Lighting();

  		// internals

  		/**
  		 * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
  		 *
  		 * @private
  		 * @type {?Function}
  		 */
  		this._getFallback = getFallback;

  		/**
  		 * The renderer's pixel ratio.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._pixelRatio = 1;

  		/**
  		 * The width of the renderer's default framebuffer in logical pixel unit.
  		 *
  		 * @private
  		 * @type {number}
  		 */
  		this._width = this.domElement.width;

  		/**
  		 * The height of the renderer's default framebuffer in logical pixel unit.
  		 *
  		 * @private
  		 * @type {number}
  		 */
  		this._height = this.domElement.height;

  		/**
  		 * The viewport of the renderer in logical pixel unit.
  		 *
  		 * @private
  		 * @type {Vector4}
  		 */
  		this._viewport = new Vector4( 0, 0, this._width, this._height );

  		/**
  		 * The scissor rectangle of the renderer in logical pixel unit.
  		 *
  		 * @private
  		 * @type {Vector4}
  		 */
  		this._scissor = new Vector4( 0, 0, this._width, this._height );

  		/**
  		 * Whether the scissor test should be enabled or not.
  		 *
  		 * @private
  		 * @type {boolean}
  		 */
  		this._scissorTest = false;

  		/**
  		 * A reference to a renderer module for managing shader attributes.
  		 *
  		 * @private
  		 * @type {?Attributes}
  		 * @default null
  		 */
  		this._attributes = null;

  		/**
  		 * A reference to a renderer module for managing geometries.
  		 *
  		 * @private
  		 * @type {?Geometries}
  		 * @default null
  		 */
  		this._geometries = null;

  		/**
  		 * A reference to a renderer module for managing node related logic.
  		 *
  		 * @private
  		 * @type {?Nodes}
  		 * @default null
  		 */
  		this._nodes = null;

  		/**
  		 * A reference to a renderer module for managing the internal animation loop.
  		 *
  		 * @private
  		 * @type {?Animation}
  		 * @default null
  		 */
  		this._animation = null;

  		/**
  		 * A reference to a renderer module for managing shader program bindings.
  		 *
  		 * @private
  		 * @type {?Bindings}
  		 * @default null
  		 */
  		this._bindings = null;

  		/**
  		 * A reference to a renderer module for managing render objects.
  		 *
  		 * @private
  		 * @type {?RenderObjects}
  		 * @default null
  		 */
  		this._objects = null;

  		/**
  		 * A reference to a renderer module for managing render and compute pipelines.
  		 *
  		 * @private
  		 * @type {?Pipelines}
  		 * @default null
  		 */
  		this._pipelines = null;

  		/**
  		 * A reference to a renderer module for managing render bundles.
  		 *
  		 * @private
  		 * @type {?RenderBundles}
  		 * @default null
  		 */
  		this._bundles = null;

  		/**
  		 * A reference to a renderer module for managing render lists.
  		 *
  		 * @private
  		 * @type {?RenderLists}
  		 * @default null
  		 */
  		this._renderLists = null;

  		/**
  		 * A reference to a renderer module for managing render contexts.
  		 *
  		 * @private
  		 * @type {?RenderContexts}
  		 * @default null
  		 */
  		this._renderContexts = null;

  		/**
  		 * A reference to a renderer module for managing textures.
  		 *
  		 * @private
  		 * @type {?Textures}
  		 * @default null
  		 */
  		this._textures = null;

  		/**
  		 * A reference to a renderer module for backgrounds.
  		 *
  		 * @private
  		 * @type {?Background}
  		 * @default null
  		 */
  		this._background = null;

  		/**
  		 * This fullscreen quad is used for internal render passes
  		 * like the tone mapping and color space output pass.
  		 *
  		 * @private
  		 * @type {QuadMesh}
  		 */
  		this._quad = new QuadMesh( new NodeMaterial() );
  		this._quad.material.name = 'Renderer_output';

  		/**
  		 * A reference to the current render context.
  		 *
  		 * @private
  		 * @type {?RenderContext}
  		 * @default null
  		 */
  		this._currentRenderContext = null;

  		/**
  		 * A custom sort function for the opaque render list.
  		 *
  		 * @private
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._opaqueSort = null;

  		/**
  		 * A custom sort function for the transparent render list.
  		 *
  		 * @private
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._transparentSort = null;

  		/**
  		 * The framebuffer target.
  		 *
  		 * @private
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this._frameBufferTarget = null;

  		const alphaClear = this.alpha === true ? 0 : 1;

  		/**
  		 * The clear color value.
  		 *
  		 * @private
  		 * @type {Color4}
  		 */
  		this._clearColor = new Color4( 0, 0, 0, alphaClear );

  		/**
  		 * The clear depth value.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 1
  		 */
  		this._clearDepth = 1;

  		/**
  		 * The clear stencil value.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 0
  		 */
  		this._clearStencil = 0;

  		/**
  		 * The current render target.
  		 *
  		 * @private
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this._renderTarget = null;

  		/**
  		 * The active cube face.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 0
  		 */
  		this._activeCubeFace = 0;

  		/**
  		 * The active mipmap level.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 0
  		 */
  		this._activeMipmapLevel = 0;

  		/**
  		 * The current output render target.
  		 *
  		 * @private
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this._outputRenderTarget = null;

  		/**
  		 * The MRT setting.
  		 *
  		 * @private
  		 * @type {?MRTNode}
  		 * @default null
  		 */
  		this._mrt = null;

  		/**
  		 * This function defines how a render object is going
  		 * to be rendered.
  		 *
  		 * @private
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._renderObjectFunction = null;

  		/**
  		 * Used to keep track of the current render object function.
  		 *
  		 * @private
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._currentRenderObjectFunction = null;

  		/**
  		 * Used to keep track of the current render bundle.
  		 *
  		 * @private
  		 * @type {?RenderBundle}
  		 * @default null
  		 */
  		this._currentRenderBundle = null;

  		/**
  		 * Next to `_renderObjectFunction()`, this function provides another hook
  		 * for influencing the render process of a render object. It is meant for internal
  		 * use and only relevant for `compileAsync()` right now. Instead of using
  		 * the default logic of `_renderObjectDirect()` which actually draws the render object,
  		 * a different function might be used which performs no draw but just the node
  		 * and pipeline updates.
  		 *
  		 * @private
  		 * @type {?Function}
  		 * @default null
  		 */
  		this._handleObjectFunction = this._renderObjectDirect;

  		/**
  		 * Indicates whether the device has been lost or not. In WebGL terms, the device
  		 * lost is considered as a context lost. When this is set to `true`, rendering
  		 * isn't possible anymore.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @default false
  		 */
  		this._isDeviceLost = false;

  		/**
  		 * A callback function that defines what should happen when a device/context lost occurs.
  		 *
  		 * @type {Function}
  		 */
  		this.onDeviceLost = this._onDeviceLost;

  		/**
  		 * Defines the type of color buffers. The default `HalfFloatType` is recommend for
  		 * best quality. To save memory and bandwidth, `UnsignedByteType` might be used.
  		 * This will reduce rendering quality though.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default HalfFloatType
  		 */
  		this._colorBufferType = colorBufferType;

  		/**
  		 * Whether the renderer has been initialized or not.
  		 *
  		 * @private
  		 * @type {boolean}
  		 * @default false
  		 */
  		this._initialized = false;

  		/**
  		 * A reference to the promise which initializes the renderer.
  		 *
  		 * @private
  		 * @type {?Promise<this>}
  		 * @default null
  		 */
  		this._initPromise = null;

  		/**
  		 * An array of compilation promises which are used in `compileAsync()`.
  		 *
  		 * @private
  		 * @type {?Array<Promise>}
  		 * @default null
  		 */
  		this._compilationPromises = null;

  		/**
  		 * Whether the renderer should render transparent render objects or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.transparent = true;

  		/**
  		 * Whether the renderer should render opaque render objects or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.opaque = true;

  		/**
  		 * Shadow map configuration
  		 * @typedef {Object} ShadowMapConfig
  		 * @property {boolean} enabled - Whether to globally enable shadows or not.
  		 * @property {number} type - The shadow map type.
  		 */

  		/**
  		 * The renderer's shadow configuration.
  		 *
  		 * @type {ShadowMapConfig}
  		 */
  		this.shadowMap = {
  			enabled: false,
  			type: PCFShadowMap
  		};

  		/**
  		 * XR configuration.
  		 * @typedef {Object} XRConfig
  		 * @property {boolean} enabled - Whether to globally enable XR or not.
  		 */

  		/**
  		 * The renderer's XR manager.
  		 *
  		 * @type {XRManager}
  		 */
  		this.xr = new XRManager( this, multiview );

  		/**
  		 * Debug configuration.
  		 * @typedef {Object} DebugConfig
  		 * @property {boolean} checkShaderErrors - Whether shader errors should be checked or not.
  		 * @property {?Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.
  		 * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camera and 3D object.
  		 */

  		/**
  		 * The renderer's debug configuration.
  		 *
  		 * @type {DebugConfig}
  		 */
  		this.debug = {
  			checkShaderErrors: true,
  			onShaderError: null,
  			getShaderAsync: async ( scene, camera, object ) => {

  				await this.compileAsync( scene, camera );

  				const renderList = this._renderLists.get( scene, camera );
  				const renderContext = this._renderContexts.get( scene, camera, this._renderTarget );

  				const material = scene.overrideMaterial || object.material;

  				const renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );

  				const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();

  				return { fragmentShader, vertexShader };

  			}
  		};

  	}

  	/**
  	 * Initializes the renderer so it is ready for usage.
  	 *
  	 * @async
  	 * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
  	 */
  	async init() {

  		if ( this._initialized ) {

  			throw new Error( 'Renderer: Backend has already been initialized.' );

  		}

  		if ( this._initPromise !== null ) {

  			return this._initPromise;

  		}

  		this._initPromise = new Promise( async ( resolve, reject ) => {

  			let backend = this.backend;

  			try {

  				await backend.init( this );

  			} catch ( error ) {

  				if ( this._getFallback !== null ) {

  					// try the fallback

  					try {

  						this.backend = backend = this._getFallback( error );
  						await backend.init( this );

  					} catch ( error ) {

  						reject( error );
  						return;

  					}

  				} else {

  					reject( error );
  					return;

  				}

  			}

  			this._nodes = new Nodes( this, backend );
  			this._animation = new Animation( this._nodes, this.info );
  			this._attributes = new Attributes( backend );
  			this._background = new Background( this, this._nodes );
  			this._geometries = new Geometries( this._attributes, this.info );
  			this._textures = new Textures( this, backend, this.info );
  			this._pipelines = new Pipelines( backend, this._nodes );
  			this._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );
  			this._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );
  			this._renderLists = new RenderLists( this.lighting );
  			this._bundles = new RenderBundles();
  			this._renderContexts = new RenderContexts();

  			//

  			this._animation.start();
  			this._initialized = true;

  			resolve( this );

  		} );

  		return this._initPromise;

  	}

  	/**
  	 * The coordinate system of the renderer. The value of this property
  	 * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
  	 * `THREE.WebGPUCoordinateSystem`.
  	 *
  	 * @readonly
  	 * @type {number}
  	 */
  	get coordinateSystem() {

  		return this.backend.coordinateSystem;

  	}

  	/**
  	 * Compiles all materials in the given scene. This can be useful to avoid a
  	 * phenomenon which is called "shader compilation stutter", which occurs when
  	 * rendering an object with a new shader for the first time.
  	 *
  	 * If you want to add a 3D object to an existing scene, use the third optional
  	 * parameter for applying the target scene. Note that the (target) scene's lighting
  	 * and environment must be configured before calling this method.
  	 *
  	 * @async
  	 * @param {Object3D} scene - The scene or 3D object to precompile.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
  	 * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.
  	 */
  	async compileAsync( scene, camera, targetScene = null ) {

  		if ( this._isDeviceLost === true ) return;

  		if ( this._initialized === false ) await this.init();

  		// preserve render tree

  		const nodeFrame = this._nodes.nodeFrame;

  		const previousRenderId = nodeFrame.renderId;
  		const previousRenderContext = this._currentRenderContext;
  		const previousRenderObjectFunction = this._currentRenderObjectFunction;
  		const previousCompilationPromises = this._compilationPromises;

  		//

  		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

  		if ( targetScene === null ) targetScene = scene;

  		const renderTarget = this._renderTarget;
  		const renderContext = this._renderContexts.get( targetScene, camera, renderTarget );
  		const activeMipmapLevel = this._activeMipmapLevel;

  		const compilationPromises = [];

  		this._currentRenderContext = renderContext;
  		this._currentRenderObjectFunction = this.renderObject;

  		this._handleObjectFunction = this._createObjectPipeline;

  		this._compilationPromises = compilationPromises;

  		nodeFrame.renderId ++;

  		//

  		nodeFrame.update();

  		//

  		renderContext.depth = this.depth;
  		renderContext.stencil = this.stencil;

  		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
  		renderContext.clippingContext.updateGlobal( sceneRef, camera );

  		//

  		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

  		//

  		const renderList = this._renderLists.get( scene, camera );
  		renderList.begin();

  		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

  		// include lights from target scene
  		if ( targetScene !== scene ) {

  			targetScene.traverseVisible( function ( object ) {

  				if ( object.isLight && object.layers.test( camera.layers ) ) {

  					renderList.pushLight( object );

  				}

  			} );

  		}

  		renderList.finish();

  		//

  		if ( renderTarget !== null ) {

  			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

  			const renderTargetData = this._textures.get( renderTarget );

  			renderContext.textures = renderTargetData.textures;
  			renderContext.depthTexture = renderTargetData.depthTexture;

  		} else {

  			renderContext.textures = null;
  			renderContext.depthTexture = null;

  		}

  		//

  		this._background.update( sceneRef, renderList, renderContext );

  		// process render lists

  		const opaqueObjects = renderList.opaque;
  		const transparentObjects = renderList.transparent;
  		const transparentDoublePassObjects = renderList.transparentDoublePass;
  		const lightsNode = renderList.lightsNode;

  		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
  		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

  		// restore render tree

  		nodeFrame.renderId = previousRenderId;

  		this._currentRenderContext = previousRenderContext;
  		this._currentRenderObjectFunction = previousRenderObjectFunction;
  		this._compilationPromises = previousCompilationPromises;

  		this._handleObjectFunction = this._renderObjectDirect;

  		// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete

  		await Promise.all( compilationPromises );

  	}

  	/**
  	 * Renders the scene in an async fashion.
  	 *
  	 * @async
  	 * @param {Object3D} scene - The scene or 3D object to render.
  	 * @param {Camera} camera - The camera.
  	 * @return {Promise} A Promise that resolves when the render has been finished.
  	 */
  	async renderAsync( scene, camera ) {

  		if ( this._initialized === false ) await this.init();

  		this._renderScene( scene, camera );

  	}

  	/**
  	 * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
  	 * the CPU waits for the GPU to complete its operation (e.g. a compute task).
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolves when synchronization has been finished.
  	 */
  	async waitForGPU() {

  		await this.backend.waitForGPU();

  	}

  	/**
  	 * Enables or disables high precision for model-view and normal-view matrices.
  	 * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
  	 *
  	 * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
  	 *
  	 * @param {boolean} value - Whether to enable or disable high precision.
  	 * @type {boolean}
  	 */
  	set highPrecision( value ) {

  		if ( value === true ) {

  			this.overrideNodes.modelViewMatrix = highpModelViewMatrix;
  			this.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix;

  		} else if ( this.highPrecision ) {

  			this.overrideNodes.modelViewMatrix = null;
  			this.overrideNodes.modelNormalViewMatrix = null;

  		}

  	}

  	/**
  	 * Returns whether high precision is enabled or not.
  	 *
  	 * @return {boolean} Whether high precision is enabled or not.
  	 * @type {boolean}
  	 */
  	get highPrecision() {

  		return this.overrideNodes.modelViewMatrix === highpModelViewMatrix && this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix;

  	}

  	/**
  	 * Sets the given MRT configuration.
  	 *
  	 * @param {MRTNode} mrt - The MRT node to set.
  	 * @return {Renderer} A reference to this renderer.
  	 */
  	setMRT( mrt ) {

  		this._mrt = mrt;

  		return this;

  	}

  	/**
  	 * Returns the MRT configuration.
  	 *
  	 * @return {MRTNode} The MRT configuration.
  	 */
  	getMRT() {

  		return this._mrt;

  	}

  	/**
  	 * Returns the color buffer type.
  	 *
  	 * @return {number} The color buffer type.
  	 */
  	getColorBufferType() {

  		return this._colorBufferType;

  	}

  	/**
  	 * Default implementation of the device lost callback.
  	 *
  	 * @private
  	 * @param {Object} info - Information about the context lost.
  	 */
  	_onDeviceLost( info ) {

  		let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;

  		if ( info.reason ) {

  			errorMessage += `\nReason: ${info.reason}`;

  		}

  		console.error( errorMessage );

  		this._isDeviceLost = true;

  	}

  	/**
  	 * Renders the given render bundle.
  	 *
  	 * @private
  	 * @param {Object} bundle - Render bundle data.
  	 * @param {Scene} sceneRef - The scene the render bundle belongs to.
  	 * @param {LightsNode} lightsNode - The lights node.
  	 */
  	_renderBundle( bundle, sceneRef, lightsNode ) {

  		const { bundleGroup, camera, renderList } = bundle;

  		const renderContext = this._currentRenderContext;

  		//

  		const renderBundle = this._bundles.get( bundleGroup, camera );
  		const renderBundleData = this.backend.get( renderBundle );

  		if ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();

  		//

  		const needsUpdate = bundleGroup.version !== renderBundleData.version;
  		const renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;

  		renderBundleData.renderContexts.add( renderContext );

  		if ( renderBundleNeedsUpdate ) {

  			this.backend.beginBundle( renderContext );

  			if ( renderBundleData.renderObjects === undefined || needsUpdate ) {

  				renderBundleData.renderObjects = [];

  			}

  			this._currentRenderBundle = renderBundle;

  			const {
  				transparentDoublePass: transparentDoublePassObjects,
  				transparent: transparentObjects,
  				opaque: opaqueObjects
  			} = renderList;

  			if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
  			if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

  			this._currentRenderBundle = null;

  			//

  			this.backend.finishBundle( renderContext, renderBundle );

  			renderBundleData.version = bundleGroup.version;

  		} else {

  			const { renderObjects } = renderBundleData;

  			for ( let i = 0, l = renderObjects.length; i < l; i ++ ) {

  				const renderObject = renderObjects[ i ];

  				if ( this._nodes.needsRefresh( renderObject ) ) {

  					this._nodes.updateBefore( renderObject );

  					this._nodes.updateForRender( renderObject );
  					this._bindings.updateForRender( renderObject );

  					this._nodes.updateAfter( renderObject );

  				}

  			}

  		}

  		this.backend.addBundle( renderContext, renderBundle );

  	}

  	/**
  	 * Renders the scene or 3D object with the given camera. This method can only be called
  	 * if the renderer has been initialized.
  	 *
  	 * The target of the method is the default framebuffer (meaning the canvas)
  	 * or alternatively a render target when specified via `setRenderTarget()`.
  	 *
  	 * @param {Object3D} scene - The scene or 3D object to render.
  	 * @param {Camera} camera - The camera to render the scene with.
  	 * @return {?Promise} A Promise that resolve when the scene has been rendered.
  	 * Only returned when the renderer has not been initialized.
  	 */
  	render( scene, camera ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );

  			return this.renderAsync( scene, camera );

  		}

  		this._renderScene( scene, camera );

  	}

  	/**
  	 * Returns an internal render target which is used when computing the output tone mapping
  	 * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
  	 * pass and not inline to achieve more correct results.
  	 *
  	 * @private
  	 * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
  	 */
  	_getFrameBufferTarget() {

  		const { currentToneMapping, currentColorSpace } = this;

  		const useToneMapping = currentToneMapping !== NoToneMapping;
  		const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;

  		if ( useToneMapping === false && useColorSpace === false ) return null;

  		const { width, height } = this.getDrawingBufferSize( _drawingBufferSize$1 );
  		const { depth, stencil } = this;

  		let frameBufferTarget = this._frameBufferTarget;

  		if ( frameBufferTarget === null ) {

  			frameBufferTarget = new RenderTarget( width, height, {
  				depthBuffer: depth,
  				stencilBuffer: stencil,
  				type: this._colorBufferType,
  				format: RGBAFormat,
  				colorSpace: LinearSRGBColorSpace,
  				generateMipmaps: false,
  				minFilter: LinearFilter,
  				magFilter: LinearFilter,
  				samples: this.samples
  			} );

  			frameBufferTarget.isPostProcessingRenderTarget = true;

  			this._frameBufferTarget = frameBufferTarget;

  		}

  		const outputRenderTarget = this.getOutputRenderTarget();

  		frameBufferTarget.depthBuffer = depth;
  		frameBufferTarget.stencilBuffer = stencil;
  		if ( outputRenderTarget !== null ) {

  			frameBufferTarget.setSize( outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth );

  		} else {

  			frameBufferTarget.setSize( width, height, 1 );

  		}

  		frameBufferTarget.viewport.copy( this._viewport );
  		frameBufferTarget.scissor.copy( this._scissor );
  		frameBufferTarget.viewport.multiplyScalar( this._pixelRatio );
  		frameBufferTarget.scissor.multiplyScalar( this._pixelRatio );
  		frameBufferTarget.scissorTest = this._scissorTest;
  		frameBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;
  		frameBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;
  		frameBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;

  		return frameBufferTarget;

  	}

  	/**
  	 * Renders the scene or 3D object with the given camera.
  	 *
  	 * @private
  	 * @param {Object3D} scene - The scene or 3D object to render.
  	 * @param {Camera} camera - The camera to render the scene with.
  	 * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
  	 * @return {RenderContext} The current render context.
  	 */
  	_renderScene( scene, camera, useFrameBufferTarget = true ) {

  		if ( this._isDeviceLost === true ) return;

  		const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;

  		// preserve render tree

  		const nodeFrame = this._nodes.nodeFrame;

  		const previousRenderId = nodeFrame.renderId;
  		const previousRenderContext = this._currentRenderContext;
  		const previousRenderObjectFunction = this._currentRenderObjectFunction;

  		//

  		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

  		const outputRenderTarget = this._renderTarget || this._outputRenderTarget;

  		const activeCubeFace = this._activeCubeFace;
  		const activeMipmapLevel = this._activeMipmapLevel;

  		//

  		let renderTarget;

  		if ( frameBufferTarget !== null ) {

  			renderTarget = frameBufferTarget;

  			this.setRenderTarget( renderTarget );

  		} else {

  			renderTarget = outputRenderTarget;

  		}

  		//

  		const renderContext = this._renderContexts.get( scene, camera, renderTarget );

  		this._currentRenderContext = renderContext;
  		this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;

  		//

  		this.info.calls ++;
  		this.info.render.calls ++;
  		this.info.render.frameCalls ++;

  		nodeFrame.renderId = this.info.calls;

  		//

  		const coordinateSystem = this.coordinateSystem;
  		const xr = this.xr;

  		if ( camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false ) {

  			camera.coordinateSystem = coordinateSystem;
  			camera.updateProjectionMatrix();

  			if ( camera.isArrayCamera ) {

  				for ( const subCamera of camera.cameras ) {

  					subCamera.coordinateSystem = coordinateSystem;
  					subCamera.updateProjectionMatrix();

  				}

  			}

  		}

  		//

  		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

  		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

  		if ( xr.enabled === true && xr.isPresenting === true ) {

  			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );
  			camera = xr.getCamera(); // use XR camera for rendering

  		}

  		//

  		let viewport = this._viewport;
  		let scissor = this._scissor;
  		let pixelRatio = this._pixelRatio;

  		if ( renderTarget !== null ) {

  			viewport = renderTarget.viewport;
  			scissor = renderTarget.scissor;
  			pixelRatio = 1;

  		}

  		this.getDrawingBufferSize( _drawingBufferSize$1 );

  		_screen.set( 0, 0, _drawingBufferSize$1.width, _drawingBufferSize$1.height );

  		const minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;
  		const maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;

  		renderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();
  		renderContext.viewportValue.width >>= activeMipmapLevel;
  		renderContext.viewportValue.height >>= activeMipmapLevel;
  		renderContext.viewportValue.minDepth = minDepth;
  		renderContext.viewportValue.maxDepth = maxDepth;
  		renderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;

  		renderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();
  		renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;
  		renderContext.scissorValue.width >>= activeMipmapLevel;
  		renderContext.scissorValue.height >>= activeMipmapLevel;

  		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
  		renderContext.clippingContext.updateGlobal( sceneRef, camera );

  		//

  		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

  		//

  		const frustum = camera.isArrayCamera ? _frustumArray : _frustum;

  		if ( ! camera.isArrayCamera ) {

  			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  			frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );

  		}

  		const renderList = this._renderLists.get( scene, camera );
  		renderList.begin();

  		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

  		renderList.finish();

  		if ( this.sortObjects === true ) {

  			renderList.sort( this._opaqueSort, this._transparentSort );

  		}

  		//

  		if ( renderTarget !== null ) {

  			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

  			const renderTargetData = this._textures.get( renderTarget );

  			renderContext.textures = renderTargetData.textures;
  			renderContext.depthTexture = renderTargetData.depthTexture;
  			renderContext.width = renderTargetData.width;
  			renderContext.height = renderTargetData.height;
  			renderContext.renderTarget = renderTarget;
  			renderContext.depth = renderTarget.depthBuffer;
  			renderContext.stencil = renderTarget.stencilBuffer;

  		} else {

  			renderContext.textures = null;
  			renderContext.depthTexture = null;
  			renderContext.width = this.domElement.width;
  			renderContext.height = this.domElement.height;
  			renderContext.depth = this.depth;
  			renderContext.stencil = this.stencil;

  		}

  		renderContext.width >>= activeMipmapLevel;
  		renderContext.height >>= activeMipmapLevel;
  		renderContext.activeCubeFace = activeCubeFace;
  		renderContext.activeMipmapLevel = activeMipmapLevel;
  		renderContext.occlusionQueryCount = renderList.occlusionQueryCount;

  		//

  		this._background.update( sceneRef, renderList, renderContext );

  		//

  		renderContext.camera = camera;
  		this.backend.beginRender( renderContext );

  		// process render lists

  		const {
  			bundles,
  			lightsNode,
  			transparentDoublePass: transparentDoublePassObjects,
  			transparent: transparentObjects,
  			opaque: opaqueObjects
  		} = renderList;

  		if ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );
  		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
  		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

  		// finish render pass

  		this.backend.finishRender( renderContext );

  		// restore render tree

  		nodeFrame.renderId = previousRenderId;

  		this._currentRenderContext = previousRenderContext;
  		this._currentRenderObjectFunction = previousRenderObjectFunction;

  		//

  		if ( frameBufferTarget !== null ) {

  			this.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );

  			this._renderOutput( renderTarget );

  		}

  		//

  		sceneRef.onAfterRender( this, scene, camera, renderTarget );

  		//

  		return renderContext;

  	}

  	_setXRLayerSize( width, height ) {

  		this._width = width;
  		this._height = height;

  		this.setViewport( 0, 0, width, height );

  	}

  	/**
  	 * The output pass performs tone mapping and color space conversion.
  	 *
  	 * @private
  	 * @param {RenderTarget} renderTarget - The current render target.
  	 */
  	_renderOutput( renderTarget ) {

  		const quad = this._quad;

  		if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

  			quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
  			quad.material.needsUpdate = true;

  		}

  		// a clear operation clears the intermediate renderTarget texture, but should not update the screen canvas.

  		const currentAutoClear = this.autoClear;
  		const currentXR = this.xr.enabled;

  		this.autoClear = false;
  		this.xr.enabled = false;

  		this._renderScene( quad, quad.camera, false );

  		this.autoClear = currentAutoClear;
  		this.xr.enabled = currentXR;


  	}

  	/**
  	 * Returns the maximum available anisotropy for texture filtering.
  	 *
  	 * @return {number} The maximum available anisotropy.
  	 */
  	getMaxAnisotropy() {

  		return this.backend.getMaxAnisotropy();

  	}

  	/**
  	 * Returns the active cube face.
  	 *
  	 * @return {number} The active cube face.
  	 */
  	getActiveCubeFace() {

  		return this._activeCubeFace;

  	}

  	/**
  	 * Returns the active mipmap level.
  	 *
  	 * @return {number} The active mipmap level.
  	 */
  	getActiveMipmapLevel() {

  		return this._activeMipmapLevel;

  	}

  	/**
  	 * Applications are advised to always define the animation loop
  	 * with this method and not manually with `requestAnimationFrame()`
  	 * for best compatibility.
  	 *
  	 * @async
  	 * @param {?Function} callback - The application's animation loop.
  	 * @return {Promise} A Promise that resolves when the set has been executed.
  	 */
  	async setAnimationLoop( callback ) {

  		if ( this._initialized === false ) await this.init();

  		this._animation.setAnimationLoop( callback );

  	}

  	/**
  	 * Can be used to transfer buffer data from a storage buffer attribute
  	 * from the GPU to the CPU in context of compute shaders.
  	 *
  	 * @async
  	 * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
  	 * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
  	 */
  	async getArrayBufferAsync( attribute ) {

  		return await this.backend.getArrayBufferAsync( attribute );

  	}

  	/**
  	 * Returns the rendering context.
  	 *
  	 * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
  	 */
  	getContext() {

  		return this.backend.getContext();

  	}

  	/**
  	 * Returns the pixel ratio.
  	 *
  	 * @return {number} The pixel ratio.
  	 */
  	getPixelRatio() {

  		return this._pixelRatio;

  	}

  	/**
  	 * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
  	 *
  	 * @param {Vector2} target - The method writes the result in this target object.
  	 * @return {Vector2} The drawing buffer size.
  	 */
  	getDrawingBufferSize( target ) {

  		return target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();

  	}

  	/**
  	 * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
  	 *
  	 * @param {Vector2} target - The method writes the result in this target object.
  	 * @return {Vector2} The renderer's size in logical pixels.
  	 */
  	getSize( target ) {

  		return target.set( this._width, this._height );

  	}

  	/**
  	 * Sets the given pixel ratio and resizes the canvas if necessary.
  	 *
  	 * @param {number} [value=1] - The pixel ratio.
  	 */
  	setPixelRatio( value = 1 ) {

  		if ( this._pixelRatio === value ) return;

  		this._pixelRatio = value;

  		this.setSize( this._width, this._height, false );

  	}

  	/**
  	 * This method allows to define the drawing buffer size by specifying
  	 * width, height and pixel ratio all at once. The size of the drawing
  	 * buffer is computed with this formula:
  	 * ```js
  	 * size.x = width * pixelRatio;
  	 * size.y = height * pixelRatio;
  	 * ```
  	 *
  	 * @param {number} width - The width in logical pixels.
  	 * @param {number} height - The height in logical pixels.
  	 * @param {number} pixelRatio - The pixel ratio.
  	 */
  	setDrawingBufferSize( width, height, pixelRatio ) {

  		// Renderer can't be resized while presenting in XR.
  		if ( this.xr && this.xr.isPresenting ) return;

  		this._width = width;
  		this._height = height;

  		this._pixelRatio = pixelRatio;

  		this.domElement.width = Math.floor( width * pixelRatio );
  		this.domElement.height = Math.floor( height * pixelRatio );

  		this.setViewport( 0, 0, width, height );

  		if ( this._initialized ) this.backend.updateSize();

  	}

  	/**
  	 * Sets the size of the renderer.
  	 *
  	 * @param {number} width - The width in logical pixels.
  	 * @param {number} height - The height in logical pixels.
  	 * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
  	 */
  	setSize( width, height, updateStyle = true ) {

  		// Renderer can't be resized while presenting in XR.
  		if ( this.xr && this.xr.isPresenting ) return;

  		this._width = width;
  		this._height = height;

  		this.domElement.width = Math.floor( width * this._pixelRatio );
  		this.domElement.height = Math.floor( height * this._pixelRatio );

  		if ( updateStyle === true ) {

  			this.domElement.style.width = width + 'px';
  			this.domElement.style.height = height + 'px';

  		}

  		this.setViewport( 0, 0, width, height );

  		if ( this._initialized ) this.backend.updateSize();

  	}

  	/**
  	 * Defines a manual sort function for the opaque render list.
  	 * Pass `null` to use the default sort.
  	 *
  	 * @param {Function} method - The sort function.
  	 */
  	setOpaqueSort( method ) {

  		this._opaqueSort = method;

  	}

  	/**
  	 * Defines a manual sort function for the transparent render list.
  	 * Pass `null` to use the default sort.
  	 *
  	 * @param {Function} method - The sort function.
  	 */
  	setTransparentSort( method ) {

  		this._transparentSort = method;

  	}

  	/**
  	 * Returns the scissor rectangle.
  	 *
  	 * @param {Vector4} target - The method writes the result in this target object.
  	 * @return {Vector4} The scissor rectangle.
  	 */
  	getScissor( target ) {

  		const scissor = this._scissor;

  		target.x = scissor.x;
  		target.y = scissor.y;
  		target.width = scissor.width;
  		target.height = scissor.height;

  		return target;

  	}

  	/**
  	 * Defines the scissor rectangle.
  	 *
  	 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
  	 * Instead of passing four arguments, the method also works with a single four-dimensional vector.
  	 * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
  	 * @param {number} width - The width of the scissor box in logical pixel unit.
  	 * @param {number} height - The height of the scissor box in logical pixel unit.
  	 */
  	setScissor( x, y, width, height ) {

  		const scissor = this._scissor;

  		if ( x.isVector4 ) {

  			scissor.copy( x );

  		} else {

  			scissor.set( x, y, width, height );

  		}

  	}

  	/**
  	 * Returns the scissor test value.
  	 *
  	 * @return {boolean} Whether the scissor test should be enabled or not.
  	 */
  	getScissorTest() {

  		return this._scissorTest;

  	}

  	/**
  	 * Defines the scissor test.
  	 *
  	 * @param {boolean} boolean - Whether the scissor test should be enabled or not.
  	 */
  	setScissorTest( boolean ) {

  		this._scissorTest = boolean;

  		this.backend.setScissorTest( boolean );

  	}

  	/**
  	 * Returns the viewport definition.
  	 *
  	 * @param {Vector4} target - The method writes the result in this target object.
  	 * @return {Vector4} The viewport definition.
  	 */
  	getViewport( target ) {

  		return target.copy( this._viewport );

  	}

  	/**
  	 * Defines the viewport.
  	 *
  	 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
  	 * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
  	 * @param {number} width - The width of the viewport in logical pixel unit.
  	 * @param {number} height - The height of the viewport in logical pixel unit.
  	 * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
  	 * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
  	 */
  	setViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {

  		const viewport = this._viewport;

  		if ( x.isVector4 ) {

  			viewport.copy( x );

  		} else {

  			viewport.set( x, y, width, height );

  		}

  		viewport.minDepth = minDepth;
  		viewport.maxDepth = maxDepth;

  	}

  	/**
  	 * Returns the clear color.
  	 *
  	 * @param {Color} target - The method writes the result in this target object.
  	 * @return {Color} The clear color.
  	 */
  	getClearColor( target ) {

  		return target.copy( this._clearColor );

  	}

  	/**
  	 * Defines the clear color and optionally the clear alpha.
  	 *
  	 * @param {Color} color - The clear color.
  	 * @param {number} [alpha=1] - The clear alpha.
  	 */
  	setClearColor( color, alpha = 1 ) {

  		this._clearColor.set( color );
  		this._clearColor.a = alpha;

  	}

  	/**
  	 * Returns the clear alpha.
  	 *
  	 * @return {number} The clear alpha.
  	 */
  	getClearAlpha() {

  		return this._clearColor.a;

  	}

  	/**
  	 * Defines the clear alpha.
  	 *
  	 * @param {number} alpha - The clear alpha.
  	 */
  	setClearAlpha( alpha ) {

  		this._clearColor.a = alpha;

  	}

  	/**
  	 * Returns the clear depth.
  	 *
  	 * @return {number} The clear depth.
  	 */
  	getClearDepth() {

  		return this._clearDepth;

  	}

  	/**
  	 * Defines the clear depth.
  	 *
  	 * @param {number} depth - The clear depth.
  	 */
  	setClearDepth( depth ) {

  		this._clearDepth = depth;

  	}

  	/**
  	 * Returns the clear stencil.
  	 *
  	 * @return {number} The clear stencil.
  	 */
  	getClearStencil() {

  		return this._clearStencil;

  	}

  	/**
  	 * Defines the clear stencil.
  	 *
  	 * @param {number} stencil - The clear stencil.
  	 */
  	setClearStencil( stencil ) {

  		this._clearStencil = stencil;

  	}

  	/**
  	 * This method performs an occlusion query for the given 3D object.
  	 * It returns `true` if the given 3D object is fully occluded by other
  	 * 3D objects in the scene.
  	 *
  	 * @param {Object3D} object - The 3D object to test.
  	 * @return {boolean} Whether the 3D object is fully occluded or not.
  	 */
  	isOccluded( object ) {

  		const renderContext = this._currentRenderContext;

  		return renderContext && this.backend.isOccluded( renderContext, object );

  	}

  	/**
  	 * Performs a manual clear operation. This method ignores `autoClear` properties.
  	 *
  	 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
  	 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
  	 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 * Only returned when the renderer has not been initialized.
  	 */
  	clear( color = true, depth = true, stencil = true ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );

  			return this.clearAsync( color, depth, stencil );

  		}

  		const renderTarget = this._renderTarget || this._getFrameBufferTarget();

  		let renderContext = null;

  		if ( renderTarget !== null ) {

  			this._textures.updateRenderTarget( renderTarget );

  			const renderTargetData = this._textures.get( renderTarget );

  			renderContext = this._renderContexts.getForClear( renderTarget );
  			renderContext.textures = renderTargetData.textures;
  			renderContext.depthTexture = renderTargetData.depthTexture;
  			renderContext.width = renderTargetData.width;
  			renderContext.height = renderTargetData.height;
  			renderContext.renderTarget = renderTarget;
  			renderContext.depth = renderTarget.depthBuffer;
  			renderContext.stencil = renderTarget.stencilBuffer;
  			// #30329
  			renderContext.clearColorValue = this.backend.getClearColor();
  			renderContext.activeCubeFace = this.getActiveCubeFace();
  			renderContext.activeMipmapLevel = this.getActiveMipmapLevel();

  		}

  		this.backend.clear( color, depth, stencil, renderContext );

  		if ( renderTarget !== null && this._renderTarget === null ) {

  			this._renderOutput( renderTarget );

  		}

  	}

  	/**
  	 * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
  	 *
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 * Only returned when the renderer has not been initialized.
  	 */
  	clearColor() {

  		return this.clear( true, false, false );

  	}

  	/**
  	 * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
  	 *
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 * Only returned when the renderer has not been initialized.
  	 */
  	clearDepth() {

  		return this.clear( false, true, false );

  	}

  	/**
  	 * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
  	 *
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 * Only returned when the renderer has not been initialized.
  	 */
  	clearStencil() {

  		return this.clear( false, false, true );

  	}

  	/**
  	 * Async version of {@link Renderer#clear}.
  	 *
  	 * @async
  	 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
  	 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
  	 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 */
  	async clearAsync( color = true, depth = true, stencil = true ) {

  		if ( this._initialized === false ) await this.init();

  		this.clear( color, depth, stencil );

  	}

  	/**
  	 * Async version of {@link Renderer#clearColor}.
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 */
  	async clearColorAsync() {

  		this.clearAsync( true, false, false );

  	}

  	/**
  	 * Async version of {@link Renderer#clearDepth}.
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 */
  	async clearDepthAsync() {

  		this.clearAsync( false, true, false );

  	}

  	/**
  	 * Async version of {@link Renderer#clearStencil}.
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolves when the clear operation has been executed.
  	 */
  	async clearStencilAsync() {

  		this.clearAsync( false, false, true );

  	}

  	/**
  	 * The current output tone mapping of the renderer. When a render target is set,
  	 * the output tone mapping is always `NoToneMapping`.
  	 *
  	 * @type {number}
  	 */
  	get currentToneMapping() {

  		return this.isOutputTarget ? this.toneMapping : NoToneMapping;

  	}

  	/**
  	 * The current output color space of the renderer. When a render target is set,
  	 * the output color space is always `LinearSRGBColorSpace`.
  	 *
  	 * @type {string}
  	 */
  	get currentColorSpace() {

  		return this.isOutputTarget ? this.outputColorSpace : LinearSRGBColorSpace;

  	}

  	/**
  	 * Returns `true` if the rendering settings are set to screen output.
  	 *
  	 * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
  	 */
  	get isOutputTarget() {

  		return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;

  	}

  	/**
  	 * Frees all internal resources of the renderer. Call this method if the renderer
  	 * is no longer in use by your app.
  	 */
  	dispose() {

  		this.info.dispose();
  		this.backend.dispose();

  		this._animation.dispose();
  		this._objects.dispose();
  		this._pipelines.dispose();
  		this._nodes.dispose();
  		this._bindings.dispose();
  		this._renderLists.dispose();
  		this._renderContexts.dispose();
  		this._textures.dispose();

  		if ( this._frameBufferTarget !== null ) this._frameBufferTarget.dispose();

  		Object.values( this.backend.timestampQueryPool ).forEach( queryPool => {

  			if ( queryPool !== null ) queryPool.dispose();

  		} );

  		this.setRenderTarget( null );
  		this.setAnimationLoop( null );

  	}

  	/**
  	 * Sets the given render target. Calling this method means the renderer does not
  	 * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
  	 * Use `null` as the first argument to reset the state.
  	 *
  	 * @param {?RenderTarget} renderTarget - The render target to set.
  	 * @param {number} [activeCubeFace=0] - The active cube face.
  	 * @param {number} [activeMipmapLevel=0] - The active mipmap level.
  	 */
  	setRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

  		this._renderTarget = renderTarget;
  		this._activeCubeFace = activeCubeFace;
  		this._activeMipmapLevel = activeMipmapLevel;

  	}

  	/**
  	 * Returns the current render target.
  	 *
  	 * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
  	 */
  	getRenderTarget() {

  		return this._renderTarget;

  	}

  	/**
  	 * Sets the output render target for the renderer.
  	 *
  	 * @param {Object} renderTarget - The render target to set as the output target.
  	 */
  	setOutputRenderTarget( renderTarget ) {

  		this._outputRenderTarget = renderTarget;

  	}

  	/**
  	 * Returns the current output target.
  	 *
  	 * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
  	 */
  	getOutputRenderTarget() {

  		return this._outputRenderTarget;

  	}

  	/**
  	 * Resets the renderer to the initial state before WebXR started.
  	 *
  	 */
  	_resetXRState() {

  		this.backend.setXRTarget( null );
  		this.setOutputRenderTarget( null );
  		this.setRenderTarget( null );

  		this._frameBufferTarget.dispose();
  		this._frameBufferTarget = null;

  	}

  	/**
  	 * Callback for {@link Renderer#setRenderObjectFunction}.
  	 *
  	 * @callback renderObjectFunction
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the object should be rendered with.
  	 * @param {BufferGeometry} geometry - The object's geometry.
  	 * @param {Material} material - The object's material.
  	 * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 * @param {ClippingContext} clippingContext - The clipping context.
  	 * @param {?string} [passId=null] - An optional ID for identifying the pass.
  	 */

  	/**
  	 * Sets the given render object function. Calling this method overwrites the default implementation
  	 * which is {@link Renderer#renderObject}. Defining a custom function can be useful
  	 * if you want to modify the way objects are rendered. For example you can define things like "every
  	 * object that has material of a certain type should perform a pre-pass with a special overwrite material".
  	 * The custom function must always call `renderObject()` in its implementation.
  	 *
  	 * Use `null` as the first argument to reset the state.
  	 *
  	 * @param {?renderObjectFunction} renderObjectFunction - The render object function.
  	 */
  	setRenderObjectFunction( renderObjectFunction ) {

  		this._renderObjectFunction = renderObjectFunction;

  	}

  	/**
  	 * Returns the current render object function.
  	 *
  	 * @return {?Function} The current render object function. Returns `null` if no function is set.
  	 */
  	getRenderObjectFunction() {

  		return this._renderObjectFunction;

  	}

  	/**
  	 * Execute a single or an array of compute nodes. This method can only be called
  	 * if the renderer has been initialized.
  	 *
  	 * @param {Node|Array<Node>} computeNodes - The compute node(s).
  	 * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
  	 */
  	compute( computeNodes ) {

  		if ( this._isDeviceLost === true ) return;

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );

  			return this.computeAsync( computeNodes );

  		}

  		//

  		const nodeFrame = this._nodes.nodeFrame;

  		const previousRenderId = nodeFrame.renderId;

  		//

  		this.info.calls ++;
  		this.info.compute.calls ++;
  		this.info.compute.frameCalls ++;

  		nodeFrame.renderId = this.info.calls;

  		//

  		const backend = this.backend;
  		const pipelines = this._pipelines;
  		const bindings = this._bindings;
  		const nodes = this._nodes;

  		const computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];

  		if ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {

  			throw new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );

  		}

  		backend.beginCompute( computeNodes );

  		for ( const computeNode of computeList ) {

  			// onInit

  			if ( pipelines.has( computeNode ) === false ) {

  				const dispose = () => {

  					computeNode.removeEventListener( 'dispose', dispose );

  					pipelines.delete( computeNode );
  					bindings.delete( computeNode );
  					nodes.delete( computeNode );

  				};

  				computeNode.addEventListener( 'dispose', dispose );

  				//

  				const onInitFn = computeNode.onInitFunction;

  				if ( onInitFn !== null ) {

  					onInitFn.call( computeNode, { renderer: this } );

  				}

  			}

  			nodes.updateForCompute( computeNode );
  			bindings.updateForCompute( computeNode );

  			const computeBindings = bindings.getForCompute( computeNode );
  			const computePipeline = pipelines.getForCompute( computeNode, computeBindings );

  			backend.compute( computeNodes, computeNode, computeBindings, computePipeline );

  		}

  		backend.finishCompute( computeNodes );

  		//

  		nodeFrame.renderId = previousRenderId;

  	}

  	/**
  	 * Execute a single or an array of compute nodes.
  	 *
  	 * @async
  	 * @param {Node|Array<Node>} computeNodes - The compute node(s).
  	 * @return {Promise} A Promise that resolve when the compute has finished.
  	 */
  	async computeAsync( computeNodes ) {

  		if ( this._initialized === false ) await this.init();

  		this.compute( computeNodes );

  	}

  	/**
  	 * Checks if the given feature is supported by the selected backend.
  	 *
  	 * @async
  	 * @param {string} name - The feature's name.
  	 * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
  	 */
  	async hasFeatureAsync( name ) {

  		if ( this._initialized === false ) await this.init();

  		return this.backend.hasFeature( name );

  	}

  	async resolveTimestampsAsync( type = 'render' ) {

  		if ( this._initialized === false ) await this.init();

  		return this.backend.resolveTimestampsAsync( type );

  	}

  	/**
  	 * Checks if the given feature is supported by the selected backend. If the
  	 * renderer has not been initialized, this method always returns `false`.
  	 *
  	 * @param {string} name - The feature's name.
  	 * @return {boolean} Whether the feature is supported or not.
  	 */
  	hasFeature( name ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );

  			return false;

  		}

  		return this.backend.hasFeature( name );

  	}

  	/**
  	 * Returns `true` when the renderer has been initialized.
  	 *
  	 * @return {boolean} Whether the renderer has been initialized or not.
  	 */
  	hasInitialized() {

  		return this._initialized;

  	}

  	/**
  	 * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
  	 * (which can cause noticeable lags due to decode and GPU upload overhead).
  	 *
  	 * @async
  	 * @param {Texture} texture - The texture.
  	 * @return {Promise} A Promise that resolves when the texture has been initialized.
  	 */
  	async initTextureAsync( texture ) {

  		if ( this._initialized === false ) await this.init();

  		this._textures.updateTexture( texture );

  	}

  	/**
  	 * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
  	 * (which can cause noticeable lags due to decode and GPU upload overhead).
  	 *
  	 * This method can only be used if the renderer has been initialized.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	initTexture( texture ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );

  		}

  		this._textures.updateTexture( texture );

  	}

  	/**
  	 * Copies the current bound framebuffer into the given texture.
  	 *
  	 * @param {FramebufferTexture} framebufferTexture - The texture.
  	 * @param {?Vector2|Vector4} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
  	 */
  	copyFramebufferToTexture( framebufferTexture, rectangle = null ) {

  		if ( rectangle !== null ) {

  			if ( rectangle.isVector2 ) {

  				rectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();

  			} else if ( rectangle.isVector4 ) {

  				rectangle = _vector4.copy( rectangle ).floor();

  			} else {

  				console.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );

  				return;

  			}

  		} else {

  			rectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );

  		}

  		//

  		let renderContext = this._currentRenderContext;
  		let renderTarget;

  		if ( renderContext !== null ) {

  			renderTarget = renderContext.renderTarget;

  		} else {

  			renderTarget = this._renderTarget || this._getFrameBufferTarget();

  			if ( renderTarget !== null ) {

  				this._textures.updateRenderTarget( renderTarget );

  				renderContext = this._textures.get( renderTarget );

  			}

  		}

  		//

  		this._textures.updateTexture( framebufferTexture, { renderTarget } );

  		this.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );

  	}

  	/**
  	 * Copies data of the given source texture into a destination texture.
  	 *
  	 * @param {Texture} srcTexture - The source texture.
  	 * @param {Texture} dstTexture - The destination texture.
  	 * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
  	 * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
  	 * @param {number} [srcLevel=0] - The source mip level to copy from.
  	 * @param {number} [dstLevel=0] - The destination mip level to copy to.
  	 */
  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {

  		this._textures.updateTexture( srcTexture );
  		this._textures.updateTexture( dstTexture );

  		this.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel );

  	}

  	/**
  	 * Reads pixel data from the given render target.
  	 *
  	 * @async
  	 * @param {RenderTarget} renderTarget - The render target to read from.
  	 * @param {number} x - The `x` coordinate of the copy region's origin.
  	 * @param {number} y - The `y` coordinate of the copy region's origin.
  	 * @param {number} width - The width of the copy region.
  	 * @param {number} height - The height of the copy region.
  	 * @param {number} [textureIndex=0] - The texture index of a MRT render target.
  	 * @param {number} [faceIndex=0] - The active cube face index.
  	 * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
  	 */
  	async readRenderTargetPixelsAsync( renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0 ) {

  		return this.backend.copyTextureToBuffer( renderTarget.textures[ textureIndex ], x, y, width, height, faceIndex );

  	}

  	/**
  	 * Analyzes the given 3D object's hierarchy and builds render lists from the
  	 * processed hierarchy.
  	 *
  	 * @param {Object3D} object - The 3D object to process (usually a scene).
  	 * @param {Camera} camera - The camera the object is rendered with.
  	 * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
  	 * @param {RenderList} renderList - The current render list.
  	 * @param {ClippingContext} clippingContext - The current clipping context.
  	 */
  	_projectObject( object, camera, groupOrder, renderList, clippingContext ) {

  		if ( object.visible === false ) return;

  		const visible = object.layers.test( camera.layers );

  		if ( visible ) {

  			if ( object.isGroup ) {

  				groupOrder = object.renderOrder;

  				if ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );

  			} else if ( object.isLOD ) {

  				if ( object.autoUpdate === true ) object.update( camera );

  			} else if ( object.isLight ) {

  				renderList.pushLight( object );

  			} else if ( object.isSprite ) {

  				const frustum = camera.isArrayCamera ? _frustumArray : _frustum;

  				if ( ! object.frustumCulled || frustum.intersectsSprite( object, camera ) ) {

  					if ( this.sortObjects === true ) {

  						_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );

  					}

  					const { geometry, material } = object;

  					if ( material.visible ) {

  						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

  					}

  				}

  			} else if ( object.isLineLoop ) {

  				console.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );

  			} else if ( object.isMesh || object.isLine || object.isPoints ) {

  				const frustum = camera.isArrayCamera ? _frustumArray : _frustum;

  				if ( ! object.frustumCulled || frustum.intersectsObject( object, camera ) ) {

  					const { geometry, material } = object;

  					if ( this.sortObjects === true ) {

  						if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  						_vector4
  							.copy( geometry.boundingSphere.center )
  							.applyMatrix4( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					if ( Array.isArray( material ) ) {

  						const groups = geometry.groups;

  						for ( let i = 0, l = groups.length; i < l; i ++ ) {

  							const group = groups[ i ];
  							const groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								renderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );

  							}

  						}

  					} else if ( material.visible ) {

  						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

  					}

  				}

  			}

  		}

  		if ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {

  			const baseRenderList = renderList;

  			// replace render list
  			renderList = this._renderLists.get( object, camera );

  			renderList.begin();

  			baseRenderList.pushBundle( {
  				bundleGroup: object,
  				camera,
  				renderList,
  			} );

  			renderList.finish();

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );

  		}

  	}

  	/**
  	 * Renders the given render bundles.
  	 *
  	 * @private
  	 * @param {Array<Object>} bundles - Array with render bundle data.
  	 * @param {Scene} sceneRef - The scene the render bundles belong to.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 */
  	_renderBundles( bundles, sceneRef, lightsNode ) {

  		for ( const bundle of bundles ) {

  			this._renderBundle( bundle, sceneRef, lightsNode );

  		}

  	}

  	/**
  	 * Renders the transparent objects from the given render lists.
  	 *
  	 * @private
  	 * @param {Array<Object>} renderList - The transparent render list.
  	 * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
  	 * @param {Camera} camera - The camera the render list should be rendered with.
  	 * @param {Scene} scene - The scene the render list belongs to.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 */
  	_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {

  		if ( doublePassList.length > 0 ) {

  			// render back side

  			for ( const { material } of doublePassList ) {

  				material.side = BackSide;

  			}

  			this._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );

  			// render front side

  			for ( const { material } of doublePassList ) {

  				material.side = FrontSide;

  			}

  			this._renderObjects( renderList, camera, scene, lightsNode );

  			// restore

  			for ( const { material } of doublePassList ) {

  				material.side = DoubleSide;

  			}

  		} else {

  			this._renderObjects( renderList, camera, scene, lightsNode );

  		}

  	}

  	/**
  	 * Renders the objects from the given render list.
  	 *
  	 * @private
  	 * @param {Array<Object>} renderList - The render list.
  	 * @param {Camera} camera - The camera the render list should be rendered with.
  	 * @param {Scene} scene - The scene the render list belongs to.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 * @param {?string} [passId=null] - An optional ID for identifying the pass.
  	 */
  	_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {

  		for ( let i = 0, il = renderList.length; i < il; i ++ ) {

  			const { object, geometry, material, group, clippingContext } = renderList[ i ];

  			this._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );

  		}

  	}

  	/**
  	 * This method represents the default render object function that manages the render lifecycle
  	 * of the object.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the object should be rendered with.
  	 * @param {BufferGeometry} geometry - The object's geometry.
  	 * @param {Material} material - The object's material.
  	 * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 * @param {?ClippingContext} clippingContext - The clipping context.
  	 * @param {?string} [passId=null] - An optional ID for identifying the pass.
  	 */
  	renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {

  		let overridePositionNode;
  		let overrideColorNode;
  		let overrideDepthNode;

  		//

  		object.onBeforeRender( this, scene, camera, geometry, material, group );

  		//

  		if ( material.allowOverride === true && scene.overrideMaterial !== null ) {

  			const overrideMaterial = scene.overrideMaterial;

  			if ( material.positionNode && material.positionNode.isNode ) {

  				overridePositionNode = overrideMaterial.positionNode;
  				overrideMaterial.positionNode = material.positionNode;

  			}

  			overrideMaterial.alphaTest = material.alphaTest;
  			overrideMaterial.alphaMap = material.alphaMap;
  			overrideMaterial.transparent = material.transparent || material.transmission > 0;

  			if ( overrideMaterial.isShadowPassMaterial ) {

  				overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;

  				if ( material.depthNode && material.depthNode.isNode ) {

  					overrideDepthNode = overrideMaterial.depthNode;
  					overrideMaterial.depthNode = material.depthNode;

  				}

  				if ( material.castShadowNode && material.castShadowNode.isNode ) {

  					overrideColorNode = overrideMaterial.colorNode;
  					overrideMaterial.colorNode = material.castShadowNode;

  				}

  				if ( material.castShadowPositionNode && material.castShadowPositionNode.isNode ) {

  					overridePositionNode = overrideMaterial.positionNode;
  					overrideMaterial.positionNode = material.castShadowPositionNode;

  				}

  			}

  			material = overrideMaterial;

  		}

  		//

  		if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

  			material.side = BackSide;
  			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id

  			material.side = FrontSide;
  			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id

  			material.side = DoubleSide;

  		} else {

  			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );

  		}

  		//

  		if ( overridePositionNode !== undefined ) {

  			scene.overrideMaterial.positionNode = overridePositionNode;

  		}

  		if ( overrideDepthNode !== undefined ) {

  			scene.overrideMaterial.depthNode = overrideDepthNode;

  		}

  		if ( overrideColorNode !== undefined ) {

  			scene.overrideMaterial.colorNode = overrideColorNode;

  		}

  		//

  		object.onAfterRender( this, scene, camera, geometry, material, group );

  	}

  	/**
  	 * This method represents the default `_handleObjectFunction` implementation which creates
  	 * a render object from the given data and performs the draw command with the selected backend.
  	 *
  	 * @private
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Material} material - The object's material.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the object should be rendered with.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {ClippingContext} clippingContext - The clipping context.
  	 * @param {?string} [passId=null] - An optional ID for identifying the pass.
  	 */
  	_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {

  		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );
  		renderObject.drawRange = object.geometry.drawRange;
  		renderObject.group = group;

  		//

  		const needsRefresh = this._nodes.needsRefresh( renderObject );

  		if ( needsRefresh ) {

  			this._nodes.updateBefore( renderObject );

  			this._geometries.updateForRender( renderObject );

  			this._nodes.updateForRender( renderObject );
  			this._bindings.updateForRender( renderObject );

  		}

  		this._pipelines.updateForRender( renderObject );

  		//

  		if ( this._currentRenderBundle !== null ) {

  			const renderBundleData = this.backend.get( this._currentRenderBundle );

  			renderBundleData.renderObjects.push( renderObject );

  			renderObject.bundle = this._currentRenderBundle.bundleGroup;

  		}

  		this.backend.draw( renderObject, this.info );

  		if ( needsRefresh ) this._nodes.updateAfter( renderObject );

  	}

  	/**
  	 * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
  	 * Used in `compileAsync()`.
  	 *
  	 * @private
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Material} material - The object's material.
  	 * @param {Scene} scene - The scene the 3D object belongs to.
  	 * @param {Camera} camera - The camera the object should be rendered with.
  	 * @param {LightsNode} lightsNode - The current lights node.
  	 * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
  	 * @param {ClippingContext} clippingContext - The clipping context.
  	 * @param {?string} [passId=null] - An optional ID for identifying the pass.
  	 */
  	_createObjectPipeline( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {

  		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );
  		renderObject.drawRange = object.geometry.drawRange;
  		renderObject.group = group;

  		//

  		this._nodes.updateBefore( renderObject );

  		this._geometries.updateForRender( renderObject );

  		this._nodes.updateForRender( renderObject );
  		this._bindings.updateForRender( renderObject );

  		this._pipelines.getForRender( renderObject, this._compilationPromises );

  		this._nodes.updateAfter( renderObject );

  	}

  	/**
  	 * Alias for `compileAsync()`.
  	 *
  	 * @method
  	 * @param {Object3D} scene - The scene or 3D object to precompile.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
  	 * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
  	 */
  	get compile() {

  		return this.compileAsync;

  	}

  }

  /**
   * A binding represents the connection between a resource (like a texture, sampler
   * or uniform buffer) and the resource definition in a shader stage.
   *
   * This module is an abstract base class for all concrete bindings types.
   *
   * @abstract
   * @private
   */
  class Binding {

  	/**
  	 * Constructs a new binding.
  	 *
  	 * @param {string} [name=''] - The binding's name.
  	 */
  	constructor( name = '' ) {

  		/**
  		 * The binding's name.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * A bitmask that defines in what shader stages the
  		 * binding's resource is accessible.
  		 *
  		 * @type {number}
  		 */
  		this.visibility = 0;

  	}

  	/**
  	 * Makes sure binding's resource is visible for the given shader stage.
  	 *
  	 * @param {number} visibility - The shader stage.
  	 */
  	setVisibility( visibility ) {

  		this.visibility |= visibility;

  	}

  	/**
  	 * Clones the binding.
  	 *
  	 * @return {Binding} The cloned binding.
  	 */
  	clone() {

  		return Object.assign( new this.constructor(), this );

  	}

  }

  /**
   * This function is usually called with the length in bytes of an array buffer.
   * It returns an padded value which ensure chunk size alignment according to STD140 layout.
   *
   * @function
   * @param {number} floatLength - The buffer length.
   * @return {number} The padded length.
   */
  function getFloatLength( floatLength ) {

  	// ensure chunk size alignment (STD140 layout)

  	return floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );

  }

  /**
   * Represents a buffer binding type.
   *
   * @private
   * @abstract
   * @augments Binding
   */
  class Buffer extends Binding {

  	/**
  	 * Constructs a new buffer.
  	 *
  	 * @param {string} name - The buffer's name.
  	 * @param {TypedArray} [buffer=null] - The buffer.
  	 */
  	constructor( name, buffer = null ) {

  		super( name );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBuffer = true;

  		/**
  		 * The bytes per element.
  		 *
  		 * @type {number}
  		 */
  		this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

  		/**
  		 * A reference to the internal buffer.
  		 *
  		 * @private
  		 * @type {TypedArray}
  		 */
  		this._buffer = buffer;

  	}

  	/**
  	 * The buffer's byte length.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get byteLength() {

  		return getFloatLength( this._buffer.byteLength );

  	}

  	/**
  	 * A reference to the internal buffer.
  	 *
  	 * @type {Float32Array}
  	 * @readonly
  	 */
  	get buffer() {

  		return this._buffer;

  	}

  	/**
  	 * Updates the binding.
  	 *
  	 * @return {boolean} Whether the buffer has been updated and must be
  	 * uploaded to the GPU.
  	 */
  	update() {

  		return true;

  	}

  }

  /**
   * Represents a uniform buffer binding type.
   *
   * @private
   * @augments Buffer
   */
  class UniformBuffer extends Buffer {

  	/**
  	 * Constructs a new uniform buffer.
  	 *
  	 * @param {string} name - The buffer's name.
  	 * @param {TypedArray} [buffer=null] - The buffer.
  	 */
  	constructor( name, buffer = null ) {

  		super( name, buffer );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isUniformBuffer = true;

  	}

  }

  let _id$4 = 0;

  /**
   * A special form of uniform buffer binding type.
   * It's buffer value is managed by a node object.
   *
   * @private
   * @augments UniformBuffer
   */
  class NodeUniformBuffer extends UniformBuffer {

  	/**
  	 * Constructs a new node-based uniform buffer.
  	 *
  	 * @param {BufferNode} nodeUniform - The uniform buffer node.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 */
  	constructor( nodeUniform, groupNode ) {

  		super( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );

  		/**
  		 * The uniform buffer node.
  		 *
  		 * @type {BufferNode}
  		 */
  		this.nodeUniform = nodeUniform;

  		/**
  		 * The uniform group node.
  		 *
  		 * @type {UniformGroupNode}
  		 */
  		this.groupNode = groupNode;

  	}

  	/**
  	 * The uniform buffer.
  	 *
  	 * @type {Float32Array}
  	 */
  	get buffer() {

  		return this.nodeUniform.value;

  	}

  }

  /**
   * This class represents a uniform buffer binding but with
   * an API that allows to maintain individual uniform objects.
   *
   * @private
   * @augments UniformBuffer
   */
  class UniformsGroup extends UniformBuffer {

  	/**
  	 * Constructs a new uniforms group.
  	 *
  	 * @param {string} name - The group's name.
  	 */
  	constructor( name ) {

  		super( name );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isUniformsGroup = true;

  		/**
  		 * An array with the raw uniform values.
  		 *
  		 * @private
  		 * @type {?Array<number>}
  		 * @default null
  		 */
  		this._values = null;

  		/**
  		 * An array of uniform objects.
  		 *
  		 * The order of uniforms in this array must match the order of uniforms in the shader.
  		 *
  		 * @type {Array<Uniform>}
  		 */
  		this.uniforms = [];

  	}

  	/**
  	 * Adds a uniform to this group.
  	 *
  	 * @param {Uniform} uniform - The uniform to add.
  	 * @return {UniformsGroup} A reference to this group.
  	 */
  	addUniform( uniform ) {

  		this.uniforms.push( uniform );

  		return this;

  	}

  	/**
  	 * Removes a uniform from this group.
  	 *
  	 * @param {Uniform} uniform - The uniform to remove.
  	 * @return {UniformsGroup} A reference to this group.
  	 */
  	removeUniform( uniform ) {

  		const index = this.uniforms.indexOf( uniform );

  		if ( index !== -1 ) {

  			this.uniforms.splice( index, 1 );

  		}

  		return this;

  	}

  	/**
  	 * An array with the raw uniform values.
  	 *
  	 * @type {Array<number>}
  	 */
  	get values() {

  		if ( this._values === null ) {

  			this._values = Array.from( this.buffer );

  		}

  		return this._values;

  	}

  	/**
  	 * A Float32 array buffer with the uniform values.
  	 *
  	 * @type {Float32Array}
  	 */
  	get buffer() {

  		let buffer = this._buffer;

  		if ( buffer === null ) {

  			const byteLength = this.byteLength;

  			buffer = new Float32Array( new ArrayBuffer( byteLength ) );

  			this._buffer = buffer;

  		}

  		return buffer;

  	}

  	/**
  	 * The byte length of the buffer with correct buffer alignment.
  	 *
  	 * @type {number}
  	 */
  	get byteLength() {

  		const bytesPerElement = this.bytesPerElement;

  		let offset = 0; // global buffer offset in bytes

  		for ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {

  			const uniform = this.uniforms[ i ];

  			const boundary = uniform.boundary;
  			const itemSize = uniform.itemSize * bytesPerElement; // size of the uniform in bytes

  			const chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk
  			const chunkPadding = chunkOffset % boundary; // required padding to match boundary
  			const chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data

  			offset += chunkPadding;

  			// Check for chunk overflow
  			if ( chunkStart !== 0 && ( GPU_CHUNK_BYTES - chunkStart ) < itemSize ) {

  				// Add padding to the end of the chunk
  				offset += ( GPU_CHUNK_BYTES - chunkStart );

  			}

  			uniform.offset = offset / bytesPerElement;

  			offset += itemSize;

  		}

  		return Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;

  	}

  	/**
  	 * Updates this group by updating each uniform object of
  	 * the internal uniform list. The uniform objects check if their
  	 * values has actually changed so this method only returns
  	 * `true` if there is a real value change.
  	 *
  	 * @return {boolean} Whether the uniforms have been updated and
  	 * must be uploaded to the GPU.
  	 */
  	update() {

  		let updated = false;

  		for ( const uniform of this.uniforms ) {

  			if ( this.updateByType( uniform ) === true ) {

  				updated = true;

  			}

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given uniform by calling an update method matching
  	 * the uniforms type.
  	 *
  	 * @param {Uniform} uniform - The uniform to update.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateByType( uniform ) {

  		if ( uniform.isNumberUniform ) return this.updateNumber( uniform );
  		if ( uniform.isVector2Uniform ) return this.updateVector2( uniform );
  		if ( uniform.isVector3Uniform ) return this.updateVector3( uniform );
  		if ( uniform.isVector4Uniform ) return this.updateVector4( uniform );
  		if ( uniform.isColorUniform ) return this.updateColor( uniform );
  		if ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );
  		if ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );

  		console.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );

  	}

  	/**
  	 * Updates a given Number uniform.
  	 *
  	 * @param {NumberUniform} uniform - The Number uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateNumber( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;
  		const type = uniform.getType();

  		if ( a[ offset ] !== v ) {

  			const b = this._getBufferForType( type );

  			b[ offset ] = a[ offset ] = v;
  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given Vector2 uniform.
  	 *
  	 * @param {Vector2Uniform} uniform - The Vector2 uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateVector2( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;
  		const type = uniform.getType();

  		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {

  			const b = this._getBufferForType( type );

  			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
  			b[ offset + 1 ] = a[ offset + 1 ] = v.y;

  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given Vector3 uniform.
  	 *
  	 * @param {Vector3Uniform} uniform - The Vector3 uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateVector3( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;
  		const type = uniform.getType();

  		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {

  			const b = this._getBufferForType( type );

  			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
  			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
  			b[ offset + 2 ] = a[ offset + 2 ] = v.z;

  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given Vector4 uniform.
  	 *
  	 * @param {Vector4Uniform} uniform - The Vector4 uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateVector4( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;
  		const type = uniform.getType();

  		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {

  			const b = this._getBufferForType( type );

  			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
  			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
  			b[ offset + 2 ] = a[ offset + 2 ] = v.z;
  			b[ offset + 3 ] = a[ offset + 3 ] = v.w;

  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given Color uniform.
  	 *
  	 * @param {ColorUniform} uniform - The Color uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateColor( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const c = uniform.getValue();
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = c.r;
  			b[ offset + 1 ] = a[ offset + 1 ] = c.g;
  			b[ offset + 2 ] = a[ offset + 2 ] = c.b;

  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given Matrix3 uniform.
  	 *
  	 * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateMatrix3( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const e = uniform.getValue().elements;
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||
  			a[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||
  			a[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];
  			b[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];
  			b[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];
  			b[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];
  			b[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];
  			b[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];
  			b[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];
  			b[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];
  			b[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];

  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Updates a given Matrix4 uniform.
  	 *
  	 * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
  	 * @return {boolean} Whether the uniform has been updated or not.
  	 */
  	updateMatrix4( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const e = uniform.getValue().elements;
  		const offset = uniform.offset;

  		if ( arraysEqual( a, e, offset ) === false ) {

  			const b = this.buffer;
  			b.set( e, offset );
  			setArray( a, e, offset );
  			updated = true;

  		}

  		return updated;

  	}

  	/**
  	 * Returns a typed array that matches the given data type.
  	 *
  	 * @param {string} type - The data type.
  	 * @return {TypedArray} The typed array.
  	 */
  	_getBufferForType( type ) {

  		if ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );
  		if ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );
  		return this.buffer;

  	}

  }

  /**
   * Sets the values of the second array to the first array.
   *
   * @private
   * @param {TypedArray} a - The first array.
   * @param {TypedArray} b - The second array.
   * @param {number} offset - An index offset for the first array.
   */
  function setArray( a, b, offset ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		a[ offset + i ] = b[ i ];

  	}

  }

  /**
   * Returns `true` if the given arrays are equal.
   *
   * @private
   * @param {TypedArray} a - The first array.
   * @param {TypedArray} b - The second array.
   * @param {number} offset - An index offset for the first array.
   * @return {boolean} Whether the given arrays are equal or not.
   */
  function arraysEqual( a, b, offset ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		if ( a[ offset + i ] !== b[ i ] ) return false;

  	}

  	return true;

  }

  let _id$3 = 0;

  /**
   * A special form of uniforms group that represents
   * the individual uniforms as node-based uniforms.
   *
   * @private
   * @augments UniformsGroup
   */
  class NodeUniformsGroup extends UniformsGroup {

  	/**
  	 * Constructs a new node-based uniforms group.
  	 *
  	 * @param {string} name - The group's name.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 */
  	constructor( name, groupNode ) {

  		super( name );

  		/**
  		 * The group's ID.
  		 *
  		 * @type {number}
  		 */
  		this.id = _id$3 ++;

  		/**
  		 * The uniform group node.
  		 *
  		 * @type {UniformGroupNode}
  		 */
  		this.groupNode = groupNode;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isNodeUniformsGroup = true;

  	}

  }

  let _id$2 = 0;

  /**
   * Represents a sampled texture binding type.
   *
   * @private
   * @augments Binding
   */
  class SampledTexture extends Binding {

  	/**
  	 * Constructs a new sampled texture.
  	 *
  	 * @param {string} name - The sampled texture's name.
  	 * @param {?Texture} texture - The texture this binding is referring to.
  	 */
  	constructor( name, texture ) {

  		super( name );

  		/**
  		 * This identifier.
  		 *
  		 * @type {number}
  		 */
  		this.id = _id$2 ++;

  		/**
  		 * The texture this binding is referring to.
  		 *
  		 * @type {?Texture}
  		 */
  		this.texture = texture;

  		/**
  		 * The binding's version.
  		 *
  		 * @type {number}
  		 */
  		this.version = texture ? texture.version : 0;

  		/**
  		 * Whether the texture is a storage texture or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.store = false;

  		/**
  		 * The binding's generation which is an additional version
  		 * qualifier.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this.generation = null;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSampledTexture = true;

  	}

  	/**
  	 * Returns `true` whether this binding requires an update for the
  	 * given generation.
  	 *
  	 * @param {number} generation - The generation.
  	 * @return {boolean} Whether an update is required or not.
  	 */
  	needsBindingsUpdate( generation ) {

  		const { texture } = this;

  		if ( generation !== this.generation ) {

  			this.generation = generation;

  			return true;

  		}

  		return texture.isVideoTexture;

  	}

  	/**
  	 * Updates the binding.
  	 *
  	 * @return {boolean} Whether the texture has been updated and must be
  	 * uploaded to the GPU.
  	 */
  	update() {

  		const { texture, version } = this;

  		if ( version !== texture.version ) {

  			this.version = texture.version;

  			return true;

  		}

  		return false;

  	}

  }

  /**
   * A special form of sampled texture binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments SampledTexture
   */
  class NodeSampledTexture extends SampledTexture {

  	/**
  	 * Constructs a new node-based sampled texture.
  	 *
  	 * @param {string} name - The textures's name.
  	 * @param {TextureNode} textureNode - The texture node.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 * @param {?string} [access=null] - The access type.
  	 */
  	constructor( name, textureNode, groupNode, access = null ) {

  		super( name, textureNode ? textureNode.value : null );

  		/**
  		 * The texture node.
  		 *
  		 * @type {TextureNode}
  		 */
  		this.textureNode = textureNode;

  		/**
  		 * The uniform group node.
  		 *
  		 * @type {UniformGroupNode}
  		 */
  		this.groupNode = groupNode;

  		/**
  		 * The access type.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.access = access;

  	}

  	/**
  	 * Overwrites the default to additionally check if the node value has changed.
  	 *
  	 * @param {number} generation - The generation.
  	 * @return {boolean} Whether an update is required or not.
  	 */
  	needsBindingsUpdate( generation ) {

  		return this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );

  	}

  	/**
  	 * Updates the binding.
  	 *
  	 * @return {boolean} Whether the texture has been updated and must be
  	 * uploaded to the GPU.
  	 */
  	update() {

  		const { textureNode } = this;

  		if ( this.texture !== textureNode.value ) {

  			this.texture = textureNode.value;

  			return true;

  		}

  		return super.update();

  	}

  }

  /**
   * A special form of sampled cube texture binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments NodeSampledTexture
   */
  class NodeSampledCubeTexture extends NodeSampledTexture {

  	/**
  	 * Constructs a new node-based sampled cube texture.
  	 *
  	 * @param {string} name - The textures's name.
  	 * @param {TextureNode} textureNode - The texture node.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 * @param {?string} [access=null] - The access type.
  	 */
  	constructor( name, textureNode, groupNode, access = null ) {

  		super( name, textureNode, groupNode, access );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSampledCubeTexture = true;

  	}

  }

  /**
   * A special form of sampled 3D texture binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments NodeSampledTexture
   */
  class NodeSampledTexture3D extends NodeSampledTexture {

  	/**
  	 * Constructs a new node-based sampled 3D texture.
  	 *
  	 * @param {string} name - The textures's name.
  	 * @param {TextureNode} textureNode - The texture node.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 * @param {?string} [access=null] - The access type.
  	 */
  	constructor( name, textureNode, groupNode, access = null ) {

  		super( name, textureNode, groupNode, access );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSampledTexture3D = true;

  	}

  }

  const glslMethods = {
  	textureDimensions: 'textureSize',
  	equals: 'equal'
  };

  const precisionLib = {
  	low: 'lowp',
  	medium: 'mediump',
  	high: 'highp'
  };

  const supports$1 = {
  	swizzleAssign: true,
  	storageBuffer: false
  };

  const interpolationTypeMap = {
  	perspective: 'smooth',
  	linear: 'noperspective'
  };

  const interpolationModeMap = {
  	'centroid': 'centroid'
  };

  const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;

  /**
   * A node builder targeting GLSL.
   *
   * This module generates GLSL shader code from node materials and also
   * generates the respective bindings and vertex buffer definitions. These
   * data are later used by the renderer to create render and compute pipelines
   * for render objects.
   *
   * @augments NodeBuilder
   */
  class GLSLNodeBuilder extends NodeBuilder {

  	/**
  	 * Constructs a new GLSL node builder renderer.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Renderer} renderer - The renderer.
  	 */
  	constructor( object, renderer ) {

  		super( object, renderer, new GLSLNodeParser() );

  		/**
  		 * A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')
  		 * another dictionary which manages UBOs per group ('render','frame','object').
  		 *
  		 * @type {Object<string,Object<string,NodeUniformsGroup>>}
  		 */
  		this.uniformGroups = {};

  		/**
  		 * An array that holds objects defining the varying and attribute data in
  		 * context of Transform Feedback.
  		 *
  		 * @type {Array<Object<string,AttributeNode|string>>}
  		 */
  		this.transforms = [];

  		/**
  		 * A dictionary that holds for each shader stage a Map of used extensions.
  		 *
  		 * @type {Object<string,Map<string,Object>>}
  		 */
  		this.extensions = {};

  		/**
  		 * A dictionary that holds for each shader stage an Array of used builtins.
  		 *
  		 * @type {Object<string,Array<string>>}
  		 */
  		this.builtins = { vertex: [], fragment: [], compute: [] };

  	}

  	/**
  	 * Checks if the given texture requires a manual conversion to the working color space.
  	 *
  	 * @param {Texture} texture - The texture to check.
  	 * @return {boolean} Whether the given texture requires a conversion to working color space or not.
  	 */
  	needsToWorkingColorSpace( texture ) {

  		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

  	}

  	/**
  	 * Returns the native shader method name for a given generic name.
  	 *
  	 * @param {string} method - The method name to resolve.
  	 * @return {string} The resolved GLSL method name.
  	 */
  	getMethod( method ) {

  		return glslMethods[ method ] || method;

  	}

  	/**
  	 * Returns the output struct name. Not relevant for GLSL.
  	 *
  	 * @return {string}
  	 */
  	getOutputStructName() {

  		return '';

  	}

  	/**
  	 * Builds the given shader node.
  	 *
  	 * @param {ShaderNodeInternal} shaderNode - The shader node.
  	 * @return {string} The GLSL function code.
  	 */
  	buildFunctionCode( shaderNode ) {

  		const layout = shaderNode.layout;
  		const flowData = this.flowShaderNode( shaderNode );

  		const parameters = [];

  		for ( const input of layout.inputs ) {

  			parameters.push( this.getType( input.type ) + ' ' + input.name );

  		}

  		//

  		const code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {

	${ flowData.vars }

${ flowData.code }
	return ${ flowData.result };

}`;

  		//

  		return code;

  	}

  	/**
  	 * Setups the Pixel Buffer Object (PBO) for the given storage
  	 * buffer node.
  	 *
  	 * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
  	 */
  	setupPBO( storageBufferNode ) {

  		const attribute = storageBufferNode.value;

  		if ( attribute.pbo === undefined ) {

  			const originalArray = attribute.array;
  			const numElements = attribute.count * attribute.itemSize;

  			const { itemSize } = attribute;

  			const isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );

  			let format = isInteger ? RedIntegerFormat : RedFormat;

  			if ( itemSize === 2 ) {

  				format = isInteger ? RGIntegerFormat : RGFormat;

  			} else if ( itemSize === 3 ) {

  				format = isInteger ? RGBIntegerFormat : RGBFormat;

  			} else if ( itemSize === 4 ) {

  				format = isInteger ? RGBAIntegerFormat : RGBAFormat;

  			}

  			const typeMap = {
  				Float32Array: FloatType,
  				Uint8Array: UnsignedByteType,
  				Uint16Array: UnsignedShortType,
  				Uint32Array: UnsignedIntType,
  				Int8Array: ByteType,
  				Int16Array: ShortType,
  				Int32Array: IntType,
  				Uint8ClampedArray: UnsignedByteType,
  			};

  			const width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );
  			let height = Math.ceil( ( numElements / itemSize ) / width );
  			if ( width * height * itemSize < numElements ) height ++; // Ensure enough space

  			const newSize = width * height * itemSize;

  			const newArray = new originalArray.constructor( newSize );

  			newArray.set( originalArray, 0 );

  			attribute.array = newArray;

  			const pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );
  			pboTexture.needsUpdate = true;
  			pboTexture.isPBOTexture = true;

  			const pbo = new TextureNode( pboTexture, null, null );
  			pbo.setPrecision( 'high' );

  			attribute.pboNode = pbo;
  			attribute.pbo = pbo.value;

  			this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );

  		}

  	}

  	/**
  	 * Returns a GLSL snippet that represents the property name of the given node.
  	 *
  	 * @param {Node} node - The node.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The property name.
  	 */
  	getPropertyName( node, shaderStage = this.shaderStage ) {

  		if ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {

  			return shaderStage.charAt( 0 ) + '_' + node.name;

  		}

  		return super.getPropertyName( node, shaderStage );

  	}

  	/**
  	 * Setups the Pixel Buffer Object (PBO) for the given storage
  	 * buffer node.
  	 *
  	 * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
  	 * @return {string} The property name.
  	 */
  	generatePBO( storageArrayElementNode ) {

  		const { node, indexNode } = storageArrayElementNode;
  		const attribute = node.value;

  		if ( this.renderer.backend.has( attribute ) ) {

  			const attributeData = this.renderer.backend.get( attribute );
  			attributeData.pbo = attribute.pbo;

  		}

  		const nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );
  		const textureName = this.getPropertyName( nodeUniform );

  		this.increaseUsage( indexNode ); // force cache generate to be used as index in x,y
  		const indexSnippet = indexNode.build( this, 'uint' );

  		const elementNodeData = this.getDataFromNode( storageArrayElementNode );

  		let propertyName = elementNodeData.propertyName;

  		if ( propertyName === undefined ) {

  			// property element

  			const nodeVar = this.getVarFromNode( storageArrayElementNode );

  			propertyName = this.getPropertyName( nodeVar );

  			// property size

  			const bufferNodeData = this.getDataFromNode( node );

  			let propertySizeName = bufferNodeData.propertySizeName;

  			if ( propertySizeName === undefined ) {

  				propertySizeName = propertyName + 'Size';

  				this.getVarFromNode( node, propertySizeName, 'uint' );

  				this.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );

  				bufferNodeData.propertySizeName = propertySizeName;

  			}

  			//

  			const { itemSize } = attribute;

  			const channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );
  			const uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;

  			const snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );

  			//


  			let prefix = 'vec4';

  			if ( attribute.pbo.type === UnsignedIntType ) {

  				prefix = 'uvec4';

  			} else if ( attribute.pbo.type === IntType ) {

  				prefix = 'ivec4';

  			}

  			this.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );

  			elementNodeData.propertyName = propertyName;

  		}

  		return propertyName;

  	}

  	/**
  	 * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
  	 * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @return {string} The GLSL snippet.
  	 */
  	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {

  		if ( depthSnippet ) {

  			return `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;

  		} else {

  			return `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;

  		}

  	}

  	/**
  	 * Generates the GLSL snippet for sampling/loading the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
  	 * @return {string} The GLSL snippet.
  	 */
  	generateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {

  		if ( texture.isDepthTexture ) {

  			if ( depthSnippet ) uvSnippet = `vec4( ${ uvSnippet }, ${ depthSnippet } )`;

  			return `texture( ${ textureProperty }, ${ uvSnippet } ).x`;

  		} else {

  			if ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;

  			return `texture( ${ textureProperty }, ${ uvSnippet } )`;

  		}

  	}

  	/**
  	 * Generates the GLSL snippet when sampling textures with explicit mip level.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @return {string} The GLSL snippet.
  	 */
  	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {

  		return `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;

  	}

  	/**
  	 * Generates the GLSL snippet when sampling textures with a bias to the mip level.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
  	 * @return {string} The GLSL snippet.
  	 */
  	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {

  		return `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;

  	}

  	/**
  	 * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
  	 * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
  	 * @return {string} The GLSL snippet.
  	 */
  	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {

  		return `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

  	}

  	/**
  	 * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
  	 * against a reference value.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
  	 * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The GLSL snippet.
  	 */
  	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			if ( depthSnippet ) {

  				return `texture( ${ textureProperty }, vec4( ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } ) )`;

  			}

  			return `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

  		}

  	}

  	/**
  	 * Returns the variables of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the variables.
  	 */
  	getVars( shaderStage ) {

  		const snippets = [];

  		const vars = this.vars[ shaderStage ];

  		if ( vars !== undefined ) {

  			for ( const variable of vars ) {

  				snippets.push( `${ this.getVar( variable.type, variable.name, variable.count ) };` );

  			}

  		}

  		return snippets.join( '\n\t' );

  	}

  	/**
  	 * Returns the uniforms of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the uniforms.
  	 */
  	getUniforms( shaderStage ) {

  		const uniforms = this.uniforms[ shaderStage ];

  		const bindingSnippets = [];
  		const uniformGroups = {};

  		for ( const uniform of uniforms ) {

  			let snippet = null;
  			let group = false;

  			if ( uniform.type === 'texture' || uniform.type === 'texture3D' ) {

  				const texture = uniform.node.value;

  				let typePrefix = '';

  				if ( texture.isDataTexture === true || texture.isData3DTexture === true ) {

  					if ( texture.type === UnsignedIntType ) {

  						typePrefix = 'u';

  					} else if ( texture.type === IntType ) {

  						typePrefix = 'i';

  					}

  				}

  				if ( uniform.type === 'texture3D' && texture.isArrayTexture === false ) {

  					snippet = `${typePrefix}sampler3D ${ uniform.name };`;

  				} else if ( texture.compareFunction ) {

  					if ( texture.isArrayTexture === true ) {

  						snippet = `sampler2DArrayShadow ${ uniform.name };`;

  					} else {

  						snippet = `sampler2DShadow ${ uniform.name };`;

  					}

  				} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

  					snippet = `${typePrefix}sampler2DArray ${ uniform.name };`;

  				} else {

  					snippet = `${typePrefix}sampler2D ${ uniform.name };`;

  				}

  			} else if ( uniform.type === 'cubeTexture' ) {

  				snippet = `samplerCube ${ uniform.name };`;

  			} else if ( uniform.type === 'buffer' ) {

  				const bufferNode = uniform.node;
  				const bufferType = this.getType( bufferNode.bufferType );
  				const bufferCount = bufferNode.bufferCount;

  				const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
  				snippet = `${bufferNode.name} {\n\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\n};\n`;

  			} else {

  				const vectorType = this.getVectorType( uniform.type );

  				snippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;

  				group = true;

  			}

  			const precision = uniform.node.precision;

  			if ( precision !== null ) {

  				snippet = precisionLib[ precision ] + ' ' + snippet;

  			}

  			if ( group ) {

  				snippet = '\t' + snippet;

  				const groupName = uniform.groupNode.name;
  				const groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );

  				groupSnippets.push( snippet );

  			} else {

  				snippet = 'uniform ' + snippet;

  				bindingSnippets.push( snippet );

  			}

  		}

  		let output = '';

  		for ( const name in uniformGroups ) {

  			const groupSnippets = uniformGroups[ name ];

  			output += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\n' ) ) + '\n';

  		}

  		output += bindingSnippets.join( '\n' );

  		return output;

  	}

  	/**
  	 * Returns the type for a given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 * @return {string} The type.
  	 */
  	getTypeFromAttribute( attribute ) {

  		let nodeType = super.getTypeFromAttribute( attribute );

  		if ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {

  			let dataAttribute = attribute;

  			if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

  			const array = dataAttribute.array;

  			if ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {

  				nodeType = nodeType.slice( 1 );

  			}

  		}

  		return nodeType;

  	}

  	/**
  	 * Returns the shader attributes of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the shader attributes.
  	 */
  	getAttributes( shaderStage ) {

  		let snippet = '';

  		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

  			const attributes = this.getAttributesArray();

  			let location = 0;

  			for ( const attribute of attributes ) {

  				snippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\n`;

  			}

  		}

  		return snippet;

  	}

  	/**
  	 * Returns the members of the given struct type node as a GLSL string.
  	 *
  	 * @param {StructTypeNode} struct - The struct type node.
  	 * @return {string} The GLSL snippet that defines the struct members.
  	 */
  	getStructMembers( struct ) {

  		const snippets = [];

  		for ( const member of struct.members ) {

  			snippets.push( `\t${ member.type } ${ member.name };` );

  		}

  		return snippets.join( '\n' );

  	}

  	/**
  	 * Returns the structs of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the structs.
  	 */
  	getStructs( shaderStage ) {

  		const snippets = [];
  		const structs = this.structs[ shaderStage ];

  		const outputSnippet = [];

  		for ( const struct of structs ) {

  			if ( struct.output ) {

  				for ( const member of struct.members ) {

  					outputSnippet.push( `layout( location = ${ member.index } ) out ${ member.type } ${ member.name };` );

  				}

  			} else {

  				let snippet = 'struct ' + struct.name + ' {\n';
  				snippet += this.getStructMembers( struct );
  				snippet += '\n};\n';

  				snippets.push( snippet );

  			}

  		}

  		if ( outputSnippet.length === 0 ) {

  			outputSnippet.push( 'layout( location = 0 ) out vec4 fragColor;' );

  		}

  		return '\n' + outputSnippet.join( '\n' ) + '\n\n' + snippets.join( '\n' );

  	}

  	/**
  	 * Returns the varyings of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the varyings.
  	 */
  	getVaryings( shaderStage ) {

  		let snippet = '';

  		const varyings = this.varyings;

  		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

  			for ( const varying of varyings ) {

  				if ( shaderStage === 'compute' ) varying.needsInterpolation = true;

  				const type = this.getType( varying.type );

  				if ( varying.needsInterpolation ) {

  					if ( varying.interpolationType ) {

  						const interpolationType = interpolationTypeMap[ varying.interpolationType ] || varying.interpolationType;
  						const sampling = interpolationModeMap[ varying.interpolationSampling ] || '';

  						snippet += `${ interpolationType } ${ sampling } out ${ type } ${ varying.name };\n`;

  					} else {

  						const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

  						snippet += `${ flat }out ${ type } ${ varying.name };\n`;

  					}

  				} else {

  					snippet += `${type} ${varying.name};\n`; // generate variable (no varying required)

  				}

  			}

  		} else if ( shaderStage === 'fragment' ) {

  			for ( const varying of varyings ) {

  				if ( varying.needsInterpolation ) {

  					const type = this.getType( varying.type );

  					if ( varying.interpolationType ) {

  						const interpolationType = interpolationTypeMap[ varying.interpolationType ] || varying.interpolationType;
  						const sampling = interpolationModeMap[ varying.interpolationSampling ] || '';

  						snippet += `${ interpolationType } ${ sampling } in ${ type } ${ varying.name };\n`;


  					} else {

  						const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

  						snippet += `${ flat }in ${ type } ${ varying.name };\n`;

  					}

  				}

  			}

  		}

  		for ( const builtin of this.builtins[ shaderStage ] ) {

  			snippet += `${builtin};\n`;

  		}

  		return snippet;

  	}

  	/**
  	 * Returns the vertex index builtin.
  	 *
  	 * @return {string} The vertex index.
  	 */
  	getVertexIndex() {

  		return 'uint( gl_VertexID )';

  	}

  	/**
  	 * Returns the instance index builtin.
  	 *
  	 * @return {string} The instance index.
  	 */
  	getInstanceIndex() {

  		return 'uint( gl_InstanceID )';

  	}

  	/**
  	 * Returns the invocation local index builtin.
  	 *
  	 * @return {string} The invocation local index.
  	 */
  	getInvocationLocalIndex() {

  		const workgroupSize = this.object.workgroupSize;

  		const size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );

  		return `uint( gl_InstanceID ) % ${size}u`;

  	}

  	/**
  	 * Returns the draw index builtin.
  	 *
  	 * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
  	 */
  	getDrawIndex() {

  		const extensions = this.renderer.backend.extensions;

  		if ( extensions.has( 'WEBGL_multi_draw' ) ) {

  			return 'uint( gl_DrawID )';

  		}

  		return null;

  	}

  	/**
  	 * Returns the front facing builtin.
  	 *
  	 * @return {string} The front facing builtin.
  	 */
  	getFrontFacing() {

  		return 'gl_FrontFacing';

  	}

  	/**
  	 * Returns the frag coord builtin.
  	 *
  	 * @return {string} The frag coord builtin.
  	 */
  	getFragCoord() {

  		return 'gl_FragCoord.xy';

  	}

  	/**
  	 * Returns the frag depth builtin.
  	 *
  	 * @return {string} The frag depth builtin.
  	 */
  	getFragDepth() {

  		return 'gl_FragDepth';

  	}

  	/**
  	 * Enables the given extension.
  	 *
  	 * @param {string} name - The extension name.
  	 * @param {string} behavior - The extension behavior.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage.
  	 */
  	enableExtension( name, behavior, shaderStage = this.shaderStage ) {

  		const map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );

  		if ( map.has( name ) === false ) {

  			map.set( name, {
  				name,
  				behavior
  			} );

  		}

  	}

  	/**
  	 * Returns the enabled extensions of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the enabled extensions.
  	 */
  	getExtensions( shaderStage ) {

  		const snippets = [];

  		if ( shaderStage === 'vertex' ) {

  			const ext = this.renderer.backend.extensions;
  			const isBatchedMesh = this.object.isBatchedMesh;

  			if ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {

  				this.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );

  			}

  		}

  		const extensions = this.extensions[ shaderStage ];

  		if ( extensions !== undefined ) {

  			for ( const { name, behavior } of extensions.values() ) {

  				snippets.push( `#extension ${name} : ${behavior}` );

  			}

  		}

  		return snippets.join( '\n' );

  	}

  	/**
  	 * Returns the clip distances builtin.
  	 *
  	 * @return {string} The clip distances builtin.
  	 */
  	getClipDistance() {

  		return 'gl_ClipDistance';

  	}

  	/**
  	 * Whether the requested feature is available or not.
  	 *
  	 * @param {string} name - The requested feature.
  	 * @return {boolean} Whether the requested feature is supported or not.
  	 */
  	isAvailable( name ) {

  		let result = supports$1[ name ];

  		if ( result === undefined ) {

  			let extensionName;

  			result = false;

  			switch ( name ) {

  				case 'float32Filterable':
  					extensionName = 'OES_texture_float_linear';
  					break;

  				case 'clipDistance':
  					extensionName = 'WEBGL_clip_cull_distance';
  					break;

  			}

  			if ( extensionName !== undefined ) {

  				const extensions = this.renderer.backend.extensions;

  				if ( extensions.has( extensionName ) ) {

  					extensions.get( extensionName );
  					result = true;

  				}

  			}

  			supports$1[ name ] = result;

  		}

  		return result;

  	}

  	/**
  	 * Whether to flip texture data along its vertical axis or not.
  	 *
  	 * @return {boolean} Returns always `true` in context of GLSL.
  	 */
  	isFlipY() {

  		return true;

  	}

  	/**
  	 * Enables hardware clipping.
  	 *
  	 * @param {string} planeCount - The clipping plane count.
  	 */
  	enableHardwareClipping( planeCount ) {

  		this.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );

  		this.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );

  	}

  	/**
  	 * Enables multiview.
  	 */
  	enableMultiview() {

  		this.enableExtension( 'GL_OVR_multiview2', 'require', 'fragment' );
  		this.enableExtension( 'GL_OVR_multiview2', 'require', 'vertex' );

  		this.builtins[ 'vertex' ].push( 'layout(num_views = 2) in' );

  	}

  	/**
  	 * Registers a transform in context of Transform Feedback.
  	 *
  	 * @param {string} varyingName - The varying name.
  	 * @param {AttributeNode} attributeNode - The attribute node.
  	 */
  	registerTransform( varyingName, attributeNode ) {

  		this.transforms.push( { varyingName, attributeNode } );

  	}

  	/**
  	 * Returns the transforms of the given shader stage as a GLSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The GLSL snippet that defines the transforms.
  	 */
  	getTransforms( /* shaderStage  */ ) {

  		const transforms = this.transforms;

  		let snippet = '';

  		for ( let i = 0; i < transforms.length; i ++ ) {

  			const transform = transforms[ i ];
  			const attributeName = this.getPropertyName( transform.attributeNode );

  			if ( attributeName ) snippet += `${ transform.varyingName } = ${ attributeName };\n\t`;

  		}

  		return snippet;

  	}

  	/**
  	 * Returns a GLSL struct based on the given name and variables.
  	 *
  	 * @private
  	 * @param {string} name - The struct name.
  	 * @param {string} vars - The struct variables.
  	 * @return {string} The GLSL snippet representing a struct.
  	 */
  	_getGLSLUniformStruct( name, vars ) {

  		return `
layout( std140 ) uniform ${name} {
${vars}
};`;

  	}

  	/**
  	 * Returns a GLSL vertex shader based on the given shader data.
  	 *
  	 * @private
  	 * @param {Object} shaderData - The shader data.
  	 * @return {string} The vertex shader.
  	 */
  	_getGLSLVertexCode( shaderData ) {

  		return `#version 300 es

${ this.getSignature() }

// extensions
${shaderData.extensions}

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;

  	}

  	/**
  	 * Returns a GLSL fragment shader based on the given shader data.
  	 *
  	 * @private
  	 * @param {Object} shaderData - The shader data.
  	 * @return {string} The vertex shader.
  	 */
  	_getGLSLFragmentCode( shaderData ) {

  		return `#version 300 es

${ this.getSignature() }

// extensions
${shaderData.extensions}

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

// structs
${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

  	}

  	/**
  	 * Controls the code build of the shader stages.
  	 */
  	buildCode() {

  		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

  		this.sortBindingGroups();

  		for ( const shaderStage in shadersData ) {

  			let flow = '// code\n\n';
  			flow += this.flowCode[ shaderStage ];

  			const flowNodes = this.flowNodes[ shaderStage ];
  			const mainNode = flowNodes[ flowNodes.length - 1 ];

  			for ( const node of flowNodes ) {

  				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
  				const slotName = node.name;

  				if ( slotName ) {

  					if ( flow.length > 0 ) flow += '\n';

  					flow += `\t// flow -> ${ slotName }\n\t`;

  				}

  				flow += `${ flowSlotData.code }\n\t`;

  				if ( node === mainNode && shaderStage !== 'compute' ) {

  					flow += '// result\n\t';

  					if ( shaderStage === 'vertex' ) {

  						flow += 'gl_Position = ';
  						flow += `${ flowSlotData.result };`;

  					} else if ( shaderStage === 'fragment' ) {

  						if ( ! node.outputNode.isOutputStructNode ) {

  							flow += 'fragColor = ';
  							flow += `${ flowSlotData.result };`;

  						}

  					}

  				}

  			}

  			const stageData = shadersData[ shaderStage ];

  			stageData.extensions = this.getExtensions( shaderStage );
  			stageData.uniforms = this.getUniforms( shaderStage );
  			stageData.attributes = this.getAttributes( shaderStage );
  			stageData.varyings = this.getVaryings( shaderStage );
  			stageData.vars = this.getVars( shaderStage );
  			stageData.structs = this.getStructs( shaderStage );
  			stageData.codes = this.getCodes( shaderStage );
  			stageData.transforms = this.getTransforms( shaderStage );
  			stageData.flow = flow;

  		}

  		if ( this.material !== null ) {

  			this.vertexShader = this._getGLSLVertexCode( shadersData.vertex );
  			this.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );

  		} else {

  			this.computeShader = this._getGLSLVertexCode( shadersData.compute );

  		}

  	}

  	/**
  	 * This method is one of the more important ones since it's responsible
  	 * for generating a matching binding instance for the given uniform node.
  	 *
  	 * These bindings are later used in the renderer to create bind groups
  	 * and layouts.
  	 *
  	 * @param {UniformNode} node - The uniform node.
  	 * @param {string} type - The node data type.
  	 * @param {string} shaderStage - The shader stage.
  	 * @param {?string} [name=null] - An optional uniform name.
  	 * @return {NodeUniform} The node uniform object.
  	 */
  	getUniformFromNode( node, type, shaderStage, name = null ) {

  		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		let uniformGPU = nodeData.uniformGPU;

  		if ( uniformGPU === undefined ) {

  			const group = node.groupNode;
  			const groupName = group.name;

  			const bindings = this.getBindGroupArray( groupName, shaderStage );

  			if ( type === 'texture' ) {

  				uniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );
  				bindings.push( uniformGPU );

  			} else if ( type === 'cubeTexture' ) {

  				uniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );
  				bindings.push( uniformGPU );

  			} else if ( type === 'texture3D' ) {

  				uniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );
  				bindings.push( uniformGPU );

  			} else if ( type === 'buffer' ) {

  				node.name = `NodeBuffer_${ node.id }`;
  				uniformNode.name = `buffer${ node.id }`;

  				const buffer = new NodeUniformBuffer( node, group );
  				buffer.name = node.name;

  				bindings.push( buffer );

  				uniformGPU = buffer;

  			} else {

  				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

  				let uniformsGroup = uniformsStage[ groupName ];

  				if ( uniformsGroup === undefined ) {

  					uniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );
  					//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

  					uniformsStage[ groupName ] = uniformsGroup;

  					bindings.push( uniformsGroup );

  				}

  				uniformGPU = this.getNodeUniform( uniformNode, type );

  				uniformsGroup.addUniform( uniformGPU );

  			}

  			nodeData.uniformGPU = uniformGPU;

  		}

  		return uniformNode;

  	}

  }

  let _vector2 = null;
  let _color4 = null;

  /**
   * Most of the rendering related logic is implemented in the
   * {@link Renderer} module and related management components.
   * Sometimes it is required though to execute commands which are
   * specific to the current 3D backend (which is WebGPU or WebGL 2).
   * This abstract base class defines an interface that encapsulates
   * all backend-related logic. Derived classes for each backend must
   * implement the interface.
   *
   * @abstract
   * @private
   */
  class Backend {

  	/**
  	 * Constructs a new backend.
  	 *
  	 * @param {Object} parameters - An object holding parameters for the backend.
  	 */
  	constructor( parameters = {} ) {

  		/**
  		 * The parameters of the backend.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = Object.assign( {}, parameters );

  		/**
  		 * This weak map holds backend-specific data of objects
  		 * like textures, attributes or render targets.
  		 *
  		 * @type {WeakMap}
  		 */
  		this.data = new WeakMap();

  		/**
  		 * A reference to the renderer.
  		 *
  		 * @type {?Renderer}
  		 * @default null
  		 */
  		this.renderer = null;

  		/**
  		 * A reference to the canvas element the renderer is drawing to.
  		 *
  		 * @type {?(HTMLCanvasElement|OffscreenCanvas)}
  		 * @default null
  		 */
  		this.domElement = null;

  		/**
  		 * A reference to the timestamp query pool.
     		 *
     		 * @type {{render: ?TimestampQueryPool, compute: ?TimestampQueryPool}}
  		 */
  		this.timestampQueryPool = {
  			'render': null,
  			'compute': null
  		};

  		/**
  		 * Whether to track timestamps with a Timestamp Query API or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.trackTimestamp = ( parameters.trackTimestamp === true );

  	}

  	/**
  	 * Initializes the backend so it is ready for usage. Concrete backends
  	 * are supposed to implement their rendering context creation and related
  	 * operations in this method.
  	 *
  	 * @async
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {Promise} A Promise that resolves when the backend has been initialized.
  	 */
  	async init( renderer ) {

  		this.renderer = renderer;

  	}

  	/**
  	 * The coordinate system of the backend.
  	 *
  	 * @abstract
  	 * @type {number}
  	 * @readonly
  	 */
  	get coordinateSystem() {}

  	// render context

  	/**
  	 * This method is executed at the beginning of a render call and
  	 * can be used by the backend to prepare the state for upcoming
  	 * draw calls.
  	 *
  	 * @abstract
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	beginRender( /*renderContext*/ ) {}

  	/**
  	 * This method is executed at the end of a render call and
  	 * can be used by the backend to finalize work after draw
  	 * calls.
  	 *
  	 * @abstract
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	finishRender( /*renderContext*/ ) {}

  	/**
  	 * This method is executed at the beginning of a compute call and
  	 * can be used by the backend to prepare the state for upcoming
  	 * compute tasks.
  	 *
  	 * @abstract
  	 * @param {Node|Array<Node>} computeGroup - The compute node(s).
  	 */
  	beginCompute( /*computeGroup*/ ) {}

  	/**
  	 * This method is executed at the end of a compute call and
  	 * can be used by the backend to finalize work after compute
  	 * tasks.
  	 *
  	 * @abstract
  	 * @param {Node|Array<Node>} computeGroup - The compute node(s).
  	 */
  	finishCompute( /*computeGroup*/ ) {}

  	// render object

  	/**
  	 * Executes a draw command for the given render object.
  	 *
  	 * @abstract
  	 * @param {RenderObject} renderObject - The render object to draw.
  	 * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
  	 */
  	draw( /*renderObject, info*/ ) { }

  	// compute node

  	/**
  	 * Executes a compute command for the given compute node.
  	 *
  	 * @abstract
  	 * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
  	 * @param {Node} computeNode - The compute node.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 * @param {ComputePipeline} computePipeline - The compute pipeline.
  	 */
  	compute( /*computeGroup, computeNode, computeBindings, computePipeline*/ ) { }

  	// program

  	/**
  	 * Creates a shader program from the given programmable stage.
  	 *
  	 * @abstract
  	 * @param {ProgrammableStage} program - The programmable stage.
  	 */
  	createProgram( /*program*/ ) { }

  	/**
  	 * Destroys the shader program of the given programmable stage.
  	 *
  	 * @abstract
  	 * @param {ProgrammableStage} program - The programmable stage.
  	 */
  	destroyProgram( /*program*/ ) { }

  	// bindings

  	/**
  	 * Creates bindings from the given bind group definition.
  	 *
  	 * @abstract
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	createBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }

  	/**
  	 * Updates the given bind group definition.
  	 *
  	 * @abstract
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	updateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }

  	/**
  	 * Updates a buffer binding.
  	 *
  	 * @abstract
  	 * @param {Buffer} binding - The buffer binding to update.
  	 */
  	updateBinding( /*binding*/ ) { }

  	// pipeline

  	/**
  	 * Creates a render pipeline for the given render object.
  	 *
  	 * @abstract
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
  	 */
  	createRenderPipeline( /*renderObject, promises*/ ) { }

  	/**
  	 * Creates a compute pipeline for the given compute node.
  	 *
  	 * @abstract
  	 * @param {ComputePipeline} computePipeline - The compute pipeline.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 */
  	createComputePipeline( /*computePipeline, bindings*/ ) { }

  	// cache key

  	/**
  	 * Returns `true` if the render pipeline requires an update.
  	 *
  	 * @abstract
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the render pipeline requires an update or not.
  	 */
  	needsRenderUpdate( /*renderObject*/ ) { }

  	/**
  	 * Returns a cache key that is used to identify render pipelines.
  	 *
  	 * @abstract
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {string} The cache key.
  	 */
  	getRenderCacheKey( /*renderObject*/ ) { }

  	// node builder

  	/**
  	 * Returns a node builder for the given render object.
  	 *
  	 * @abstract
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {NodeBuilder} The node builder.
  	 */
  	createNodeBuilder( /*renderObject, renderer*/ ) { }

  	// textures

  	/**
  	 * Creates a GPU sampler for the given texture.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture to create the sampler for.
  	 */
  	createSampler( /*texture*/ ) { }

  	/**
  	 * Destroys the GPU sampler for the given texture.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture to destroy the sampler for.
  	 */
  	destroySampler( /*texture*/ ) {}

  	/**
  	 * Creates a default texture for the given texture that can be used
  	 * as a placeholder until the actual texture is ready for usage.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture to create a default texture for.
  	 */
  	createDefaultTexture( /*texture*/ ) { }

  	/**
  	 * Defines a texture on the GPU for the given texture object.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	createTexture( /*texture, options={}*/ ) { }

  	/**
  	 * Uploads the updated texture data to the GPU.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	updateTexture( /*texture, options = {}*/ ) { }

  	/**
  	 * Generates mipmaps for the given texture.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture.
  	 */
  	generateMipmaps( /*texture*/ ) { }

  	/**
  	 * Destroys the GPU data for the given texture object.
  	 *
  	 * @abstract
  	 * @param {Texture} texture - The texture.
  	 */
  	destroyTexture( /*texture*/ ) { }

  	/**
  	 * Returns texture data as a typed array.
  	 *
  	 * @abstract
  	 * @async
  	 * @param {Texture} texture - The texture to copy.
  	 * @param {number} x - The x coordinate of the copy origin.
  	 * @param {number} y - The y coordinate of the copy origin.
  	 * @param {number} width - The width of the copy.
  	 * @param {number} height - The height of the copy.
  	 * @param {number} faceIndex - The face index.
  	 * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
  	 */
  	async copyTextureToBuffer( /*texture, x, y, width, height, faceIndex*/ ) {}

  	/**
  	 * Copies data of the given source texture to the given destination texture.
  	 *
  	 * @abstract
  	 * @param {Texture} srcTexture - The source texture.
  	 * @param {Texture} dstTexture - The destination texture.
  	 * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
  	 * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
  	 * @param {number} [srcLevel=0] - The source mip level to copy from.
  	 * @param {number} [dstLevel=0] - The destination mip level to copy to.
  	 */
  	copyTextureToTexture( /*srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0*/ ) {}

  	/**
  	* Copies the current bound framebuffer to the given texture.
  	*
  	* @abstract
  	* @param {Texture} texture - The destination texture.
  	* @param {RenderContext} renderContext - The render context.
  	* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  	*/
  	copyFramebufferToTexture( /*texture, renderContext, rectangle*/ ) {}

  	// attributes

  	/**
  	 * Creates the GPU buffer of a shader attribute.
  	 *
  	 * @abstract
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createAttribute( /*attribute*/ ) { }

  	/**
  	 * Creates the GPU buffer of an indexed shader attribute.
  	 *
  	 * @abstract
  	 * @param {BufferAttribute} attribute - The indexed buffer attribute.
  	 */
  	createIndexAttribute( /*attribute*/ ) { }

  	/**
  	 * Creates the GPU buffer of a storage attribute.
  	 *
  	 * @abstract
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createStorageAttribute( /*attribute*/ ) { }

  	/**
  	 * Updates the GPU buffer of a shader attribute.
  	 *
  	 * @abstract
  	 * @param {BufferAttribute} attribute - The buffer attribute to update.
  	 */
  	updateAttribute( /*attribute*/ ) { }

  	/**
  	 * Destroys the GPU buffer of a shader attribute.
  	 *
  	 * @abstract
  	 * @param {BufferAttribute} attribute - The buffer attribute to destroy.
  	 */
  	destroyAttribute( /*attribute*/ ) { }

  	// canvas

  	/**
  	 * Returns the backend's rendering context.
  	 *
  	 * @abstract
  	 * @return {Object} The rendering context.
  	 */
  	getContext() { }

  	/**
  	 * Backends can use this method if they have to run
  	 * logic when the renderer gets resized.
  	 *
  	 * @abstract
  	 */
  	updateSize() { }

  	/**
  	 * Updates the viewport with the values from the given render context.
  	 *
  	 * @abstract
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	updateViewport( /*renderContext*/ ) {}

  	// utils

  	/**
  	 * Returns `true` if the given 3D object is fully occluded by other
  	 * 3D objects in the scene. Backends must implement this method by using
  	 * a Occlusion Query API.
  	 *
  	 * @abstract
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object3D} object - The 3D object to test.
  	 * @return {boolean} Whether the 3D object is fully occluded or not.
  	 */
  	isOccluded( /*renderContext, object*/ ) {}

  	/**
  	 * Resolves the time stamp for the given render context and type.
  	 *
  	 * @async
  	 * @abstract
  	 * @param {string} [type='render'] - The type of the time stamp.
  	 * @return {Promise<number>} A Promise that resolves with the time stamp.
  	 */
  	async resolveTimestampsAsync( type = 'render' ) {

  		if ( ! this.trackTimestamp ) {

  			warnOnce( 'WebGPURenderer: Timestamp tracking is disabled.' );
  			return;

  		}

  		const queryPool = this.timestampQueryPool[ type ];
  		if ( ! queryPool ) {

  			warnOnce( `WebGPURenderer: No timestamp query pool for type '${type}' found.` );
  			return;

  		}

  		const duration = await queryPool.resolveQueriesAsync();

  		this.renderer.info[ type ].timestamp = duration;

  		return duration;

  	}

  	/**
  	 * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
  	 * the CPU waits for the GPU to complete its operation (e.g. a compute task).
  	 *
  	 * @async
  	 * @abstract
  	 * @return {Promise} A Promise that resolves when synchronization has been finished.
  	 */
  	async waitForGPU() {}

  	/**
  	 * This method performs a readback operation by moving buffer data from
  	 * a storage buffer attribute from the GPU to the CPU.
  	 *
  	 * @async
  	 * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
  	 * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
  	 */
  	async getArrayBufferAsync( /* attribute */ ) {}

  	/**
  	 * Checks if the given feature is supported by the backend.
  	 *
  	 * @async
  	 * @abstract
  	 * @param {string} name - The feature's name.
  	 * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
  	 */
  	async hasFeatureAsync( /*name*/ ) { }

  	/**
  	 * Checks if the given feature is supported  by the backend.
  	 *
  	 * @abstract
  	 * @param {string} name - The feature's name.
  	 * @return {boolean} Whether the feature is supported or not.
  	 */
  	hasFeature( /*name*/ ) {}

  	/**
  	 * Returns the maximum anisotropy texture filtering value.
  	 *
  	 * @abstract
  	 * @return {number} The maximum anisotropy texture filtering value.
  	 */
  	getMaxAnisotropy() {}

  	/**
  	 * Returns the drawing buffer size.
  	 *
  	 * @return {Vector2} The drawing buffer size.
  	 */
  	getDrawingBufferSize() {

  		_vector2 = _vector2 || new Vector2();

  		return this.renderer.getDrawingBufferSize( _vector2 );

  	}

  	/**
  	 * Defines the scissor test.
  	 *
  	 * @abstract
  	 * @param {boolean} boolean - Whether the scissor test should be enabled or not.
  	 */
  	setScissorTest( /*boolean*/ ) { }

  	/**
  	 * Returns the clear color and alpha into a single
  	 * color object.
  	 *
  	 * @return {Color4} The clear color.
  	 */
  	getClearColor() {

  		const renderer = this.renderer;

  		_color4 = _color4 || new Color4();

  		renderer.getClearColor( _color4 );

  		_color4.getRGB( _color4 );

  		return _color4;

  	}

  	/**
  	 * Returns the DOM element. If no DOM element exists, the backend
  	 * creates a new one.
  	 *
  	 * @return {HTMLCanvasElement} The DOM element.
  	 */
  	getDomElement() {

  		let domElement = this.domElement;

  		if ( domElement === null ) {

  			domElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();

  			// OffscreenCanvas does not have setAttribute, see #22811
  			if ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );

  			this.domElement = domElement;

  		}

  		return domElement;

  	}

  	/**
  	 * Sets a dictionary for the given object into the
  	 * internal data structure.
  	 *
  	 * @param {Object} object - The object.
  	 * @param {Object} value - The dictionary to set.
  	 */
  	set( object, value ) {

  		this.data.set( object, value );

  	}

  	/**
  	 * Returns the dictionary for the given object.
  	 *
  	 * @param {Object} object - The object.
  	 * @return {Object} The object's dictionary.
  	 */
  	get( object ) {

  		let map = this.data.get( object );

  		if ( map === undefined ) {

  			map = {};
  			this.data.set( object, map );

  		}

  		return map;

  	}

  	/**
  	 * Checks if the given object has a dictionary
  	 * with data defined.
  	 *
  	 * @param {Object} object - The object.
  	 * @return {boolean} Whether a dictionary for the given object as been defined or not.
  	 */
  	has( object ) {

  		return this.data.has( object );

  	}

  	/**
  	 * Deletes an object from the internal data structure.
  	 *
  	 * @param {Object} object - The object to delete.
  	 */
  	delete( object ) {

  		this.data.delete( object );

  	}

  	/**
  	 * Frees internal resources.
  	 *
  	 * @abstract
  	 */
  	dispose() { }

  }

  let _id$1 = 0;

  /**
   * This module is internally used in context of compute shaders.
   * This type of shader is not natively supported in WebGL 2 and
   * thus implemented via Transform Feedback. `DualAttributeData`
   * manages the related data.
   *
   * @private
   */
  class DualAttributeData {

  	constructor( attributeData, dualBuffer ) {

  		this.buffers = [ attributeData.bufferGPU, dualBuffer ];
  		this.type = attributeData.type;
  		this.bufferType = attributeData.bufferType;
  		this.pbo = attributeData.pbo;
  		this.byteLength = attributeData.byteLength;
  		this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
  		this.version = attributeData.version;
  		this.isInteger = attributeData.isInteger;
  		this.activeBufferIndex = 0;
  		this.baseId = attributeData.id;

  	}


  	get id() {

  		return `${ this.baseId }|${ this.activeBufferIndex }`;

  	}

  	get bufferGPU() {

  		return this.buffers[ this.activeBufferIndex ];

  	}

  	get transformBuffer() {

  		return this.buffers[ this.activeBufferIndex ^ 1 ];

  	}

  	switchBuffers() {

  		this.activeBufferIndex ^= 1;

  	}

  }

  /**
   * A WebGL 2 backend utility module for managing shader attributes.
   *
   * @private
   */
  class WebGLAttributeUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGLBackend} backend - The WebGL 2 backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGL 2 backend.
  		 *
  		 * @type {WebGLBackend}
  		 */
  		this.backend = backend;

  	}

  	/**
  	 * Creates the GPU buffer for the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
  	 */
  	createAttribute( attribute, bufferType ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		const array = attribute.array;
  		const usage = attribute.usage || gl.STATIC_DRAW;

  		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  		const bufferData = backend.get( bufferAttribute );

  		let bufferGPU = bufferData.bufferGPU;

  		if ( bufferGPU === undefined ) {

  			bufferGPU = this._createBuffer( gl, bufferType, array, usage );

  			bufferData.bufferGPU = bufferGPU;
  			bufferData.bufferType = bufferType;
  			bufferData.version = bufferAttribute.version;

  		}

  		//attribute.onUploadCallback();

  		let type;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {

  			type = gl.HALF_FLOAT;

  		} else if ( array instanceof Uint16Array ) {

  			if ( attribute.isFloat16BufferAttribute ) {

  				type = gl.HALF_FLOAT;

  			} else {

  				type = gl.UNSIGNED_SHORT;

  			}

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		} else if ( array instanceof Uint8ClampedArray ) {

  			type = gl.UNSIGNED_BYTE;

  		} else {

  			throw new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );

  		}

  		let attributeData = {
  			bufferGPU,
  			bufferType,
  			type,
  			byteLength: array.byteLength,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version,
  			pbo: attribute.pbo,
  			isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,
  			id: _id$1 ++
  		};

  		if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

  			// create buffer for transform feedback use
  			const bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );
  			attributeData = new DualAttributeData( attributeData, bufferGPUDual );

  		}

  		backend.set( attribute, attributeData );

  	}

  	/**
  	 * Updates the GPU buffer of the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	updateAttribute( attribute ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		const array = attribute.array;
  		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  		const bufferData = backend.get( bufferAttribute );
  		const bufferType = bufferData.bufferType;
  		const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;

  		gl.bindBuffer( bufferType, bufferData.bufferGPU );

  		if ( updateRanges.length === 0 ) {

  			// Not using update ranges

  			gl.bufferSubData( bufferType, 0, array );

  		} else {

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];
  				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
  					array, range.start, range.count );

  			}

  			bufferAttribute.clearUpdateRanges();

  		}

  		gl.bindBuffer( bufferType, null );

  		bufferData.version = bufferAttribute.version;

  	}

  	/**
  	 * Destroys the GPU buffer of the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	destroyAttribute( attribute ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		if ( attribute.isInterleavedBufferAttribute ) {

  			backend.delete( attribute.data );

  		}

  		const attributeData = backend.get( attribute );

  		gl.deleteBuffer( attributeData.bufferGPU );

  		backend.delete( attribute );

  	}

  	/**
  	 * This method performs a readback operation by moving buffer data from
  	 * a storage buffer attribute from the GPU to the CPU.
  	 *
  	 * @async
  	 * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
  	 * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
  	 */
  	async getArrayBufferAsync( attribute ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  		const { bufferGPU } = backend.get( bufferAttribute );

  		const array = attribute.array;
  		const byteLength = array.byteLength;

  		gl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );

  		const writeBuffer = gl.createBuffer();

  		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );
  		gl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );

  		gl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );

  		await backend.utils._clientWaitAsync();

  		const dstBuffer = new attribute.array.constructor( array.length );

  		// Ensure the buffer is bound before reading
  		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );

  		gl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );

  		gl.deleteBuffer( writeBuffer );

  		gl.bindBuffer( gl.COPY_READ_BUFFER, null );
  		gl.bindBuffer( gl.COPY_WRITE_BUFFER, null );

  		return dstBuffer.buffer;

  	}

  	/**
  	 * Creates a WebGL buffer with the given data.
  	 *
  	 * @private
  	 * @param {WebGL2RenderingContext} gl - The rendering context.
  	 * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
  	 * @param {TypedArray} array - The array of the buffer attribute.
  	 * @param {GLenum} usage - The usage.
  	 * @return {WebGLBuffer} The WebGL buffer.
  	 */
  	_createBuffer( gl, bufferType, array, usage ) {

  		const bufferGPU = gl.createBuffer();

  		gl.bindBuffer( bufferType, bufferGPU );
  		gl.bufferData( bufferType, array, usage );
  		gl.bindBuffer( bufferType, null );

  		return bufferGPU;

  	}

  }

  let equationToGL, factorToGL;

  /**
   * A WebGL 2 backend utility module for managing the WebGL state.
   *
   * The major goal of this module is to reduce the number of state changes
   * by caching the WEbGL state with a series of variables. In this way, the
   * renderer only executes state change commands when necessary which
   * improves the overall performance.
   *
   * @private
   */
  class WebGLState {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGLBackend} backend - The WebGL 2 backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGL 2 backend.
  		 *
  		 * @type {WebGLBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A reference to the rendering context.
  		 *
  		 * @type {WebGL2RenderingContext}
  		 */
  		this.gl = this.backend.gl;

  		// Below properties are intended to cache
  		// the WebGL state and are not explicitly
  		// documented for convenience reasons.

  		this.enabled = {};
  		this.currentFlipSided = null;
  		this.currentCullFace = null;
  		this.currentProgram = null;
  		this.currentBlendingEnabled = false;
  		this.currentBlending = null;
  		this.currentBlendSrc = null;
  		this.currentBlendDst = null;
  		this.currentBlendSrcAlpha = null;
  		this.currentBlendDstAlpha = null;
  		this.currentPremultipledAlpha = null;
  		this.currentPolygonOffsetFactor = null;
  		this.currentPolygonOffsetUnits = null;
  		this.currentColorMask = null;
  		this.currentDepthFunc = null;
  		this.currentDepthMask = null;
  		this.currentStencilFunc = null;
  		this.currentStencilRef = null;
  		this.currentStencilFuncMask = null;
  		this.currentStencilFail = null;
  		this.currentStencilZFail = null;
  		this.currentStencilZPass = null;
  		this.currentStencilMask = null;
  		this.currentLineWidth = null;
  		this.currentClippingPlanes = 0;

  		this.currentVAO = null;
  		this.currentIndex = null;

  		this.currentBoundFramebuffers = {};
  		this.currentDrawbuffers = new WeakMap();

  		this.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );
  		this.currentTextureSlot = null;
  		this.currentBoundTextures = {};
  		this.currentBoundBufferBases = {};


  		this._init();

  	}

  	/**
  	 * Inits the state of the utility.
  	 *
  	 * @private
  	 */
  	_init() {

  		const gl = this.gl;

  		// Store only WebGL constants here.

  		equationToGL = {
  			[ AddEquation ]: gl.FUNC_ADD,
  			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
  			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
  		};

  		factorToGL = {
  			[ ZeroFactor ]: gl.ZERO,
  			[ OneFactor ]: gl.ONE,
  			[ SrcColorFactor ]: gl.SRC_COLOR,
  			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
  			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
  			[ DstColorFactor ]: gl.DST_COLOR,
  			[ DstAlphaFactor ]: gl.DST_ALPHA,
  			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
  			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
  			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
  			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
  		};

  		const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
  		const viewportParam = gl.getParameter( gl.VIEWPORT );

  		this.currentScissor = new Vector4().fromArray( scissorParam );
  		this.currentViewport = new Vector4().fromArray( viewportParam );

  		this._tempVec4 = new Vector4();

  	}

  	/**
  	 * Enables the given WebGL capability.
  	 *
  	 * This method caches the capability state so
  	 * `gl.enable()` is only called when necessary.
  	 *
  	 * @param {GLenum} id - The capability to enable.
  	 */
  	enable( id ) {

  		const { enabled } = this;

  		if ( enabled[ id ] !== true ) {

  			this.gl.enable( id );
  			enabled[ id ] = true;

  		}

  	}

  	/**
  	 * Disables the given WebGL capability.
  	 *
  	 * This method caches the capability state so
  	 * `gl.disable()` is only called when necessary.
  	 *
  	 * @param {GLenum} id - The capability to enable.
  	 */
  	disable( id ) {

  		const { enabled } = this;

  		if ( enabled[ id ] !== false ) {

  			this.gl.disable( id );
  			enabled[ id ] = false;

  		}

  	}

  	/**
  	 * Specifies whether polygons are front- or back-facing
  	 * by setting the winding orientation.
  	 *
  	 * This method caches the state so `gl.frontFace()` is only
  	 * called when necessary.
  	 *
  	 * @param {boolean} flipSided - Whether triangles flipped their sides or not.
  	 */
  	setFlipSided( flipSided ) {

  		if ( this.currentFlipSided !== flipSided ) {

  			const { gl } = this;

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			this.currentFlipSided = flipSided;

  		}

  	}

  	/**
  	 * Specifies whether or not front- and/or back-facing
  	 * polygons can be culled.
  	 *
  	 * This method caches the state so `gl.cullFace()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} cullFace - Defines which polygons are candidates for culling.
  	 */
  	setCullFace( cullFace ) {

  		const { gl } = this;

  		if ( cullFace !== CullFaceNone ) {

  			this.enable( gl.CULL_FACE );

  			if ( cullFace !== this.currentCullFace ) {

  				if ( cullFace === CullFaceBack ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			this.disable( gl.CULL_FACE );

  		}

  		this.currentCullFace = cullFace;

  	}

  	/**
  	 * Specifies the width of line primitives.
  	 *
  	 * This method caches the state so `gl.lineWidth()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} width - The line width.
  	 */
  	setLineWidth( width ) {

  		const { currentLineWidth, gl } = this;

  		if ( width !== currentLineWidth ) {

  			gl.lineWidth( width );

  			this.currentLineWidth = width;

  		}

  	}

  	/**
  	 * Defines the blending.
  	 *
  	 * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
  	 * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
  	 *
  	 * @param {number} blending - The blending type.
  	 * @param {number} blendEquation - The blending equation.
  	 * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
  	 * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
  	 * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
  	 * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
  	 * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
  	 * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
  	 */
  	setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  		const { gl } = this;

  		if ( blending === NoBlending ) {

  			if ( this.currentBlendingEnabled === true ) {

  				this.disable( gl.BLEND );
  				this.currentBlendingEnabled = false;

  			}

  			return;

  		}

  		if ( this.currentBlendingEnabled === false ) {

  			this.enable( gl.BLEND );
  			this.currentBlendingEnabled = true;

  		}

  		if ( blending !== CustomBlending ) {

  			if ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {

  				if ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {

  					gl.blendEquation( gl.FUNC_ADD );

  					this.currentBlendEquation = AddEquation;
  					this.currentBlendEquationAlpha = AddEquation;

  				}

  				if ( premultipliedAlpha ) {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
  							break;

  						case MultiplyBlending:
  							gl.blendFuncSeparate( gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				} else {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							console.error( 'THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true' );
  							break;

  						case MultiplyBlending:
  							console.error( 'THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true' );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				}

  				this.currentBlendSrc = null;
  				this.currentBlendDst = null;
  				this.currentBlendSrcAlpha = null;
  				this.currentBlendDstAlpha = null;

  				this.currentBlending = blending;
  				this.currentPremultipledAlpha = premultipliedAlpha;

  			}

  			return;

  		}

  		// custom blending

  		blendEquationAlpha = blendEquationAlpha || blendEquation;
  		blendSrcAlpha = blendSrcAlpha || blendSrc;
  		blendDstAlpha = blendDstAlpha || blendDst;

  		if ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {

  			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

  			this.currentBlendEquation = blendEquation;
  			this.currentBlendEquationAlpha = blendEquationAlpha;

  		}

  		if ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {

  			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

  			this.currentBlendSrc = blendSrc;
  			this.currentBlendDst = blendDst;
  			this.currentBlendSrcAlpha = blendSrcAlpha;
  			this.currentBlendDstAlpha = blendDstAlpha;

  		}

  		this.currentBlending = blending;
  		this.currentPremultipledAlpha = false;

  	}

  	/**
  	 * Specifies whether colors can be written when rendering
  	 * into a framebuffer or not.
  	 *
  	 * This method caches the state so `gl.colorMask()` is only
  	 * called when necessary.
  	 *
  	 * @param {boolean} colorMask - The color mask.
  	 */
  	setColorMask( colorMask ) {

  		if ( this.currentColorMask !== colorMask ) {

  			this.gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  			this.currentColorMask = colorMask;

  		}

  	}

  	/**
  	 * Specifies whether the depth test is enabled or not.
  	 *
  	 * @param {boolean} depthTest - Whether the depth test is enabled or not.
  	 */
  	setDepthTest( depthTest ) {

  		const { gl } = this;

  		if ( depthTest ) {

  			this.enable( gl.DEPTH_TEST );

  		} else {

  			this.disable( gl.DEPTH_TEST );

  		}

  	}

  	/**
  	 * Specifies whether depth values can be written when rendering
  	 * into a framebuffer or not.
  	 *
  	 * This method caches the state so `gl.depthMask()` is only
  	 * called when necessary.
  	 *
  	 * @param {boolean} depthMask - The depth mask.
  	 */
  	setDepthMask( depthMask ) {

  		if ( this.currentDepthMask !== depthMask ) {

  			this.gl.depthMask( depthMask );
  			this.currentDepthMask = depthMask;

  		}

  	}

  	/**
  	 * Specifies the depth compare function.
  	 *
  	 * This method caches the state so `gl.depthFunc()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} depthFunc - The depth compare function.
  	 */
  	setDepthFunc( depthFunc ) {

  		if ( this.currentDepthFunc !== depthFunc ) {

  			const { gl } = this;

  			switch ( depthFunc ) {

  				case NeverDepth:

  					gl.depthFunc( gl.NEVER );
  					break;

  				case AlwaysDepth:

  					gl.depthFunc( gl.ALWAYS );
  					break;

  				case LessDepth:

  					gl.depthFunc( gl.LESS );
  					break;

  				case LessEqualDepth:

  					gl.depthFunc( gl.LEQUAL );
  					break;

  				case EqualDepth:

  					gl.depthFunc( gl.EQUAL );
  					break;

  				case GreaterEqualDepth:

  					gl.depthFunc( gl.GEQUAL );
  					break;

  				case GreaterDepth:

  					gl.depthFunc( gl.GREATER );
  					break;

  				case NotEqualDepth:

  					gl.depthFunc( gl.NOTEQUAL );
  					break;

  				default:

  					gl.depthFunc( gl.LEQUAL );

  			}

  			this.currentDepthFunc = depthFunc;

  		}

  	}

  	/**
  	 * Specifies the scissor box.
  	 *
  	 * @param {number} x - The x-coordinate of the lower left corner of the viewport.
  	 * @param {number} y - The y-coordinate of the lower left corner of the viewport.
  	 * @param {number} width - The width of the viewport.
  	 * @param {number} height - The height of the viewport.
  	 *
  	 */
  	scissor( x, y, width, height ) {

  		const scissor = this._tempVec4.set( x, y, width, height );

  		if ( this.currentScissor.equals( scissor ) === false ) {

  			const { gl } = this;

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			this.currentScissor.copy( scissor );

  		}

  	}

  	/**
  	 * Specifies the viewport.
  	 *
  	 * @param {number} x - The x-coordinate of the lower left corner of the viewport.
  	 * @param {number} y - The y-coordinate of the lower left corner of the viewport.
  	 * @param {number} width - The width of the viewport.
  	 * @param {number} height - The height of the viewport.
  	 *
  	 */
  	viewport( x, y, width, height ) {

  		const viewport = this._tempVec4.set( x, y, width, height );

  		if ( this.currentViewport.equals( viewport ) === false ) {

  			const { gl } = this;

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			this.currentViewport.copy( viewport );

  		}

  	}

  	/**
  	 * Defines the scissor test.
  	 *
  	 * @param {boolean} boolean - Whether the scissor test should be enabled or not.
  	 */
  	setScissorTest( boolean ) {

  		const gl = this.gl;

  		if ( boolean ) {

  			gl.enable( gl.SCISSOR_TEST );

  		} else {

  			gl.disable( gl.SCISSOR_TEST );

  		}

  	}

  	/**
  	 * Specifies whether the stencil test is enabled or not.
  	 *
  	 * @param {boolean} stencilTest - Whether the stencil test is enabled or not.
  	 */
  	setStencilTest( stencilTest ) {

  		const { gl } = this;

  		if ( stencilTest ) {

  			this.enable( gl.STENCIL_TEST );

  		} else {

  			this.disable( gl.STENCIL_TEST );

  		}

  	}

  	/**
  	 * Specifies whether stencil values can be written when rendering
  	 * into a framebuffer or not.
  	 *
  	 * This method caches the state so `gl.stencilMask()` is only
  	 * called when necessary.
  	 *
  	 * @param {boolean} stencilMask - The stencil mask.
  	 */
  	setStencilMask( stencilMask ) {

  		if ( this.currentStencilMask !== stencilMask ) {

  			this.gl.stencilMask( stencilMask );
  			this.currentStencilMask = stencilMask;

  		}

  	}

  	/**
  	 * Specifies whether the stencil test functions.
  	 *
  	 * This method caches the state so `gl.stencilFunc()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} stencilFunc - The stencil compare function.
  	 * @param {number} stencilRef - The reference value for the stencil test.
  	 * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
  	 */
  	setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

  		if ( this.currentStencilFunc !== stencilFunc ||
  			 this.currentStencilRef !== stencilRef ||
  			 this.currentStencilFuncMask !== stencilMask ) {

  			this.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  			this.currentStencilFunc = stencilFunc;
  			this.currentStencilRef = stencilRef;
  			this.currentStencilFuncMask = stencilMask;

  		}

  	}

  	/**
  	 * Specifies whether the stencil test operation.
  	 *
  	 * This method caches the state so `gl.stencilOp()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} stencilFail - The function to use when the stencil test fails.
  	 * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
  	 * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
  	 * or when the stencil test passes and there is no depth buffer or depth testing is disabled.
  	 */
  	setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

  		if ( this.currentStencilFail !== stencilFail ||
  			 this.currentStencilZFail !== stencilZFail ||
  			 this.currentStencilZPass !== stencilZPass ) {

  			this.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  			this.currentStencilFail = stencilFail;
  			this.currentStencilZFail = stencilZFail;
  			this.currentStencilZPass = stencilZPass;

  		}

  	}

  	/**
  	 * Configures the WebGL state for the given material.
  	 *
  	 * @param {Material} material - The material to configure the state for.
  	 * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
  	 * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
  	 */
  	setMaterial( material, frontFaceCW, hardwareClippingPlanes ) {

  		const { gl } = this;

  		material.side === DoubleSide
  			? this.disable( gl.CULL_FACE )
  			: this.enable( gl.CULL_FACE );

  		let flipSided = ( material.side === BackSide );
  		if ( frontFaceCW ) flipSided = ! flipSided;

  		this.setFlipSided( flipSided );

  		( material.blending === NormalBlending && material.transparent === false )
  			? this.setBlending( NoBlending )
  			: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

  		this.setDepthFunc( material.depthFunc );
  		this.setDepthTest( material.depthTest );
  		this.setDepthMask( material.depthWrite );
  		this.setColorMask( material.colorWrite );

  		const stencilWrite = material.stencilWrite;
  		this.setStencilTest( stencilWrite );
  		if ( stencilWrite ) {

  			this.setStencilMask( material.stencilWriteMask );
  			this.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
  			this.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

  		}

  		this.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  		material.alphaToCoverage === true && this.backend.renderer.samples > 1
  			? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
  			: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

  		if ( hardwareClippingPlanes > 0 ) {

  			if ( this.currentClippingPlanes !== hardwareClippingPlanes ) {

  				const CLIP_DISTANCE0_WEBGL = 0x3000;

  				for ( let i = 0; i < 8; i ++ ) {

  					if ( i < hardwareClippingPlanes ) {

  						this.enable( CLIP_DISTANCE0_WEBGL + i );

  					} else {

  						this.disable( CLIP_DISTANCE0_WEBGL + i );

  					}

  				}

  			}

  		}

  	}

  	/**
  	 * Specifies the polygon offset.
  	 *
  	 * This method caches the state so `gl.polygonOffset()` is only
  	 * called when necessary.
  	 *
  	 * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
  	 * @param {number} factor - The scale factor for the variable depth offset for each polygon.
  	 * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
  	 */
  	setPolygonOffset( polygonOffset, factor, units ) {

  		const { gl } = this;

  		if ( polygonOffset ) {

  			this.enable( gl.POLYGON_OFFSET_FILL );

  			if ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				this.currentPolygonOffsetFactor = factor;
  				this.currentPolygonOffsetUnits = units;

  			}

  		} else {

  			this.disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	/**
  	 * Defines the usage of the given WebGL program.
  	 *
  	 * This method caches the state so `gl.useProgram()` is only
  	 * called when necessary.
  	 *
  	 * @param {WebGLProgram} program - The WebGL program to use.
  	 * @return {boolean} Whether a program change has been executed or not.
  	 */
  	useProgram( program ) {

  		if ( this.currentProgram !== program ) {

  			this.gl.useProgram( program );

  			this.currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	/**
  	 * Sets the vertex state by binding the given VAO and element buffer.
  	 *
  	 * @param {WebGLVertexArrayObject} vao - The VAO.
  	 * @param {WebGLBuffer} indexBuffer - The index buffer.
  	 * @return {boolean} Whether a vertex state has been changed or not.
  	 */
  	setVertexState( vao, indexBuffer = null ) {

  		const gl = this.gl;

  		if ( this.currentVAO !== vao || this.currentIndex !== indexBuffer ) {

  			gl.bindVertexArray( vao );

  			if ( indexBuffer !== null ) {

  				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexBuffer );

  			}

  			this.currentVAO = vao;
  			this.currentIndex = indexBuffer;

  			return true;

  		}

  		return false;

  	}

  	/**
  	 * Resets the vertex array state by resetting the VAO and element buffer.
  	 */
  	resetVertexState() {

  		const gl = this.gl;

  		gl.bindVertexArray( null );
  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );

  		this.currentVAO = null;
  		this.currentIndex = null;

  	}

  	// framebuffer


  	/**
  	 * Binds the given framebuffer.
  	 *
  	 * This method caches the state so `gl.bindFramebuffer()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} target - The binding point (target).
  	 * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
  	 * @return {boolean} Whether a bind has been executed or not.
  	 */
  	bindFramebuffer( target, framebuffer ) {

  		const { gl, currentBoundFramebuffers } = this;

  		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

  			gl.bindFramebuffer( target, framebuffer );

  			currentBoundFramebuffers[ target ] = framebuffer;

  			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

  			if ( target === gl.DRAW_FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

  			}

  			if ( target === gl.FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

  			}

  			return true;

  		}

  		return false;

  	}

  	/**
  	 * Defines draw buffers to which fragment colors are written into.
  	 * Configures the MRT setup of custom framebuffers.
  	 *
  	 * This method caches the state so `gl.drawBuffers()` is only
  	 * called when necessary.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
  	 */
  	drawBuffers( renderContext, framebuffer ) {

  		const { gl } = this;

  		let drawBuffers = [];

  		let needsUpdate = false;

  		if ( renderContext.textures !== null ) {

  			drawBuffers = this.currentDrawbuffers.get( framebuffer );

  			if ( drawBuffers === undefined ) {

  				drawBuffers = [];
  				this.currentDrawbuffers.set( framebuffer, drawBuffers );

  			}


  			const textures = renderContext.textures;

  			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

  				for ( let i = 0, il = textures.length; i < il; i ++ ) {

  					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

  				}

  				drawBuffers.length = textures.length;

  				needsUpdate = true;

  			}


  		} else {

  			if ( drawBuffers[ 0 ] !== gl.BACK ) {

  				drawBuffers[ 0 ] = gl.BACK;

  				needsUpdate = true;

  			}

  		}

  		if ( needsUpdate ) {

  			gl.drawBuffers( drawBuffers );

  		}

  	}


  	// texture

  	/**
  	 * Makes the given texture unit active.
  	 *
  	 * This method caches the state so `gl.activeTexture()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} webglSlot - The texture unit to make active.
  	 */
  	activeTexture( webglSlot ) {

  		const { gl, currentTextureSlot, maxTextures } = this;

  		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			this.currentTextureSlot = webglSlot;

  		}

  	}

  	/**
  	 * Binds the given WebGL texture to a target.
  	 *
  	 * This method caches the state so `gl.bindTexture()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} webglType - The binding point (target).
  	 * @param {WebGLTexture} webglTexture - The WebGL texture to bind.
  	 * @param {number} webglSlot - The texture.
  	 */
  	bindTexture( webglType, webglTexture, webglSlot ) {

  		const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;

  		if ( webglSlot === undefined ) {

  			if ( currentTextureSlot === null ) {

  				webglSlot = gl.TEXTURE0 + maxTextures - 1;

  			} else {

  				webglSlot = currentTextureSlot;

  			}

  		}

  		let boundTexture = currentBoundTextures[ webglSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ webglSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			if ( currentTextureSlot !== webglSlot ) {

  				gl.activeTexture( webglSlot );
  				this.currentTextureSlot = webglSlot;

  			}

  			gl.bindTexture( webglType, webglTexture );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	/**
  	 * Binds a given WebGL buffer to a given binding point (target) at a given index.
  	 *
  	 * This method caches the state so `gl.bindBufferBase()` is only
  	 * called when necessary.
  	 *
  	 * @param {number} target - The target for the bind operation.
  	 * @param {number} index - The index of the target.
  	 * @param {WebGLBuffer} buffer - The WebGL buffer.
  	 * @return {boolean} Whether a bind has been executed or not.
  	 */
  	bindBufferBase( target, index, buffer ) {

  		const { gl } = this;

  		const key = `${target}-${index}`;

  		if ( this.currentBoundBufferBases[ key ] !== buffer ) {

  			gl.bindBufferBase( target, index, buffer );
  			this.currentBoundBufferBases[ key ] = buffer;

  			return true;

  		}

  		return false;

  	}


  	/**
  	 * Unbinds the current bound texture.
  	 *
  	 * This method caches the state so `gl.bindTexture()` is only
  	 * called when necessary.
  	 */
  	unbindTexture() {

  		const { gl, currentTextureSlot, currentBoundTextures } = this;

  		const boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

  			gl.bindTexture( boundTexture.type, null );

  			boundTexture.type = undefined;
  			boundTexture.texture = undefined;

  		}

  	}

  }

  /**
   * A WebGL 2 backend utility module with common helpers.
   *
   * @private
   */
  class WebGLUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGLBackend} backend - The WebGL 2 backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGL 2 backend.
  		 *
  		 * @type {WebGLBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A reference to the rendering context.
  		 *
  		 * @type {WebGL2RenderingContext}
  		 */
  		this.gl = this.backend.gl;

  		/**
  		 * A reference to a backend module holding extension-related
  		 * utility functions.
  		 *
  		 * @type {WebGLExtensions}
  		 */
  		this.extensions = backend.extensions;

  	}

  	/**
  	 * Converts the given three.js constant into a WebGL constant.
  	 * The method currently supports the conversion of texture formats
  	 * and types.
  	 *
  	 * @param {number} p - The three.js constant.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space.
  	 * @return {?number} The corresponding WebGL constant.
  	 */
  	convert( p, colorSpace = NoColorSpace ) {

  		const { gl, extensions } = this;

  		let extension;

  		const transfer = ColorManagement.getTransfer( colorSpace );

  		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
  		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
  		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
  		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

  		if ( p === ByteType ) return gl.BYTE;
  		if ( p === ShortType ) return gl.SHORT;
  		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
  		if ( p === IntType ) return gl.INT;
  		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
  		if ( p === FloatType ) return gl.FLOAT;

  		if ( p === HalfFloatType ) {

  			return gl.HALF_FLOAT;

  		}

  		if ( p === AlphaFormat ) return gl.ALPHA;
  		if ( p === RGBFormat ) return gl.RGB;
  		if ( p === RGBAFormat ) return gl.RGBA;
  		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
  		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

  		// WebGL2 formats.

  		if ( p === RedFormat ) return gl.RED;
  		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
  		if ( p === RGFormat ) return gl.RG;
  		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
  		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

  		// S3TC

  		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  			if ( transfer === SRGBTransfer ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			} else {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			}

  		}

  		// PVRTC

  		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  			} else {

  				return null;

  			}

  		}

  		// ETC

  		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

  			if ( extension !== null ) {

  				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
  				if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

  			} else {

  				return null;

  			}

  		}

  		// ASTC

  		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
  				if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
  				if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
  				if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
  				if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
  				if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
  				if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
  				if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
  				if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
  				if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
  				if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
  				if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
  				if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
  				if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

  			} else {

  				return null;

  			}

  		}

  		// BPTC

  		if ( p === RGBA_BPTC_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_bptc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

  			} else {

  				return null;

  			}

  		}

  		// RGTC

  		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_rgtc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
  				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
  				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
  				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

  			} else {

  				return null;

  			}

  		}

  		//

  		if ( p === UnsignedInt248Type ) {

  			return gl.UNSIGNED_INT_24_8;

  		}

  		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

  		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

  	}

  	/**
  	 * This method can be used to synchronize the CPU with the GPU by waiting until
  	 * ongoing GPU commands have been completed.
  	 *
  	 * @private
  	 * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
  	 */
  	_clientWaitAsync() {

  		const { gl } = this;

  		const sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

  		gl.flush();

  		return new Promise( ( resolve, reject ) => {

  			function test() {

  				const res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );

  				if ( res === gl.WAIT_FAILED ) {

  					gl.deleteSync( sync );

  					reject();
  					return;

  				}

  				if ( res === gl.TIMEOUT_EXPIRED ) {

  					requestAnimationFrame( test );
  					return;

  				}

  				gl.deleteSync( sync );

  				resolve();

  			}

  			test();

  		} );

  	}

  }

  let initialized = false, wrappingToGL, filterToGL, compareToGL;

  /**
   * A WebGL 2 backend utility module for managing textures.
   *
   * @private
   */
  class WebGLTextureUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGLBackend} backend - The WebGL 2 backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGL 2 backend.
  		 *
  		 * @type {WebGLBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A reference to the rendering context.
  		 *
  		 * @type {WebGL2RenderingContext}
  		 */
  		this.gl = backend.gl;

  		/**
  		 * A reference to a backend module holding extension-related
  		 * utility functions.
  		 *
  		 * @type {WebGLExtensions}
  		 */
  		this.extensions = backend.extensions;

  		/**
  		 * A dictionary for managing default textures. The key
  		 * is the binding point (target), the value the WEbGL texture object.
  		 *
  		 * @type {Object<GLenum,WebGLTexture>}
  		 */
  		this.defaultTextures = {};

  		if ( initialized === false ) {

  			this._init();

  			initialized = true;

  		}

  	}

  	/**
  	 * Inits the state of the utility.
  	 *
  	 * @private
  	 */
  	_init() {

  		const gl = this.gl;

  		// Store only WebGL constants here.

  		wrappingToGL = {
  			[ RepeatWrapping ]: gl.REPEAT,
  			[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,
  			[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT
  		};

  		filterToGL = {
  			[ NearestFilter ]: gl.NEAREST,
  			[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,
  			[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,

  			[ LinearFilter ]: gl.LINEAR,
  			[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,
  			[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR
  		};

  		compareToGL = {
  			[ NeverCompare ]: gl.NEVER,
  			[ AlwaysCompare ]: gl.ALWAYS,
  			[ LessCompare ]: gl.LESS,
  			[ LessEqualCompare ]: gl.LEQUAL,
  			[ EqualCompare ]: gl.EQUAL,
  			[ GreaterEqualCompare ]: gl.GEQUAL,
  			[ GreaterCompare ]: gl.GREATER,
  			[ NotEqualCompare ]: gl.NOTEQUAL
  		};

  	}

  	/**
  	 * Returns the native texture type for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {GLenum} The native texture type.
  	 */
  	getGLTextureType( texture ) {

  		const { gl } = this;

  		let glTextureType;

  		if ( texture.isCubeTexture === true ) {

  			glTextureType = gl.TEXTURE_CUBE_MAP;

  		} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

  			glTextureType = gl.TEXTURE_2D_ARRAY;

  		} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642

  			glTextureType = gl.TEXTURE_3D;

  		} else {

  			glTextureType = gl.TEXTURE_2D;


  		}

  		return glTextureType;

  	}

  	/**
  	 * Returns the native texture type for the given texture.
  	 *
  	 * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
  	 * @param {GLenum} glFormat - The WebGL format.
  	 * @param {GLenum} glType - The WebGL type.
  	 * @param {string} colorSpace - The texture's color space.
  	 * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
  	 * @return {GLenum} The internal format.
  	 */
  	getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

  		const { gl, extensions } = this;

  		if ( internalFormatName !== null ) {

  			if ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];

  			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

  		}

  		let internalFormat = glFormat;

  		if ( glFormat === gl.RED ) {

  			if ( glType === gl.FLOAT ) internalFormat = gl.R32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
  			if ( glType === gl.INT ) internalFormat = gl.R32I;

  		}

  		if ( glFormat === gl.RED_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
  			if ( glType === gl.INT ) internalFormat = gl.R32I;

  		}

  		if ( glFormat === gl.RG ) {

  			if ( glType === gl.FLOAT ) internalFormat = gl.RG32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
  			if ( glType === gl.INT ) internalFormat = gl.RG32I;

  		}

  		if ( glFormat === gl.RG_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
  			if ( glType === gl.INT ) internalFormat = gl.RG32I;

  		}

  		if ( glFormat === gl.RGB ) {

  			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

  			if ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGB32I;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? gl.SRGB8 : gl.RGB8;
  			if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;
  			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;
  			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;
  			if ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;

  		}

  		if ( glFormat === gl.RGB_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGB32I;

  		}

  		if ( glFormat === gl.RGBA ) {

  			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

  			if ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;
  			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;
  			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;

  		}

  		if ( glFormat === gl.RGBA_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;

  		}

  		if ( glFormat === gl.DEPTH_COMPONENT ) {

  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.DEPTH_COMPONENT16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH_COMPONENT24;
  			if ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;

  		}

  		if ( glFormat === gl.DEPTH_STENCIL ) {

  			if ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;

  		}

  		if ( internalFormat === gl.R16F || internalFormat === gl.R32F ||
  			internalFormat === gl.RG16F || internalFormat === gl.RG32F ||
  			internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {

  			extensions.get( 'EXT_color_buffer_float' );

  		}

  		return internalFormat;

  	}

  	/**
  	 * Sets the texture parameters for the given texture.
  	 *
  	 * @param {GLenum} textureType - The texture type.
  	 * @param {Texture} texture - The texture.
  	 */
  	setTextureParameters( textureType, texture ) {

  		const { gl, extensions, backend } = this;

  		const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
  		const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
  		const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? gl.NONE : gl.BROWSER_DEFAULT_WEBGL;

  		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  		gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
  		gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

  		gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
  		gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

  		if ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {

  			// WebGL 2 does not support wrapping for depth 2D array textures
  			if ( ! texture.isArrayTexture ) {

  				gl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

  			}

  		}

  		gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );


  		const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;

  		// follow WebGPU backend mapping for texture filtering
  		const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;

  		gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );

  		if ( texture.compareFunction ) {

  			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );
  			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

  		}

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			if ( texture.magFilter === NearestFilter ) return;
  			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
  			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2

  			if ( texture.anisotropy > 1 ) {

  				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
  				gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );

  			}

  		}

  	}

  	/**
  	 * Creates a default texture for the given texture that can be used
  	 * as a placeholder until the actual texture is ready for usage.
  	 *
  	 * @param {Texture} texture - The texture to create a default texture for.
  	 */
  	createDefaultTexture( texture ) {

  		const { gl, backend, defaultTextures } = this;


  		const glTextureType = this.getGLTextureType( texture );

  		let textureGPU = defaultTextures[ glTextureType ];

  		if ( textureGPU === undefined ) {

  			textureGPU = gl.createTexture();

  			backend.state.bindTexture( glTextureType, textureGPU );
  			gl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  			gl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  			// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  			defaultTextures[ glTextureType ] = textureGPU;

  		}

  		backend.set( texture, {
  			textureGPU,
  			glTextureType,
  			isDefault: true
  		} );

  	}

  	/**
  	 * Defines a texture on the GPU for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 * @return {undefined}
  	 */
  	createTexture( texture, options ) {

  		const { gl, backend } = this;
  		const { levels, width, height, depth } = options;

  		const glFormat = backend.utils.convert( texture.format, texture.colorSpace );
  		const glType = backend.utils.convert( texture.type );
  		const glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

  		const textureGPU = gl.createTexture();
  		const glTextureType = this.getGLTextureType( texture );

  		backend.state.bindTexture( glTextureType, textureGPU );

  		this.setTextureParameters( glTextureType, texture );

  		if ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

  			gl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );

  		} else if ( texture.isData3DTexture ) {

  			gl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );

  		} else if ( ! texture.isVideoTexture ) {

  			gl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );

  		}

  		backend.set( texture, {
  			textureGPU,
  			glTextureType,
  			glFormat,
  			glType,
  			glInternalFormat
  		} );

  	}

  	/**
  	 * Uploads texture buffer data to the GPU memory.
  	 *
  	 * @param {WebGLBuffer} buffer - The buffer data.
  	 * @param {Texture} texture - The texture,
  	 */
  	copyBufferToTexture( buffer, texture ) {

  		const { gl, backend } = this;

  		const { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );

  		const { width, height } = texture.source.data;

  		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );

  		backend.state.bindTexture( glTextureType, textureGPU );

  		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
  		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
  		gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );

  		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );

  		backend.state.unbindTexture();
  		// debug
  		// const framebuffer = gl.createFramebuffer();
  		// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
  		// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );

  		// const readout = new Float32Array( width * height * 4 );

  		// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
  		// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );

  		// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
  		// gl.bindFramebuffer( gl.FRAMEBUFFER, null );
  		// console.log( readout );

  	}

  	/**
  	 * Uploads the updated texture data to the GPU.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	updateTexture( texture, options ) {

  		const { gl } = this;
  		const { width, height } = options;
  		const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );

  		if ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )
  			return;

  		this.backend.state.bindTexture( glTextureType, textureGPU );

  		this.setTextureParameters( glTextureType, texture );

  		if ( texture.isCompressedTexture ) {

  			const mipmaps = texture.mipmaps;
  			const image = options.image;

  			for ( let i = 0; i < mipmaps.length; i ++ ) {

  				const mipmap = mipmaps[ i ];

  				if ( texture.isCompressedArrayTexture ) {


  					if ( texture.format !== gl.RGBA ) {

  						if ( glFormat !== null ) {

  							gl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

  						} else {

  							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  						}

  					} else {

  						gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

  					}

  				} else {

  					if ( glFormat !== null ) {

  						gl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

  					} else {

  						console.warn( 'Unsupported compressed texture format' );

  					}

  				}

  			}


  		} else if ( texture.isCubeTexture ) {

  			const images = options.images;

  			for ( let i = 0; i < 6; i ++ ) {

  				const image = getImage( images[ i ] );

  				gl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );

  			}

  		} else if ( texture.isDataArrayTexture || texture.isArrayTexture ) {

  			const image = options.image;

  			gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  		} else if ( texture.isData3DTexture ) {

  			const image = options.image;

  			gl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  		} else if ( texture.isVideoTexture ) {

  			texture.update();

  			gl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );


  		} else {

  			const image = getImage( options.image );

  			gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );

  		}

  	}

  	/**
  	 * Generates mipmaps for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	generateMipmaps( texture ) {

  		const { gl, backend } = this;
  		const { textureGPU, glTextureType } = backend.get( texture );

  		backend.state.bindTexture( glTextureType, textureGPU );
  		gl.generateMipmap( glTextureType );

  	}

  	/**
  	 * Deallocates the render buffers of the given render target.
  	 *
  	 * @param {RenderTarget} renderTarget - The render target.
  	 */
  	deallocateRenderBuffers( renderTarget ) {

  		const { gl, backend } = this;

  		// remove framebuffer reference
  		if ( renderTarget ) {

  			const renderContextData = backend.get( renderTarget );

  			renderContextData.renderBufferStorageSetup = undefined;

  			if ( renderContextData.framebuffers ) {

  				for ( const cacheKey in renderContextData.framebuffers ) {

  					gl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );

  				}

  				delete renderContextData.framebuffers;

  			}

  			if ( renderContextData.depthRenderbuffer ) {

  				gl.deleteRenderbuffer( renderContextData.depthRenderbuffer );
  				delete renderContextData.depthRenderbuffer;

  			}

  			if ( renderContextData.stencilRenderbuffer ) {

  				gl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );
  				delete renderContextData.stencilRenderbuffer;

  			}

  			if ( renderContextData.msaaFrameBuffer ) {

  				gl.deleteFramebuffer( renderContextData.msaaFrameBuffer );
  				delete renderContextData.msaaFrameBuffer;

  			}

  			if ( renderContextData.msaaRenderbuffers ) {

  				for ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {

  					gl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );

  				}

  				delete renderContextData.msaaRenderbuffers;

  			}

  		}

  	}

  	/**
  	 * Destroys the GPU data for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	destroyTexture( texture ) {

  		const { gl, backend } = this;
  		const { textureGPU, renderTarget } = backend.get( texture );

  		this.deallocateRenderBuffers( renderTarget );
  		gl.deleteTexture( textureGPU );

  		backend.delete( texture );

  	}

  	/**
  	 * Copies data of the given source texture to the given destination texture.
  	 *
  	 * @param {Texture} srcTexture - The source texture.
  	 * @param {Texture} dstTexture - The destination texture.
  	 * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
  	 * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
  	 * @param {number} [srcLevel=0] - The source mip level to copy from.
  	 * @param {number} [dstLevel=0] - The destination mip level to copy to.
  	 */
  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {

  		const { gl, backend } = this;
  		const { state } = this.backend;

  		const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );

  		state.bindTexture( glTextureType, dstTextureGPU );

  		// gather the necessary dimensions to copy
  		let width, height, depth, minX, minY, minZ;
  		let dstX, dstY, dstZ;
  		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;

  		if ( srcRegion !== null ) {

  			width = srcRegion.max.x - srcRegion.min.x;
  			height = srcRegion.max.y - srcRegion.min.y;
  			depth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
  			minX = srcRegion.min.x;
  			minY = srcRegion.min.y;
  			minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;

  		} else {

  			const levelScale = Math.pow( 2, - srcLevel );
  			width = Math.floor( image.width * levelScale );
  			height = Math.floor( image.height * levelScale );

  			if ( srcTexture.isDataArrayTexture || srcTexture.isArrayTexture ) {

  				depth = image.depth;

  			} else if ( srcTexture.isData3DTexture ) {

  				depth = Math.floor( image.depth * levelScale );

  			} else {

  				depth = 1;

  			}

  			minX = 0;
  			minY = 0;
  			minZ = 0;

  		}

  		if ( dstPosition !== null ) {

  			dstX = dstPosition.x;
  			dstY = dstPosition.y;
  			dstZ = dstPosition.z;

  		} else {

  			dstX = 0;
  			dstY = 0;
  			dstZ = 0;

  		}


  		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
  		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
  		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

  		// used for copying data from cpu
  		const currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );
  		const currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );
  		const currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );
  		const currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );
  		const currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );

  		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );
  		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );
  		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );
  		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );
  		gl.pixelStorei( gl.UNPACK_SKIP_IMAGES, minZ );

  		// set up the src texture
  		const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture || dstTexture.isArrayTexture;
  		if ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {

  			const srcTextureData = backend.get( srcTexture );
  			const dstTextureData = backend.get( dstTexture );

  			const srcRenderContextData = backend.get( srcTextureData.renderTarget );
  			const dstRenderContextData = backend.get( dstTextureData.renderTarget );

  			const srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];
  			const dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];

  			state.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );
  			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );

  			let mask = gl.COLOR_BUFFER_BIT;

  			if ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;

  			gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );

  			state.bindFramebuffer( gl.READ_FRAMEBUFFER, null );
  			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );

  		} else {

  			if ( isDst3D ) {

  				// copy data into the 3d texture
  				if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

  					gl.texSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );

  				} else if ( dstTexture.isCompressedArrayTexture ) {

  					gl.compressedTexSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );

  				} else {

  					gl.texSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );

  				}

  			} else {

  				// copy data into the 2d texture
  				if ( srcTexture.isDataTexture ) {

  					gl.texSubImage2D( glTextureType, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );

  				} else if ( srcTexture.isCompressedTexture ) {

  					gl.compressedTexSubImage2D( glTextureType, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );

  				} else {

  					gl.texSubImage2D( glTextureType, dstLevel, dstX, dstY, width, height, glFormat, glType, image );

  				}

  			}

  		}

  		// reset values
  		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
  		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
  		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
  		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
  		gl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

  		// Generate mipmaps only when copying level 0
  		if ( dstLevel === 0 && dstTexture.generateMipmaps ) {

  			gl.generateMipmap( glTextureType );

  		}

  		state.unbindTexture();

  	}


  	/**
  	 * Copies the current bound framebuffer to the given texture.
  	 *
  	 * @param {Texture} texture - The destination texture.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  	 */
  	copyFramebufferToTexture( texture, renderContext, rectangle ) {

  		const { gl } = this;
  		const { state } = this.backend;

  		const { textureGPU } = this.backend.get( texture );

  		const { x, y, z: width, w: height } = rectangle;

  		const requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );

  		const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;

  		if ( requireDrawFrameBuffer ) {

  			const partial = ( x !== 0 || y !== 0 );
  			let mask;
  			let attachment;

  			if ( texture.isDepthTexture === true ) {

  				mask = gl.DEPTH_BUFFER_BIT;
  				attachment = gl.DEPTH_ATTACHMENT;

  				if ( renderContext.stencil ) {

  					mask |= gl.STENCIL_BUFFER_BIT;

  				}

  			} else {

  				mask = gl.COLOR_BUFFER_BIT;
  				attachment = gl.COLOR_ATTACHMENT0;

  			}

  			if ( partial ) {

  				const renderTargetContextData = this.backend.get( renderContext.renderTarget );

  				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];
  				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );
  				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );

  				const flippedY = srcHeight - y - height;

  				gl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );

  				state.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

  				state.bindTexture( gl.TEXTURE_2D, textureGPU );

  				gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );

  				state.unbindTexture();

  			} else {

  				const fb = gl.createFramebuffer();

  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

  				gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );
  				gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );

  				gl.deleteFramebuffer( fb );

  			}

  		} else {

  			state.bindTexture( gl.TEXTURE_2D, textureGPU );
  			gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );

  			state.unbindTexture();

  		}

  		if ( texture.generateMipmaps ) this.generateMipmaps( texture );

  		this.backend._setFramebuffer( renderContext );

  	}

  	/**
  	 * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
  	 *
  	 * @param {WebGLRenderbuffer} renderbuffer - The render buffer.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {number} samples - The MSAA sample count.
  	 * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
  	 */
  	setupRenderBufferStorage( renderbuffer, renderContext, samples, useMultisampledRTT = false ) {

  		const { gl } = this;
  		const renderTarget = renderContext.renderTarget;

  		const { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;

  		gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

  		if ( depthBuffer && ! stencilBuffer ) {

  			let glInternalFormat = gl.DEPTH_COMPONENT24;

  			if ( useMultisampledRTT === true ) {

  				const multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );

  				multisampledRTTExt.renderbufferStorageMultisampleEXT( gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height );

  			} else if ( samples > 0 ) {

  				if ( depthTexture && depthTexture.isDepthTexture ) {

  					if ( depthTexture.type === gl.FLOAT ) {

  						glInternalFormat = gl.DEPTH_COMPONENT32F;

  					}

  				}

  				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );

  			} else {

  				gl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );

  			}

  			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

  		} else if ( depthBuffer && stencilBuffer ) {

  			if ( samples > 0 ) {

  				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );

  			} else {

  				gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );

  			}


  			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

  		}

  		gl.bindRenderbuffer( gl.RENDERBUFFER, null );

  	}

  	/**
  	 * Returns texture data as a typed array.
  	 *
  	 * @async
  	 * @param {Texture} texture - The texture to copy.
  	 * @param {number} x - The x coordinate of the copy origin.
  	 * @param {number} y - The y coordinate of the copy origin.
  	 * @param {number} width - The width of the copy.
  	 * @param {number} height - The height of the copy.
  	 * @param {number} faceIndex - The face index.
  	 * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
  	 */
  	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		const { backend, gl } = this;

  		const { textureGPU, glFormat, glType } = this.backend.get( texture );

  		const fb = gl.createFramebuffer();

  		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

  		const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;

  		gl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );

  		const typedArrayType = this._getTypedArrayType( glType );
  		const bytesPerTexel = this._getBytesPerTexel( glType, glFormat );

  		const elementCount = width * height;
  		const byteLength = elementCount * bytesPerTexel;

  		const buffer = gl.createBuffer();

  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
  		gl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );
  		gl.readPixels( x, y, width, height, glFormat, glType, 0 );
  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

  		await backend.utils._clientWaitAsync();

  		const dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );

  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
  		gl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );
  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

  		gl.deleteFramebuffer( fb );

  		return dstBuffer;

  	}

  	/**
  	 * Returns the corresponding typed array type for the given WebGL data type.
  	 *
  	 * @private
  	 * @param {GLenum} glType - The WebGL data type.
  	 * @return {TypedArray.constructor} The typed array type.
  	 */
  	_getTypedArrayType( glType ) {

  		const { gl } = this;

  		if ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;

  		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_INT ) return Uint32Array;

  		if ( glType === gl.HALF_FLOAT ) return Uint16Array;
  		if ( glType === gl.FLOAT ) return Float32Array;

  		throw new Error( `Unsupported WebGL type: ${glType}` );

  	}

  	/**
  	 * Returns the bytes-per-texel value for the given WebGL data type and texture format.
  	 *
  	 * @private
  	 * @param {GLenum} glType - The WebGL data type.
  	 * @param {GLenum} glFormat - The WebGL texture format.
  	 * @return {number} The bytes-per-texel.
  	 */
  	_getBytesPerTexel( glType, glFormat ) {

  		const { gl } = this;

  		let bytesPerComponent = 0;

  		if ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;

  		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
  			glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
  			glType === gl.UNSIGNED_SHORT_5_6_5 ||
  			glType === gl.UNSIGNED_SHORT ||
  			glType === gl.HALF_FLOAT ) bytesPerComponent = 2;

  		if ( glType === gl.UNSIGNED_INT ||
  			glType === gl.FLOAT ) bytesPerComponent = 4;

  		if ( glFormat === gl.RGBA ) return bytesPerComponent * 4;
  		if ( glFormat === gl.RGB ) return bytesPerComponent * 3;
  		if ( glFormat === gl.ALPHA ) return bytesPerComponent;

  	}

  }

  function getImage( source ) {

  	if ( source.isDataTexture ) {

  		return source.image.data;

  	} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||
  		( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||
  		( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||
  		( typeof OffscreenCanvas !== 'undefined' && source instanceof OffscreenCanvas ) ) {

  		return source;

  	}

  	return source.data;

  }

  /**
   * A WebGL 2 backend utility module for managing extensions.
   *
   * @private
   */
  class WebGLExtensions {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGLBackend} backend - The WebGL 2 backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGL 2 backend.
  		 *
  		 * @type {WebGLBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A reference to the rendering context.
  		 *
  		 * @type {WebGL2RenderingContext}
  		 */
  		this.gl = this.backend.gl;

  		/**
  		 * A list with all the supported WebGL extensions.
  		 *
  		 * @type {Array<string>}
  		 */
  		this.availableExtensions = this.gl.getSupportedExtensions();

  		/**
  		 * A dictionary with requested WebGL extensions.
  		 * The key is the name of the extension, the value
  		 * the requested extension object.
  		 *
  		 * @type {Object<string,Object>}
  		 */
  		this.extensions = {};

  	}

  	/**
  	 * Returns the extension object for the given extension name.
  	 *
  	 * @param {string} name - The extension name.
  	 * @return {Object} The extension object.
  	 */
  	get( name ) {

  		let extension = this.extensions[ name ];

  		if ( extension === undefined ) {

  			extension = this.gl.getExtension( name );

  			this.extensions[ name ] = extension;

  		}

  		return extension;

  	}

  	/**
  	 * Returns `true` if the requested extension is available.
  	 *
  	 * @param {string} name - The extension name.
  	 * @return {boolean} Whether the given extension is available or not.
  	 */
  	has( name ) {

  		return this.availableExtensions.includes( name );

  	}

  }

  /**
   * A WebGL 2 backend utility module for managing the device's capabilities.
   *
   * @private
   */
  class WebGLCapabilities {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGLBackend} backend - The WebGL 2 backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGL 2 backend.
  		 *
  		 * @type {WebGLBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * This value holds the cached max anisotropy value.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this.maxAnisotropy = null;

  	}

  	/**
  	 * Returns the maximum anisotropy texture filtering value. This value
  	 * depends on the device and is reported by the `EXT_texture_filter_anisotropic`
  	 * WebGL extension.
  	 *
  	 * @return {number} The maximum anisotropy texture filtering value.
  	 */
  	getMaxAnisotropy() {

  		if ( this.maxAnisotropy !== null ) return this.maxAnisotropy;

  		const gl = this.backend.gl;
  		const extensions = this.backend.extensions;

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			this.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			this.maxAnisotropy = 0;

  		}

  		return this.maxAnisotropy;

  	}

  }

  const GLFeatureName = {

  	'WEBGL_multi_draw': 'WEBGL_multi_draw',
  	'WEBGL_compressed_texture_astc': 'texture-compression-astc',
  	'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
  	'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
  	'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
  	'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
  	'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
  	'EXT_texture_compression_bptc': 'texture-compression-bptc',
  	'EXT_disjoint_timer_query_webgl2': 'timestamp-query',
  	'OVR_multiview2': 'OVR_multiview2'

  };

  class WebGLBufferRenderer {

  	constructor( backend ) {

  		this.gl = backend.gl;
  		this.extensions = backend.extensions;
  		this.info = backend.renderer.info;
  		this.mode = null;
  		this.index = 0;
  		this.type = null;
  		this.object = null;

  	}

  	render( start, count ) {

  		const { gl, mode, object, type, info, index } = this;

  		if ( index !== 0 ) {

  			gl.drawElements( mode, count, type, start );

  		} else {

  			gl.drawArrays( mode, start, count );

  		}

  		info.update( object, count, 1 );

  	}

  	renderInstances( start, count, primcount ) {

  		const { gl, mode, type, index, object, info } = this;

  		if ( primcount === 0 ) return;

  		if ( index !== 0 ) {

  			gl.drawElementsInstanced( mode, count, type, start, primcount );

  		} else {

  			gl.drawArraysInstanced( mode, start, count, primcount );

  		}

  		info.update( object, count, primcount );

  	}

  	renderMultiDraw( starts, counts, drawCount ) {

  		const { extensions, mode, object, info } = this;

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < drawCount; i ++ ) {

  				this.render( starts[ i ], counts[ i ] );

  			}

  		} else {

  			if ( this.index !== 0 ) {

  				extension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );

  			} else {

  				extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

  			}

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ];

  			}

  			info.update( object, elementCount, 1 );

  		}

  	}

  	renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

  		const { extensions, mode, object, info } = this;

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < drawCount; i ++ ) {

  				this.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

  			}

  		} else {

  			if ( this.index !== 0 ) {

  				extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );

  			} else {

  				extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

  			}

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ] * primcount[ i ];

  			}

  			info.update( object, elementCount, 1 );

  		}

  	}

  	//

  }

  /**
   * Abstract base class of a timestamp query pool.
   *
   * @abstract
   */
  class TimestampQueryPool {

  	/**
  	 * Creates a new timestamp query pool.
  	 *
  	 * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
  	 */
  	constructor( maxQueries = 256 ) {

  		/**
  		 * Whether to track timestamps or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.trackTimestamp = true;

  		/**
  		 * Maximum number of queries this pool can hold.
  		 *
  		 * @type {number}
  		 * @default 256
  		 */
  		this.maxQueries = maxQueries;

  		/**
  		 * How many queries allocated so far.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.currentQueryIndex = 0;

  		/**
  		 * Tracks offsets for different contexts.
  		 *
  		 * @type {Map<string, number>}
  		 */
  		this.queryOffsets = new Map();

  		/**
  		 * Whether the pool has been disposed or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.isDisposed = false;

  		/**
  		 * TODO
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.lastValue = 0;

  		/**
  		 * TODO
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.pendingResolve = false;

  	}

  	/**
  	 * Allocate queries for a specific renderContext.
  	 *
  	 * @abstract
  	 * @param {Object} renderContext - The render context to allocate queries for.
  	 * @returns {?number}
  	 */
  	allocateQueriesForContext( /* renderContext */ ) {}

  	/**
  	 * Resolve all timestamps and return data (or process them).
  	 *
  	 * @abstract
  	 * @async
  	 * @returns {Promise<number>|number} The resolved timestamp value.
  	 */
  	async resolveQueriesAsync() {}

  	/**
  	 * Dispose of the query pool.
  	 *
  	 * @abstract
  	 */
  	dispose() {}

  }

  /**
   * Manages a pool of WebGL timestamp queries for performance measurement.
   * Handles creation, execution, and resolution of timer queries using WebGL extensions.
   *
   * @augments TimestampQueryPool
   */
  class WebGLTimestampQueryPool extends TimestampQueryPool {

  	/**
  	 * Creates a new WebGL timestamp query pool.
  	 *
  	 * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
  	 * @param {string} type - The type identifier for this query pool.
  	 * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
  	 */
  	constructor( gl, type, maxQueries = 2048 ) {

  		super( maxQueries );

  		this.gl = gl;
  		this.type = type;

  		// Check for timer query extensions
  		this.ext = gl.getExtension( 'EXT_disjoint_timer_query_webgl2' ) ||
  				  gl.getExtension( 'EXT_disjoint_timer_query' );

  		if ( ! this.ext ) {

  			console.warn( 'EXT_disjoint_timer_query not supported; timestamps will be disabled.' );
  			this.trackTimestamp = false;
  			return;

  		}

  		// Create query objects
  		this.queries = [];
  		for ( let i = 0; i < this.maxQueries; i ++ ) {

  			this.queries.push( gl.createQuery() );

  		}

  		this.activeQuery = null;
  		this.queryStates = new Map(); // Track state of each query: 'inactive', 'started', 'ended'

  	}

  	/**
  	 * Allocates a pair of queries for a given render context.
  	 *
  	 * @param {Object} renderContext - The render context to allocate queries for.
  	 * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
  	 */
  	allocateQueriesForContext( renderContext ) {

  		if ( ! this.trackTimestamp ) return null;

  		// Check if we have enough space for a new query pair
  		if ( this.currentQueryIndex + 2 > this.maxQueries ) {

  			warnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );
  			return null;

  		}

  		const baseOffset = this.currentQueryIndex;
  		this.currentQueryIndex += 2;

  		// Initialize query states
  		this.queryStates.set( baseOffset, 'inactive' );
  		this.queryOffsets.set( renderContext.id, baseOffset );

  		return baseOffset;

  	}

  	/**
  	 * Begins a timestamp query for the specified render context.
  	 *
  	 * @param {Object} renderContext - The render context to begin timing for.
  	 */
  	beginQuery( renderContext ) {

  		if ( ! this.trackTimestamp || this.isDisposed ) {

  			return;

  		}

  		const baseOffset = this.queryOffsets.get( renderContext.id );
  		if ( baseOffset == null ) {

  			return;

  		}

  		// Don't start a new query if there's an active one
  		if ( this.activeQuery !== null ) {

  			return;

  		}

  		const query = this.queries[ baseOffset ];
  		if ( ! query ) {

  			return;

  		}

  		try {

  			// Only begin if query is inactive
  			if ( this.queryStates.get( baseOffset ) === 'inactive' ) {

  				this.gl.beginQuery( this.ext.TIME_ELAPSED_EXT, query );
  				this.activeQuery = baseOffset;
  				this.queryStates.set( baseOffset, 'started' );

  			}

  		} catch ( error ) {

  			console.error( 'Error in beginQuery:', error );
  			this.activeQuery = null;
  			this.queryStates.set( baseOffset, 'inactive' );

  		}

  	}

  	/**
  	 * Ends the active timestamp query for the specified render context.
  	 *
  	 * @param {Object} renderContext - The render context to end timing for.
  	 * @param {string} renderContext.id - Unique identifier for the render context.
  	 */
  	endQuery( renderContext ) {

  		if ( ! this.trackTimestamp || this.isDisposed ) {

  			return;

  		}

  		const baseOffset = this.queryOffsets.get( renderContext.id );
  		if ( baseOffset == null ) {

  			return;

  		}

  		// Only end if this is the active query
  		if ( this.activeQuery !== baseOffset ) {

  			return;

  		}

  		try {

  			this.gl.endQuery( this.ext.TIME_ELAPSED_EXT );
  			this.queryStates.set( baseOffset, 'ended' );
  			this.activeQuery = null;

  		} catch ( error ) {

  			console.error( 'Error in endQuery:', error );
  			// Reset state on error
  			this.queryStates.set( baseOffset, 'inactive' );
  			this.activeQuery = null;

  		}

  	}

  	/**
  	 * Asynchronously resolves all completed queries and returns the total duration.
  	 *
  	 * @async
  	 * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
  	 */
  	async resolveQueriesAsync() {

  		if ( ! this.trackTimestamp || this.pendingResolve ) {

  			return this.lastValue;

  		}

  		this.pendingResolve = true;

  		try {

  			// Wait for all ended queries to complete
  			const resolvePromises = [];

  			for ( const [ baseOffset, state ] of this.queryStates ) {

  				if ( state === 'ended' ) {

  					const query = this.queries[ baseOffset ];
  					resolvePromises.push( this.resolveQuery( query ) );

  				}

  			}

  			if ( resolvePromises.length === 0 ) {

  				return this.lastValue;

  			}

  			const results = await Promise.all( resolvePromises );
  			const totalDuration = results.reduce( ( acc, val ) => acc + val, 0 );

  			// Store the last valid result
  			this.lastValue = totalDuration;

  			// Reset states
  			this.currentQueryIndex = 0;
  			this.queryOffsets.clear();
  			this.queryStates.clear();
  			this.activeQuery = null;

  			return totalDuration;

  		} catch ( error ) {

  			console.error( 'Error resolving queries:', error );
  			return this.lastValue;

  		} finally {

  			this.pendingResolve = false;

  		}

  	}

  	/**
  	 * Resolves a single query, checking for completion and disjoint operation.
  	 *
  	 * @async
  	 * @param {WebGLQuery} query - The query object to resolve.
  	 * @returns {Promise<number>} The elapsed time in milliseconds.
  	 */
  	async resolveQuery( query ) {

  		return new Promise( ( resolve ) => {

  			if ( this.isDisposed ) {

  				resolve( this.lastValue );
  				return;

  			}

  			let timeoutId;
  			let isResolved = false;

  			const cleanup = () => {

  				if ( timeoutId ) {

  					clearTimeout( timeoutId );
  					timeoutId = null;

  				}

  			};

  			const finalizeResolution = ( value ) => {

  				if ( ! isResolved ) {

  					isResolved = true;
  					cleanup();
  					resolve( value );

  				}

  			};

  			const checkQuery = () => {

  				if ( this.isDisposed ) {

  					finalizeResolution( this.lastValue );
  					return;

  				}

  				try {

  					// Check if the GPU timer was disjoint (i.e., timing was unreliable)
  					const disjoint = this.gl.getParameter( this.ext.GPU_DISJOINT_EXT );
  					if ( disjoint ) {

  						finalizeResolution( this.lastValue );
  						return;

  					}

  					const available = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT_AVAILABLE );
  					if ( ! available ) {

  						timeoutId = setTimeout( checkQuery, 1 );
  						return;

  					}

  					const elapsed = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT );
  					resolve( Number( elapsed ) / 1e6 ); // Convert nanoseconds to milliseconds

  				} catch ( error ) {

  					console.error( 'Error checking query:', error );
  					resolve( this.lastValue );

  				}

  			};

  			checkQuery();

  		} );

  	}

  	/**
  	 * Releases all resources held by this query pool.
  	 * This includes deleting all query objects and clearing internal state.
  	 */
  	dispose() {

  		if ( this.isDisposed ) {

  			return;

  		}

  		this.isDisposed = true;

  		if ( ! this.trackTimestamp ) return;

  		for ( const query of this.queries ) {

  			this.gl.deleteQuery( query );

  		}

  		this.queries = [];
  		this.queryStates.clear();
  		this.queryOffsets.clear();
  		this.lastValue = 0;
  		this.activeQuery = null;

  	}

  }

  const _drawingBufferSize = /*@__PURE__*/ new Vector2();

  /**
   * A backend implementation targeting WebGL 2.
   *
   * @private
   * @augments Backend
   */
  class WebGLBackend extends Backend {

  	/**
  	 * WebGLBackend options.
  	 *
  	 * @typedef {Object} WebGLBackend~Options
  	 * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
  	 * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
  	 * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
  	 * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
  	 * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
  	 * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
  	 * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
  	 * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
  	 */

  	/**
  	 * Constructs a new WebGPU backend.
  	 *
  	 * @param {WebGLBackend~Options} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters = {} ) {

  		super( parameters );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGLBackend = true;

  		/**
  		 * A reference to a backend module holding shader attribute-related
  		 * utility functions.
  		 *
  		 * @type {?WebGLAttributeUtils}
  		 * @default null
  		 */
  		this.attributeUtils = null;

  		/**
  		 * A reference to a backend module holding extension-related
  		 * utility functions.
  		 *
  		 * @type {?WebGLExtensions}
  		 * @default null
  		 */
  		this.extensions = null;

  		/**
  		 * A reference to a backend module holding capability-related
  		 * utility functions.
  		 *
  		 * @type {?WebGLCapabilities}
  		 * @default null
  		 */
  		this.capabilities = null;

  		/**
  		 * A reference to a backend module holding texture-related
  		 * utility functions.
  		 *
  		 * @type {?WebGLTextureUtils}
  		 * @default null
  		 */
  		this.textureUtils = null;

  		/**
  		 * A reference to a backend module holding renderer-related
  		 * utility functions.
  		 *
  		 * @type {?WebGLBufferRenderer}
  		 * @default null
  		 */
  		this.bufferRenderer = null;

  		/**
  		 * A reference to the rendering context.
  		 *
  		 * @type {?WebGL2RenderingContext}
  		 * @default null
  		 */
  		this.gl = null;

  		/**
  		 * A reference to a backend module holding state-related
  		 * utility functions.
  		 *
  		 * @type {?WebGLState}
  		 * @default null
  		 */
  		this.state = null;

  		/**
  		 * A reference to a backend module holding common
  		 * utility functions.
  		 *
  		 * @type {?WebGLUtils}
  		 * @default null
  		 */
  		this.utils = null;

  		/**
  		 * Dictionary for caching VAOs.
  		 *
  		 * @type {Object<string,WebGLVertexArrayObject>}
  		 */
  		this.vaoCache = {};

  		/**
  		 * Dictionary for caching transform feedback objects.
  		 *
  		 * @type {Object<string,WebGLTransformFeedback>}
  		 */
  		this.transformFeedbackCache = {};

  		/**
  		 * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.
  		 * Only relevant when using compute shaders.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.discard = false;

  		/**
  		 * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the
  		 * device does not support the extension.
  		 *
  		 * @type {?EXTDisjointTimerQueryWebGL2}
  		 * @default null
  		 */
  		this.disjoint = null;

  		/**
  		* A reference to the `KHR_parallel_shader_compile` extension. `null` if the
  		* device does not support the extension.
  		*
  		* @type {?KHRParallelShaderCompile}
  		* @default null
  		*/
  		this.parallel = null;

  		/**
  		 * A reference to the current render context.
  		 *
  		 * @private
  		 * @type {RenderContext}
  		 * @default null
  		 */
  		this._currentContext = null;

  		/**
  		 * A unique collection of bindings.
  		 *
  		 * @private
  		 * @type {WeakSet}
  		 */
  		this._knownBindings = new WeakSet();


  		/**
  		 * Whether the device supports framebuffers invalidation or not.
  		 *
  		 * @private
  		 * @type {boolean}
  		 */
  		this._supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

  		/**
  		 * The target framebuffer when rendering with
  		 * the WebXR device API.
  		 *
  		 * @private
  		 * @type {WebGLFramebuffer}
  		 * @default null
  		 */
  		this._xrFramebuffer = null;

  	}

  	/**
  	 * Initializes the backend so it is ready for usage.
  	 *
  	 * @param {Renderer} renderer - The renderer.
  	 */
  	init( renderer ) {

  		super.init( renderer );

  		//

  		const parameters = this.parameters;

  		const contextAttributes = {
  			antialias: renderer.samples > 0,
  			alpha: true, // always true for performance reasons
  			depth: renderer.depth,
  			stencil: renderer.stencil
  		};

  		const glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2', contextAttributes );

  	 	function onContextLost( event ) {

  			event.preventDefault();

  			const contextLossInfo = {
  				api: 'WebGL',
  				message: event.statusMessage || 'Unknown reason',
  				reason: null,
  				originalEvent: event
  			};

  			renderer.onDeviceLost( contextLossInfo );

  		}

  		this._onContextLost = onContextLost;

  		renderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );

  		this.gl = glContext;

  		this.extensions = new WebGLExtensions( this );
  		this.capabilities = new WebGLCapabilities( this );
  		this.attributeUtils = new WebGLAttributeUtils( this );
  		this.textureUtils = new WebGLTextureUtils( this );
  		this.bufferRenderer = new WebGLBufferRenderer( this );

  		this.state = new WebGLState( this );
  		this.utils = new WebGLUtils( this );

  		this.extensions.get( 'EXT_color_buffer_float' );
  		this.extensions.get( 'WEBGL_clip_cull_distance' );
  		this.extensions.get( 'OES_texture_float_linear' );
  		this.extensions.get( 'EXT_color_buffer_half_float' );
  		this.extensions.get( 'WEBGL_multisampled_render_to_texture' );
  		this.extensions.get( 'WEBGL_render_shared_exponent' );
  		this.extensions.get( 'WEBGL_multi_draw' );
  		this.extensions.get( 'OVR_multiview2' );

  		this.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );
  		this.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );

  	}

  	/**
  	 * The coordinate system of the backend.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get coordinateSystem() {

  		return WebGLCoordinateSystem;

  	}

  	/**
  	 * This method performs a readback operation by moving buffer data from
  	 * a storage buffer attribute from the GPU to the CPU.
  	 *
  	 * @async
  	 * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
  	 * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
  	 */
  	async getArrayBufferAsync( attribute ) {

  		return await this.attributeUtils.getArrayBufferAsync( attribute );

  	}

  	/**
  	 * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
  	 * the CPU waits for the GPU to complete its operation (e.g. a compute task).
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolves when synchronization has been finished.
  	 */
  	async waitForGPU() {

  		await this.utils._clientWaitAsync();

  	}

  	/**
  	 * Ensures the backend is XR compatible.
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolve when the renderer is XR compatible.
  	 */
  	async makeXRCompatible() {

  		const attributes = this.gl.getContextAttributes();

  		if ( attributes.xrCompatible !== true ) {

  			await this.gl.makeXRCompatible();

  		}

  	}
  	/**
  	 * Sets the XR rendering destination.
  	 *
  	 * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
  	 */
  	setXRTarget( xrFramebuffer ) {

  		this._xrFramebuffer = xrFramebuffer;

  	}

  	/**
  	 * Configures the given XR render target with external textures.
  	 *
  	 * This method is only relevant when using the WebXR Layers API.
  	 *
  	 * @param {XRRenderTarget} renderTarget - The XR render target.
  	 * @param {WebGLTexture} colorTexture - A native color texture.
  	 * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
  	 */
  	setXRRenderTargetTextures( renderTarget, colorTexture, depthTexture = null ) {

  		const gl = this.gl;

  		this.set( renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 } ); // see #24698 why RGBA8 and not SRGB8_ALPHA8 is used

  		if ( depthTexture !== null ) {

  			const glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;

  			this.set( renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat: glInternalFormat } );

  			// The multisample_render_to_texture extension doesn't work properly if there
  			// are midframe flushes and an external depth texture.
  			if ( ( this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false ) {

  				console.warn( 'THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided' );

  			}

  			renderTarget._autoAllocateDepthBuffer = false;

  		}

  	}

  	/**
  	 * Inits a time stamp query for the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	initTimestampQuery( renderContext ) {

  		if ( ! this.disjoint || ! this.trackTimestamp ) return;

  		const type = renderContext.isComputeNode ? 'compute' : 'render';

  		if ( ! this.timestampQueryPool[ type ] ) {

  			// TODO: Variable maxQueries?
  			this.timestampQueryPool[ type ] = new WebGLTimestampQueryPool( this.gl, type, 2048 );

  		}

  		const timestampQueryPool = this.timestampQueryPool[ type ];

  		const baseOffset = timestampQueryPool.allocateQueriesForContext( renderContext );

  		if ( baseOffset !== null ) {

  			timestampQueryPool.beginQuery( renderContext );

  		}

  	}

  	// timestamp utils

  	/**
  	 * Prepares the timestamp buffer.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	prepareTimestampBuffer( renderContext ) {

  		if ( ! this.disjoint || ! this.trackTimestamp ) return;

  		const type = renderContext.isComputeNode ? 'compute' : 'render';
  		const timestampQueryPool = this.timestampQueryPool[ type ];

  		timestampQueryPool.endQuery( renderContext );

  	}


  	/**
  	 * Returns the backend's rendering context.
  	 *
  	 * @return {WebGL2RenderingContext} The rendering context.
  	 */
  	getContext() {

  		return this.gl;

  	}

  	/**
  	 * This method is executed at the beginning of a render call and prepares
  	 * the WebGL state for upcoming render calls
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	beginRender( renderContext ) {

  		const { state } = this;
  		const renderContextData = this.get( renderContext );

  		//

  		if ( renderContext.viewport ) {

  			this.updateViewport( renderContext );

  		} else {

  			const { width, height } = this.getDrawingBufferSize( _drawingBufferSize );
  			state.viewport( 0, 0, width, height );

  		}

  		if ( renderContext.scissor ) {

  			const { x, y, width, height } = renderContext.scissorValue;

  			state.scissor( x, renderContext.height - height - y, width, height );

  		}

  		//

  		this.initTimestampQuery( renderContext );

  		renderContextData.previousContext = this._currentContext;
  		this._currentContext = renderContext;

  		this._setFramebuffer( renderContext );
  		this.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );

  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		if ( occlusionQueryCount > 0 ) {

  			// Get a reference to the array of objects with queries. The renderContextData property
  			// can be changed by another render pass before the async reading of all previous queries complete
  			renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
  			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

  			renderContextData.lastOcclusionObject = null;
  			renderContextData.occlusionQueries = new Array( occlusionQueryCount );
  			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );
  			renderContextData.occlusionQueryIndex = 0;

  		}

  	}

  	/**
  	 * This method is executed at the end of a render call and finalizes work
  	 * after draw calls.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	finishRender( renderContext ) {

  		const { gl, state } = this;
  		const renderContextData = this.get( renderContext );
  		const previousContext = renderContextData.previousContext;

  		state.resetVertexState();

  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		if ( occlusionQueryCount > 0 ) {

  			if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

  				gl.endQuery( gl.ANY_SAMPLES_PASSED );

  			}

  			this.resolveOccludedAsync( renderContext );

  		}

  		const textures = renderContext.textures;

  		if ( textures !== null ) {

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				if ( texture.generateMipmaps ) {

  					this.generateMipmaps( texture );

  				}

  			}

  		}

  		this._currentContext = previousContext;
  		const renderTarget = renderContext.renderTarget;

  		if ( renderContext.textures !== null && renderTarget ) {

  			const renderTargetContextData = this.get( renderTarget );

  			if ( renderTarget.samples > 0 && this._useMultisampledExtension( renderTarget ) === false ) {

  				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];

  				let mask = gl.COLOR_BUFFER_BIT;

  				if ( renderTarget.resolveDepthBuffer ) {

  					if ( renderTarget.depthBuffer ) mask |= gl.DEPTH_BUFFER_BIT;
  					if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= gl.STENCIL_BUFFER_BIT;

  				}

  				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
  				const msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;

  				const textures = renderContext.textures;
  				const isMRT = textures.length > 1;

  				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );
  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

  				if ( isMRT ) {

  					// blitFramebuffer() can only copy/resolve the first color attachment of a framebuffer. When using MRT,
  					// the engine temporarily removes all attachments and then configures each attachment for the resolve.

  					for ( let i = 0; i < textures.length; i ++ ) {

  						gl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, null );
  						gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0 );

  					}

  				}

  				for ( let i = 0; i < textures.length; i ++ ) {

  					if ( isMRT ) {

  						// configure attachment for resolve

  						const { textureGPU } = this.get( textures[ i ] );

  						gl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );
  						gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0 );

  					}

  					if ( renderContext.scissor ) {

  						const { x, y, width, height } = renderContext.scissorValue;

  						const viewY = renderContext.height - height - y;

  						gl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );

  					} else {

  						gl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );

  					}

  				}

  				if ( isMRT ) {

  					// restore attachments

  					for ( let i = 0; i < textures.length; i ++ ) {

  						const { textureGPU } = this.get( textures[ i ] );

  						gl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );
  						gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0 );

  					}

  				}

  				if ( this._supportsInvalidateFramebuffer === true ) {

  					gl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );

  				}

  			} else if ( renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers ) {

  				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];
  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );
  				gl.invalidateFramebuffer( gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray );

  			}

  		}

  		if ( previousContext !== null ) {

  			this._setFramebuffer( previousContext );

  			if ( previousContext.viewport ) {

  				this.updateViewport( previousContext );

  			} else {

  				const { width, height } = this.getDrawingBufferSize( _drawingBufferSize );
  				state.viewport( 0, 0, width, height );

  			}

  		}

  		this.prepareTimestampBuffer( renderContext );

  	}

  	/**
  	 * This method processes the result of occlusion queries and writes it
  	 * into render context data.
  	 *
  	 * @async
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	resolveOccludedAsync( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		// handle occlusion query results

  		const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;

  		if ( currentOcclusionQueries && currentOcclusionQueryObjects ) {

  			const occluded = new WeakSet();
  			const { gl } = this;

  			renderContextData.currentOcclusionQueryObjects = null;
  			renderContextData.currentOcclusionQueries = null;

  			const check = () => {

  				let completed = 0;

  				// check all queries and requeue as appropriate
  				for ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {

  					const query = currentOcclusionQueries[ i ];

  					if ( query === null ) continue;

  					if ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {

  						if ( gl.getQueryParameter( query, gl.QUERY_RESULT ) === 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );

  						currentOcclusionQueries[ i ] = null;
  						gl.deleteQuery( query );

  						completed ++;

  					}

  				}

  				if ( completed < currentOcclusionQueries.length ) {

  					requestAnimationFrame( check );

  				} else {

  					renderContextData.occluded = occluded;

  				}

  			};

  			check();

  		}

  	}

  	/**
  	 * Returns `true` if the given 3D object is fully occluded by other
  	 * 3D objects in the scene.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object3D} object - The 3D object to test.
  	 * @return {boolean} Whether the 3D object is fully occluded or not.
  	 */
  	isOccluded( renderContext, object ) {

  		const renderContextData = this.get( renderContext );

  		return renderContextData.occluded && renderContextData.occluded.has( object );

  	}

  	/**
  	 * Updates the viewport with the values from the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	updateViewport( renderContext ) {

  		const { state } = this;
  		const { x, y, width, height } = renderContext.viewportValue;

  		state.viewport( x, renderContext.height - height - y, width, height );

  	}

  	/**
  	 * Defines the scissor test.
  	 *
  	 * @param {boolean} boolean - Whether the scissor test should be enabled or not.
  	 */
  	setScissorTest( boolean ) {

  		const state = this.state;

  		state.setScissorTest( boolean );

  	}

  	/**
  	 * Returns the clear color and alpha into a single
  	 * color object.
  	 *
  	 * @return {Color4} The clear color.
  	 */
  	getClearColor() {

  		const clearColor = super.getClearColor();

  		// Since the canvas is always created with alpha: true,
  		// WebGL must always premultiply the clear color.

  		clearColor.r *= clearColor.a;
  		clearColor.g *= clearColor.a;
  		clearColor.b *= clearColor.a;

  		return clearColor;

  	}

  	/**
  	 * Performs a clear operation.
  	 *
  	 * @param {boolean} color - Whether the color buffer should be cleared or not.
  	 * @param {boolean} depth - Whether the depth buffer should be cleared or not.
  	 * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
  	 * @param {?Object} [descriptor=null] - The render context of the current set render target.
  	 * @param {boolean} [setFrameBuffer=true] - TODO.
  	 */
  	clear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {

  		const { gl, renderer } = this;

  		if ( descriptor === null ) {

  			const clearColor = this.getClearColor();

  			descriptor = {
  				textures: null,
  				clearColorValue: clearColor
  			};

  		}

  		//

  		let clear = 0;

  		if ( color ) clear |= gl.COLOR_BUFFER_BIT;
  		if ( depth ) clear |= gl.DEPTH_BUFFER_BIT;
  		if ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;

  		if ( clear !== 0 ) {

  			let clearColor;

  			if ( descriptor.clearColorValue ) {

  				clearColor = descriptor.clearColorValue;

  			} else {

  				clearColor = this.getClearColor();

  			}

  			const clearDepth = renderer.getClearDepth();
  			const clearStencil = renderer.getClearStencil();

  			if ( depth ) this.state.setDepthMask( true );

  			if ( descriptor.textures === null ) {

  				gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );
  				gl.clear( clear );

  			} else {

  				if ( setFrameBuffer ) this._setFramebuffer( descriptor );

  				if ( color ) {

  					for ( let i = 0; i < descriptor.textures.length; i ++ ) {

  						if ( i === 0 ) {

  							gl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );

  						} else {

  							gl.clearBufferfv( gl.COLOR, i, [ 0, 0, 0, 1 ] );

  						}

  					}

  				}

  				if ( depth && stencil ) {

  					gl.clearBufferfi( gl.DEPTH_STENCIL, 0, clearDepth, clearStencil );

  				} else if ( depth ) {

  					gl.clearBufferfv( gl.DEPTH, 0, [ clearDepth ] );

  				} else if ( stencil ) {

  					gl.clearBufferiv( gl.STENCIL, 0, [ clearStencil ] );

  				}

  			}

  		}

  	}

  	/**
  	 * This method is executed at the beginning of a compute call and
  	 * prepares the state for upcoming compute tasks.
  	 *
  	 * @param {Node|Array<Node>} computeGroup - The compute node(s).
  	 */
  	beginCompute( computeGroup ) {

  		const { state, gl } = this;

  		state.bindFramebuffer( gl.FRAMEBUFFER, null );
  		this.initTimestampQuery( computeGroup );

  	}

  	/**
  	 * Executes a compute command for the given compute node.
  	 *
  	 * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
  	 * @param {Node} computeNode - The compute node.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 * @param {ComputePipeline} pipeline - The compute pipeline.
  	 */
  	compute( computeGroup, computeNode, bindings, pipeline ) {

  		const { state, gl } = this;

  		if ( this.discard === false ) {

  			// required here to handle async behaviour of render.compute()
  			gl.enable( gl.RASTERIZER_DISCARD );
  			this.discard = true;

  		}

  		const { programGPU, transformBuffers, attributes } = this.get( pipeline );

  		const vaoKey = this._getVaoKey( attributes );

  		const vaoGPU = this.vaoCache[ vaoKey ];

  		if ( vaoGPU === undefined ) {

  			this.vaoCache[ vaoKey ] = this._createVao( attributes );

  		} else {

  			state.setVertexState( vaoGPU );

  		}

  		state.useProgram( programGPU );

  		this._bindUniforms( bindings );

  		const transformFeedbackGPU = this._getTransformFeedback( transformBuffers );

  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );
  		gl.beginTransformFeedback( gl.POINTS );

  		if ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {

  			gl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );

  		} else {

  			gl.drawArrays( gl.POINTS, 0, computeNode.count );

  		}

  		gl.endTransformFeedback();
  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

  		// switch active buffers

  		for ( let i = 0; i < transformBuffers.length; i ++ ) {

  			const dualAttributeData = transformBuffers[ i ];

  			if ( dualAttributeData.pbo && this.has( dualAttributeData.pbo ) ) {

  				this.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );

  			}

  			dualAttributeData.switchBuffers();


  		}

  	}

  	/**
  	 * This method is executed at the end of a compute call and
  	 * finalizes work after compute tasks.
  	 *
  	 * @param {Node|Array<Node>} computeGroup - The compute node(s).
  	 */
  	finishCompute( computeGroup ) {

  		const gl = this.gl;

  		this.discard = false;

  		gl.disable( gl.RASTERIZER_DISCARD );

  		this.prepareTimestampBuffer( computeGroup );

  		if ( this._currentContext ) {

  			this._setFramebuffer( this._currentContext );

  		}

  	}

  	/**
  	 * Internal to determine if the current render target is a render target array with depth 2D array texture.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
  	 *
  	 * @private
  	 */
  	_isRenderCameraDepthArray( renderContext ) {

  		return renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;

  	}

  	/**
  	 * Executes a draw command for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object to draw.
  	 * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
  	 */
  	draw( renderObject/*, info*/ ) {

  		const { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;
  		const { programGPU } = this.get( pipeline );

  		const { gl, state } = this;

  		const contextData = this.get( context );

  		const drawParams = renderObject.getDrawParameters();

  		if ( drawParams === null ) return;

  		//

  		this._bindUniforms( renderObject.getBindings() );

  		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  		state.setMaterial( material, frontFaceCW, hardwareClippingPlanes );

  		state.useProgram( programGPU );

  		// vertex state

  		const attributes = renderObject.getAttributes();
  		const attributesData = this.get( attributes );

  		let vaoGPU = attributesData.vaoGPU;

  		if ( vaoGPU === undefined ) {

  			const vaoKey = this._getVaoKey( attributes );

  			vaoGPU = this.vaoCache[ vaoKey ];

  			if ( vaoGPU === undefined ) {

  				vaoGPU = this._createVao( attributes );

  				this.vaoCache[ vaoKey ] = vaoGPU;
  				attributesData.vaoGPU = vaoGPU;

  			}

  		}

  		const index = renderObject.getIndex();
  		const indexGPU = ( index !== null ) ? this.get( index ).bufferGPU : null;

  		state.setVertexState( vaoGPU, indexGPU );

  		//

  		const lastObject = contextData.lastOcclusionObject;

  		if ( lastObject !== object && lastObject !== undefined ) {

  			if ( lastObject !== null && lastObject.occlusionTest === true ) {

  				gl.endQuery( gl.ANY_SAMPLES_PASSED );

  				contextData.occlusionQueryIndex ++;

  			}

  			if ( object.occlusionTest === true ) {

  				const query = gl.createQuery();

  				gl.beginQuery( gl.ANY_SAMPLES_PASSED, query );

  				contextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;
  				contextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;

  			}

  			contextData.lastOcclusionObject = object;

  		}

  		//
  		const renderer = this.bufferRenderer;

  		if ( object.isPoints ) renderer.mode = gl.POINTS;
  		else if ( object.isLineSegments ) renderer.mode = gl.LINES;
  		else if ( object.isLine ) renderer.mode = gl.LINE_STRIP;
  		else if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;
  		else {

  			if ( material.wireframe === true ) {

  				state.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );
  				renderer.mode = gl.LINES;

  			} else {

  				renderer.mode = gl.TRIANGLES;

  			}

  		}

  		//

  		const { vertexCount, instanceCount } = drawParams;
  		let { firstVertex } = drawParams;

  		renderer.object = object;

  		if ( index !== null ) {

  			firstVertex *= index.array.BYTES_PER_ELEMENT;

  			const indexData = this.get( index );

  			renderer.index = index.count;
  			renderer.type = indexData.type;

  		} else {

  			renderer.index = 0;

  		}

  		const draw = () => {

  			if ( object.isBatchedMesh ) {

  				if ( object._multiDrawInstances !== null ) {

  					// @deprecated, r174
  					warnOnce( 'THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );
  					renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

  				} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {

  					warnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );

  				} else {

  					renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

  				}

  			} else if ( instanceCount > 1 ) {

  				renderer.renderInstances( firstVertex, vertexCount, instanceCount );

  			} else {

  				renderer.render( firstVertex, vertexCount );

  			}

  		};

  		if ( renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false ) {

  			const cameraData = this.get( renderObject.camera );
  			const cameras = renderObject.camera.cameras;
  			const cameraIndex = renderObject.getBindingGroup( 'cameraIndex' ).bindings[ 0 ];

  			if ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {

  				const data = new Uint32Array( [ 0, 0, 0, 0 ] );
  				const indexesGPU = [];

  				for ( let i = 0, len = cameras.length; i < len; i ++ ) {

  					const bufferGPU = gl.createBuffer();

  					data[ 0 ] = i;

  					gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
  					gl.bufferData( gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW );

  					indexesGPU.push( bufferGPU );

  				}

  				cameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this

  			}

  			const cameraIndexData = this.get( cameraIndex );
  			const pixelRatio = this.renderer.getPixelRatio();

  			const renderTarget = this._currentContext.renderTarget;
  			const isRenderCameraDepthArray = this._isRenderCameraDepthArray( this._currentContext );
  			const prevActiveCubeFace = this._currentContext.activeCubeFace;

  			if ( isRenderCameraDepthArray ) {

  				// Clear the depth texture
  				const textureData = this.get( renderTarget.depthTexture );

  				if ( textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId ) {

  					textureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;

  					const { stencilBuffer } = renderTarget;

  					for ( let i = 0, len = cameras.length; i < len; i ++ ) {

  						this.renderer._activeCubeFace = i;
  						this._currentContext.activeCubeFace = i;

  						this._setFramebuffer( this._currentContext );
  						this.clear( false, true, stencilBuffer, this._currentContext, false );

  					}

  					this.renderer._activeCubeFace = prevActiveCubeFace;
  					this._currentContext.activeCubeFace = prevActiveCubeFace;

  				}

  			}

  			for ( let i = 0, len = cameras.length; i < len; i ++ ) {

  				const subCamera = cameras[ i ];

  				if ( object.layers.test( subCamera.layers ) ) {

  					if ( isRenderCameraDepthArray ) {

  						// Update the active layer
  						this.renderer._activeCubeFace = i;
  						this._currentContext.activeCubeFace = i;

  						this._setFramebuffer( this._currentContext );

  					}

  					const vp = subCamera.viewport;

  					if ( vp !== undefined ) {

  						const x = vp.x * pixelRatio;
  						const y = vp.y * pixelRatio;
  						const width = vp.width * pixelRatio;
  						const height = vp.height * pixelRatio;

  						state.viewport(
  							Math.floor( x ),
  							Math.floor( renderObject.context.height - height - y ),
  							Math.floor( width ),
  							Math.floor( height )
  						);

  					}

  					state.bindBufferBase( gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[ i ] );

  					draw();

  				}

  				this._currentContext.activeCubeFace = prevActiveCubeFace;
  				this.renderer._activeCubeFace = prevActiveCubeFace;

  			}

  		} else {

  			draw();

  		}

  	}

  	/**
  	 * Explain why always null is returned.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the render pipeline requires an update or not.
  	 */
  	needsRenderUpdate( /*renderObject*/ ) {

  		return false;

  	}

  	/**
  	 * Explain why no cache key is computed.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {string} The cache key.
  	 */
  	getRenderCacheKey( /*renderObject*/ ) {

  		return '';

  	}

  	// textures

  	/**
  	 * Creates a default texture for the given texture that can be used
  	 * as a placeholder until the actual texture is ready for usage.
  	 *
  	 * @param {Texture} texture - The texture to create a default texture for.
  	 */
  	createDefaultTexture( texture ) {

  		this.textureUtils.createDefaultTexture( texture );

  	}

  	/**
  	 * Defines a texture on the GPU for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	createTexture( texture, options ) {

  		this.textureUtils.createTexture( texture, options );

  	}

  	/**
  	 * Uploads the updated texture data to the GPU.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	updateTexture( texture, options ) {

  		this.textureUtils.updateTexture( texture, options );

  	}

  	/**
  	 * Generates mipmaps for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	generateMipmaps( texture ) {

  		this.textureUtils.generateMipmaps( texture );

  	}

  	/**
  	 * Destroys the GPU data for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	destroyTexture( texture ) {

  		this.textureUtils.destroyTexture( texture );

  	}

  	/**
  	 * Returns texture data as a typed array.
  	 *
  	 * @async
  	 * @param {Texture} texture - The texture to copy.
  	 * @param {number} x - The x coordinate of the copy origin.
  	 * @param {number} y - The y coordinate of the copy origin.
  	 * @param {number} width - The width of the copy.
  	 * @param {number} height - The height of the copy.
  	 * @param {number} faceIndex - The face index.
  	 * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
  	 */
  	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

  	}

  	/**
  	 * This method does nothing since WebGL 2 has no concept of samplers.
  	 *
  	 * @param {Texture} texture - The texture to create the sampler for.
  	 */
  	createSampler( /*texture*/ ) {

  		//console.warn( 'Abstract class.' );

  	}

  	/**
  	 * This method does nothing since WebGL 2 has no concept of samplers.
  	 *
  	 * @param {Texture} texture - The texture to destroy the sampler for.
  	 */
  	destroySampler( /*texture*/ ) {}

  	// node builder

  	/**
  	 * Returns a node builder for the given render object.
  	 *
  	 * @param {RenderObject} object - The render object.
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {GLSLNodeBuilder} The node builder.
  	 */
  	createNodeBuilder( object, renderer ) {

  		return new GLSLNodeBuilder( object, renderer );

  	}

  	// program

  	/**
  	 * Creates a shader program from the given programmable stage.
  	 *
  	 * @param {ProgrammableStage} program - The programmable stage.
  	 */
  	createProgram( program ) {

  		const gl = this.gl;
  		const { stage, code } = program;

  		const shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );

  		gl.shaderSource( shader, code );
  		gl.compileShader( shader );

  		this.set( program, {
  			shaderGPU: shader
  		} );

  	}

  	/**
  	 * Destroys the shader program of the given programmable stage.
  	 *
  	 * @param {ProgrammableStage} program - The programmable stage.
  	 */
  	destroyProgram( program ) {

  		this.delete( program );

  	}

  	/**
  	 * Creates a render pipeline for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
  	 */
  	createRenderPipeline( renderObject, promises ) {

  		const gl = this.gl;
  		const pipeline = renderObject.pipeline;

  		// Program

  		const { fragmentProgram, vertexProgram } = pipeline;

  		const programGPU = gl.createProgram();

  		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
  		const vertexShader = this.get( vertexProgram ).shaderGPU;

  		gl.attachShader( programGPU, fragmentShader );
  		gl.attachShader( programGPU, vertexShader );
  		gl.linkProgram( programGPU );

  		this.set( pipeline, {
  			programGPU,
  			fragmentShader,
  			vertexShader
  		} );

  		if ( promises !== null && this.parallel ) {

  			const p = new Promise( ( resolve /*, reject*/ ) => {

  				const parallel = this.parallel;
  				const checkStatus = () => {

  					if ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {

  						this._completeCompile( renderObject, pipeline );
  						resolve();

  					} else {

  						requestAnimationFrame( checkStatus );

  					}

  				};

  				checkStatus();

  			} );

  			promises.push( p );

  			return;

  		}

  		this._completeCompile( renderObject, pipeline );

  	}

  	/**
  	 * Formats the source code of error messages.
  	 *
  	 * @private
  	 * @param {string} string - The code.
  	 * @param {number} errorLine - The error line.
  	 * @return {string} The formatted code.
  	 */
  	_handleSource( string, errorLine ) {

  		const lines = string.split( '\n' );
  		const lines2 = [];

  		const from = Math.max( errorLine - 6, 0 );
  		const to = Math.min( errorLine + 6, lines.length );

  		for ( let i = from; i < to; i ++ ) {

  			const line = i + 1;
  			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

  		}

  		return lines2.join( '\n' );

  	}

  	/**
  	 * Gets the shader compilation errors from the info log.
  	 *
  	 * @private
  	 * @param {WebGL2RenderingContext} gl - The rendering context.
  	 * @param {WebGLShader} shader - The WebGL shader object.
  	 * @param {string} type - The shader type.
  	 * @return {string} The shader errors.
  	 */
  	_getShaderErrors( gl, shader, type ) {

  		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
  		const errors = gl.getShaderInfoLog( shader ).trim();

  		if ( status && errors === '' ) return '';

  		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
  		if ( errorMatches ) {

  			const errorLine = parseInt( errorMatches[ 1 ] );
  			return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );

  		} else {

  			return errors;

  		}

  	}

  	/**
  	 * Logs shader compilation errors.
  	 *
  	 * @private
  	 * @param {WebGLProgram} programGPU - The WebGL program.
  	 * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
  	 * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
  	 */
  	_logProgramError( programGPU, glFragmentShader, glVertexShader ) {

  		if ( this.renderer.debug.checkShaderErrors ) {

  			const gl = this.gl;

  			const programLog = gl.getProgramInfoLog( programGPU ).trim();

  			if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {


  				if ( typeof this.renderer.debug.onShaderError === 'function' ) {

  					this.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );

  				} else {

  					// default error reporting

  					const vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );
  					const fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );

  					console.error(
  						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
  						'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\n\n' +
  						'Program Info Log: ' + programLog + '\n' +
  						vertexErrors + '\n' +
  						fragmentErrors
  					);

  				}

  			} else if ( programLog !== '' ) {

  				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

  			}

  		}

  	}

  	/**
  	 * Completes the shader program setup for the given render object.
  	 *
  	 * @private
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {RenderPipeline} pipeline - The render pipeline.
  	 */
  	_completeCompile( renderObject, pipeline ) {

  		const { state, gl } = this;
  		const pipelineData = this.get( pipeline );
  		const { programGPU, fragmentShader, vertexShader } = pipelineData;

  		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

  			this._logProgramError( programGPU, fragmentShader, vertexShader );

  		}

  		state.useProgram( programGPU );

  		// Bindings

  		const bindings = renderObject.getBindings();

  		this._setupBindings( bindings, programGPU );

  		//

  		this.set( pipeline, {
  			programGPU
  		} );

  	}

  	/**
  	 * Creates a compute pipeline for the given compute node.
  	 *
  	 * @param {ComputePipeline} computePipeline - The compute pipeline.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 */
  	createComputePipeline( computePipeline, bindings ) {

  		const { state, gl } = this;

  		// Program

  		const fragmentProgram = {
  			stage: 'fragment',
  			code: '#version 300 es\nprecision highp float;\nvoid main() {}'
  		};

  		this.createProgram( fragmentProgram );

  		const { computeProgram } = computePipeline;

  		const programGPU = gl.createProgram();

  		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
  		const vertexShader = this.get( computeProgram ).shaderGPU;

  		const transforms = computeProgram.transforms;

  		const transformVaryingNames = [];
  		const transformAttributeNodes = [];

  		for ( let i = 0; i < transforms.length; i ++ ) {

  			const transform = transforms[ i ];

  			transformVaryingNames.push( transform.varyingName );
  			transformAttributeNodes.push( transform.attributeNode );

  		}

  		gl.attachShader( programGPU, fragmentShader );
  		gl.attachShader( programGPU, vertexShader );

  		gl.transformFeedbackVaryings(
  			programGPU,
  			transformVaryingNames,
  			gl.SEPARATE_ATTRIBS
  		);

  		gl.linkProgram( programGPU );

  		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

  			this._logProgramError( programGPU, fragmentShader, vertexShader );


  		}

  		state.useProgram( programGPU );

  		// Bindings

  		this._setupBindings( bindings, programGPU );

  		const attributeNodes = computeProgram.attributes;
  		const attributes = [];
  		const transformBuffers = [];

  		for ( let i = 0; i < attributeNodes.length; i ++ ) {

  			const attribute = attributeNodes[ i ].node.attribute;

  			attributes.push( attribute );

  			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  		}

  		for ( let i = 0; i < transformAttributeNodes.length; i ++ ) {

  			const attribute = transformAttributeNodes[ i ].attribute;

  			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  			const attributeData = this.get( attribute );

  			transformBuffers.push( attributeData );

  		}

  		//

  		this.set( computePipeline, {
  			programGPU,
  			transformBuffers,
  			attributes
  		} );

  	}

  	/**
  	 * Creates bindings from the given bind group definition.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	createBindings( bindGroup, bindings /*, cacheIndex, version*/ ) {

  		if ( this._knownBindings.has( bindings ) === false ) {

  			this._knownBindings.add( bindings );

  			let uniformBuffers = 0;
  			let textures = 0;

  			for ( const bindGroup of bindings ) {

  				this.set( bindGroup, {
  					textures: textures,
  					uniformBuffers: uniformBuffers
  				} );

  				for ( const binding of bindGroup.bindings ) {

  					if ( binding.isUniformBuffer ) uniformBuffers ++;
  					if ( binding.isSampledTexture ) textures ++;

  				}

  			}

  		}

  		this.updateBindings( bindGroup, bindings );

  	}

  	/**
  	 * Updates the given bind group definition.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	updateBindings( bindGroup /*, bindings, cacheIndex, version*/ ) {

  		const { gl } = this;

  		const bindGroupData = this.get( bindGroup );

  		let i = bindGroupData.uniformBuffers;
  		let t = bindGroupData.textures;

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  				const data = binding.buffer;
  				const bufferGPU = gl.createBuffer();

  				gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
  				gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

  				this.set( binding, {
  					index: i ++,
  					bufferGPU
  				} );

  			} else if ( binding.isSampledTexture ) {

  				const { textureGPU, glTextureType } = this.get( binding.texture );

  				this.set( binding, {
  					index: t ++,
  					textureGPU,
  					glTextureType
  				} );

  			}

  		}

  	}

  	/**
  	 * Updates a buffer binding.
  	 *
  	 *  @param {Buffer} binding - The buffer binding to update.
  	 */
  	updateBinding( binding ) {

  		const gl = this.gl;

  		if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  			const bindingData = this.get( binding );
  			const bufferGPU = bindingData.bufferGPU;
  			const data = binding.buffer;

  			gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
  			gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

  		}

  	}

  	// attributes

  	/**
  	 * Creates the GPU buffer of an indexed shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The indexed buffer attribute.
  	 */
  	createIndexAttribute( attribute ) {

  		const gl = this.gl;

  		this.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

  	}

  	/**
  	 * Creates the GPU buffer of a shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createAttribute( attribute ) {

  		if ( this.has( attribute ) ) return;

  		const gl = this.gl;

  		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  	}

  	/**
  	 * Creates the GPU buffer of a storage attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createStorageAttribute( attribute ) {

  		if ( this.has( attribute ) ) return;

  		const gl = this.gl;

  		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  	}

  	/**
  	 * Updates the GPU buffer of a shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute to update.
  	 */
  	updateAttribute( attribute ) {

  		this.attributeUtils.updateAttribute( attribute );

  	}

  	/**
  	 * Destroys the GPU buffer of a shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute to destroy.
  	 */
  	destroyAttribute( attribute ) {

  		this.attributeUtils.destroyAttribute( attribute );

  	}

  	/**
  	 * Checks if the given feature is supported  by the backend.
  	 *
  	 * @param {string} name - The feature's name.
  	 * @return {boolean} Whether the feature is supported or not.
  	 */
  	hasFeature( name ) {

  		const keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );

  		const extensions = this.extensions;

  		for ( let i = 0; i < keysMatching.length; i ++ ) {

  			if ( extensions.has( keysMatching[ i ] ) ) return true;

  		}

  		return false;

  	}

  	/**
  	 * Returns the maximum anisotropy texture filtering value.
  	 *
  	 * @return {number} The maximum anisotropy texture filtering value.
  	 */
  	getMaxAnisotropy() {

  		return this.capabilities.getMaxAnisotropy();

  	}

  	/**
  	 * Copies data of the given source texture to the given destination texture.
  	 *
  	 * @param {Texture} srcTexture - The source texture.
  	 * @param {Texture} dstTexture - The destination texture.
  	 * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
  	 * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
  	 * @param {number} [srcLevel=0] - The source mip level to copy from.
  	 * @param {number} [dstLevel=0] - The destination mip level to copy to.
  	 */
  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {

  		this.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel );

  	}

  	/**
  	 * Copies the current bound framebuffer to the given texture.
  	 *
  	 * @param {Texture} texture - The destination texture.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  	 */
  	copyFramebufferToTexture( texture, renderContext, rectangle ) {

  		this.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );

  	}

  	/**
  	 * Configures the active framebuffer from the given render context.
  	 *
  	 * @private
  	 * @param {RenderContext} descriptor - The render context.
  	 */
  	_setFramebuffer( descriptor ) {

  		const { gl, state } = this;

  		let currentFrameBuffer = null;

  		if ( descriptor.textures !== null ) {

  			const renderTarget = descriptor.renderTarget;
  			const renderTargetContextData = this.get( renderTarget );
  			const { samples, depthBuffer, stencilBuffer } = renderTarget;

  			const isCube = renderTarget.isWebGLCubeRenderTarget === true;
  			const isRenderTarget3D = renderTarget.isRenderTarget3D === true;
  			const isRenderTargetArray = renderTarget.depth > 1;
  			const isXRRenderTarget = renderTarget.isXRRenderTarget === true;
  			const _hasExternalTextures = ( isXRRenderTarget === true && renderTarget._hasExternalTextures === true );

  			let msaaFb = renderTargetContextData.msaaFrameBuffer;
  			let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
  			const multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );
  			const multiviewExt = this.extensions.get( 'OVR_multiview2' );
  			const useMultisampledRTT = this._useMultisampledExtension( renderTarget );
  			const cacheKey = getCacheKey( descriptor );

  			let fb;

  			if ( isCube ) {

  				renderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );

  				fb = renderTargetContextData.cubeFramebuffers[ cacheKey ];

  			} else if ( isXRRenderTarget && _hasExternalTextures === false ) {

  				fb = this._xrFramebuffer;

  			} else {

  				renderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );

  				fb = renderTargetContextData.framebuffers[ cacheKey ];

  			}

  			if ( fb === undefined ) {

  				fb = gl.createFramebuffer();

  				state.bindFramebuffer( gl.FRAMEBUFFER, fb );

  				const textures = descriptor.textures;
  				const depthInvalidationArray = [];

  				if ( isCube ) {

  					renderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;

  					const { textureGPU } = this.get( textures[ 0 ] );

  					const cubeFace = this.renderer._activeCubeFace;

  					gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );

  				} else {

  					renderTargetContextData.framebuffers[ cacheKey ] = fb;

  					for ( let i = 0; i < textures.length; i ++ ) {

  						const texture = textures[ i ];
  						const textureData = this.get( texture );
  						textureData.renderTarget = descriptor.renderTarget;
  						textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

  						const attachment = gl.COLOR_ATTACHMENT0 + i;

  						if ( renderTarget.multiview ) {

  							multiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2 );

  						} else if ( isRenderTarget3D || isRenderTargetArray ) {

  							const layer = this.renderer._activeCubeFace;

  							gl.framebufferTextureLayer( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer );

  						} else {

  							if ( useMultisampledRTT ) {

  								multisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );

  							} else {

  								gl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );

  							}

  						}

  					}

  				}

  				const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

  				if ( renderTarget._autoAllocateDepthBuffer === true ) {

  					const renderbuffer = gl.createRenderbuffer();
  					this.textureUtils.setupRenderBufferStorage( renderbuffer, descriptor, 0, useMultisampledRTT );
  					renderTargetContextData.xrDepthRenderbuffer = renderbuffer;
  					depthInvalidationArray.push( stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT );

  					gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );
  					gl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );


  				} else {

  					if ( descriptor.depthTexture !== null ) {

  						depthInvalidationArray.push( stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT );

  						const textureData = this.get( descriptor.depthTexture );
  						textureData.renderTarget = descriptor.renderTarget;
  						textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

  						if ( renderTarget.multiview ) {

  							multiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2 );

  						} else if ( _hasExternalTextures && useMultisampledRTT ) {

  							multisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );

  						} else {

  							if ( descriptor.depthTexture.isArrayTexture ) {

  								const layer = this.renderer._activeCubeFace;

  								gl.framebufferTextureLayer( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer );

  							} else {

  								gl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );

  							}

  						}

  					}

  				}

  				renderTargetContextData.depthInvalidationArray = depthInvalidationArray;


  			} else {

  				const isRenderCameraDepthArray = this._isRenderCameraDepthArray( descriptor );

  				if ( isRenderCameraDepthArray ) {

  					state.bindFramebuffer( gl.FRAMEBUFFER, fb );

  					const layer = this.renderer._activeCubeFace;

  					const depthData = this.get( descriptor.depthTexture );
  					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
  					gl.framebufferTextureLayer(
  						gl.FRAMEBUFFER,
  						depthStyle,
  						depthData.textureGPU,
  						0,
  						layer
  					);

  				}

  				// rebind external XR textures

  				if ( ( isXRRenderTarget || useMultisampledRTT || renderTarget.multiview ) && ( renderTarget._isOpaqueFramebuffer !== true ) ) {

  					state.bindFramebuffer( gl.FRAMEBUFFER, fb );

  					// rebind color

  					const textureData = this.get( descriptor.textures[ 0 ] );

  					if ( renderTarget.multiview ) {

  						multiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2 );

  					} else if ( useMultisampledRTT ) {

  						multisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );

  					} else {

  						gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0 );

  					}

  					// rebind depth

  					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

  					if ( renderTarget._autoAllocateDepthBuffer === true ) {

  						const renderbuffer = renderTargetContextData.xrDepthRenderbuffer;
  						gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );
  						gl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );

  					} else {

  						const textureData = this.get( descriptor.depthTexture );

  						if ( renderTarget.multiview ) {

  							multiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2 );

  						} else if ( useMultisampledRTT ) {

  							multisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );

  						} else {

  							gl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );

  						}

  					}

  				}

  			}

  			if ( samples > 0 && useMultisampledRTT === false && ! renderTarget.multiview ) {

  				if ( msaaFb === undefined ) {

  					const invalidationArray = [];

  					msaaFb = gl.createFramebuffer();

  					state.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );

  					const msaaRenderbuffers = [];

  					const textures = descriptor.textures;

  					for ( let i = 0; i < textures.length; i ++ ) {

  						msaaRenderbuffers[ i ] = gl.createRenderbuffer();

  						gl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );

  						invalidationArray.push( gl.COLOR_ATTACHMENT0 + i );

  						const texture = descriptor.textures[ i ];
  						const textureData = this.get( texture );

  						gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );
  						gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );


  					}

  					gl.bindRenderbuffer( gl.RENDERBUFFER, null );

  					renderTargetContextData.msaaFrameBuffer = msaaFb;
  					renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;

  					if ( depthBuffer && depthRenderbuffer === undefined ) {

  						depthRenderbuffer = gl.createRenderbuffer();
  						this.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor, samples );

  						renderTargetContextData.depthRenderbuffer = depthRenderbuffer;

  						const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
  						invalidationArray.push( depthStyle );

  					}

  					renderTargetContextData.invalidationArray = invalidationArray;

  				}

  				currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;

  			} else {

  				currentFrameBuffer = fb;

  			}

  			state.drawBuffers( descriptor, fb );

  		}

  		state.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );

  	}

  	/**
  	 * Computes the VAO key for the given index and attributes.
  	 *
  	 * @private
  	 * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
  	 * @return {string} The VAO key.
  	 */
  	_getVaoKey( attributes ) {

  		let key = '';

  		for ( let i = 0; i < attributes.length; i ++ ) {

  			const attributeData = this.get( attributes[ i ] );

  			key += ':' + attributeData.id;

  		}

  		return key;

  	}

  	/**
  	 * Creates a VAO from the index and attributes.
  	 *
  	 * @private
  	 * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
  	 * @return {Object} The VAO data.
  	 */
  	_createVao( attributes ) {

  		const { gl } = this;

  		const vaoGPU = gl.createVertexArray();

  		gl.bindVertexArray( vaoGPU );

  		for ( let i = 0; i < attributes.length; i ++ ) {

  			const attribute = attributes[ i ];
  			const attributeData = this.get( attribute );

  			gl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );
  			gl.enableVertexAttribArray( i );

  			let stride, offset;

  			if ( attribute.isInterleavedBufferAttribute === true ) {

  				stride = attribute.data.stride * attributeData.bytesPerElement;
  				offset = attribute.offset * attributeData.bytesPerElement;

  			} else {

  				stride = 0;
  				offset = 0;

  			}

  			if ( attributeData.isInteger ) {

  				gl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );

  			} else {

  				gl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );

  			}

  			if ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {

  				gl.vertexAttribDivisor( i, attribute.meshPerAttribute );

  			} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {

  				gl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );

  			}

  		}

  		gl.bindBuffer( gl.ARRAY_BUFFER, null );

  		return vaoGPU;

  	}

  	/**
  	 * Creates a transform feedback from the given transform buffers.
  	 *
  	 * @private
  	 * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
  	 * @return {WebGLTransformFeedback} The transform feedback.
  	 */
  	_getTransformFeedback( transformBuffers ) {

  		let key = '';

  		for ( let i = 0; i < transformBuffers.length; i ++ ) {

  			key += ':' + transformBuffers[ i ].id;

  		}

  		let transformFeedbackGPU = this.transformFeedbackCache[ key ];

  		if ( transformFeedbackGPU !== undefined ) {

  			return transformFeedbackGPU;

  		}

  		const { gl } = this;

  		transformFeedbackGPU = gl.createTransformFeedback();

  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );

  		for ( let i = 0; i < transformBuffers.length; i ++ ) {

  			const attributeData = transformBuffers[ i ];

  			gl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );

  		}

  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

  		this.transformFeedbackCache[ key ] = transformFeedbackGPU;

  		return transformFeedbackGPU;

  	}

  	/**
  	 * Setups the given bindings.
  	 *
  	 * @private
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 * @param {WebGLProgram} programGPU - The WebGL program.
  	 */
  	_setupBindings( bindings, programGPU ) {

  		const gl = this.gl;

  		for ( const bindGroup of bindings ) {

  			for ( const binding of bindGroup.bindings ) {

  				const bindingData = this.get( binding );
  				const index = bindingData.index;

  				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  					const location = gl.getUniformBlockIndex( programGPU, binding.name );
  					gl.uniformBlockBinding( programGPU, location, index );

  				} else if ( binding.isSampledTexture ) {

  					const location = gl.getUniformLocation( programGPU, binding.name );
  					gl.uniform1i( location, index );

  				}

  			}

  		}

  	}

  	/**
  	 * Binds the given uniforms.
  	 *
  	 * @private
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 */
  	_bindUniforms( bindings ) {

  		const { gl, state } = this;

  		for ( const bindGroup of bindings ) {

  			for ( const binding of bindGroup.bindings ) {

  				const bindingData = this.get( binding );
  				const index = bindingData.index;

  				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  					// TODO USE bindBufferRange to group multiple uniform buffers
  					state.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );

  				} else if ( binding.isSampledTexture ) {

  					state.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );

  				}

  			}

  		}

  	}

  	/**
  	 * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
  	 * should be used when MSAA is enabled.
  	 *
  	 * @private
  	 * @param {RenderTarget} renderTarget - The render target that should be multisampled.
  	 * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
  	 */
  	_useMultisampledExtension( renderTarget ) {

  		if ( renderTarget.multiview === true ) {

  			return true;

  		}

  		return renderTarget.samples > 0 && this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTarget._autoAllocateDepthBuffer !== false;

  	}

  	/**
  	 * Frees internal resources.
  	 */
  	dispose() {

  		const extension = this.extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) extension.loseContext();

  		this.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );

  	}

  }

  const GPUPrimitiveTopology = {
  	PointList: 'point-list',
  	LineList: 'line-list',
  	LineStrip: 'line-strip',
  	TriangleList: 'triangle-list',
  	TriangleStrip: 'triangle-strip',
  };

  const GPUCompareFunction = {
  	Never: 'never',
  	Less: 'less',
  	Equal: 'equal',
  	LessEqual: 'less-equal',
  	Greater: 'greater',
  	NotEqual: 'not-equal',
  	GreaterEqual: 'greater-equal',
  	Always: 'always'
  };

  const GPUStoreOp = {
  	Store: 'store'};

  const GPULoadOp = {
  	Load: 'load',
  	Clear: 'clear'
  };

  const GPUFrontFace = {
  	CCW: 'ccw'};

  const GPUCullMode = {
  	None: 'none',
  	Front: 'front',
  	Back: 'back'
  };

  const GPUIndexFormat = {
  	Uint16: 'uint16',
  	Uint32: 'uint32'
  };

  const GPUTextureFormat = {

  	// 8-bit formats

  	R8Unorm: 'r8unorm',
  	R8Snorm: 'r8snorm',
  	R8Uint: 'r8uint',
  	R8Sint: 'r8sint',

  	// 16-bit formats

  	R16Uint: 'r16uint',
  	R16Sint: 'r16sint',
  	R16Float: 'r16float',
  	RG8Unorm: 'rg8unorm',
  	RG8Snorm: 'rg8snorm',
  	RG8Uint: 'rg8uint',
  	RG8Sint: 'rg8sint',

  	// 32-bit formats

  	R32Uint: 'r32uint',
  	R32Sint: 'r32sint',
  	R32Float: 'r32float',
  	RG16Uint: 'rg16uint',
  	RG16Sint: 'rg16sint',
  	RG16Float: 'rg16float',
  	RGBA8Unorm: 'rgba8unorm',
  	RGBA8UnormSRGB: 'rgba8unorm-srgb',
  	RGBA8Snorm: 'rgba8snorm',
  	RGBA8Uint: 'rgba8uint',
  	RGBA8Sint: 'rgba8sint',
  	BGRA8Unorm: 'bgra8unorm',
  	BGRA8UnormSRGB: 'bgra8unorm-srgb',
  	// Packed 32-bit formats
  	RGB9E5UFloat: 'rgb9e5ufloat',
  	RGB10A2Unorm: 'rgb10a2unorm',
  	RG11B10UFloat: 'rgb10a2unorm',

  	// 64-bit formats

  	RG32Uint: 'rg32uint',
  	RG32Sint: 'rg32sint',
  	RG32Float: 'rg32float',
  	RGBA16Uint: 'rgba16uint',
  	RGBA16Sint: 'rgba16sint',
  	RGBA16Float: 'rgba16float',

  	// 128-bit formats

  	RGBA32Uint: 'rgba32uint',
  	RGBA32Sint: 'rgba32sint',
  	RGBA32Float: 'rgba32float',

  	Depth16Unorm: 'depth16unorm',
  	Depth24Plus: 'depth24plus',
  	Depth24PlusStencil8: 'depth24plus-stencil8',
  	Depth32Float: 'depth32float',

  	// 'depth32float-stencil8' extension

  	Depth32FloatStencil8: 'depth32float-stencil8',

  	// BC compressed formats usable if 'texture-compression-bc' is both
  	// supported by the device/user agent and enabled in requestDevice.

  	BC1RGBAUnorm: 'bc1-rgba-unorm',
  	BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
  	BC2RGBAUnorm: 'bc2-rgba-unorm',
  	BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
  	BC3RGBAUnorm: 'bc3-rgba-unorm',
  	BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
  	BC4RUnorm: 'bc4-r-unorm',
  	BC4RSnorm: 'bc4-r-snorm',
  	BC5RGUnorm: 'bc5-rg-unorm',
  	BC5RGSnorm: 'bc5-rg-snorm',
  	BC6HRGBUFloat: 'bc6h-rgb-ufloat',
  	BC6HRGBFloat: 'bc6h-rgb-float',
  	BC7RGBAUnorm: 'bc7-rgba-unorm',
  	BC7RGBAUnormSRGB: 'bc7-rgba-srgb',

  	// ETC2 compressed formats usable if 'texture-compression-etc2' is both
  	// supported by the device/user agent and enabled in requestDevice.

  	ETC2RGB8Unorm: 'etc2-rgb8unorm',
  	ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
  	ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
  	ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
  	ETC2RGBA8Unorm: 'etc2-rgba8unorm',
  	ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
  	EACR11Unorm: 'eac-r11unorm',
  	EACR11Snorm: 'eac-r11snorm',
  	EACRG11Unorm: 'eac-rg11unorm',
  	EACRG11Snorm: 'eac-rg11snorm',

  	// ASTC compressed formats usable if 'texture-compression-astc' is both
  	// supported by the device/user agent and enabled in requestDevice.

  	ASTC4x4Unorm: 'astc-4x4-unorm',
  	ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
  	ASTC5x4Unorm: 'astc-5x4-unorm',
  	ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
  	ASTC5x5Unorm: 'astc-5x5-unorm',
  	ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
  	ASTC6x5Unorm: 'astc-6x5-unorm',
  	ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
  	ASTC6x6Unorm: 'astc-6x6-unorm',
  	ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
  	ASTC8x5Unorm: 'astc-8x5-unorm',
  	ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
  	ASTC8x6Unorm: 'astc-8x6-unorm',
  	ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
  	ASTC8x8Unorm: 'astc-8x8-unorm',
  	ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
  	ASTC10x5Unorm: 'astc-10x5-unorm',
  	ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
  	ASTC10x6Unorm: 'astc-10x6-unorm',
  	ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
  	ASTC10x8Unorm: 'astc-10x8-unorm',
  	ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
  	ASTC10x10Unorm: 'astc-10x10-unorm',
  	ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
  	ASTC12x10Unorm: 'astc-12x10-unorm',
  	ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
  	ASTC12x12Unorm: 'astc-12x12-unorm',
  	ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',

  };

  const GPUAddressMode = {
  	ClampToEdge: 'clamp-to-edge',
  	Repeat: 'repeat',
  	MirrorRepeat: 'mirror-repeat'
  };

  const GPUFilterMode = {
  	Linear: 'linear',
  	Nearest: 'nearest'
  };

  const GPUBlendFactor = {
  	Zero: 'zero',
  	One: 'one',
  	Src: 'src',
  	OneMinusSrc: 'one-minus-src',
  	SrcAlpha: 'src-alpha',
  	OneMinusSrcAlpha: 'one-minus-src-alpha',
  	Dst: 'dst',
  	OneMinusDst: 'one-minus-dst',
  	DstAlpha: 'dst-alpha',
  	OneMinusDstAlpha: 'one-minus-dst-alpha',
  	SrcAlphaSaturated: 'src-alpha-saturated',
  	Constant: 'constant',
  	OneMinusConstant: 'one-minus-constant'
  };

  const GPUBlendOperation = {
  	Add: 'add',
  	Subtract: 'subtract',
  	ReverseSubtract: 'reverse-subtract',
  	Min: 'min',
  	Max: 'max'
  };

  const GPUColorWriteFlags = {
  	None: 0,
  	All: 0xF
  };

  const GPUStencilOperation = {
  	Keep: 'keep',
  	Zero: 'zero',
  	Replace: 'replace',
  	Invert: 'invert',
  	IncrementClamp: 'increment-clamp',
  	DecrementClamp: 'decrement-clamp',
  	IncrementWrap: 'increment-wrap',
  	DecrementWrap: 'decrement-wrap'
  };

  const GPUBufferBindingType = {
  	Storage: 'storage',
  	ReadOnlyStorage: 'read-only-storage'
  };

  const GPUStorageTextureAccess = {
  	WriteOnly: 'write-only',
  	ReadOnly: 'read-only',
  	ReadWrite: 'read-write',
  };

  const GPUSamplerBindingType = {
  	NonFiltering: 'non-filtering',
  	Comparison: 'comparison'
  };

  const GPUTextureSampleType = {
  	Float: 'float',
  	UnfilterableFloat: 'unfilterable-float',
  	Depth: 'depth',
  	SInt: 'sint',
  	UInt: 'uint'
  };

  const GPUTextureDimension = {
  	TwoD: '2d',
  	ThreeD: '3d'
  };

  const GPUTextureViewDimension = {
  	TwoD: '2d',
  	TwoDArray: '2d-array',
  	Cube: 'cube',
  	ThreeD: '3d'
  };

  const GPUTextureAspect = {
  	All: 'all'};

  const GPUInputStepMode = {
  	Vertex: 'vertex',
  	Instance: 'instance'
  };

  const GPUFeatureName = {
  	CoreFeaturesAndLimits: 'core-features-and-limits',
  	DepthClipControl: 'depth-clip-control',
  	Depth32FloatStencil8: 'depth32float-stencil8',
  	TextureCompressionBC: 'texture-compression-bc',
  	TextureCompressionBCSliced3D: 'texture-compression-bc-sliced-3d',
  	TextureCompressionETC2: 'texture-compression-etc2',
  	TextureCompressionASTC: 'texture-compression-astc',
  	TextureCompressionASTCSliced3D: 'texture-compression-astc-sliced-3d',
  	TimestampQuery: 'timestamp-query',
  	IndirectFirstInstance: 'indirect-first-instance',
  	ShaderF16: 'shader-f16',
  	RG11B10UFloat: 'rg11b10ufloat-renderable',
  	BGRA8UNormStorage: 'bgra8unorm-storage',
  	Float32Filterable: 'float32-filterable',
  	Float32Blendable: 'float32-blendable',
  	ClipDistances: 'clip-distances',
  	DualSourceBlending: 'dual-source-blending',
  	Subgroups: 'subgroups',
  	TextureFormatsTier1: 'texture-formats-tier1',
  	TextureFormatsTier2: 'texture-formats-tier2'
  };

  /**
   * Represents a sampler binding type.
   *
   * @private
   * @augments Binding
   */
  class Sampler extends Binding {

  	/**
  	 * Constructs a new sampler.
  	 *
  	 * @param {string} name - The samplers's name.
  	 * @param {?Texture} texture - The texture this binding is referring to.
  	 */
  	constructor( name, texture ) {

  		super( name );

  		/**
  		 * The texture the sampler is referring to.
  		 *
  		 * @type {?Texture}
  		 */
  		this.texture = texture;

  		/**
  		 * The binding's version.
  		 *
  		 * @type {number}
  		 */
  		this.version = texture ? texture.version : 0;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSampler = true;

  	}

  }

  /**
   * A special form of sampler binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments Sampler
   */
  class NodeSampler extends Sampler {

  	/**
  	 * Constructs a new node-based sampler.
  	 *
  	 * @param {string} name - The samplers's name.
  	 * @param {TextureNode} textureNode - The texture node.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 */
  	constructor( name, textureNode, groupNode ) {

  		super( name, textureNode ? textureNode.value : null );

  		/**
  		 * The texture node.
  		 *
  		 * @type {TextureNode}
  		 */
  		this.textureNode = textureNode;

  		/**
  		 * The uniform group node.
  		 *
  		 * @type {UniformGroupNode}
  		 */
  		this.groupNode = groupNode;

  	}

  	/**
  	 * Updates the texture value of this sampler.
  	 */
  	update() {

  		this.texture = this.textureNode.value;

  	}

  }

  /**
   * Represents a storage buffer binding type.
   *
   * @private
   * @augments Buffer
   */
  class StorageBuffer extends Buffer {

  	/**
  	 * Constructs a new uniform buffer.
  	 *
  	 * @param {string} name - The buffer's name.
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	constructor( name, attribute ) {

  		super( name, attribute ? attribute.array : null );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {BufferAttribute}
  		 */
  		this.attribute = attribute;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isStorageBuffer = true;

  	}

  }

  let _id = 0;

  /**
   * A special form of storage buffer binding type.
   * It's buffer value is managed by a node object.
   *
   * @private
   * @augments StorageBuffer
   */
  class NodeStorageBuffer extends StorageBuffer {

  	/**
  	 * Constructs a new node-based storage buffer.
  	 *
  	 * @param {StorageBufferNode} nodeUniform - The storage buffer node.
  	 * @param {UniformGroupNode} groupNode - The uniform group node.
  	 */
  	constructor( nodeUniform, groupNode ) {

  		super( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );

  		/**
  		 * The node uniform.
  		 *
  		 * @type {StorageBufferNode}
  		 */
  		this.nodeUniform = nodeUniform;

  		/**
  		 * The access type.
  		 *
  		 * @type {string}
  		 */
  		this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;

  		/**
  		 * The uniform group node.
  		 *
  		 * @type {UniformGroupNode}
  		 */
  		this.groupNode = groupNode;

  	}

  	/**
  	 * The storage buffer.
  	 *
  	 * @type {BufferAttribute}
  	 */
  	get buffer() {

  		return this.nodeUniform.value;

  	}

  }

  /**
   * A WebGPU backend utility module used by {@link WebGPUTextureUtils}.
   *
   * @private
   */
  class WebGPUTexturePassUtils extends DataMap {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {GPUDevice} device - The WebGPU device.
  	 */
  	constructor( device ) {

  		super();

  		/**
  		 * The WebGPU device.
  		 *
  		 * @type {GPUDevice}
  		 */
  		this.device = device;

  		const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;

  		const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;

  		const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;

  		/**
  		 * The mipmap GPU sampler.
  		 *
  		 * @type {GPUSampler}
  		 */
  		this.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );

  		/**
  		 * The flipY GPU sampler.
  		 *
  		 * @type {GPUSampler}
  		 */
  		this.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()

  		/**
  		 * A cache for GPU render pipelines used for copy/transfer passes.
  		 * Every texture format requires a unique pipeline.
  		 *
  		 * @type {Object<string,GPURenderPipeline>}
  		 */
  		this.transferPipelines = {};

  		/**
  		 * A cache for GPU render pipelines used for flipY passes.
  		 * Every texture format requires a unique pipeline.
  		 *
  		 * @type {Object<string,GPURenderPipeline>}
  		 */
  		this.flipYPipelines = {};

  		/**
  		 * The mipmap vertex shader module.
  		 *
  		 * @type {GPUShaderModule}
  		 */
  		this.mipmapVertexShaderModule = device.createShaderModule( {
  			label: 'mipmapVertex',
  			code: mipmapVertexSource
  		} );

  		/**
  		 * The mipmap fragment shader module.
  		 *
  		 * @type {GPUShaderModule}
  		 */
  		this.mipmapFragmentShaderModule = device.createShaderModule( {
  			label: 'mipmapFragment',
  			code: mipmapFragmentSource
  		} );

  		/**
  		 * The flipY fragment shader module.
  		 *
  		 * @type {GPUShaderModule}
  		 */
  		this.flipYFragmentShaderModule = device.createShaderModule( {
  			label: 'flipYFragment',
  			code: flipYFragmentSource
  		} );

  	}

  	/**
  	 * Returns a render pipeline for the internal copy render pass. The pass
  	 * requires a unique render pipeline for each texture format.
  	 *
  	 * @param {string} format - The GPU texture format
  	 * @return {GPURenderPipeline} The GPU render pipeline.
  	 */
  	getTransferPipeline( format ) {

  		let pipeline = this.transferPipelines[ format ];

  		if ( pipeline === undefined ) {

  			pipeline = this.device.createRenderPipeline( {
  				label: `mipmap-${ format }`,
  				vertex: {
  					module: this.mipmapVertexShaderModule,
  					entryPoint: 'main'
  				},
  				fragment: {
  					module: this.mipmapFragmentShaderModule,
  					entryPoint: 'main',
  					targets: [ { format } ]
  				},
  				primitive: {
  					topology: GPUPrimitiveTopology.TriangleStrip,
  					stripIndexFormat: GPUIndexFormat.Uint32
  				},
  				layout: 'auto'
  			} );

  			this.transferPipelines[ format ] = pipeline;

  		}

  		return pipeline;

  	}

  	/**
  	 * Returns a render pipeline for the flipY render pass. The pass
  	 * requires a unique render pipeline for each texture format.
  	 *
  	 * @param {string} format - The GPU texture format
  	 * @return {GPURenderPipeline} The GPU render pipeline.
  	 */
  	getFlipYPipeline( format ) {

  		let pipeline = this.flipYPipelines[ format ];

  		if ( pipeline === undefined ) {

  			pipeline = this.device.createRenderPipeline( {
  				label: `flipY-${ format }`,
  				vertex: {
  					module: this.mipmapVertexShaderModule,
  					entryPoint: 'main'
  				},
  				fragment: {
  					module: this.flipYFragmentShaderModule,
  					entryPoint: 'main',
  					targets: [ { format } ]
  				},
  				primitive: {
  					topology: GPUPrimitiveTopology.TriangleStrip,
  					stripIndexFormat: GPUIndexFormat.Uint32
  				},
  				layout: 'auto'
  			} );

  			this.flipYPipelines[ format ] = pipeline;

  		}

  		return pipeline;

  	}

  	/**
  	 * Flip the contents of the given GPU texture along its vertical axis.
  	 *
  	 * @param {GPUTexture} textureGPU - The GPU texture object.
  	 * @param {Object} textureGPUDescriptor - The texture descriptor.
  	 * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
  	 */
  	flipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

  		const format = textureGPUDescriptor.format;
  		const { width, height } = textureGPUDescriptor.size;

  		const transferPipeline = this.getTransferPipeline( format );
  		const flipYPipeline = this.getFlipYPipeline( format );

  		const tempTexture = this.device.createTexture( {
  			size: { width, height, depthOrArrayLayers: 1 },
  			format,
  			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
  		} );

  		const srcView = textureGPU.createView( {
  			baseMipLevel: 0,
  			mipLevelCount: 1,
  			dimension: GPUTextureViewDimension.TwoD,
  			baseArrayLayer
  		} );

  		const dstView = tempTexture.createView( {
  			baseMipLevel: 0,
  			mipLevelCount: 1,
  			dimension: GPUTextureViewDimension.TwoD,
  			baseArrayLayer: 0
  		} );

  		const commandEncoder = this.device.createCommandEncoder( {} );

  		const pass = ( pipeline, sourceView, destinationView ) => {

  			const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

  			const bindGroup = this.device.createBindGroup( {
  				layout: bindGroupLayout,
  				entries: [ {
  					binding: 0,
  					resource: this.flipYSampler
  				}, {
  					binding: 1,
  					resource: sourceView
  				} ]
  			} );

  			const passEncoder = commandEncoder.beginRenderPass( {
  				colorAttachments: [ {
  					view: destinationView,
  					loadOp: GPULoadOp.Clear,
  					storeOp: GPUStoreOp.Store,
  					clearValue: [ 0, 0, 0, 0 ]
  				} ]
  			} );

  			passEncoder.setPipeline( pipeline );
  			passEncoder.setBindGroup( 0, bindGroup );
  			passEncoder.draw( 4, 1, 0, 0 );
  			passEncoder.end();

  		};

  		pass( transferPipeline, srcView, dstView );
  		pass( flipYPipeline, dstView, srcView );

  		this.device.queue.submit( [ commandEncoder.finish() ] );

  		tempTexture.destroy();

  	}

  	/**
  	 * Generates mipmaps for the given GPU texture.
  	 *
  	 * @param {GPUTexture} textureGPU - The GPU texture object.
  	 * @param {Object} textureGPUDescriptor - The texture descriptor.
  	 * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
  	 */
  	generateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

  		const textureData = this.get( textureGPU );

  		if ( textureData.useCount === undefined ) {

  			textureData.useCount = 0;
  			textureData.layers = [];

  		}

  		const passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );

  		const commandEncoder = this.device.createCommandEncoder( {} );

  		this._mipmapRunBundles( commandEncoder, passes );

  		this.device.queue.submit( [ commandEncoder.finish() ] );

  		if ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;

  		textureData.useCount ++;

  	}

  	/**
  	 * Since multiple copy render passes are required to generate mipmaps, the passes
  	 * are managed as render bundles to improve performance.
  	 *
  	 * @param {GPUTexture} textureGPU - The GPU texture object.
  	 * @param {Object} textureGPUDescriptor - The texture descriptor.
  	 * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
  	 * @return {Array<Object>} An array of render bundles.
  	 */
  	_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {

  		const pipeline = this.getTransferPipeline( textureGPUDescriptor.format );

  		const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

  		let srcView = textureGPU.createView( {
  			baseMipLevel: 0,
  			mipLevelCount: 1,
  			dimension: GPUTextureViewDimension.TwoD,
  			baseArrayLayer
  		} );

  		const passes = [];

  		for ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {

  			const bindGroup = this.device.createBindGroup( {
  				layout: bindGroupLayout,
  				entries: [ {
  					binding: 0,
  					resource: this.mipmapSampler
  				}, {
  					binding: 1,
  					resource: srcView
  				} ]
  			} );

  			const dstView = textureGPU.createView( {
  				baseMipLevel: i,
  				mipLevelCount: 1,
  				dimension: GPUTextureViewDimension.TwoD,
  				baseArrayLayer
  			} );

  			const passDescriptor = {
  				colorAttachments: [ {
  					view: dstView,
  					loadOp: GPULoadOp.Clear,
  					storeOp: GPUStoreOp.Store,
  					clearValue: [ 0, 0, 0, 0 ]
  				} ]
  			};

  			const passEncoder = this.device.createRenderBundleEncoder( {
  				colorFormats: [ textureGPUDescriptor.format ]
  			} );

  			passEncoder.setPipeline( pipeline );
  			passEncoder.setBindGroup( 0, bindGroup );
  			passEncoder.draw( 4, 1, 0, 0 );

  			passes.push( {
  				renderBundles: [ passEncoder.finish() ],
  				passDescriptor
  			} );

  			srcView = dstView;

  		}

  		return passes;

  	}

  	/**
  	 * Executes the render bundles.
  	 *
  	 * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
  	 * @param {Array<Object>} passes - An array of render bundles.
  	 */
  	_mipmapRunBundles( commandEncoder, passes ) {

  		const levels = passes.length;

  		for ( let i = 0; i < levels; i ++ ) {

  			const pass = passes[ i ];

  			const passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );

  			passEncoder.executeBundles( pass.renderBundles );

  			passEncoder.end();

  		}

  	}

  }

  const _compareToWebGPU = {
  	[ NeverCompare ]: 'never',
  	[ LessCompare ]: 'less',
  	[ EqualCompare ]: 'equal',
  	[ LessEqualCompare ]: 'less-equal',
  	[ GreaterCompare ]: 'greater',
  	[ GreaterEqualCompare ]: 'greater-equal',
  	[ AlwaysCompare ]: 'always',
  	[ NotEqualCompare ]: 'not-equal'
  };

  const _flipMap = [ 0, 1, 3, 2, 4, 5 ];

  /**
   * A WebGPU backend utility module for managing textures.
   *
   * @private
   */
  class WebGPUTextureUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGPUBackend} backend - The WebGPU backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGPU backend.
  		 *
  		 * @type {WebGPUBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A reference to the pass utils.
  		 *
  		 * @type {?WebGPUTexturePassUtils}
  		 * @default null
  		 */
  		this._passUtils = null;

  		/**
  		 * A dictionary for managing default textures. The key
  		 * is the texture format, the value the texture object.
  		 *
  		 * @type {Object<string,Texture>}
  		 */
  		this.defaultTexture = {};

  		/**
  		 * A dictionary for managing default cube textures. The key
  		 * is the texture format, the value the texture object.
  		 *
  		 * @type {Object<string,CubeTexture>}
  		 */
  		this.defaultCubeTexture = {};

  		/**
  		 * A default video frame.
  		 *
  		 * @type {?VideoFrame}
  		 * @default null
  		 */
  		this.defaultVideoFrame = null;

  		/**
  		 * Represents the color attachment of the default framebuffer.
  		 *
  		 * @type {?GPUTexture}
  		 * @default null
  		 */
  		this.colorBuffer = null;

  		/**
  		 * Represents the depth attachment of the default framebuffer.
  		 *
  		 * @type {DepthTexture}
  		 */
  		this.depthTexture = new DepthTexture();
  		this.depthTexture.name = 'depthBuffer';

  	}

  	/**
  	 * Creates a GPU sampler for the given texture.
  	 *
  	 * @param {Texture} texture - The texture to create the sampler for.
  	 */
  	createSampler( texture ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const textureGPU = backend.get( texture );

  		const samplerDescriptorGPU = {
  			addressModeU: this._convertAddressMode( texture.wrapS ),
  			addressModeV: this._convertAddressMode( texture.wrapT ),
  			addressModeW: this._convertAddressMode( texture.wrapR ),
  			magFilter: this._convertFilterMode( texture.magFilter ),
  			minFilter: this._convertFilterMode( texture.minFilter ),
  			mipmapFilter: this._convertFilterMode( texture.minFilter ),
  			maxAnisotropy: 1
  		};

  		// anisotropy can only be used when all filter modes are set to linear.

  		if ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {

  			samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;

  		}

  		if ( texture.isDepthTexture && texture.compareFunction !== null ) {

  			samplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];

  		}

  		textureGPU.sampler = device.createSampler( samplerDescriptorGPU );

  	}

  	/**
  	 * Creates a default texture for the given texture that can be used
  	 * as a placeholder until the actual texture is ready for usage.
  	 *
  	 * @param {Texture} texture - The texture to create a default texture for.
  	 */
  	createDefaultTexture( texture ) {

  		let textureGPU;

  		const format = getFormat( texture );

  		if ( texture.isCubeTexture ) {

  			textureGPU = this._getDefaultCubeTextureGPU( format );

  		} else if ( texture.isVideoTexture ) {

  			this.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();

  		} else {

  			textureGPU = this._getDefaultTextureGPU( format );

  		}

  		this.backend.get( texture ).texture = textureGPU;

  	}

  	/**
  	 * Defines a texture on the GPU for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	createTexture( texture, options = {} ) {

  		const backend = this.backend;
  		const textureData = backend.get( texture );

  		if ( textureData.initialized ) {

  			throw new Error( 'WebGPUTextureUtils: Texture already initialized.' );

  		}

  		if ( options.needsMipmaps === undefined ) options.needsMipmaps = false;
  		if ( options.levels === undefined ) options.levels = 1;
  		if ( options.depth === undefined ) options.depth = 1;

  		const { width, height, depth, levels } = options;

  		if ( texture.isFramebufferTexture ) {

  			if ( options.renderTarget ) {

  				options.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );

  			} else {

  				options.format = this.backend.utils.getPreferredCanvasFormat();

  			}

  		}

  		const dimension = this._getDimension( texture );
  		const format = texture.internalFormat || options.format || getFormat( texture, backend.device );

  		textureData.format = format;

  		const { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );

  		let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;

  		if ( texture.isStorageTexture === true ) {

  			usage |= GPUTextureUsage.STORAGE_BINDING;

  		}

  		if ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {

  			usage |= GPUTextureUsage.RENDER_ATTACHMENT;

  		}

  		const textureDescriptorGPU = {
  			label: texture.name,
  			size: {
  				width: width,
  				height: height,
  				depthOrArrayLayers: depth,
  			},
  			mipLevelCount: levels,
  			sampleCount: primarySamples,
  			dimension: dimension,
  			format: format,
  			usage: usage
  		};

  		// texture creation

  		if ( texture.isVideoTexture ) {

  			const video = texture.source.data;
  			const videoFrame = new VideoFrame( video );

  			textureDescriptorGPU.size.width = videoFrame.displayWidth;
  			textureDescriptorGPU.size.height = videoFrame.displayHeight;

  			videoFrame.close();

  			textureData.externalTexture = video;

  		} else {

  			if ( format === undefined ) {

  				console.warn( 'WebGPURenderer: Texture format not supported.' );

  				this.createDefaultTexture( texture );
  				return;

  			}

  			if ( texture.isCubeTexture ) {

  				textureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;

  			}

  			textureData.texture = backend.device.createTexture( textureDescriptorGPU );

  		}

  		if ( isMSAA ) {

  			const msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );

  			msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
  			msaaTextureDescriptorGPU.sampleCount = samples;

  			textureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );

  		}

  		textureData.initialized = true;

  		textureData.textureDescriptorGPU = textureDescriptorGPU;

  	}

  	/**
  	 * Destroys the GPU data for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	destroyTexture( texture ) {

  		const backend = this.backend;
  		const textureData = backend.get( texture );

  		if ( textureData.texture !== undefined ) textureData.texture.destroy();

  		if ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();

  		backend.delete( texture );

  	}

  	/**
  	 * Destroys the GPU sampler for the given texture.
  	 *
  	 * @param {Texture} texture - The texture to destroy the sampler for.
  	 */
  	destroySampler( texture ) {

  		const backend = this.backend;
  		const textureData = backend.get( texture );

  		delete textureData.sampler;

  	}

  	/**
  	 * Generates mipmaps for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	generateMipmaps( texture ) {

  		const textureData = this.backend.get( texture );

  		if ( texture.isCubeTexture ) {

  			for ( let i = 0; i < 6; i ++ ) {

  				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

  			}

  		} else {

  			const depth = texture.image.depth || 1;

  			for ( let i = 0; i < depth; i ++ ) {

  				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

  			}

  		}

  	}

  	/**
  	 * Returns the color buffer representing the color
  	 * attachment of the default framebuffer.
  	 *
  	 * @return {GPUTexture} The color buffer.
  	 */
  	getColorBuffer() {

  		if ( this.colorBuffer ) this.colorBuffer.destroy();

  		const backend = this.backend;
  		const { width, height } = backend.getDrawingBufferSize();

  		this.colorBuffer = backend.device.createTexture( {
  			label: 'colorBuffer',
  			size: {
  				width: width,
  				height: height,
  				depthOrArrayLayers: 1
  			},
  			sampleCount: backend.utils.getSampleCount( backend.renderer.samples ),
  			format: backend.utils.getPreferredCanvasFormat(),
  			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
  		} );

  		return this.colorBuffer;

  	}

  	/**
  	 * Returns the depth buffer representing the depth
  	 * attachment of the default framebuffer.
  	 *
  	 * @param {boolean} [depth=true] - Whether depth is enabled or not.
  	 * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
  	 * @return {GPUTexture} The depth buffer.
  	 */
  	getDepthBuffer( depth = true, stencil = false ) {

  		const backend = this.backend;
  		const { width, height } = backend.getDrawingBufferSize();

  		const depthTexture = this.depthTexture;
  		const depthTextureGPU = backend.get( depthTexture ).texture;

  		let format, type;

  		if ( stencil ) {

  			format = DepthStencilFormat;
  			type = UnsignedInt248Type;

  		} else if ( depth ) {

  			format = DepthFormat;
  			type = UnsignedIntType;

  		}

  		if ( depthTextureGPU !== undefined ) {

  			if ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {

  				return depthTextureGPU;

  			}

  			this.destroyTexture( depthTexture );

  		}

  		depthTexture.name = 'depthBuffer';
  		depthTexture.format = format;
  		depthTexture.type = type;
  		depthTexture.image.width = width;
  		depthTexture.image.height = height;

  		this.createTexture( depthTexture, { width, height } );

  		return backend.get( depthTexture ).texture;

  	}

  	/**
  	 * Uploads the updated texture data to the GPU.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	updateTexture( texture, options ) {

  		const textureData = this.backend.get( texture );

  		const { textureDescriptorGPU } = textureData;

  		if ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )
  			return;

  		// transfer texture data

  		if ( texture.isDataTexture ) {

  			this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

  		} else if ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {

  			for ( let i = 0; i < options.image.depth; i ++ ) {

  				this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );

  			}

  		} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {

  			this._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );

  		} else if ( texture.isCubeTexture ) {

  			this._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY, texture.premultiplyAlpha );

  		} else if ( texture.isVideoTexture ) {

  			const video = texture.source.data;

  			textureData.externalTexture = video;

  		} else {

  			this._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY, texture.premultiplyAlpha );

  		}

  		//

  		textureData.version = texture.version;

  		if ( texture.onUpdate ) texture.onUpdate( texture );

  	}

  	/**
  	 * Returns texture data as a typed array.
  	 *
  	 * @async
  	 * @param {Texture} texture - The texture to copy.
  	 * @param {number} x - The x coordinate of the copy origin.
  	 * @param {number} y - The y coordinate of the copy origin.
  	 * @param {number} width - The width of the copy.
  	 * @param {number} height - The height of the copy.
  	 * @param {number} faceIndex - The face index.
  	 * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
  	 */
  	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		const device = this.backend.device;

  		const textureData = this.backend.get( texture );
  		const textureGPU = textureData.texture;
  		const format = textureData.textureDescriptorGPU.format;
  		const bytesPerTexel = this._getBytesPerTexel( format );

  		let bytesPerRow = width * bytesPerTexel;
  		bytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes

  		const readBuffer = device.createBuffer(
  			{
  				size: width * height * bytesPerTexel,
  				usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  			}
  		);

  		const encoder = device.createCommandEncoder();

  		encoder.copyTextureToBuffer(
  			{
  				texture: textureGPU,
  				origin: { x, y, z: faceIndex },
  			},
  			{
  				buffer: readBuffer,
  				bytesPerRow: bytesPerRow
  			},
  			{
  				width: width,
  				height: height
  			}

  		);

  		const typedArrayType = this._getTypedArrayType( format );

  		device.queue.submit( [ encoder.finish() ] );

  		await readBuffer.mapAsync( GPUMapMode.READ );

  		const buffer = readBuffer.getMappedRange();

  		return new typedArrayType( buffer );

  	}

  	/**
  	 * Returns the default GPU texture for the given format.
  	 *
  	 * @private
  	 * @param {string} format - The GPU format.
  	 * @return {GPUTexture} The GPU texture.
  	 */
  	_getDefaultTextureGPU( format ) {

  		let defaultTexture = this.defaultTexture[ format ];

  		if ( defaultTexture === undefined ) {

  			const texture = new Texture();
  			texture.minFilter = NearestFilter;
  			texture.magFilter = NearestFilter;

  			this.createTexture( texture, { width: 1, height: 1, format } );

  			this.defaultTexture[ format ] = defaultTexture = texture;

  		}

  		return this.backend.get( defaultTexture ).texture;

  	}

  	/**
  	 * Returns the default GPU cube texture for the given format.
  	 *
  	 * @private
  	 * @param {string} format - The GPU format.
  	 * @return {GPUTexture} The GPU texture.
  	 */
  	_getDefaultCubeTextureGPU( format ) {

  		let defaultCubeTexture = this.defaultTexture[ format ];

  		if ( defaultCubeTexture === undefined ) {

  			const texture = new CubeTexture();
  			texture.minFilter = NearestFilter;
  			texture.magFilter = NearestFilter;

  			this.createTexture( texture, { width: 1, height: 1, depth: 6 } );

  			this.defaultCubeTexture[ format ] = defaultCubeTexture = texture;

  		}

  		return this.backend.get( defaultCubeTexture ).texture;

  	}

  	/**
  	 * Returns the default video frame used as default data in context of video textures.
  	 *
  	 * @private
  	 * @return {VideoFrame} The video frame.
  	 */
  	_getDefaultVideoFrame() {

  		let defaultVideoFrame = this.defaultVideoFrame;

  		if ( defaultVideoFrame === null ) {

  			const init = {
  				timestamp: 0,
  				codedWidth: 1,
  				codedHeight: 1,
  				format: 'RGBA',
  			};

  			this.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );

  		}

  		return defaultVideoFrame;

  	}

  	/**
  	 * Uploads cube texture image data to the GPU memory.
  	 *
  	 * @private
  	 * @param {Array} images - The cube image data.
  	 * @param {GPUTexture} textureGPU - The GPU texture.
  	 * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
  	 * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
  	 * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
  	 */
  	_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY, premultiplyAlpha ) {

  		for ( let i = 0; i < 6; i ++ ) {

  			const image = images[ i ];

  			const flipIndex = flipY === true ? _flipMap[ i ] : i;

  			if ( image.isDataTexture ) {

  				this._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

  			} else {

  				this._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY, premultiplyAlpha );

  			}

  		}

  	}

  	/**
  	 * Uploads texture image data to the GPU memory.
  	 *
  	 * @private
  	 * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
  	 * @param {GPUTexture} textureGPU - The GPU texture.
  	 * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
  	 * @param {number} originDepth - The origin depth.
  	 * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
  	 * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
  	 */
  	_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha ) {

  		const device = this.backend.device;

  		device.queue.copyExternalImageToTexture(
  			{
  				source: image,
  				flipY: flipY
  			}, {
  				texture: textureGPU,
  				mipLevel: 0,
  				origin: { x: 0, y: 0, z: originDepth },
  				premultipliedAlpha: premultiplyAlpha
  			}, {
  				width: image.width,
  				height: image.height,
  				depthOrArrayLayers: 1
  			}
  		);

  	}

  	/**
  	 * Returns the pass utils singleton.
  	 *
  	 * @private
  	 * @return {WebGPUTexturePassUtils} The utils instance.
  	 */
  	_getPassUtils() {

  		let passUtils = this._passUtils;

  		if ( passUtils === null ) {

  			this._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );

  		}

  		return passUtils;

  	}

  	/**
  	 * Generates mipmaps for the given GPU texture.
  	 *
  	 * @private
  	 * @param {GPUTexture} textureGPU - The GPU texture object.
  	 * @param {Object} textureDescriptorGPU - The texture descriptor.
  	 * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
  	 */
  	_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {

  		this._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );

  	}

  	/**
  	 * Flip the contents of the given GPU texture along its vertical axis.
  	 *
  	 * @private
  	 * @param {GPUTexture} textureGPU - The GPU texture object.
  	 * @param {Object} textureDescriptorGPU - The texture descriptor.
  	 * @param {number} [originDepth=0] - The origin depth.
  	 */
  	_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {

  		this._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );

  	}

  	/**
  	 * Uploads texture buffer data to the GPU memory.
  	 *
  	 * @private
  	 * @param {Object} image - An object defining the image buffer data.
  	 * @param {GPUTexture} textureGPU - The GPU texture.
  	 * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
  	 * @param {number} originDepth - The origin depth.
  	 * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
  	 * @param {number} [depth=0] - TODO.
  	 */
  	_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {

  		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
  		// @TODO: Consider to support valid buffer layouts with other formats like RGB

  		const device = this.backend.device;

  		const data = image.data;

  		const bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );
  		const bytesPerRow = image.width * bytesPerTexel;

  		device.queue.writeTexture(
  			{
  				texture: textureGPU,
  				mipLevel: 0,
  				origin: { x: 0, y: 0, z: originDepth }
  			},
  			data,
  			{
  				offset: image.width * image.height * bytesPerTexel * depth,
  				bytesPerRow
  			},
  			{
  				width: image.width,
  				height: image.height,
  				depthOrArrayLayers: 1
  			} );

  		if ( flipY === true ) {

  			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

  		}

  	}

  	/**
  	 * Uploads compressed texture data to the GPU memory.
  	 *
  	 * @private
  	 * @param {Array<Object>} mipmaps - An array with mipmap data.
  	 * @param {GPUTexture} textureGPU - The GPU texture.
  	 * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
  	 */
  	_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {

  		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

  		const device = this.backend.device;

  		const blockData = this._getBlockData( textureDescriptorGPU.format );
  		const isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;

  		for ( let i = 0; i < mipmaps.length; i ++ ) {

  			const mipmap = mipmaps[ i ];

  			const width = mipmap.width;
  			const height = mipmap.height;
  			const depth = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;

  			const bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;
  			const bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );

  			for ( let j = 0; j < depth; j ++ ) {

  				device.queue.writeTexture(
  					{
  						texture: textureGPU,
  						mipLevel: i,
  						origin: { x: 0, y: 0, z: j }
  					},
  					mipmap.data,
  					{
  						offset: j * bytesPerImage,
  						bytesPerRow,
  						rowsPerImage: Math.ceil( height / blockData.height )
  					},
  					{
  						width: Math.ceil( width / blockData.width ) * blockData.width,
  						height: Math.ceil( height / blockData.height ) * blockData.height,
  						depthOrArrayLayers: 1
  					}
  				);

  			}

  		}

  	}

  	/**
  	 * This method is only relevant for compressed texture formats. It returns a block
  	 * data descriptor for the given GPU compressed texture format.
  	 *
  	 * @private
  	 * @param {string} format - The GPU compressed texture format.
  	 * @return {Object} The block data descriptor.
  	 */
  	_getBlockData( format ) {

  		if ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1
  		if ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3
  		if ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5
  		if ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSnorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
  		if ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
  		if ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
  		if ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)

  		if ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };

  		if ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };
  		if ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };
  		if ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };
  		if ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };
  		if ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };
  		if ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };
  		if ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };
  		if ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };
  		if ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };
  		if ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };
  		if ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };
  		if ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };
  		if ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };

  	}

  	/**
  	 * Converts the three.js uv wrapping constants to GPU address mode constants.
  	 *
  	 * @private
  	 * @param {number} value - The three.js constant defining a uv wrapping mode.
  	 * @return {string} The GPU address mode.
  	 */
  	_convertAddressMode( value ) {

  		let addressMode = GPUAddressMode.ClampToEdge;

  		if ( value === RepeatWrapping ) {

  			addressMode = GPUAddressMode.Repeat;

  		} else if ( value === MirroredRepeatWrapping ) {

  			addressMode = GPUAddressMode.MirrorRepeat;

  		}

  		return addressMode;

  	}

  	/**
  	 * Converts the three.js filter constants to GPU filter constants.
  	 *
  	 * @private
  	 * @param {number} value - The three.js constant defining a filter mode.
  	 * @return {string} The GPU filter mode.
  	 */
  	_convertFilterMode( value ) {

  		let filterMode = GPUFilterMode.Linear;

  		if ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {

  			filterMode = GPUFilterMode.Nearest;

  		}

  		return filterMode;

  	}

  	/**
  	 * Returns the bytes-per-texel value for the given GPU texture format.
  	 *
  	 * @private
  	 * @param {string} format - The GPU texture format.
  	 * @return {number} The bytes-per-texel.
  	 */
  	_getBytesPerTexel( format ) {

  		// 8-bit formats
  		if ( format === GPUTextureFormat.R8Unorm ||
  			format === GPUTextureFormat.R8Snorm ||
  			format === GPUTextureFormat.R8Uint ||
  			format === GPUTextureFormat.R8Sint ) return 1;

  		// 16-bit formats
  		if ( format === GPUTextureFormat.R16Uint ||
  			format === GPUTextureFormat.R16Sint ||
  			format === GPUTextureFormat.R16Float ||
  			format === GPUTextureFormat.RG8Unorm ||
  			format === GPUTextureFormat.RG8Snorm ||
  			format === GPUTextureFormat.RG8Uint ||
  			format === GPUTextureFormat.RG8Sint ) return 2;

  		// 32-bit formats
  		if ( format === GPUTextureFormat.R32Uint ||
  			format === GPUTextureFormat.R32Sint ||
  			format === GPUTextureFormat.R32Float ||
  			format === GPUTextureFormat.RG16Uint ||
  			format === GPUTextureFormat.RG16Sint ||
  			format === GPUTextureFormat.RG16Float ||
  			format === GPUTextureFormat.RGBA8Unorm ||
  			format === GPUTextureFormat.RGBA8UnormSRGB ||
  			format === GPUTextureFormat.RGBA8Snorm ||
  			format === GPUTextureFormat.RGBA8Uint ||
  			format === GPUTextureFormat.RGBA8Sint ||
  			format === GPUTextureFormat.BGRA8Unorm ||
  			format === GPUTextureFormat.BGRA8UnormSRGB ||
  			// Packed 32-bit formats
  			format === GPUTextureFormat.RGB9E5UFloat ||
  			format === GPUTextureFormat.RGB10A2Unorm ||
  			format === GPUTextureFormat.RG11B10UFloat ||
  			format === GPUTextureFormat.Depth32Float ||
  			format === GPUTextureFormat.Depth24Plus ||
  			format === GPUTextureFormat.Depth24PlusStencil8 ||
  			format === GPUTextureFormat.Depth32FloatStencil8 ) return 4;

  		// 64-bit formats
  		if ( format === GPUTextureFormat.RG32Uint ||
  			format === GPUTextureFormat.RG32Sint ||
  			format === GPUTextureFormat.RG32Float ||
  			format === GPUTextureFormat.RGBA16Uint ||
  			format === GPUTextureFormat.RGBA16Sint ||
  			format === GPUTextureFormat.RGBA16Float ) return 8;

  		// 128-bit formats
  		if ( format === GPUTextureFormat.RGBA32Uint ||
  			format === GPUTextureFormat.RGBA32Sint ||
  			format === GPUTextureFormat.RGBA32Float ) return 16;


  	}

  	/**
  	 * Returns the corresponding typed array type for the given GPU texture format.
  	 *
  	 * @private
  	 * @param {string} format - The GPU texture format.
  	 * @return {TypedArray.constructor} The typed array type.
  	 */
  	_getTypedArrayType( format ) {

  		if ( format === GPUTextureFormat.R8Uint ) return Uint8Array;
  		if ( format === GPUTextureFormat.R8Sint ) return Int8Array;
  		if ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.R8Snorm ) return Int8Array;
  		if ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;
  		if ( format === GPUTextureFormat.RG8Sint ) return Int8Array;
  		if ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;
  		if ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;
  		if ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;
  		if ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;


  		if ( format === GPUTextureFormat.R16Uint ) return Uint16Array;
  		if ( format === GPUTextureFormat.R16Sint ) return Int16Array;
  		if ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;
  		if ( format === GPUTextureFormat.RG16Sint ) return Int16Array;
  		if ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;
  		if ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;
  		if ( format === GPUTextureFormat.R16Float ) return Uint16Array;
  		if ( format === GPUTextureFormat.RG16Float ) return Uint16Array;
  		if ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;


  		if ( format === GPUTextureFormat.R32Uint ) return Uint32Array;
  		if ( format === GPUTextureFormat.R32Sint ) return Int32Array;
  		if ( format === GPUTextureFormat.R32Float ) return Float32Array;
  		if ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;
  		if ( format === GPUTextureFormat.RG32Sint ) return Int32Array;
  		if ( format === GPUTextureFormat.RG32Float ) return Float32Array;
  		if ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;
  		if ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;
  		if ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;

  		if ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;
  		if ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;
  		if ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;
  		if ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;

  		if ( format === GPUTextureFormat.Depth32Float ) return Float32Array;
  		if ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;
  		if ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;
  		if ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;

  	}

  	/**
  	 * Returns the GPU dimensions for the given texture.
  	 *
  	 * @private
  	 * @param {Texture} texture - The texture.
  	 * @return {string} The GPU dimension.
  	 */
  	_getDimension( texture ) {

  		let dimension;

  		if ( texture.is3DTexture || texture.isData3DTexture ) {

  			dimension = GPUTextureDimension.ThreeD;

  		} else {

  			dimension = GPUTextureDimension.TwoD;

  		}

  		return dimension;

  	}

  }

  /**
   * Returns the GPU format for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {?GPUDevice} [device=null] - The GPU device which is used for feature detection.
   * It is not necessary to apply the device for most formats.
   * @return {string} The GPU format.
   */
  function getFormat( texture, device = null ) {

  	const format = texture.format;
  	const type = texture.type;
  	const colorSpace = texture.colorSpace;
  	const transfer = ColorManagement.getTransfer( colorSpace );

  	let formatGPU;

  	if ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {

  		switch ( format ) {

  			case RGBA_S3TC_DXT1_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
  				break;

  			case RGBA_S3TC_DXT3_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
  				break;

  			case RGBA_S3TC_DXT5_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
  				break;

  			case RGB_ETC2_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
  				break;

  			case RGBA_ETC2_EAC_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
  				break;

  			case RGBA_ASTC_4x4_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
  				break;

  			case RGBA_ASTC_5x4_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
  				break;

  			case RGBA_ASTC_5x5_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
  				break;

  			case RGBA_ASTC_6x5_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
  				break;

  			case RGBA_ASTC_6x6_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
  				break;

  			case RGBA_ASTC_8x5_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
  				break;

  			case RGBA_ASTC_8x6_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
  				break;

  			case RGBA_ASTC_8x8_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
  				break;

  			case RGBA_ASTC_10x5_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
  				break;

  			case RGBA_ASTC_10x6_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
  				break;

  			case RGBA_ASTC_10x8_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
  				break;

  			case RGBA_ASTC_10x10_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
  				break;

  			case RGBA_ASTC_12x10_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
  				break;

  			case RGBA_ASTC_12x12_Format:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
  				break;

  			case RGBAFormat:
  				formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
  				break;

  			default:
  				console.error( 'WebGPURenderer: Unsupported texture format.', format );

  		}

  	} else {

  		switch ( format ) {

  			case RGBAFormat:

  				switch ( type ) {

  					case ByteType:
  						formatGPU = GPUTextureFormat.RGBA8Snorm;
  						break;

  					case ShortType:
  						formatGPU = GPUTextureFormat.RGBA16Sint;
  						break;

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.RGBA16Uint;
  						break;
  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RGBA32Uint;
  						break;

  					case IntType:
  						formatGPU = GPUTextureFormat.RGBA32Sint;
  						break;

  					case UnsignedByteType:
  						formatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
  						break;

  					case HalfFloatType:
  						formatGPU = GPUTextureFormat.RGBA16Float;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.RGBA32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );

  				}

  				break;

  			case RGBFormat:

  				switch ( type ) {

  					case UnsignedInt5999Type:
  						formatGPU = GPUTextureFormat.RGB9E5UFloat;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );

  				}

  				break;

  			case RedFormat:

  				switch ( type ) {

  					case ByteType:
  						formatGPU = GPUTextureFormat.R8Snorm;
  						break;

  					case ShortType:
  						formatGPU = GPUTextureFormat.R16Sint;
  						break;

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.R16Uint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.R32Uint;
  						break;

  					case IntType:
  						formatGPU = GPUTextureFormat.R32Sint;
  						break;

  					case UnsignedByteType:
  						formatGPU = GPUTextureFormat.R8Unorm;
  						break;

  					case HalfFloatType:
  						formatGPU = GPUTextureFormat.R16Float;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.R32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );

  				}

  				break;

  			case RGFormat:

  				switch ( type ) {

  					case ByteType:
  						formatGPU = GPUTextureFormat.RG8Snorm;
  						break;

  					case ShortType:
  						formatGPU = GPUTextureFormat.RG16Sint;
  						break;

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.RG16Uint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RG32Uint;
  						break;

  					case IntType:
  						formatGPU = GPUTextureFormat.RG32Sint;
  						break;

  					case UnsignedByteType:
  						formatGPU = GPUTextureFormat.RG8Unorm;
  						break;

  					case HalfFloatType:
  						formatGPU = GPUTextureFormat.RG16Float;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.RG32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );

  				}

  				break;

  			case DepthFormat:

  				switch ( type ) {

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.Depth16Unorm;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.Depth24Plus;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.Depth32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );

  				}

  				break;

  			case DepthStencilFormat:

  				switch ( type ) {

  					case UnsignedInt248Type:
  						formatGPU = GPUTextureFormat.Depth24PlusStencil8;
  						break;

  					case FloatType:

  						if ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {

  							console.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.' );

  						}

  						formatGPU = GPUTextureFormat.Depth32FloatStencil8;

  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );

  				}

  				break;

  			case RedIntegerFormat:

  				switch ( type ) {

  					case IntType:
  						formatGPU = GPUTextureFormat.R32Sint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.R32Uint;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );

  				}

  				break;

  			case RGIntegerFormat:

  				switch ( type ) {

  					case IntType:
  						formatGPU = GPUTextureFormat.RG32Sint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RG32Uint;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );

  				}

  				break;

  			case RGBAIntegerFormat:

  				switch ( type ) {

  					case IntType:
  						formatGPU = GPUTextureFormat.RGBA32Sint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RGBA32Uint;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );

  				}

  				break;

  			default:
  				console.error( 'WebGPURenderer: Unsupported texture format.', format );

  		}

  	}

  	return formatGPU;

  }

  const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
  const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;

  const wgslTypeLib$1 = {
  	'f32': 'float',
  	'i32': 'int',
  	'u32': 'uint',
  	'bool': 'bool',

  	'vec2<f32>': 'vec2',
   	'vec2<i32>': 'ivec2',
   	'vec2<u32>': 'uvec2',
   	'vec2<bool>': 'bvec2',

  	'vec2f': 'vec2',
  	'vec2i': 'ivec2',
  	'vec2u': 'uvec2',
  	'vec2b': 'bvec2',

  	'vec3<f32>': 'vec3',
  	'vec3<i32>': 'ivec3',
  	'vec3<u32>': 'uvec3',
  	'vec3<bool>': 'bvec3',

  	'vec3f': 'vec3',
  	'vec3i': 'ivec3',
  	'vec3u': 'uvec3',
  	'vec3b': 'bvec3',

  	'vec4<f32>': 'vec4',
  	'vec4<i32>': 'ivec4',
  	'vec4<u32>': 'uvec4',
  	'vec4<bool>': 'bvec4',

  	'vec4f': 'vec4',
  	'vec4i': 'ivec4',
  	'vec4u': 'uvec4',
  	'vec4b': 'bvec4',

  	'mat2x2<f32>': 'mat2',
  	'mat2x2f': 'mat2',

  	'mat3x3<f32>': 'mat3',
  	'mat3x3f': 'mat3',

  	'mat4x4<f32>': 'mat4',
  	'mat4x4f': 'mat4',

  	'sampler': 'sampler',

  	'texture_1d': 'texture',

  	'texture_2d': 'texture',
  	'texture_2d_array': 'texture',
  	'texture_multisampled_2d': 'cubeTexture',

  	'texture_depth_2d': 'depthTexture',
  	'texture_depth_2d_array': 'depthTexture',
  	'texture_depth_multisampled_2d': 'depthTexture',
  	'texture_depth_cube': 'depthTexture',
  	'texture_depth_cube_array': 'depthTexture',

  	'texture_3d': 'texture3D',

  	'texture_cube': 'cubeTexture',
  	'texture_cube_array': 'cubeTexture',

  	'texture_storage_1d': 'storageTexture',
  	'texture_storage_2d': 'storageTexture',
  	'texture_storage_2d_array': 'storageTexture',
  	'texture_storage_3d': 'storageTexture'

  };

  const parse = ( source ) => {

  	source = source.trim();

  	const declaration = source.match( declarationRegexp );

  	if ( declaration !== null && declaration.length === 4 ) {

  		const inputsCode = declaration[ 2 ];
  		const propsMatches = [];
  		let match = null;

  		while ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {

  			propsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );

  		}

  		// Process matches to correctly pair names and types
  		const inputs = [];
  		for ( let i = 0; i < propsMatches.length; i ++ ) {

  			const { name, type } = propsMatches[ i ];

  			let resolvedType = type;

  			if ( resolvedType.startsWith( 'ptr' ) ) {

  				resolvedType = 'pointer';

  			} else {

  				if ( resolvedType.startsWith( 'texture' ) ) {

  					resolvedType = type.split( '<' )[ 0 ];

  				}

  				resolvedType = wgslTypeLib$1[ resolvedType ];

  			}

  			inputs.push( new NodeFunctionInput( resolvedType, name ) );

  		}

  		const blockCode = source.substring( declaration[ 0 ].length );
  		const outputType = declaration[ 3 ] || 'void';

  		const name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';
  		const type = wgslTypeLib$1[ outputType ] || outputType;

  		return {
  			type,
  			inputs,
  			name,
  			inputsCode,
  			blockCode,
  			outputType
  		};

  	} else {

  		throw new Error( 'FunctionNode: Function is not a WGSL code.' );

  	}

  };

  /**
   * This class represents a WSL node function.
   *
   * @augments NodeFunction
   */
  class WGSLNodeFunction extends NodeFunction {

  	/**
  	 * Constructs a new WGSL node function.
  	 *
  	 * @param {string} source - The WGSL source.
  	 */
  	constructor( source ) {

  		const { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );

  		super( type, inputs, name );

  		this.inputsCode = inputsCode;
  		this.blockCode = blockCode;
  		this.outputType = outputType;

  	}

  	/**
  	 * This method returns the WGSL code of the node function.
  	 *
  	 * @param {string} [name=this.name] - The function's name.
  	 * @return {string} The shader code.
  	 */
  	getCode( name = this.name ) {

  		const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';

  		return `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;

  	}

  }

  /**
   * A WGSL node parser.
   *
   * @augments NodeParser
   */
  class WGSLNodeParser extends NodeParser {

  	/**
  	 * The method parses the given WGSL code an returns a node function.
  	 *
  	 * @param {string} source - The WGSL code.
  	 * @return {WGSLNodeFunction} A node function.
  	 */
  	parseFunction( source ) {

  		return new WGSLNodeFunction( source );

  	}

  }

  // GPUShaderStage is not defined in browsers not supporting WebGPU
  const GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };

  const accessNames = {
  	[ NodeAccess.READ_ONLY ]: 'read',
  	[ NodeAccess.WRITE_ONLY ]: 'write',
  	[ NodeAccess.READ_WRITE ]: 'read_write'
  };

  const wrapNames = {
  	[ RepeatWrapping ]: 'repeat',
  	[ ClampToEdgeWrapping ]: 'clamp',
  	[ MirroredRepeatWrapping ]: 'mirror'
  };

  const gpuShaderStageLib = {
  	'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
  	'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
  	'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
  };

  const supports = {
  	instance: true,
  	swizzleAssign: false,
  	storageBuffer: true
  };

  const wgslFnOpLib = {
  	'^^': 'tsl_xor'
  };

  const wgslTypeLib = {
  	float: 'f32',
  	int: 'i32',
  	uint: 'u32',
  	bool: 'bool',
  	color: 'vec3<f32>',

  	vec2: 'vec2<f32>',
  	ivec2: 'vec2<i32>',
  	uvec2: 'vec2<u32>',
  	bvec2: 'vec2<bool>',

  	vec3: 'vec3<f32>',
  	ivec3: 'vec3<i32>',
  	uvec3: 'vec3<u32>',
  	bvec3: 'vec3<bool>',

  	vec4: 'vec4<f32>',
  	ivec4: 'vec4<i32>',
  	uvec4: 'vec4<u32>',
  	bvec4: 'vec4<bool>',

  	mat2: 'mat2x2<f32>',
  	mat3: 'mat3x3<f32>',
  	mat4: 'mat4x4<f32>'
  };

  const wgslCodeCache = {};

  const wgslPolyfill = {
  	tsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),
  	mod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),
  	mod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),
  	mod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),
  	mod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),
  	equals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),
  	equals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),
  	equals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),
  	equals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),
  	repeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),
  	mirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),
  	clampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),
  	biquadraticTexture: new CodeNode( /* wgsl */`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
` )
  };

  const wgslMethods = {
  	dFdx: 'dpdx',
  	dFdy: '- dpdy',
  	mod_float: 'tsl_mod_float',
  	mod_vec2: 'tsl_mod_vec2',
  	mod_vec3: 'tsl_mod_vec3',
  	mod_vec4: 'tsl_mod_vec4',
  	equals_bool: 'tsl_equals_bool',
  	equals_bvec2: 'tsl_equals_bvec2',
  	equals_bvec3: 'tsl_equals_bvec3',
  	equals_bvec4: 'tsl_equals_bvec4',
  	inversesqrt: 'inverseSqrt',
  	bitcast: 'bitcast<f32>'
  };

  // WebGPU issue: does not support pow() with negative base on Windows

  if ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {

  	wgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );
  	wgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );
  	wgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );
  	wgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );

  	wgslMethods.pow_float = 'tsl_pow_float';
  	wgslMethods.pow_vec2 = 'tsl_pow_vec2';
  	wgslMethods.pow_vec3 = 'tsl_pow_vec3';
  	wgslMethods.pow_vec4 = 'tsl_pow_vec4';

  }

  //

  let diagnostics = '';

  if ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {

  	diagnostics += 'diagnostic( off, derivative_uniformity );\n';

  }

  /**
   * A node builder targeting WGSL.
   *
   * This module generates WGSL shader code from node materials and also
   * generates the respective bindings and vertex buffer definitions. These
   * data are later used by the renderer to create render and compute pipelines
   * for render objects.
   *
   * @augments NodeBuilder
   */
  class WGSLNodeBuilder extends NodeBuilder {

  	/**
  	 * Constructs a new WGSL node builder renderer.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Renderer} renderer - The renderer.
  	 */
  	constructor( object, renderer ) {

  		super( object, renderer, new WGSLNodeParser() );

  		/**
  		 * A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')
  		 * another dictionary which manages UBOs per group ('render','frame','object').
  		 *
  		 * @type {Object<string,Object<string,NodeUniformsGroup>>}
  		 */
  		this.uniformGroups = {};

  		/**
  		 * A dictionary that holds for each shader stage a Map of builtins.
  		 *
  		 * @type {Object<string,Map<string,Object>>}
  		 */
  		this.builtins = {};

  		/**
  		 * A dictionary that holds for each shader stage a Set of directives.
  		 *
  		 * @type {Object<string,Set<string>>}
  		 */
  		this.directives = {};

  		/**
  		 * A map for managing scope arrays. Only relevant for when using
  		 * {@link WorkgroupInfoNode} in context of compute shaders.
  		 *
  		 * @type {Map<string,Object>}
  		 */
  		this.scopedArrays = new Map();

  	}

  	/**
  	 * Checks if the given texture requires a manual conversion to the working color space.
  	 *
  	 * @param {Texture} texture - The texture to check.
  	 * @return {boolean} Whether the given texture requires a conversion to working color space or not.
  	 */
  	needsToWorkingColorSpace( texture ) {

  		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

  	}

  	/**
  	 * Generates the WGSL snippet for sampled textures.
  	 *
  	 * @private
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			if ( depthSnippet ) {

  				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;

  			} else {

  				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;

  			}

  		} else {

  			return this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, '0', depthSnippet );

  		}

  	}

  	/**
  	 * Generates the WGSL snippet when sampling video textures.
  	 *
  	 * @private
  	 * @param {string} textureProperty - The name of the video texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			return `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );

  		}

  	}

  	/**
  	 * Generates the WGSL snippet when sampling textures with explicit mip level.
  	 *
  	 * @private
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @return {string} The WGSL snippet.
  	 */
  	_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet ) {

  		if ( this.isUnfilterable( texture ) === false ) {

  			return `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;

  		} else if ( this.isFilteredTexture( texture ) ) {

  			return this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );

  		} else {

  			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );

  		}

  	}

  	/**
  	 * Generates a wrap function used in context of textures.
  	 *
  	 * @param {Texture} texture - The texture to generate the function for.
  	 * @return {string} The name of the generated function.
  	 */
  	generateWrapFunction( texture ) {

  		const functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }_${ texture.isData3DTexture ? '3d' : '2d' }T`;

  		let nodeCode = wgslCodeCache[ functionName ];

  		if ( nodeCode === undefined ) {

  			const includes = [];

  			// For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate
  			const coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';
  			let code = `fn ${ functionName }( coord : ${ coordType } ) -> ${ coordType } {\n\n\treturn ${ coordType }(\n`;

  			const addWrapSnippet = ( wrap, axis ) => {

  				if ( wrap === RepeatWrapping ) {

  					includes.push( wgslPolyfill.repeatWrapping_float );

  					code += `\t\ttsl_repeatWrapping_float( coord.${ axis } )`;

  				} else if ( wrap === ClampToEdgeWrapping ) {

  					includes.push( wgslPolyfill.clampWrapping_float );

  					code += `\t\ttsl_clampWrapping_float( coord.${ axis } )`;

  				} else if ( wrap === MirroredRepeatWrapping ) {

  					includes.push( wgslPolyfill.mirrorWrapping_float );

  					code += `\t\ttsl_mirrorWrapping_float( coord.${ axis } )`;

  				} else {

  					code += `\t\tcoord.${ axis }`;

  					console.warn( `WebGPURenderer: Unsupported texture wrap type "${ wrap }" for vertex shader.` );

  				}

  			};

  			addWrapSnippet( texture.wrapS, 'x' );

  			code += ',\n';

  			addWrapSnippet( texture.wrapT, 'y' );

  			if ( texture.isData3DTexture ) {

  				code += ',\n';
  				addWrapSnippet( texture.wrapR, 'z' );

  			}

  			code += '\n\t);\n\n}\n';

  			wgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );

  		}

  		nodeCode.build( this );

  		return functionName;

  	}

  	/**
  	 * Generates the array declaration string.
  	 *
  	 * @param {string} type - The type.
  	 * @param {?number} [count] - The count.
  	 * @return {string} The generated value as a shader string.
  	 */
  	generateArrayDeclaration( type, count ) {

  		return `array< ${ this.getType( type ) }, ${ count } >`;

  	}

  	/**
  	 * Generates a WGSL variable that holds the texture dimension of the given texture.
  	 * It also returns information about the number of layers (elements) of an arrayed
  	 * texture as well as the cube face count of cube textures.
  	 *
  	 * @param {Texture} texture - The texture to generate the function for.
  	 * @param {string} textureProperty - The name of the video texture uniform in the shader.
  	 * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @return {string} The name of the dimension variable.
  	 */
  	generateTextureDimension( texture, textureProperty, levelSnippet ) {

  		const textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );

  		if ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};

  		let textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];

  		if ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {

  			let textureDimensionsParams;
  			let dimensionType;

  			const { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );
  			const isMultisampled = primarySamples > 1;

  			if ( texture.isData3DTexture ) {

  				dimensionType = 'vec3<u32>';

  			} else {

  				// Regular 2D textures, depth textures, etc.
  				dimensionType = 'vec2<u32>';

  			}

  			// Build parameters string based on texture type and multisampling
  			if ( isMultisampled || texture.isVideoTexture || texture.isStorageTexture ) {

  				textureDimensionsParams = textureProperty;

  			} else {

  				textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${ levelSnippet } )` : ''}`;

  			}

  			textureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, dimensionType ) );

  			textureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;

  			if ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {

  				textureData.arrayLayerCount = new VarNode(
  					new ExpressionNode(
  						`textureNumLayers(${textureProperty})`,
  						'u32'
  					)
  				);

  			}

  			// For cube textures, we know it's always 6 faces
  			if ( texture.isTextureCube ) {

  				textureData.cubeFaceCount = new VarNode(
  					new ExpressionNode( '6u', 'u32' )
  				);

  			}

  		}

  		return textureDimensionNode.build( this );

  	}

  	/**
  	 * Generates the WGSL snippet for a manual filtered texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {

  		this._include( 'biquadraticTexture' );

  		const wrapFunction = this.generateWrapFunction( texture );
  		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

  		return `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;

  	}

  	/**
  	 * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
  	 * Since it's a lookup, no sampling or filtering is applied.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {

  		const wrapFunction = this.generateWrapFunction( texture );
  		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

  		const vecType = texture.isData3DTexture ? 'vec3' : 'vec2';
  		const coordSnippet = `${ vecType }<u32>( ${ wrapFunction }( ${ uvSnippet } ) * ${ vecType }<f32>( ${ textureDimension } ) )`;

  		return this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );

  	}

  	/**
  	 * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {

  		let snippet;

  		if ( texture.isVideoTexture === true ) {

  			snippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;

  		} else if ( depthSnippet ) {

  			snippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;

  		} else {

  			snippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;

  			if ( this.renderer.backend.compatibilityMode && texture.isDepthTexture ) {

  				snippet += '.x';

  			}

  		}

  		return snippet;

  	}

  	/**
  	 * Generates the WGSL snippet that writes a single texel to a texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureStore( texture, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet ) {

  		let snippet;

  		if ( depthSnippet ) {

  			snippet = `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, ${ valueSnippet } )`;

  		} else {

  			snippet = `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;

  		}

  		return snippet;

  	}

  	/**
  	 * Returns `true` if the sampled values of the given texture should be compared against a reference value.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
  	 */
  	isSampleCompare( texture ) {

  		return texture.isDepthTexture === true && texture.compareFunction !== null;

  	}

  	/**
  	 * Returns `true` if the given texture is unfilterable.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {boolean} Whether the given texture is unfilterable or not.
  	 */
  	isUnfilterable( texture ) {

  		return this.getComponentTypeFromTexture( texture ) !== 'float' ||
  			( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||
  			( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||
  			this.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;

  	}

  	/**
  	 * Generates the WGSL snippet for sampling/loading the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		let snippet = null;

  		if ( texture.isVideoTexture === true ) {

  			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

  		} else if ( this.isUnfilterable( texture ) ) {

  			snippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );

  		} else {

  			snippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );

  		}

  		return snippet;

  	}

  	/**
  	 * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
  			return `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );

  		}

  	}

  	/**
  	 * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
  	 * against a reference value.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			if ( texture.isDepthTexture === true && texture.isArrayTexture === true ) {

  				return `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } )`;

  			}

  			return `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

  		}

  	}

  	/**
  	 * Generates the WGSL snippet when sampling textures with explicit mip level.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		let snippet = null;

  		if ( texture.isVideoTexture === true ) {

  			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

  		} else {

  			snippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );

  		}

  		return snippet;

  	}

  	/**
  	 * Generates the WGSL snippet when sampling textures with a bias to the mip level.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {string} textureProperty - The name of the texture uniform in the shader.
  	 * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
  	 * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
  	 * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The WGSL snippet.
  	 */
  	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			return `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );

  		}

  	}

  	/**
  	 * Returns a WGSL snippet that represents the property name of the given node.
  	 *
  	 * @param {Node} node - The node.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The property name.
  	 */
  	getPropertyName( node, shaderStage = this.shaderStage ) {

  		if ( node.isNodeVarying === true && node.needsInterpolation === true ) {

  			if ( shaderStage === 'vertex' ) {

  				return `varyings.${ node.name }`;

  			}

  		} else if ( node.isNodeUniform === true ) {

  			const name = node.name;
  			const type = node.type;

  			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

  				return name;

  			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

  				if ( this.isCustomStruct( node ) ) {

  					return name;

  				}

  				return name + '.value';

  			} else {

  				return node.groupNode.name + '.' + name;

  			}

  		}

  		return super.getPropertyName( node );

  	}

  	/**
  	 * Returns the output struct name.
  	 *
  	 * @return {string} The name of the output struct.
  	 */
  	getOutputStructName() {

  		return 'output';

  	}

  	/**
  	 * Returns the native shader operator name for a given generic name.
  	 *
  	 * @param {string} op - The operator name to resolve.
  	 * @return {?string} The resolved operator name.
  	 */
  	getFunctionOperator( op ) {

  		const fnOp = wgslFnOpLib[ op ];

  		if ( fnOp !== undefined ) {

  			this._include( fnOp );

  			return fnOp;

  		}

  		return null;

  	}

  	/**
  	 * Returns the node access for the given node and shader stage.
  	 *
  	 * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The node access.
  	 */
  	getNodeAccess( node, shaderStage ) {

  		if ( shaderStage !== 'compute' )
  			return NodeAccess.READ_ONLY;

  		return node.access;

  	}

  	/**
  	 * Returns A WGSL snippet representing the storage access.
  	 *
  	 * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The WGSL snippet representing the storage access.
  	 */
  	getStorageAccess( node, shaderStage ) {

  		return accessNames[ this.getNodeAccess( node, shaderStage ) ];

  	}

  	/**
  	 * This method is one of the more important ones since it's responsible
  	 * for generating a matching binding instance for the given uniform node.
  	 *
  	 * These bindings are later used in the renderer to create bind groups
  	 * and layouts.
  	 *
  	 * @param {UniformNode} node - The uniform node.
  	 * @param {string} type - The node data type.
  	 * @param {string} shaderStage - The shader stage.
  	 * @param {?string} [name=null] - An optional uniform name.
  	 * @return {NodeUniform} The node uniform object.
  	 */
  	getUniformFromNode( node, type, shaderStage, name = null ) {

  		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		if ( nodeData.uniformGPU === undefined ) {

  			let uniformGPU;

  			const group = node.groupNode;
  			const groupName = group.name;

  			const bindings = this.getBindGroupArray( groupName, shaderStage );

  			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

  				let texture = null;

  				const access = this.getNodeAccess( node, shaderStage );

  				if ( type === 'texture' || type === 'storageTexture' ) {

  					texture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );

  				} else if ( type === 'cubeTexture' ) {

  					texture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );

  				} else if ( type === 'texture3D' ) {

  					texture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );

  				}

  				texture.store = node.isStorageTextureNode === true;
  				texture.setVisibility( gpuShaderStageLib[ shaderStage ] );

  				if ( this.isUnfilterable( node.value ) === false && texture.store === false ) {

  					const sampler = new NodeSampler( `${ uniformNode.name }_sampler`, uniformNode.node, group );
  					sampler.setVisibility( gpuShaderStageLib[ shaderStage ] );

  					bindings.push( sampler, texture );

  					uniformGPU = [ sampler, texture ];

  				} else {

  					bindings.push( texture );

  					uniformGPU = [ texture ];

  				}

  			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

  				const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;

  				const buffer = new bufferClass( node, group );
  				buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );

  				bindings.push( buffer );

  				uniformGPU = buffer;

  				uniformNode.name = name ? name : 'NodeBuffer_' + uniformNode.id;

  			} else {

  				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

  				let uniformsGroup = uniformsStage[ groupName ];

  				if ( uniformsGroup === undefined ) {

  					uniformsGroup = new NodeUniformsGroup( groupName, group );
  					uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

  					uniformsStage[ groupName ] = uniformsGroup;

  					bindings.push( uniformsGroup );

  				}

  				uniformGPU = this.getNodeUniform( uniformNode, type );

  				uniformsGroup.addUniform( uniformGPU );

  			}

  			nodeData.uniformGPU = uniformGPU;

  		}

  		return uniformNode;

  	}

  	/**
  	 * This method should be used whenever builtins are required in nodes.
  	 * The internal builtins data structure will make sure builtins are
  	 * defined in the WGSL source.
  	 *
  	 * @param {string} name - The builtin name.
  	 * @param {string} property - The property name.
  	 * @param {string} type - The node data type.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {string} The property name.
  	 */
  	getBuiltin( name, property, type, shaderStage = this.shaderStage ) {

  		const map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );

  		if ( map.has( name ) === false ) {

  			map.set( name, {
  				name,
  				property,
  				type
  			} );

  		}

  		return property;

  	}

  	/**
  	 * Returns `true` if the given builtin is defined in the given shader stage.
  	 *
  	 * @param {string} name - The builtin name.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
  	 * @return {boolean} Whether the given builtin is defined in the given shader stage or not.
  	 */
  	hasBuiltin( name, shaderStage = this.shaderStage ) {

  		return ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );

  	}

  	/**
  	 * Returns the vertex index builtin.
  	 *
  	 * @return {string} The vertex index.
  	 */
  	getVertexIndex() {

  		if ( this.shaderStage === 'vertex' ) {

  			return this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );

  		}

  		return 'vertexIndex';

  	}

  	/**
  	 * Builds the given shader node.
  	 *
  	 * @param {ShaderNodeInternal} shaderNode - The shader node.
  	 * @return {string} The WGSL function code.
  	 */
  	buildFunctionCode( shaderNode ) {

  		const layout = shaderNode.layout;
  		const flowData = this.flowShaderNode( shaderNode );

  		const parameters = [];

  		for ( const input of layout.inputs ) {

  			parameters.push( input.name + ' : ' + this.getType( input.type ) );

  		}

  		//

  		let code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {
${ flowData.vars }
${ flowData.code }
`;

  		if ( flowData.result ) {

  			code += `\treturn ${ flowData.result };\n`;

  		}

  		code += '\n}\n';

  		//

  		return code;

  	}

  	/**
  	 * Returns the instance index builtin.
  	 *
  	 * @return {string} The instance index.
  	 */
  	getInstanceIndex() {

  		if ( this.shaderStage === 'vertex' ) {

  			return this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );

  		}

  		return 'instanceIndex';

  	}

  	/**
  	 * Returns the invocation local index builtin.
  	 *
  	 * @return {string} The invocation local index.
  	 */
  	getInvocationLocalIndex() {

  		return this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );

  	}

  	/**
  	 * Returns the subgroup size builtin.
  	 *
  	 * @return {string} The subgroup size.
  	 */
  	getSubgroupSize() {

  		this.enableSubGroups();

  		return this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

  	}

  	/**
  	 * Returns the invocation subgroup index builtin.
  	 *
  	 * @return {string} The invocation subgroup index.
  	 */
  	getInvocationSubgroupIndex() {

  		this.enableSubGroups();

  		return this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );

  	}

  	/**
  	 * Returns the subgroup index builtin.
  	 *
  	 * @return {string} The subgroup index.
  	 */
  	getSubgroupIndex() {

  		this.enableSubGroups();

  		return this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );

  	}

  	/**
  	 * Overwritten as a NOP since this method is intended for the WebGL 2 backend.
  	 *
  	 * @return {null} Null.
  	 */
  	getDrawIndex() {

  		return null;

  	}

  	/**
  	 * Returns the front facing builtin.
  	 *
  	 * @return {string} The front facing builtin.
  	 */
  	getFrontFacing() {

  		return this.getBuiltin( 'front_facing', 'isFront', 'bool' );

  	}

  	/**
  	 * Returns the frag coord builtin.
  	 *
  	 * @return {string} The frag coord builtin.
  	 */
  	getFragCoord() {

  		return this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';

  	}

  	/**
  	 * Returns the frag depth builtin.
  	 *
  	 * @return {string} The frag depth builtin.
  	 */
  	getFragDepth() {

  		return 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );

  	}

  	/**
  	 * Returns the clip distances builtin.
  	 *
  	 * @return {string} The clip distances builtin.
  	 */
  	getClipDistance() {

  		return 'varyings.hw_clip_distances';

  	}

  	/**
  	 * Whether to flip texture data along its vertical axis or not.
  	 *
  	 * @return {boolean} Returns always `false` in context of WGSL.
  	 */
  	isFlipY() {

  		return false;

  	}

  	/**
  	 * Enables the given directive for the given shader stage.
  	 *
  	 * @param {string} name - The directive name.
  	 * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
  	 */
  	enableDirective( name, shaderStage = this.shaderStage ) {

  		const stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );
  		stage.add( name );

  	}

  	/**
  	 * Returns the directives of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} A WGSL snippet that enables the directives of the given stage.
  	 */
  	getDirectives( shaderStage ) {

  		const snippets = [];
  		const directives = this.directives[ shaderStage ];

  		if ( directives !== undefined ) {

  			for ( const directive of directives ) {

  				snippets.push( `enable ${directive};` );

  			}

  		}

  		return snippets.join( '\n' );

  	}

  	/**
  	 * Enables the 'subgroups' directive.
  	 */
  	enableSubGroups() {

  		this.enableDirective( 'subgroups' );

  	}

  	/**
  	 * Enables the 'subgroups-f16' directive.
  	 */
  	enableSubgroupsF16() {

  		this.enableDirective( 'subgroups-f16' );

  	}

  	/**
  	 * Enables the 'clip_distances' directive.
  	 */
  	enableClipDistances() {

  		this.enableDirective( 'clip_distances' );

  	}

  	/**
  	 * Enables the 'f16' directive.
  	 */
  	enableShaderF16() {

  		this.enableDirective( 'f16' );

  	}

  	/**
  	 * Enables the 'dual_source_blending' directive.
  	 */
  	enableDualSourceBlending() {

  		this.enableDirective( 'dual_source_blending' );

  	}

  	/**
  	 * Enables hardware clipping.
  	 *
  	 * @param {string} planeCount - The clipping plane count.
  	 */
  	enableHardwareClipping( planeCount ) {

  		this.enableClipDistances();
  		this.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );

  	}

  	/**
  	 * Returns the builtins of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} A WGSL snippet that represents the builtins of the given stage.
  	 */
  	getBuiltins( shaderStage ) {

  		const snippets = [];
  		const builtins = this.builtins[ shaderStage ];

  		if ( builtins !== undefined ) {

  			for ( const { name, property, type } of builtins.values() ) {

  				snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

  			}

  		}

  		return snippets.join( ',\n\t' );

  	}

  	/**
  	 * This method should be used when a new scoped buffer is used in context of
  	 * compute shaders. It adds the array to the internal data structure which is
  	 * later used to generate the respective WGSL.
  	 *
  	 * @param {string} name - The array name.
  	 * @param {string} scope - The scope.
  	 * @param {string} bufferType - The buffer type.
  	 * @param {string} bufferCount - The buffer count.
  	 * @return {string} The array name.
  	 */
  	getScopedArray( name, scope, bufferType, bufferCount ) {

  		if ( this.scopedArrays.has( name ) === false ) {

  			this.scopedArrays.set( name, {
  				name,
  				scope,
  				bufferType,
  				bufferCount
  			} );

  		}

  		return name;

  	}

  	/**
  	 * Returns the scoped arrays of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string|undefined} The WGSL snippet that defines the scoped arrays.
  	 * Returns `undefined` when used in the vertex or fragment stage.
  	 */
  	getScopedArrays( shaderStage ) {

  		if ( shaderStage !== 'compute' ) {

  			return;

  		}

  		const snippets = [];

  		for ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {

  			const type = this.getType( bufferType );

  			snippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );

  		}

  		return snippets.join( '\n' );

  	}

  	/**
  	 * Returns the shader attributes of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The WGSL snippet that defines the shader attributes.
  	 */
  	getAttributes( shaderStage ) {

  		const snippets = [];

  		if ( shaderStage === 'compute' ) {

  			this.getBuiltin( 'global_invocation_id', 'globalId', 'vec3<u32>', 'attribute' );
  			this.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );
  			this.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );
  			this.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );

  			if ( this.renderer.hasFeature( 'subgroups' ) ) {

  				this.enableDirective( 'subgroups', shaderStage );
  				this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

  			}

  		}

  		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

  			const builtins = this.getBuiltins( 'attribute' );

  			if ( builtins ) snippets.push( builtins );

  			const attributes = this.getAttributesArray();

  			for ( let index = 0, length = attributes.length; index < length; index ++ ) {

  				const attribute = attributes[ index ];
  				const name = attribute.name;
  				const type = this.getType( attribute.type );

  				snippets.push( `@location( ${index} ) ${ name } : ${ type }` );

  			}

  		}

  		return snippets.join( ',\n\t' );

  	}

  	/**
  	 * Returns the members of the given struct type node as a WGSL string.
  	 *
  	 * @param {StructTypeNode} struct - The struct type node.
  	 * @return {string} The WGSL snippet that defines the struct members.
  	 */
  	getStructMembers( struct ) {

  		const snippets = [];

  		for ( const member of struct.members ) {

  			const prefix = struct.output ? '@location( ' + member.index + ' ) ' : '';

  			let type = this.getType( member.type );

  			if ( member.atomic ) {

  				type = 'atomic< ' + type + ' >';

  			}

  			snippets.push( `\t${ prefix + member.name } : ${ type }` );

  		}

  		if ( struct.output ) {

  			snippets.push( `\t${ this.getBuiltins( 'output' ) }` );

  		}

  		return snippets.join( ',\n' );

  	}

  	/**
  	 * Returns the structs of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The WGSL snippet that defines the structs.
  	 */
  	getStructs( shaderStage ) {

  		let result = '';

  		const structs = this.structs[ shaderStage ];

  		if ( structs.length > 0 ) {

  			const snippets = [];

  			for ( const struct of structs ) {

  				let snippet = `struct ${ struct.name } {\n`;
  				snippet += this.getStructMembers( struct );
  				snippet += '\n};';

  				snippets.push( snippet );

  			}

  			result = '\n' + snippets.join( '\n\n' ) + '\n';

  		}

  		return result;

  	}

  	/**
  	 * Returns a WGSL string representing a variable.
  	 *
  	 * @param {string} type - The variable's type.
  	 * @param {string} name - The variable's name.
  	 * @param {?number} [count=null] - The array length.
  	 * @return {string} The WGSL snippet that defines a variable.
  	 */
  	getVar( type, name, count = null ) {

  		let snippet = `var ${ name } : `;

  		if ( count !== null ) {

  			snippet += this.generateArrayDeclaration( type, count );

  		} else {

  			snippet += this.getType( type );

  		}

  		return snippet;

  	}

  	/**
  	 * Returns the variables of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The WGSL snippet that defines the variables.
  	 */
  	getVars( shaderStage ) {

  		const snippets = [];
  		const vars = this.vars[ shaderStage ];

  		if ( vars !== undefined ) {

  			for ( const variable of vars ) {

  				snippets.push( `\t${ this.getVar( variable.type, variable.name, variable.count ) };` );

  			}

  		}

  		return `\n${ snippets.join( '\n' ) }\n`;

  	}

  	/**
  	 * Returns the varyings of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The WGSL snippet that defines the varyings.
  	 */
  	getVaryings( shaderStage ) {

  		const snippets = [];

  		if ( shaderStage === 'vertex' ) {

  			this.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );

  		}

  		if ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {

  			const varyings = this.varyings;
  			const vars = this.vars[ shaderStage ];

  			for ( let index = 0; index < varyings.length; index ++ ) {

  				const varying = varyings[ index ];

  				if ( varying.needsInterpolation ) {

  					let attributesSnippet = `@location( ${index} )`;

  					if ( varying.interpolationType ) {

  						const samplingSnippet = varying.interpolationSampling !== null ? `, ${ varying.interpolationSampling } )` : ' )';

  						attributesSnippet += ` @interpolate( ${ varying.interpolationType }${ samplingSnippet }`;

  						// Otherwise, optimize interpolation when sensible

  					} else if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {

  						attributesSnippet += ` @interpolate( ${ this.renderer.backend.compatibilityMode ? 'flat, either' : 'flat' } )`;

  					}

  					snippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );

  				} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {

  					vars.push( varying );

  				}

  			}

  		}

  		const builtins = this.getBuiltins( shaderStage );

  		if ( builtins ) snippets.push( builtins );

  		const code = snippets.join( ',\n\t' );

  		return shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\t' + code ) : code;

  	}

  	isCustomStruct( nodeUniform ) {

  		const attribute = nodeUniform.value;
  		const bufferNode = nodeUniform.node;

  		const isAttributeStructType = ( attribute.isBufferAttribute || attribute.isInstancedBufferAttribute ) && bufferNode.structTypeNode !== null;

  		const isStructArray =
  			( bufferNode.value && bufferNode.value.array ) &&
  			( typeof bufferNode.value.itemSize === 'number' && bufferNode.value.array.length > bufferNode.value.itemSize );

  		return isAttributeStructType && ! isStructArray;

  	}

  	/**
  	 * Returns the uniforms of the given shader stage as a WGSL string.
  	 *
  	 * @param {string} shaderStage - The shader stage.
  	 * @return {string} The WGSL snippet that defines the uniforms.
  	 */
  	getUniforms( shaderStage ) {

  		const uniforms = this.uniforms[ shaderStage ];

  		const bindingSnippets = [];
  		const bufferSnippets = [];
  		const structSnippets = [];
  		const uniformGroups = {};

  		for ( const uniform of uniforms ) {

  			const groupName = uniform.groupNode.name;
  			const uniformIndexes = this.bindingsIndexes[ groupName ];

  			if ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {

  				const texture = uniform.node.value;

  				if ( this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {

  					if ( this.isSampleCompare( texture ) ) {

  						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );

  					} else {

  						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );

  					}

  				}

  				let textureType;

  				let multisampled = '';

  				const { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );

  				if ( primarySamples > 1 ) {

  					multisampled = '_multisampled';

  				}

  				if ( texture.isCubeTexture === true ) {

  					textureType = 'texture_cube<f32>';

  				} else if ( texture.isDepthTexture === true ) {

  					if ( this.renderer.backend.compatibilityMode && texture.compareFunction === null ) {

  						textureType = `texture${ multisampled }_2d<f32>`;

  					} else {

  						textureType = `texture_depth${ multisampled }_2d${ texture.isArrayTexture === true ? '_array' : '' }`;

  					}

  				} else if ( uniform.node.isStorageTextureNode === true ) {

  					const format = getFormat( texture );
  					const access = this.getStorageAccess( uniform.node, shaderStage );

  					const is3D = uniform.node.value.is3DTexture;
  					const isArrayTexture = uniform.node.value.isArrayTexture;

  					const dimension = is3D ? '3d' : `2d${ isArrayTexture ? '_array' : '' }`;

  					textureType = `texture_storage_${ dimension }<${ format }, ${ access }>`;

  				} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

  					textureType = 'texture_2d_array<f32>';

  				} else if ( texture.is3DTexture === true || texture.isData3DTexture === true ) {

  					textureType = 'texture_3d<f32>';

  				} else if ( texture.isVideoTexture === true ) {

  					textureType = 'texture_external';

  				} else {

  					const componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );

  					textureType = `texture${ multisampled }_2d<${ componentPrefix }32>`;

  				}

  				bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );

  			} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {

  				const bufferNode = uniform.node;
  				const bufferType = this.getType( bufferNode.getNodeType( this ) );
  				const bufferCount = bufferNode.bufferCount;
  				const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';
  				const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';

  				if ( this.isCustomStruct( uniform ) ) {

  					bufferSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var<${ bufferAccessMode }> ${ uniform.name } : ${ bufferType };` );

  				} else {

  					const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${ bufferType }>` : `${ bufferType }`;
  					const bufferSnippet = `\tvalue : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >`;

  					bufferSnippets.push( this._getWGSLStructBinding( uniform.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );

  				}

  			} else {

  				const vectorType = this.getType( this.getVectorType( uniform.type ) );
  				const groupName = uniform.groupNode.name;

  				const group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {
  					index: uniformIndexes.binding ++,
  					id: uniformIndexes.group,
  					snippets: []
  				} );

  				group.snippets.push( `\t${ uniform.name } : ${ vectorType }` );

  			}

  		}

  		for ( const name in uniformGroups ) {

  			const group = uniformGroups[ name ];

  			structSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\n' ), 'uniform', group.index, group.id ) );

  		}

  		let code = bindingSnippets.join( '\n' );
  		code += bufferSnippets.join( '\n' );
  		code += structSnippets.join( '\n' );

  		return code;

  	}

  	/**
  	 * Controls the code build of the shader stages.
  	 */
  	buildCode() {

  		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

  		this.sortBindingGroups();

  		for ( const shaderStage in shadersData ) {

  			this.shaderStage = shaderStage;

  			const stageData = shadersData[ shaderStage ];
  			stageData.uniforms = this.getUniforms( shaderStage );
  			stageData.attributes = this.getAttributes( shaderStage );
  			stageData.varyings = this.getVaryings( shaderStage );
  			stageData.structs = this.getStructs( shaderStage );
  			stageData.vars = this.getVars( shaderStage );
  			stageData.codes = this.getCodes( shaderStage );
  			stageData.directives = this.getDirectives( shaderStage );
  			stageData.scopedArrays = this.getScopedArrays( shaderStage );

  			//

  			let flow = '// code\n\n';
  			flow += this.flowCode[ shaderStage ];

  			const flowNodes = this.flowNodes[ shaderStage ];
  			const mainNode = flowNodes[ flowNodes.length - 1 ];

  			const outputNode = mainNode.outputNode;
  			const isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );

  			for ( const node of flowNodes ) {

  				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
  				const slotName = node.name;

  				if ( slotName ) {

  					if ( flow.length > 0 ) flow += '\n';

  					flow += `\t// flow -> ${ slotName }\n`;

  				}

  				flow += `${ flowSlotData.code }\n\t`;

  				if ( node === mainNode && shaderStage !== 'compute' ) {

  					flow += '// result\n\n\t';

  					if ( shaderStage === 'vertex' ) {

  						flow += `varyings.Vertex = ${ flowSlotData.result };`;

  					} else if ( shaderStage === 'fragment' ) {

  						if ( isOutputStruct ) {

  							stageData.returnType = outputNode.getNodeType( this );
  							stageData.structs += 'var<private> output : ' + stageData.returnType + ';';

  							flow += `return ${ flowSlotData.result };`;

  						} else {

  							let structSnippet = '\t@location(0) color: vec4<f32>';

  							const builtins = this.getBuiltins( 'output' );

  							if ( builtins ) structSnippet += ',\n\t' + builtins;

  							stageData.returnType = 'OutputStruct';
  							stageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );
  							stageData.structs += '\nvar<private> output : OutputStruct;';

  							flow += `output.color = ${ flowSlotData.result };\n\n\treturn output;`;

  						}

  					}

  				}

  			}

  			stageData.flow = flow;

  		}

  		this.shaderStage = null;

  		if ( this.material !== null ) {

  			this.vertexShader = this._getWGSLVertexCode( shadersData.vertex );
  			this.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );

  		} else {

  			this.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );

  		}

  	}

  	/**
  	 * Returns the native shader method name for a given generic name.
  	 *
  	 * @param {string} method - The method name to resolve.
  	 * @param {?string} [output=null] - An optional output.
  	 * @return {string} The resolved WGSL method name.
  	 */
  	getMethod( method, output = null ) {

  		let wgslMethod;

  		if ( output !== null ) {

  			wgslMethod = this._getWGSLMethod( method + '_' + output );

  		}

  		if ( wgslMethod === undefined ) {

  			wgslMethod = this._getWGSLMethod( method );

  		}

  		return wgslMethod || method;

  	}

  	/**
  	 * Returns the WGSL type of the given node data type.
  	 *
  	 * @param {string} type - The node data type.
  	 * @return {string} The WGSL type.
  	 */
  	getType( type ) {

  		return wgslTypeLib[ type ] || type;

  	}

  	/**
  	 * Whether the requested feature is available or not.
  	 *
  	 * @param {string} name - The requested feature.
  	 * @return {boolean} Whether the requested feature is supported or not.
  	 */
  	isAvailable( name ) {

  		let result = supports[ name ];

  		if ( result === undefined ) {

  			if ( name === 'float32Filterable' ) {

  				result = this.renderer.hasFeature( 'float32-filterable' );

  			} else if ( name === 'clipDistance' ) {

  				result = this.renderer.hasFeature( 'clip-distances' );

  			}

  			supports[ name ] = result;

  		}

  		return result;

  	}

  	/**
  	 * Returns the native shader method name for a given generic name.
  	 *
  	 * @private
  	 * @param {string} method - The method name to resolve.
  	 * @return {string} The resolved WGSL method name.
  	 */
  	_getWGSLMethod( method ) {

  		if ( wgslPolyfill[ method ] !== undefined ) {

  			this._include( method );

  		}

  		return wgslMethods[ method ];

  	}

  	/**
  	 * Includes the given method name into the current
  	 * function node.
  	 *
  	 * @private
  	 * @param {string} name - The method name to include.
  	 * @return {CodeNode} The respective code node.
  	 */
  	_include( name ) {

  		const codeNode = wgslPolyfill[ name ];
  		codeNode.build( this );

  		if ( this.currentFunctionNode !== null ) {

  			this.currentFunctionNode.includes.push( codeNode );

  		}

  		return codeNode;

  	}

  	/**
  	 * Returns a WGSL vertex shader based on the given shader data.
  	 *
  	 * @private
  	 * @param {Object} shaderData - The shader data.
  	 * @return {string} The vertex shader.
  	 */
  	_getWGSLVertexCode( shaderData ) {

  		return `${ this.getSignature() }
// directives
${shaderData.directives}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;

  	}

  	/**
  	 * Returns a WGSL fragment shader based on the given shader data.
  	 *
  	 * @private
  	 * @param {Object} shaderData - The shader data.
  	 * @return {string} The vertex shader.
  	 */
  	_getWGSLFragmentCode( shaderData ) {

  		return `${ this.getSignature() }
// global
${ diagnostics }

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

  	}

  	/**
  	 * Returns a WGSL compute shader based on the given shader data.
  	 *
  	 * @private
  	 * @param {Object} shaderData - The shader data.
  	 * @param {string} workgroupSize - The workgroup size.
  	 * @return {string} The vertex shader.
  	 */
  	_getWGSLComputeCode( shaderData, workgroupSize ) {

  		return `${ this.getSignature() }
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = globalId.x + globalId.y * numWorkgroups.x * u32(${workgroupSize}) + globalId.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

  	}

  	/**
  	 * Returns a WGSL struct based on the given name and variables.
  	 *
  	 * @private
  	 * @param {string} name - The struct name.
  	 * @param {string} vars - The struct variables.
  	 * @return {string} The WGSL snippet representing a struct.
  	 */
  	_getWGSLStruct( name, vars ) {

  		return `
struct ${name} {
${vars}
};`;

  	}

  	/**
  	 * Returns a WGSL struct binding.
  	 *
  	 * @private
  	 * @param {string} name - The struct name.
  	 * @param {string} vars - The struct variables.
  	 * @param {string} access - The access.
  	 * @param {number} [binding=0] - The binding index.
  	 * @param {number} [group=0] - The group index.
  	 * @return {string} The WGSL snippet representing a struct binding.
  	 */
  	_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {

  		const structName = name + 'Struct';
  		const structSnippet = this._getWGSLStruct( structName, vars );

  		return `${structSnippet}
@binding( ${ binding } ) @group( ${ group } )
var<${access}> ${ name } : ${ structName };`;

  	}

  }

  /**
   * A WebGPU backend utility module with common helpers.
   *
   * @private
   */
  class WebGPUUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGPUBackend} backend - The WebGPU backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGPU backend.
  		 *
  		 * @type {WebGPUBackend}
  		 */
  		this.backend = backend;

  	}

  	/**
  	 * Returns the depth/stencil GPU format for the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {string} The depth/stencil GPU texture format.
  	 */
  	getCurrentDepthStencilFormat( renderContext ) {

  		let format;

  		if ( renderContext.depthTexture !== null ) {

  			format = this.getTextureFormatGPU( renderContext.depthTexture );

  		} else if ( renderContext.depth && renderContext.stencil ) {

  			format = GPUTextureFormat.Depth24PlusStencil8;

  		} else if ( renderContext.depth ) {

  			format = GPUTextureFormat.Depth24Plus;

  		}

  		return format;

  	}

  	/**
  	 * Returns the GPU format for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {string} The GPU texture format.
  	 */
  	getTextureFormatGPU( texture ) {

  		return this.backend.get( texture ).format;

  	}

  	/**
  	 * Returns an object that defines the multi-sampling state of the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @return {Object} The multi-sampling state.
  	 */
  	getTextureSampleData( texture ) {

  		let samples;

  		if ( texture.isFramebufferTexture ) {

  			samples = 1;

  		} else if ( texture.isDepthTexture && ! texture.renderTarget ) {

  			const renderer = this.backend.renderer;
  			const renderTarget = renderer.getRenderTarget();

  			samples = renderTarget ? renderTarget.samples : renderer.samples;

  		} else if ( texture.renderTarget ) {

  			samples = texture.renderTarget.samples;

  		}

  		samples = samples || 1;

  		const isMSAA = samples > 1 && texture.renderTarget !== null && ( texture.isDepthTexture !== true && texture.isFramebufferTexture !== true );
  		const primarySamples = isMSAA ? 1 : samples;

  		return { samples, primarySamples, isMSAA };

  	}

  	/**
  	 * Returns the default color attachment's GPU format of the current render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {string} The GPU texture format of the default color attachment.
  	 */
  	getCurrentColorFormat( renderContext ) {

  		let format;

  		if ( renderContext.textures !== null ) {

  			format = this.getTextureFormatGPU( renderContext.textures[ 0 ] );

  		} else {

  			format = this.getPreferredCanvasFormat(); // default context format

  		}

  		return format;

  	}

  	/**
  	 * Returns the output color space of the current render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {string} The output color space.
  	 */
  	getCurrentColorSpace( renderContext ) {

  		if ( renderContext.textures !== null ) {

  			return renderContext.textures[ 0 ].colorSpace;

  		}

  		return this.backend.renderer.outputColorSpace;

  	}

  	/**
  	 * Returns GPU primitive topology for the given object and material.
  	 *
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Material} material - The material.
  	 * @return {string} The GPU primitive topology.
  	 */
  	getPrimitiveTopology( object, material ) {

  		if ( object.isPoints ) return GPUPrimitiveTopology.PointList;
  		else if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;
  		else if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;
  		else if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;

  	}

  	/**
  	 * Returns a modified sample count from the given sample count value.
  	 *
  	 * That is required since WebGPU does not support arbitrary sample counts.
  	 *
  	 * @param {number} sampleCount - The input sample count.
  	 * @return {number} The (potentially updated) output sample count.
  	 */
  	getSampleCount( sampleCount ) {

  		let count = 1;

  		if ( sampleCount > 1 ) {

  			// WebGPU only supports power-of-two sample counts and 2 is not a valid value
  			count = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );

  			if ( count === 2 ) {

  				count = 4;

  			}

  		}

  		return count;

  	}

  	/**
  	 * Returns the sample count of the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {number} The sample count.
  	 */
  	getSampleCountRenderContext( renderContext ) {

  		if ( renderContext.textures !== null ) {

  			return this.getSampleCount( renderContext.sampleCount );

  		}

  		return this.getSampleCount( this.backend.renderer.samples );

  	}

  	/**
  	 * Returns the preferred canvas format.
  	 *
  	 * There is a separate method for this so it's possible to
  	 * honor edge cases for specific devices.
  	 *
  	 * @return {string} The GPU texture format of the canvas.
  	 */
  	getPreferredCanvasFormat() {

  		const outputType = this.backend.parameters.outputType;

  		if ( outputType === undefined ) {

  			return navigator.gpu.getPreferredCanvasFormat();

  		} else if ( outputType === UnsignedByteType ) {

  			return GPUTextureFormat.BGRA8Unorm;

  		} else if ( outputType === HalfFloatType ) {

  			return GPUTextureFormat.RGBA16Float;

  		} else {

  			throw new Error( 'Unsupported outputType' );

  		}

  	}

  }

  const typedArraysToVertexFormatPrefix = new Map( [
  	[ Int8Array, [ 'sint8', 'snorm8' ]],
  	[ Uint8Array, [ 'uint8', 'unorm8' ]],
  	[ Int16Array, [ 'sint16', 'snorm16' ]],
  	[ Uint16Array, [ 'uint16', 'unorm16' ]],
  	[ Int32Array, [ 'sint32', 'snorm32' ]],
  	[ Uint32Array, [ 'uint32', 'unorm32' ]],
  	[ Float32Array, [ 'float32', ]],
  ] );

  if ( typeof Float16Array !== 'undefined' ) {

  	typedArraysToVertexFormatPrefix.set( Float16Array, [ 'float16' ] );

  }

  const typedAttributeToVertexFormatPrefix = new Map( [
  	[ Float16BufferAttribute, [ 'float16', ]],
  ] );

  const typeArraysToVertexFormatPrefixForItemSize1 = new Map( [
  	[ Int32Array, 'sint32' ],
  	[ Int16Array, 'sint32' ], // patch for INT16
  	[ Uint32Array, 'uint32' ],
  	[ Uint16Array, 'uint32' ], // patch for UINT16
  	[ Float32Array, 'float32' ]
  ] );

  /**
   * A WebGPU backend utility module for managing shader attributes.
   *
   * @private
   */
  class WebGPUAttributeUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGPUBackend} backend - The WebGPU backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGPU backend.
  		 *
  		 * @type {WebGPUBackend}
  		 */
  		this.backend = backend;

  	}

  	/**
  	 * Creates the GPU buffer for the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
  	 */
  	createAttribute( attribute, usage ) {

  		const bufferAttribute = this._getBufferAttribute( attribute );

  		const backend = this.backend;
  		const bufferData = backend.get( bufferAttribute );

  		let buffer = bufferData.buffer;

  		if ( buffer === undefined ) {

  			const device = backend.device;

  			let array = bufferAttribute.array;

  			// patch for INT16 and UINT16
  			if ( attribute.normalized === false ) {

  				if ( array.constructor === Int16Array || array.constructor === Int8Array ) {

  					array = new Int32Array( array );

  				} else if ( array.constructor === Uint16Array || array.constructor === Uint8Array ) {

  					array = new Uint32Array( array );

  					if ( usage & GPUBufferUsage.INDEX ) {

  						for ( let i = 0; i < array.length; i ++ ) {

  							if ( array[ i ] === 0xffff ) array[ i ] = 0xffffffff; // use correct primitive restart index

  						}

  					}

  				}

  			}

  			bufferAttribute.array = array;

  			if ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {

  				array = new array.constructor( bufferAttribute.count * 4 );

  				for ( let i = 0; i < bufferAttribute.count; i ++ ) {

  					array.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );

  				}

  				// Update BufferAttribute
  				bufferAttribute.itemSize = 4;
  				bufferAttribute.array = array;

  				bufferData._force3to4BytesAlignment = true;

  			}

  			// ensure 4 byte alignment
  			const byteLength = array.byteLength;
  			const size = byteLength + ( ( 4 - ( byteLength % 4 ) ) % 4 );

  			buffer = device.createBuffer( {
  				label: bufferAttribute.name,
  				size: size,
  				usage: usage,
  				mappedAtCreation: true
  			} );

  			new array.constructor( buffer.getMappedRange() ).set( array );

  			buffer.unmap();

  			bufferData.buffer = buffer;

  		}

  	}

  	/**
  	 * Updates the GPU buffer of the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	updateAttribute( attribute ) {

  		const bufferAttribute = this._getBufferAttribute( attribute );

  		const backend = this.backend;
  		const device = backend.device;

  		const bufferData = backend.get( bufferAttribute );
  		const buffer = backend.get( bufferAttribute ).buffer;

  		let array = bufferAttribute.array;

  		//  if storage buffer ensure 4 byte alignment
  		if ( bufferData._force3to4BytesAlignment === true ) {

  			array = new array.constructor( bufferAttribute.count * 4 );

  			for ( let i = 0; i < bufferAttribute.count; i ++ ) {

  				array.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );

  			}

  			bufferAttribute.array = array;

  		}


  		const isTypedArray = this._isTypedArray( array );
  		const updateRanges = bufferAttribute.updateRanges;

  		if ( updateRanges.length === 0 ) {

  			// Not using update ranges

  			device.queue.writeBuffer(
  				buffer,
  				0,
  				array,
  				0
  			);

  		} else {

  			const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];
  				let dataOffset, size;

  				if ( bufferData._force3to4BytesAlignment === true ) {

  					const vertexStart = Math.floor( range.start / 3 );
  					const vertexCount = Math.ceil( range.count / 3 );
  					dataOffset = vertexStart * 4 * byteOffsetFactor;
  					size = vertexCount * 4 * byteOffsetFactor;

  				} else {

  					dataOffset = range.start * byteOffsetFactor;
  					size = range.count * byteOffsetFactor;

  				}

  				const bufferOffset = dataOffset * ( isTypedArray ? array.BYTES_PER_ELEMENT : 1 ); // bufferOffset is always in bytes

  				device.queue.writeBuffer(
  					buffer,
  					bufferOffset,
  					array,
  					dataOffset,
  					size
  				);

  			}

  			bufferAttribute.clearUpdateRanges();

  		}

  	}

  	/**
  	 * This method creates the vertex buffer layout data which are
  	 * require when creating a render pipeline for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
  	 */
  	createShaderVertexBuffers( renderObject ) {

  		const attributes = renderObject.getAttributes();
  		const vertexBuffers = new Map();

  		for ( let slot = 0; slot < attributes.length; slot ++ ) {

  			const geometryAttribute = attributes[ slot ];
  			const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
  			const bufferAttribute = this._getBufferAttribute( geometryAttribute );

  			let vertexBufferLayout = vertexBuffers.get( bufferAttribute );

  			if ( vertexBufferLayout === undefined ) {

  				let arrayStride, stepMode;

  				if ( geometryAttribute.isInterleavedBufferAttribute === true ) {

  					arrayStride = geometryAttribute.data.stride * bytesPerElement;
  					stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

  				} else {

  					arrayStride = geometryAttribute.itemSize * bytesPerElement;
  					stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

  				}

  				// patch for INT16 and UINT16
  				if ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {

  					arrayStride = 4;

  				}

  				vertexBufferLayout = {
  					arrayStride,
  					attributes: [],
  					stepMode
  				};

  				vertexBuffers.set( bufferAttribute, vertexBufferLayout );

  			}

  			const format = this._getVertexFormat( geometryAttribute );
  			const offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;

  			vertexBufferLayout.attributes.push( {
  				shaderLocation: slot,
  				offset,
  				format
  			} );

  		}

  		return Array.from( vertexBuffers.values() );

  	}

  	/**
  	 * Destroys the GPU buffer of the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	destroyAttribute( attribute ) {

  		const backend = this.backend;
  		const data = backend.get( this._getBufferAttribute( attribute ) );

  		data.buffer.destroy();

  		backend.delete( attribute );

  	}

  	/**
  	 * This method performs a readback operation by moving buffer data from
  	 * a storage buffer attribute from the GPU to the CPU.
  	 *
  	 * @async
  	 * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
  	 * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
  	 */
  	async getArrayBufferAsync( attribute ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const data = backend.get( this._getBufferAttribute( attribute ) );
  		const bufferGPU = data.buffer;
  		const size = bufferGPU.size;

  		const readBufferGPU = device.createBuffer( {
  			label: `${ attribute.name }_readback`,
  			size,
  			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  		} );

  		const cmdEncoder = device.createCommandEncoder( {
  			label: `readback_encoder_${ attribute.name }`
  		} );

  		cmdEncoder.copyBufferToBuffer(
  			bufferGPU,
  			0,
  			readBufferGPU,
  			0,
  			size
  		);

  		const gpuCommands = cmdEncoder.finish();
  		device.queue.submit( [ gpuCommands ] );

  		await readBufferGPU.mapAsync( GPUMapMode.READ );

  		const arrayBuffer = readBufferGPU.getMappedRange();

  		const dstBuffer = new attribute.array.constructor( arrayBuffer.slice( 0 ) );

  		readBufferGPU.unmap();

  		return dstBuffer.buffer;

  	}

  	/**
  	 * Returns the vertex format of the given buffer attribute.
  	 *
  	 * @private
  	 * @param {BufferAttribute} geometryAttribute - The buffer attribute.
  	 * @return {string|undefined} The vertex format (e.g. 'float32x3').
  	 */
  	_getVertexFormat( geometryAttribute ) {

  		const { itemSize, normalized } = geometryAttribute;
  		const ArrayType = geometryAttribute.array.constructor;
  		const AttributeType = geometryAttribute.constructor;

  		let format;

  		if ( itemSize === 1 ) {

  			format = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );

  		} else {

  			const prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );
  			const prefix = prefixOptions[ normalized ? 1 : 0 ];

  			if ( prefix ) {

  				const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
  				const paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;
  				const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;

  				if ( paddedItemSize % 1 ) {

  					throw new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );

  				}

  				format = `${prefix}x${paddedItemSize}`;

  			}

  		}

  		if ( ! format ) {

  			console.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );

  		}

  		return format;

  	}

  	/**
  	 * Returns `true` if the given array is a typed array.
  	 *
  	 * @private
  	 * @param {any} array - The array.
  	 * @return {boolean} Whether the given array is a typed array or not.
  	 */
  	_isTypedArray( array ) {

  		return ArrayBuffer.isView( array ) && ! ( array instanceof DataView );

  	}

  	/**
  	 * Utility method for handling interleaved buffer attributes correctly.
  	 * To process them, their `InterleavedBuffer` is returned.
  	 *
  	 * @private
  	 * @param {BufferAttribute} attribute - The attribute.
  	 * @return {BufferAttribute|InterleavedBuffer}
  	 */
  	_getBufferAttribute( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return attribute;

  	}

  }

  /**
   * A WebGPU backend utility module for managing bindings.
   *
   * When reading the documentation it's helpful to keep in mind that
   * all class definitions starting with 'GPU*' are modules from the
   * WebGPU API. So for example `BindGroup` is a class from the engine
   * whereas `GPUBindGroup` is a class from WebGPU.
   *
   * @private
   */
  class WebGPUBindingUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGPUBackend} backend - The WebGPU backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGPU backend.
  		 *
  		 * @type {WebGPUBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A cache for managing bind group layouts.
  		 *
  		 * @type {WeakMap<Array<Binding>,GPUBindGroupLayout>}
  		 */
  		this.bindGroupLayoutCache = new WeakMap();

  	}

  	/**
  	 * Creates a GPU bind group layout for the given bind group.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @return {GPUBindGroupLayout} The GPU bind group layout.
  	 */
  	createBindingsLayout( bindGroup ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const entries = [];

  		let index = 0;

  		for ( const binding of bindGroup.bindings ) {

  			const bindingGPU = {
  				binding: index ++,
  				visibility: binding.visibility
  			};

  			if ( binding.isUniformBuffer || binding.isStorageBuffer ) {

  				const buffer = {}; // GPUBufferBindingLayout

  				if ( binding.isStorageBuffer ) {

  					if ( binding.visibility & 4 ) {

  						// compute

  						if ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {

  							buffer.type = GPUBufferBindingType.Storage;

  						} else {

  							buffer.type = GPUBufferBindingType.ReadOnlyStorage;

  						}

  					} else {

  						buffer.type = GPUBufferBindingType.ReadOnlyStorage;

  					}

  				}

  				bindingGPU.buffer = buffer;

  			} else if ( binding.isSampler ) {

  				const sampler = {}; // GPUSamplerBindingLayout

  				if ( binding.texture.isDepthTexture ) {

  					if ( binding.texture.compareFunction !== null ) {

  						sampler.type = GPUSamplerBindingType.Comparison;

  					} else if ( backend.compatibilityMode ) {

  						sampler.type = GPUSamplerBindingType.NonFiltering;

  					}

  				}

  				bindingGPU.sampler = sampler;

  			} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {

  				bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout

  			} else if ( binding.isSampledTexture && binding.store ) {

  				const storageTexture = {}; // GPUStorageTextureBindingLayout
  				storageTexture.format = this.backend.get( binding.texture ).texture.format;

  				const access = binding.access;

  				if ( access === NodeAccess.READ_WRITE ) {

  					storageTexture.access = GPUStorageTextureAccess.ReadWrite;

  				} else if ( access === NodeAccess.WRITE_ONLY ) {

  					storageTexture.access = GPUStorageTextureAccess.WriteOnly;

  				} else {

  					storageTexture.access = GPUStorageTextureAccess.ReadOnly;

  				}

  				if ( binding.texture.isArrayTexture ) {

  					storageTexture.viewDimension = GPUTextureViewDimension.TwoDArray;

  				} else if ( binding.texture.is3DTexture ) {

  					storageTexture.viewDimension = GPUTextureViewDimension.ThreeD;

  				}

  				bindingGPU.storageTexture = storageTexture;

  			} else if ( binding.isSampledTexture ) {

  				const texture = {}; // GPUTextureBindingLayout

  				const { primarySamples } = backend.utils.getTextureSampleData( binding.texture );

  				if ( primarySamples > 1 ) {

  					texture.multisampled = true;

  					if ( ! binding.texture.isDepthTexture ) {

  						texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

  					}

  				}

  				if ( binding.texture.isDepthTexture ) {

  					if ( backend.compatibilityMode && binding.texture.compareFunction === null ) {

  						texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

  					} else {

  						texture.sampleType = GPUTextureSampleType.Depth;

  					}

  				} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {

  					const type = binding.texture.type;

  					if ( type === IntType ) {

  						texture.sampleType = GPUTextureSampleType.SInt;

  					} else if ( type === UnsignedIntType ) {

  						texture.sampleType = GPUTextureSampleType.UInt;

  					} else if ( type === FloatType ) {

  						if ( this.backend.hasFeature( 'float32-filterable' ) ) {

  							texture.sampleType = GPUTextureSampleType.Float;

  						} else {

  							texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

  						}

  					}

  				}

  				if ( binding.isSampledCubeTexture ) {

  					texture.viewDimension = GPUTextureViewDimension.Cube;

  				} else if ( binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

  					texture.viewDimension = GPUTextureViewDimension.TwoDArray;

  				} else if ( binding.isSampledTexture3D ) {

  					texture.viewDimension = GPUTextureViewDimension.ThreeD;

  				}

  				bindingGPU.texture = texture;

  			} else {

  				console.error( `WebGPUBindingUtils: Unsupported binding "${ binding }".` );

  			}

  			entries.push( bindingGPU );

  		}

  		return device.createBindGroupLayout( { entries } );

  	}

  	/**
  	 * Creates bindings from the given bind group definition.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	createBindings( bindGroup, bindings, cacheIndex, version = 0 ) {

  		const { backend, bindGroupLayoutCache } = this;
  		const bindingsData = backend.get( bindGroup );

  		// setup (static) binding layout and (dynamic) binding group

  		let bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );

  		if ( bindLayoutGPU === undefined ) {

  			bindLayoutGPU = this.createBindingsLayout( bindGroup );
  			bindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );

  		}

  		let bindGroupGPU;

  		if ( cacheIndex > 0 ) {

  			if ( bindingsData.groups === undefined ) {

  				bindingsData.groups = [];
  				bindingsData.versions = [];

  			}

  			if ( bindingsData.versions[ cacheIndex ] === version ) {

  				bindGroupGPU = bindingsData.groups[ cacheIndex ];

  			}

  		}

  		if ( bindGroupGPU === undefined ) {

  			bindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );

  			if ( cacheIndex > 0 ) {

  				bindingsData.groups[ cacheIndex ] = bindGroupGPU;
  				bindingsData.versions[ cacheIndex ] = version;

  			}

  		}

  		bindingsData.group = bindGroupGPU;
  		bindingsData.layout = bindLayoutGPU;

  	}

  	/**
  	 * Updates a buffer binding.
  	 *
  	 *  @param {Buffer} binding - The buffer binding to update.
  	 */
  	updateBinding( binding ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const buffer = binding.buffer;
  		const bufferGPU = backend.get( binding ).buffer;

  		device.queue.writeBuffer( bufferGPU, 0, buffer, 0 );

  	}

  	/**
  	 * Creates a GPU bind group for the camera index.
  	 *
  	 * @param {Uint32Array} data - The index data.
  	 * @param {GPUBindGroupLayout} layout - The GPU bind group layout.
  	 * @return {GPUBindGroup} The GPU bind group.
  	 */
  	createBindGroupIndex( data, layout ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
  		const index = data[ 0 ];

  		const buffer = device.createBuffer( {
  			label: 'bindingCameraIndex_' + index,
  			size: 16, // uint(4) * 4
  			usage: usage
  		} );

  		device.queue.writeBuffer( buffer, 0, data, 0 );

  		const entries = [ { binding: 0, resource: { buffer } } ];

  		return device.createBindGroup( {
  			label: 'bindGroupCameraIndex_' + index,
  			layout,
  			entries
  		} );

  	}

  	/**
  	 * Creates a GPU bind group for the given bind group and GPU layout.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
  	 * @return {GPUBindGroup} The GPU bind group.
  	 */
  	createBindGroup( bindGroup, layoutGPU ) {

  		const backend = this.backend;
  		const device = backend.device;

  		let bindingPoint = 0;
  		const entriesGPU = [];

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isUniformBuffer ) {

  				const bindingData = backend.get( binding );

  				if ( bindingData.buffer === undefined ) {

  					const byteLength = binding.byteLength;

  					const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;

  					const bufferGPU = device.createBuffer( {
  						label: 'bindingBuffer_' + binding.name,
  						size: byteLength,
  						usage: usage
  					} );

  					bindingData.buffer = bufferGPU;

  				}

  				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

  			} else if ( binding.isStorageBuffer ) {

  				const bindingData = backend.get( binding );

  				if ( bindingData.buffer === undefined ) {

  					const attribute = binding.attribute;
  					//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

  					//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

  					bindingData.buffer = backend.get( attribute ).buffer;

  				}

  				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

  			} else if ( binding.isSampler ) {

  				const textureGPU = backend.get( binding.texture );

  				entriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );

  			} else if ( binding.isSampledTexture ) {

  				const textureData = backend.get( binding.texture );

  				let resourceGPU;

  				if ( textureData.externalTexture !== undefined ) {

  					resourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );

  				} else {

  					const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
  					const propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;

  					resourceGPU = textureData[ propertyName ];

  					if ( resourceGPU === undefined ) {

  						const aspectGPU = GPUTextureAspect.All;

  						let dimensionViewGPU;

  						if ( binding.isSampledCubeTexture ) {

  							dimensionViewGPU = GPUTextureViewDimension.Cube;

  						} else if ( binding.isSampledTexture3D ) {

  							dimensionViewGPU = GPUTextureViewDimension.ThreeD;

  						} else if ( binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

  							dimensionViewGPU = GPUTextureViewDimension.TwoDArray;

  						} else {

  							dimensionViewGPU = GPUTextureViewDimension.TwoD;

  						}

  						resourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );

  					}

  				}

  				entriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );

  			}

  			bindingPoint ++;

  		}

  		return device.createBindGroup( {
  			label: 'bindGroup_' + bindGroup.name,
  			layout: layoutGPU,
  			entries: entriesGPU
  		} );

  	}

  }

  /**
   * A WebGPU backend utility module for managing pipelines.
   *
   * @private
   */
  class WebGPUPipelineUtils {

  	/**
  	 * Constructs a new utility object.
  	 *
  	 * @param {WebGPUBackend} backend - The WebGPU backend.
  	 */
  	constructor( backend ) {

  		/**
  		 * A reference to the WebGPU backend.
  		 *
  		 * @type {WebGPUBackend}
  		 */
  		this.backend = backend;

  		/**
  		 * A Weak Map that tracks the active pipeline for render or compute passes.
  		 *
  		 * @private
  		 * @type {WeakMap<(GPURenderPassEncoder|GPUComputePassEncoder),(GPURenderPipeline|GPUComputePipeline)>}
  		 */
  		this._activePipelines = new WeakMap();

  	}

  	/**
  	 * Sets the given pipeline for the given pass. The method makes sure to only set the
  	 * pipeline when necessary.
  	 *
  	 * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
  	 * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
  	 */
  	setPipeline( pass, pipeline ) {

  		const currentPipeline = this._activePipelines.get( pass );

  		if ( currentPipeline !== pipeline ) {

  			pass.setPipeline( pipeline );

  			this._activePipelines.set( pass, pipeline );

  		}

  	}

  	/**
  	 * Returns the sample count derived from the given render context.
  	 *
  	 * @private
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {number} The sample count.
  	 */
  	_getSampleCount( renderContext ) {

  		return this.backend.utils.getSampleCountRenderContext( renderContext );

  	}

  	/**
  	 * Creates a render pipeline for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
  	 */
  	createRenderPipeline( renderObject, promises ) {

  		const { object, material, geometry, pipeline } = renderObject;
  		const { vertexProgram, fragmentProgram } = pipeline;

  		const backend = this.backend;
  		const device = backend.device;
  		const utils = backend.utils;

  		const pipelineData = backend.get( pipeline );

  		// bind group layouts

  		const bindGroupLayouts = [];

  		for ( const bindGroup of renderObject.getBindings() ) {

  			const bindingsData = backend.get( bindGroup );

  			bindGroupLayouts.push( bindingsData.layout );

  		}

  		// vertex buffers

  		const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );

  		// blending

  		let blending;

  		if ( material.blending !== NoBlending && ( material.blending !== NormalBlending || material.transparent !== false ) ) {

  			blending = this._getBlending( material );

  		}

  		// stencil

  		let stencilFront = {};

  		if ( material.stencilWrite === true ) {

  			stencilFront = {
  				compare: this._getStencilCompare( material ),
  				failOp: this._getStencilOperation( material.stencilFail ),
  				depthFailOp: this._getStencilOperation( material.stencilZFail ),
  				passOp: this._getStencilOperation( material.stencilZPass )
  			};

  		}

  		const colorWriteMask = this._getColorWriteMask( material );

  		const targets = [];

  		if ( renderObject.context.textures !== null ) {

  			const textures = renderObject.context.textures;

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const colorFormat = utils.getTextureFormatGPU( textures[ i ] );

  				targets.push( {
  					format: colorFormat,
  					blend: blending,
  					writeMask: colorWriteMask
  				} );

  			}

  		} else {

  			const colorFormat = utils.getCurrentColorFormat( renderObject.context );

  			targets.push( {
  				format: colorFormat,
  				blend: blending,
  				writeMask: colorWriteMask
  			} );

  		}

  		const vertexModule = backend.get( vertexProgram ).module;
  		const fragmentModule = backend.get( fragmentProgram ).module;

  		const primitiveState = this._getPrimitiveState( object, geometry, material );
  		const depthCompare = this._getDepthCompare( material );
  		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );

  		const sampleCount = this._getSampleCount( renderObject.context );

  		const pipelineDescriptor = {
  			label: `renderPipeline_${ material.name || material.type }_${ material.id }`,
  			vertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),
  			fragment: Object.assign( {}, fragmentModule, { targets } ),
  			primitive: primitiveState,
  			multisample: {
  				count: sampleCount,
  				alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
  			},
  			layout: device.createPipelineLayout( {
  				bindGroupLayouts
  			} )
  		};


  		const depthStencil = {};
  		const renderDepth = renderObject.context.depth;
  		const renderStencil = renderObject.context.stencil;

  		if ( renderDepth === true || renderStencil === true ) {

  			if ( renderDepth === true ) {

  				depthStencil.format = depthStencilFormat;
  				depthStencil.depthWriteEnabled = material.depthWrite;
  				depthStencil.depthCompare = depthCompare;

  			}

  			if ( renderStencil === true ) {

  				depthStencil.stencilFront = stencilFront;
  				depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
  				depthStencil.stencilReadMask = material.stencilFuncMask;
  				depthStencil.stencilWriteMask = material.stencilWriteMask;

  			}

  			if ( material.polygonOffset === true ) {

  				depthStencil.depthBias = material.polygonOffsetUnits;
  				depthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;
  				depthStencil.depthBiasClamp = 0; // three.js does not provide an API to configure this value

  			}

  			pipelineDescriptor.depthStencil = depthStencil;

  		}


  		if ( promises === null ) {

  			pipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );

  		} else {

  			const p = new Promise( ( resolve /*, reject*/ ) => {

  				device.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {

  					pipelineData.pipeline = pipeline;
  					resolve();

  				} );

  			} );

  			promises.push( p );

  		}

  	}

  	/**
  	 * Creates GPU render bundle encoder for the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {?string} [label='renderBundleEncoder'] - The label.
  	 * @return {GPURenderBundleEncoder} The GPU render bundle encoder.
  	 */
  	createBundleEncoder( renderContext, label = 'renderBundleEncoder' ) {

  		const backend = this.backend;
  		const { utils, device } = backend;

  		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );
  		const colorFormat = utils.getCurrentColorFormat( renderContext );
  		const sampleCount = this._getSampleCount( renderContext );

  		const descriptor = {
  			label: label,
  			colorFormats: [ colorFormat ],
  			depthStencilFormat,
  			sampleCount
  		};

  		return device.createRenderBundleEncoder( descriptor );

  	}

  	/**
  	 * Creates a compute pipeline for the given compute node.
  	 *
  	 * @param {ComputePipeline} pipeline - The compute pipeline.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 */
  	createComputePipeline( pipeline, bindings ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const computeProgram = backend.get( pipeline.computeProgram ).module;

  		const pipelineGPU = backend.get( pipeline );

  		// bind group layouts

  		const bindGroupLayouts = [];

  		for ( const bindingsGroup of bindings ) {

  			const bindingsData = backend.get( bindingsGroup );

  			bindGroupLayouts.push( bindingsData.layout );

  		}

  		pipelineGPU.pipeline = device.createComputePipeline( {
  			compute: computeProgram,
  			layout: device.createPipelineLayout( {
  				bindGroupLayouts
  			} )
  		} );

  	}

  	/**
  	 * Returns the blending state as a descriptor object required
  	 * for the pipeline creation.
  	 *
  	 * @private
  	 * @param {Material} material - The material.
  	 * @return {Object} The blending state.
  	 */
  	_getBlending( material ) {

  		let color, alpha;

  		const blending = material.blending;
  		const blendSrc = material.blendSrc;
  		const blendDst = material.blendDst;
  		const blendEquation = material.blendEquation;


  		if ( blending === CustomBlending ) {

  			const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
  			const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
  			const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;

  			color = {
  				srcFactor: this._getBlendFactor( blendSrc ),
  				dstFactor: this._getBlendFactor( blendDst ),
  				operation: this._getBlendOperation( blendEquation )
  			};

  			alpha = {
  				srcFactor: this._getBlendFactor( blendSrcAlpha ),
  				dstFactor: this._getBlendFactor( blendDstAlpha ),
  				operation: this._getBlendOperation( blendEquationAlpha )
  			};

  		} else {

  			const premultipliedAlpha = material.premultipliedAlpha;

  			const setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {

  				color = {
  					srcFactor: srcRGB,
  					dstFactor: dstRGB,
  					operation: GPUBlendOperation.Add
  				};

  				alpha = {
  					srcFactor: srcAlpha,
  					dstFactor: dstAlpha,
  					operation: GPUBlendOperation.Add
  				};

  			};

  			if ( premultipliedAlpha ) {

  				switch ( blending ) {

  					case NormalBlending:
  						setBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
  						break;

  					case AdditiveBlending:
  						setBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
  						break;

  					case SubtractiveBlending:
  						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
  						break;

  					case MultiplyBlending:
  						setBlend( GPUBlendFactor.Dst, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.Zero, GPUBlendFactor.One );
  						break;

  				}

  			} else {

  				switch ( blending ) {

  					case NormalBlending:
  						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
  						break;

  					case AdditiveBlending:
  						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
  						break;

  					case SubtractiveBlending:
  						console.error( 'THREE.WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true' );
  						break;

  					case MultiplyBlending:
  						console.error( 'THREE.WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true' );
  						break;

  				}

  			}

  		}

  		if ( color !== undefined && alpha !== undefined ) {

  			return { color, alpha };

  		} else {

  			console.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );

  		}

  	}
  	/**
  	 * Returns the GPU blend factor which is required for the pipeline creation.
  	 *
  	 * @private
  	 * @param {number} blend - The blend factor as a three.js constant.
  	 * @return {string} The GPU blend factor.
  	 */
  	_getBlendFactor( blend ) {

  		let blendFactor;

  		switch ( blend ) {

  			case ZeroFactor:
  				blendFactor = GPUBlendFactor.Zero;
  				break;

  			case OneFactor:
  				blendFactor = GPUBlendFactor.One;
  				break;

  			case SrcColorFactor:
  				blendFactor = GPUBlendFactor.Src;
  				break;

  			case OneMinusSrcColorFactor:
  				blendFactor = GPUBlendFactor.OneMinusSrc;
  				break;

  			case SrcAlphaFactor:
  				blendFactor = GPUBlendFactor.SrcAlpha;
  				break;

  			case OneMinusSrcAlphaFactor:
  				blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
  				break;

  			case DstColorFactor:
  				blendFactor = GPUBlendFactor.Dst;
  				break;

  			case OneMinusDstColorFactor:
  				blendFactor = GPUBlendFactor.OneMinusDst;
  				break;

  			case DstAlphaFactor:
  				blendFactor = GPUBlendFactor.DstAlpha;
  				break;

  			case OneMinusDstAlphaFactor:
  				blendFactor = GPUBlendFactor.OneMinusDstAlpha;
  				break;

  			case SrcAlphaSaturateFactor:
  				blendFactor = GPUBlendFactor.SrcAlphaSaturated;
  				break;

  			case BlendColorFactor:
  				blendFactor = GPUBlendFactor.Constant;
  				break;

  			case OneMinusBlendColorFactor:
  				blendFactor = GPUBlendFactor.OneMinusConstant;
  				break;

  			default:
  				console.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );

  		}

  		return blendFactor;

  	}

  	/**
  	 * Returns the GPU stencil compare function which is required for the pipeline creation.
  	 *
  	 * @private
  	 * @param {Material} material - The material.
  	 * @return {string} The GPU stencil compare function.
  	 */
  	_getStencilCompare( material ) {

  		let stencilCompare;

  		const stencilFunc = material.stencilFunc;

  		switch ( stencilFunc ) {

  			case NeverStencilFunc:
  				stencilCompare = GPUCompareFunction.Never;
  				break;

  			case AlwaysStencilFunc:
  				stencilCompare = GPUCompareFunction.Always;
  				break;

  			case LessStencilFunc:
  				stencilCompare = GPUCompareFunction.Less;
  				break;

  			case LessEqualStencilFunc:
  				stencilCompare = GPUCompareFunction.LessEqual;
  				break;

  			case EqualStencilFunc:
  				stencilCompare = GPUCompareFunction.Equal;
  				break;

  			case GreaterEqualStencilFunc:
  				stencilCompare = GPUCompareFunction.GreaterEqual;
  				break;

  			case GreaterStencilFunc:
  				stencilCompare = GPUCompareFunction.Greater;
  				break;

  			case NotEqualStencilFunc:
  				stencilCompare = GPUCompareFunction.NotEqual;
  				break;

  			default:
  				console.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );

  		}

  		return stencilCompare;

  	}

  	/**
  	 * Returns the GPU stencil operation which is required for the pipeline creation.
  	 *
  	 * @private
  	 * @param {number} op - A three.js constant defining the stencil operation.
  	 * @return {string} The GPU stencil operation.
  	 */
  	_getStencilOperation( op ) {

  		let stencilOperation;

  		switch ( op ) {

  			case KeepStencilOp:
  				stencilOperation = GPUStencilOperation.Keep;
  				break;

  			case ZeroStencilOp:
  				stencilOperation = GPUStencilOperation.Zero;
  				break;

  			case ReplaceStencilOp:
  				stencilOperation = GPUStencilOperation.Replace;
  				break;

  			case InvertStencilOp:
  				stencilOperation = GPUStencilOperation.Invert;
  				break;

  			case IncrementStencilOp:
  				stencilOperation = GPUStencilOperation.IncrementClamp;
  				break;

  			case DecrementStencilOp:
  				stencilOperation = GPUStencilOperation.DecrementClamp;
  				break;

  			case IncrementWrapStencilOp:
  				stencilOperation = GPUStencilOperation.IncrementWrap;
  				break;

  			case DecrementWrapStencilOp:
  				stencilOperation = GPUStencilOperation.DecrementWrap;
  				break;

  			default:
  				console.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );

  		}

  		return stencilOperation;

  	}

  	/**
  	 * Returns the GPU blend operation which is required for the pipeline creation.
  	 *
  	 * @private
  	 * @param {number} blendEquation - A three.js constant defining the blend equation.
  	 * @return {string} The GPU blend operation.
  	 */
  	_getBlendOperation( blendEquation ) {

  		let blendOperation;

  		switch ( blendEquation ) {

  			case AddEquation:
  				blendOperation = GPUBlendOperation.Add;
  				break;

  			case SubtractEquation:
  				blendOperation = GPUBlendOperation.Subtract;
  				break;

  			case ReverseSubtractEquation:
  				blendOperation = GPUBlendOperation.ReverseSubtract;
  				break;

  			case MinEquation:
  				blendOperation = GPUBlendOperation.Min;
  				break;

  			case MaxEquation:
  				blendOperation = GPUBlendOperation.Max;
  				break;

  			default:
  				console.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );

  		}

  		return blendOperation;

  	}

  	/**
  	 * Returns the primitive state as a descriptor object required
  	 * for the pipeline creation.
  	 *
  	 * @private
  	 * @param {Object3D} object - The 3D object.
  	 * @param {BufferGeometry} geometry - The geometry.
  	 * @param {Material} material - The material.
  	 * @return {Object} The primitive state.
  	 */
  	_getPrimitiveState( object, geometry, material ) {

  		const descriptor = {};
  		const utils = this.backend.utils;

  		descriptor.topology = utils.getPrimitiveTopology( object, material );

  		if ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {

  			descriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

  		}

  		switch ( material.side ) {

  			case FrontSide:
  				descriptor.frontFace = GPUFrontFace.CCW;
  				descriptor.cullMode = GPUCullMode.Back;
  				break;

  			case BackSide:
  				descriptor.frontFace = GPUFrontFace.CCW;
  				descriptor.cullMode = GPUCullMode.Front;
  				break;

  			case DoubleSide:
  				descriptor.frontFace = GPUFrontFace.CCW;
  				descriptor.cullMode = GPUCullMode.None;
  				break;

  			default:
  				console.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );
  				break;

  		}

  		return descriptor;

  	}

  	/**
  	 * Returns the GPU color write mask which is required for the pipeline creation.
  	 *
  	 * @private
  	 * @param {Material} material - The material.
  	 * @return {string} The GPU color write mask.
  	 */
  	_getColorWriteMask( material ) {

  		return ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;

  	}

  	/**
  	 * Returns the GPU depth compare function which is required for the pipeline creation.
  	 *
  	 * @private
  	 * @param {Material} material - The material.
  	 * @return {string} The GPU depth compare function.
  	 */
  	_getDepthCompare( material ) {

  		let depthCompare;

  		if ( material.depthTest === false ) {

  			depthCompare = GPUCompareFunction.Always;

  		} else {

  			const depthFunc = material.depthFunc;

  			switch ( depthFunc ) {

  				case NeverDepth:
  					depthCompare = GPUCompareFunction.Never;
  					break;

  				case AlwaysDepth:
  					depthCompare = GPUCompareFunction.Always;
  					break;

  				case LessDepth:
  					depthCompare = GPUCompareFunction.Less;
  					break;

  				case LessEqualDepth:
  					depthCompare = GPUCompareFunction.LessEqual;
  					break;

  				case EqualDepth:
  					depthCompare = GPUCompareFunction.Equal;
  					break;

  				case GreaterEqualDepth:
  					depthCompare = GPUCompareFunction.GreaterEqual;
  					break;

  				case GreaterDepth:
  					depthCompare = GPUCompareFunction.Greater;
  					break;

  				case NotEqualDepth:
  					depthCompare = GPUCompareFunction.NotEqual;
  					break;

  				default:
  					console.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );

  			}

  		}

  		return depthCompare;

  	}

  }

  /**
   * Manages a pool of WebGPU timestamp queries for performance measurement.
   * Extends the base TimestampQueryPool to provide WebGPU-specific implementation.
   *
   * @augments TimestampQueryPool
   */
  class WebGPUTimestampQueryPool extends TimestampQueryPool {

  	/**
  	 * Creates a new WebGPU timestamp query pool.
  	 *
  	 * @param {GPUDevice} device - The WebGPU device to create queries on.
  	 * @param {string} type - The type identifier for this query pool.
  	 * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
  	 */
  	constructor( device, type, maxQueries = 2048 ) {

  		super( maxQueries );
  		this.device = device;
  		this.type = type;

  		this.querySet = this.device.createQuerySet( {
  			type: 'timestamp',
  			count: this.maxQueries,
  			label: `queryset_global_timestamp_${type}`
  		} );

  		const bufferSize = this.maxQueries * 8;
  		this.resolveBuffer = this.device.createBuffer( {
  			label: `buffer_timestamp_resolve_${type}`,
  			size: bufferSize,
  			usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
  		} );

  		this.resultBuffer = this.device.createBuffer( {
  			label: `buffer_timestamp_result_${type}`,
  			size: bufferSize,
  			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  		} );

  	}

  	/**
  	 * Allocates a pair of queries for a given render context.
  	 *
  	 * @param {Object} renderContext - The render context to allocate queries for.
  	 * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
  	 */
  	allocateQueriesForContext( renderContext ) {

  		if ( ! this.trackTimestamp || this.isDisposed ) return null;

  		if ( this.currentQueryIndex + 2 > this.maxQueries ) {

  			warnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );
  			return null;

  		}

  		const baseOffset = this.currentQueryIndex;
  		this.currentQueryIndex += 2;

  		this.queryOffsets.set( renderContext.id, baseOffset );
  		return baseOffset;

  	}

  	/**
  	 * Asynchronously resolves all pending queries and returns the total duration.
  	 * If there's already a pending resolve operation, returns that promise instead.
  	 *
  	 * @async
  	 * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
  	 */
  	async resolveQueriesAsync() {

  		if ( ! this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed ) {

  			return this.lastValue;

  		}

  		if ( this.pendingResolve ) {

  			return this.pendingResolve;

  		}

  		this.pendingResolve = this._resolveQueries();

  		try {

  			const result = await this.pendingResolve;
  			return result;

  		} finally {

  			this.pendingResolve = null;

  		}

  	}

  	/**
  	 * Internal method to resolve queries and calculate total duration.
  	 *
  	 * @async
  	 * @private
  	 * @returns {Promise<number>} The total duration in milliseconds.
  	 */
  	async _resolveQueries() {

  		if ( this.isDisposed ) {

  			return this.lastValue;

  		}

  		try {

  			if ( this.resultBuffer.mapState !== 'unmapped' ) {

  				return this.lastValue;

  			}

  			const currentOffsets = new Map( this.queryOffsets );
  			const queryCount = this.currentQueryIndex;
  			const bytesUsed = queryCount * 8;

  			// Reset state before GPU work
  			this.currentQueryIndex = 0;
  			this.queryOffsets.clear();

  			const commandEncoder = this.device.createCommandEncoder();

  			commandEncoder.resolveQuerySet(
  				this.querySet,
  				0,
  				queryCount,
  				this.resolveBuffer,
  				0
  			);

  			commandEncoder.copyBufferToBuffer(
  				this.resolveBuffer,
  				0,
  				this.resultBuffer,
  				0,
  				bytesUsed
  			);

  			const commandBuffer = commandEncoder.finish();
  			this.device.queue.submit( [ commandBuffer ] );

  			if ( this.resultBuffer.mapState !== 'unmapped' ) {

  				return this.lastValue;

  			}

  			// Create and track the mapping operation
  			await this.resultBuffer.mapAsync( GPUMapMode.READ, 0, bytesUsed );

  			if ( this.isDisposed ) {

  				if ( this.resultBuffer.mapState === 'mapped' ) {

  					this.resultBuffer.unmap();

  				}

  				return this.lastValue;

  			}

  			const times = new BigUint64Array( this.resultBuffer.getMappedRange( 0, bytesUsed ) );
  			let totalDuration = 0;

  			for ( const [ , baseOffset ] of currentOffsets ) {

  				const startTime = times[ baseOffset ];
  				const endTime = times[ baseOffset + 1 ];
  				const duration = Number( endTime - startTime ) / 1e6;
  				totalDuration += duration;

  			}

  			this.resultBuffer.unmap();
  			this.lastValue = totalDuration;

  			return totalDuration;

  		} catch ( error ) {

  			console.error( 'Error resolving queries:', error );
  			if ( this.resultBuffer.mapState === 'mapped' ) {

  				this.resultBuffer.unmap();

  			}

  			return this.lastValue;

  		}

  	}

  	/**
  	 * Dispose of the query pool.
  	 *
  	 * @async
  	 * @returns {Promise} A Promise that resolves when the dispose has been executed.
  	 */
  	async dispose() {

  		if ( this.isDisposed ) {

  			return;

  		}

  		this.isDisposed = true;

  		// Wait for pending resolve operation
  		if ( this.pendingResolve ) {

  			try {

  				await this.pendingResolve;

  			} catch ( error ) {

  				console.error( 'Error waiting for pending resolve:', error );

  			}

  		}

  		// Ensure buffer is unmapped before destroying
  		if ( this.resultBuffer && this.resultBuffer.mapState === 'mapped' ) {

  			try {

  				this.resultBuffer.unmap();

  			} catch ( error ) {

  				console.error( 'Error unmapping buffer:', error );

  			}

  		}

  		// Destroy resources
  		if ( this.querySet ) {

  			this.querySet.destroy();
  			this.querySet = null;

  		}

  		if ( this.resolveBuffer ) {

  			this.resolveBuffer.destroy();
  			this.resolveBuffer = null;

  		}

  		if ( this.resultBuffer ) {

  			this.resultBuffer.destroy();
  			this.resultBuffer = null;

  		}

  		this.queryOffsets.clear();
  		this.pendingResolve = null;

  	}

  }

  /*// debugger tools
  import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
  //*/


  /**
   * A backend implementation targeting WebGPU.
   *
   * @private
   * @augments Backend
   */
  class WebGPUBackend extends Backend {

  	/**
  	 * WebGPUBackend options.
  	 *
  	 * @typedef {Object} WebGPUBackend~Options
  	 * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
  	 * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
  	 * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
  	 * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
  	 * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
  	 * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
  	 * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
  	 * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
  	 * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
  	 * @property {string} [powerPreference=undefined] - The power preference.
  	 * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
  	 * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
  	 * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
  	 */

  	/**
  	 * Constructs a new WebGPU backend.
  	 *
  	 * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters = {} ) {

  		super( parameters );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGPUBackend = true;

  		// some parameters require default values other than "undefined"
  		this.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;
  		this.parameters.compatibilityMode = ( parameters.compatibilityMode === undefined ) ? false : parameters.compatibilityMode;

  		this.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;

  		/**
  		 * Indicates whether the backend is in compatibility mode or not.
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.compatibilityMode = this.parameters.compatibilityMode;

  		/**
  		 * A reference to the device.
  		 *
  		 * @type {?GPUDevice}
  		 * @default null
  		 */
  		this.device = null;

  		/**
  		 * A reference to the context.
  		 *
  		 * @type {?GPUCanvasContext}
  		 * @default null
  		 */
  		this.context = null;

  		/**
  		 * A reference to the color attachment of the default framebuffer.
  		 *
  		 * @type {?GPUTexture}
  		 * @default null
  		 */
  		this.colorBuffer = null;

  		/**
  		 * A reference to the default render pass descriptor.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.defaultRenderPassdescriptor = null;

  		/**
  		 * A reference to a backend module holding common utility functions.
  		 *
  		 * @type {WebGPUUtils}
  		 */
  		this.utils = new WebGPUUtils( this );

  		/**
  		 * A reference to a backend module holding shader attribute-related
  		 * utility functions.
  		 *
  		 * @type {WebGPUAttributeUtils}
  		 */
  		this.attributeUtils = new WebGPUAttributeUtils( this );

  		/**
  		 * A reference to a backend module holding shader binding-related
  		 * utility functions.
  		 *
  		 * @type {WebGPUBindingUtils}
  		 */
  		this.bindingUtils = new WebGPUBindingUtils( this );

  		/**
  		 * A reference to a backend module holding shader pipeline-related
  		 * utility functions.
  		 *
  		 * @type {WebGPUPipelineUtils}
  		 */
  		this.pipelineUtils = new WebGPUPipelineUtils( this );

  		/**
  		 * A reference to a backend module holding shader texture-related
  		 * utility functions.
  		 *
  		 * @type {WebGPUTextureUtils}
  		 */
  		this.textureUtils = new WebGPUTextureUtils( this );

  		/**
  		 * A map that manages the resolve buffers for occlusion queries.
  		 *
  		 * @type {Map<number,GPUBuffer>}
  		 */
  		this.occludedResolveCache = new Map();

  	}

  	/**
  	 * Initializes the backend so it is ready for usage.
  	 *
  	 * @async
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {Promise} A Promise that resolves when the backend has been initialized.
  	 */
  	async init( renderer ) {

  		await super.init( renderer );

  		//

  		const parameters = this.parameters;

  		// create the device if it is not passed with parameters

  		let device;

  		if ( parameters.device === undefined ) {

  			const adapterOptions = {
  				powerPreference: parameters.powerPreference,
  				featureLevel: parameters.compatibilityMode ? 'compatibility' : undefined
  			};

  			const adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;

  			if ( adapter === null ) {

  				throw new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );

  			}

  			// feature support

  			const features = Object.values( GPUFeatureName );

  			const supportedFeatures = [];

  			for ( const name of features ) {

  				if ( adapter.features.has( name ) ) {

  					supportedFeatures.push( name );

  				}

  			}

  			const deviceDescriptor = {
  				requiredFeatures: supportedFeatures,
  				requiredLimits: parameters.requiredLimits
  			};

  			device = await adapter.requestDevice( deviceDescriptor );

  		} else {

  			device = parameters.device;

  		}

  		device.lost.then( ( info ) => {

  			const deviceLossInfo = {
  				api: 'WebGPU',
  				message: info.message || 'Unknown reason',
  				reason: info.reason || null,
  				originalEvent: info
  			};

  			renderer.onDeviceLost( deviceLossInfo );

  		} );

  		const context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );

  		this.device = device;
  		this.context = context;

  		const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';

  		this.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );

  		this.context.configure( {
  			device: this.device,
  			format: this.utils.getPreferredCanvasFormat(),
  			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
  			alphaMode: alphaMode
  		} );

  		this.updateSize();

  	}

  	/**
  	 * The coordinate system of the backend.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get coordinateSystem() {

  		return WebGPUCoordinateSystem;

  	}

  	/**
  	 * This method performs a readback operation by moving buffer data from
  	 * a storage buffer attribute from the GPU to the CPU.
  	 *
  	 * @async
  	 * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
  	 * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
  	 */
  	async getArrayBufferAsync( attribute ) {

  		return await this.attributeUtils.getArrayBufferAsync( attribute );

  	}

  	/**
  	 * Returns the backend's rendering context.
  	 *
  	 * @return {GPUCanvasContext} The rendering context.
  	 */
  	getContext() {

  		return this.context;

  	}

  	/**
  	 * Returns the default render pass descriptor.
  	 *
  	 * In WebGPU, the default framebuffer must be configured
  	 * like custom framebuffers so the backend needs a render
  	 * pass descriptor even when rendering directly to screen.
  	 *
  	 * @private
  	 * @return {Object} The render pass descriptor.
  	 */
  	_getDefaultRenderPassDescriptor() {

  		let descriptor = this.defaultRenderPassdescriptor;

  		if ( descriptor === null ) {

  			const renderer = this.renderer;

  			descriptor = {
  				colorAttachments: [ {
  					view: null
  				} ],
  			};

  			if ( this.renderer.depth === true || this.renderer.stencil === true ) {

  				descriptor.depthStencilAttachment = {
  					view: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()
  				};

  			}

  			const colorAttachment = descriptor.colorAttachments[ 0 ];

  			if ( this.renderer.samples > 0 ) {

  				colorAttachment.view = this.colorBuffer.createView();

  			} else {

  				colorAttachment.resolveTarget = undefined;

  			}

  			this.defaultRenderPassdescriptor = descriptor;

  		}

  		const colorAttachment = descriptor.colorAttachments[ 0 ];

  		if ( this.renderer.samples > 0 ) {

  			colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

  		} else {

  			colorAttachment.view = this.context.getCurrentTexture().createView();

  		}

  		return descriptor;

  	}

  	/**
  	 * Internal to determine if the current render target is a render target array with depth 2D array texture.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
  	 *
  	 * @private
  	 */
  	_isRenderCameraDepthArray( renderContext ) {

  		return renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;

  	}

  	/**
  	 * Returns the render pass descriptor for the given render context.
  	 *
  	 * @private
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
  	 * @return {Object} The render pass descriptor.
  	 */
  	_getRenderPassDescriptor( renderContext, colorAttachmentsConfig = {} ) {

  		const renderTarget = renderContext.renderTarget;
  		const renderTargetData = this.get( renderTarget );

  		let descriptors = renderTargetData.descriptors;

  		if ( descriptors === undefined ||
  			renderTargetData.width !== renderTarget.width ||
  			renderTargetData.height !== renderTarget.height ||
  			renderTargetData.dimensions !== renderTarget.dimensions ||
  			renderTargetData.activeMipmapLevel !== renderContext.activeMipmapLevel ||
  			renderTargetData.activeCubeFace !== renderContext.activeCubeFace ||
  			renderTargetData.samples !== renderTarget.samples
  		) {

  			descriptors = {};

  			renderTargetData.descriptors = descriptors;

  			// dispose

  			const onDispose = () => {

  				renderTarget.removeEventListener( 'dispose', onDispose );
  				this.delete( renderTarget );

  			};

  			if ( renderTarget.hasEventListener( 'dispose', onDispose ) === false ) {

  				renderTarget.addEventListener( 'dispose', onDispose );

  			}

  		}

  		const cacheKey = renderContext.getCacheKey();
  		let descriptorBase = descriptors[ cacheKey ];

  		if ( descriptorBase === undefined ) {

  			const textures = renderContext.textures;
  			const textureViews = [];

  			let sliceIndex;

  			const isRenderCameraDepthArray = this._isRenderCameraDepthArray( renderContext );

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const textureData = this.get( textures[ i ] );

  				const viewDescriptor = {
  					label: `colorAttachment_${ i }`,
  					baseMipLevel: renderContext.activeMipmapLevel,
  					mipLevelCount: 1,
  					baseArrayLayer: renderContext.activeCubeFace,
  					arrayLayerCount: 1,
  					dimension: GPUTextureViewDimension.TwoD
  				};

  				if ( renderTarget.isRenderTarget3D ) {

  					sliceIndex = renderContext.activeCubeFace;

  					viewDescriptor.baseArrayLayer = 0;
  					viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
  					viewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;

  				} else if ( renderTarget.isRenderTarget && textures[ i ].image.depth > 1 ) {

  					if ( isRenderCameraDepthArray === true ) {

  						const cameras = renderContext.camera.cameras;
  						for ( let layer = 0; layer < cameras.length; layer ++ ) {

  							const layerViewDescriptor = {
  								...viewDescriptor,
  								baseArrayLayer: layer,
  								arrayLayerCount: 1,
  								dimension: GPUTextureViewDimension.TwoD
  							};
  							const textureView = textureData.texture.createView( layerViewDescriptor );
  							textureViews.push( {
  								view: textureView,
  								resolveTarget: undefined,
  								depthSlice: undefined
  							} );

  						}

  					} else {

  						viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
  						viewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;

  					}

  				}

  				if ( isRenderCameraDepthArray !== true ) {

  					const textureView = textureData.texture.createView( viewDescriptor );

  					let view, resolveTarget;

  					if ( textureData.msaaTexture !== undefined ) {

  						view = textureData.msaaTexture.createView();
  						resolveTarget = textureView;

  					} else {

  						view = textureView;
  						resolveTarget = undefined;

  					}

  					textureViews.push( {
  						view,
  						resolveTarget,
  						depthSlice: sliceIndex
  					} );

  				}

  			}

  			descriptorBase = { textureViews };

  			if ( renderContext.depth ) {

  				const depthTextureData = this.get( renderContext.depthTexture );
  				const options = {};
  				if ( renderContext.depthTexture.isArrayTexture ) {

  					options.dimension = GPUTextureViewDimension.TwoD;
  					options.arrayLayerCount = 1;
  					options.baseArrayLayer = renderContext.activeCubeFace;

  				}

  				descriptorBase.depthStencilView = depthTextureData.texture.createView( options );

  			}

  			descriptors[ cacheKey ] = descriptorBase;

  			renderTargetData.width = renderTarget.width;
  			renderTargetData.height = renderTarget.height;
  			renderTargetData.samples = renderTarget.samples;
  			renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
  			renderTargetData.activeCubeFace = renderContext.activeCubeFace;
  			renderTargetData.dimensions = renderTarget.dimensions;

  		}

  		const descriptor = {
  			colorAttachments: []
  		};

  		// Apply dynamic properties to cached views
  		for ( let i = 0; i < descriptorBase.textureViews.length; i ++ ) {

  			const viewInfo = descriptorBase.textureViews[ i ];

  			let clearValue = { r: 0, g: 0, b: 0, a: 1 };
  			if ( i === 0 && colorAttachmentsConfig.clearValue ) {

  				clearValue = colorAttachmentsConfig.clearValue;

  			}

  			descriptor.colorAttachments.push( {
  				view: viewInfo.view,
  				depthSlice: viewInfo.depthSlice,
  				resolveTarget: viewInfo.resolveTarget,
  				loadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,
  				storeOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,
  				clearValue: clearValue
  			} );

  		}

  		if ( descriptorBase.depthStencilView ) {

  			descriptor.depthStencilAttachment = {
  				view: descriptorBase.depthStencilView
  			};

  		}

  		return descriptor;

  	}

  	/**
  	 * This method is executed at the beginning of a render call and prepares
  	 * the WebGPU state for upcoming render calls
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	beginRender( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		const device = this.device;
  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		let occlusionQuerySet;

  		if ( occlusionQueryCount > 0 ) {

  			if ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();
  			if ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();

  			// Get a reference to the array of objects with queries. The renderContextData property
  			// can be changed by another render pass before the buffer.mapAsyc() completes.
  			renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
  			renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
  			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

  			//

  			occlusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );

  			renderContextData.occlusionQuerySet = occlusionQuerySet;
  			renderContextData.occlusionQueryIndex = 0;
  			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );

  			renderContextData.lastOcclusionObject = null;

  		}

  		let descriptor;

  		if ( renderContext.textures === null ) {

  			descriptor = this._getDefaultRenderPassDescriptor();

  		} else {

  			descriptor = this._getRenderPassDescriptor( renderContext, { loadOp: GPULoadOp.Load } );

  		}

  		this.initTimestampQuery( renderContext, descriptor );

  		descriptor.occlusionQuerySet = occlusionQuerySet;

  		const depthStencilAttachment = descriptor.depthStencilAttachment;

  		if ( renderContext.textures !== null ) {

  			const colorAttachments = descriptor.colorAttachments;

  			for ( let i = 0; i < colorAttachments.length; i ++ ) {

  				const colorAttachment = colorAttachments[ i ];

  				if ( renderContext.clearColor ) {

  					colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
  					colorAttachment.loadOp = GPULoadOp.Clear;

  				} else {

  					colorAttachment.loadOp = GPULoadOp.Load;

  				}

  				colorAttachment.storeOp = GPUStoreOp.Store;

  			}

  		} else {

  			const colorAttachment = descriptor.colorAttachments[ 0 ];

  			if ( renderContext.clearColor ) {

  				colorAttachment.clearValue = renderContext.clearColorValue;
  				colorAttachment.loadOp = GPULoadOp.Clear;

  			} else {

  				colorAttachment.loadOp = GPULoadOp.Load;

  			}

  		  	colorAttachment.storeOp = GPUStoreOp.Store;

  		}

  		//

  		if ( renderContext.depth ) {

  			if ( renderContext.clearDepth ) {

  				depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
  				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;

  			} else {

  				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;

  			}

  		  depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  		}

  		if ( renderContext.stencil ) {

  		  if ( renderContext.clearStencil ) {

  				depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;

  			} else {

  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

  			}

  		  depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  		}

  		//

  		const encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );

  		// shadow arrays - prepare bundle encoders for each camera in an array camera

  		if ( this._isRenderCameraDepthArray( renderContext ) === true ) {

  			const cameras = renderContext.camera.cameras;

  			if ( ! renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length ) {

  				this._createDepthLayerDescriptors( renderContext, renderContextData, descriptor, cameras );

  			} else {

  				this._updateDepthLayerDescriptors( renderContext, renderContextData, cameras );

  			}

  			// Create bundle encoders for each layer
  			renderContextData.bundleEncoders = [];
  			renderContextData.bundleSets = [];

  			// Create separate bundle encoders for each camera in the array
  			for ( let i = 0; i < cameras.length; i ++ ) {

  				const bundleEncoder = this.pipelineUtils.createBundleEncoder(
  					renderContext,
  					'renderBundleArrayCamera_' + i
  				);

  				// Initialize state tracking for this bundle
  				const bundleSets = {
  					attributes: {},
  					bindingGroups: [],
  					pipeline: null,
  					index: null
  				};

  				renderContextData.bundleEncoders.push( bundleEncoder );
  				renderContextData.bundleSets.push( bundleSets );

  			}

  			// We'll complete the bundles in finishRender
  			renderContextData.currentPass = null;

  		} else {

  			const currentPass = encoder.beginRenderPass( descriptor );
  			renderContextData.currentPass = currentPass;

  			if ( renderContext.viewport ) {

  				this.updateViewport( renderContext );

  			}

  			if ( renderContext.scissor ) {

  				const { x, y, width, height } = renderContext.scissorValue;
  				currentPass.setScissorRect( x, y, width, height );

  			}

  		}

  		//

  		renderContextData.descriptor = descriptor;
  		renderContextData.encoder = encoder;
  		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
  		renderContextData.renderBundles = [];

  	}

  	/**
  	 * This method creates layer descriptors for each camera in an array camera
  	 * to prepare for rendering to a depth array texture.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object} renderContextData - The render context data.
  	 * @param {Object} descriptor  - The render pass descriptor.
  	 * @param {ArrayCamera} cameras - The array camera.
  	 *
  	 * @private
  	 */
  	_createDepthLayerDescriptors( renderContext, renderContextData, descriptor, cameras ) {

  		const depthStencilAttachment = descriptor.depthStencilAttachment;
  		renderContextData.layerDescriptors = [];

  		const depthTextureData = this.get( renderContext.depthTexture );
  		if ( ! depthTextureData.viewCache ) {

  			depthTextureData.viewCache = [];

  		}

  		for ( let i = 0; i < cameras.length; i ++ ) {

  			const layerDescriptor = {
  				...descriptor,
  				colorAttachments: [ {
  					...descriptor.colorAttachments[ 0 ],
  					view: descriptor.colorAttachments[ i ].view
  				} ]
  			};

  			if ( descriptor.depthStencilAttachment ) {

  				const layerIndex = i;

  				if ( ! depthTextureData.viewCache[ layerIndex ] ) {

  					depthTextureData.viewCache[ layerIndex ] = depthTextureData.texture.createView( {
  						dimension: GPUTextureViewDimension.TwoD,
  						baseArrayLayer: i,
  						arrayLayerCount: 1
  					} );

  				}

  				layerDescriptor.depthStencilAttachment = {
  					view: depthTextureData.viewCache[ layerIndex ],
  					depthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,
  					depthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,
  					depthClearValue: depthStencilAttachment.depthClearValue || 1.0
  				};

  				if ( renderContext.stencil ) {

  					layerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;
  					layerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;
  					layerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;

  				}

  			} else {

  				layerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };

  			}

  			renderContextData.layerDescriptors.push( layerDescriptor );

  		}

  	}

  	/**
  	 * This method updates the layer descriptors for each camera in an array camera
  	 * to prepare for rendering to a depth array texture.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object} renderContextData - The render context data.
  	 * @param {ArrayCamera} cameras - The array camera.
  	 *
  	 */
  	_updateDepthLayerDescriptors( renderContext, renderContextData, cameras ) {

  		for ( let i = 0; i < cameras.length; i ++ ) {

  			const layerDescriptor = renderContextData.layerDescriptors[ i ];

  			if ( layerDescriptor.depthStencilAttachment ) {

  				const depthAttachment = layerDescriptor.depthStencilAttachment;

  				if ( renderContext.depth ) {

  					if ( renderContext.clearDepth ) {

  						depthAttachment.depthClearValue = renderContext.clearDepthValue;
  						depthAttachment.depthLoadOp = GPULoadOp.Clear;

  					} else {

  						depthAttachment.depthLoadOp = GPULoadOp.Load;

  					}

  				}

  				if ( renderContext.stencil ) {

  					if ( renderContext.clearStencil ) {

  						depthAttachment.stencilClearValue = renderContext.clearStencilValue;
  						depthAttachment.stencilLoadOp = GPULoadOp.Clear;

  					} else {

  						depthAttachment.stencilLoadOp = GPULoadOp.Load;

  					}

  				}

  			}

  		}

  	}

  	/**
  	 * This method is executed at the end of a render call and finalizes work
  	 * after draw calls.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	finishRender( renderContext ) {

  		const renderContextData = this.get( renderContext );
  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		if ( renderContextData.renderBundles.length > 0 ) {

  			renderContextData.currentPass.executeBundles( renderContextData.renderBundles );

  		}

  		if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

  			renderContextData.currentPass.endOcclusionQuery();

  		}

  		// shadow arrays - Execute bundles for each layer

  		const encoder = renderContextData.encoder;

  		if ( this._isRenderCameraDepthArray( renderContext ) === true ) {

  		  const bundles = [];

  		  for ( let i = 0; i < renderContextData.bundleEncoders.length; i ++ ) {

  				const bundleEncoder = renderContextData.bundleEncoders[ i ];
  				bundles.push( bundleEncoder.finish() );

  			}

  		  for ( let i = 0; i < renderContextData.layerDescriptors.length; i ++ ) {

  				if ( i < bundles.length ) {

  					const layerDescriptor = renderContextData.layerDescriptors[ i ];
  					const renderPass = encoder.beginRenderPass( layerDescriptor );

  					if ( renderContext.viewport ) {

  						const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
  						renderPass.setViewport( x, y, width, height, minDepth, maxDepth );

  					}

  					if ( renderContext.scissor ) {

  						const { x, y, width, height } = renderContext.scissorValue;
  						renderPass.setScissorRect( x, y, width, height );

  					}

  					renderPass.executeBundles( [ bundles[ i ] ] );

  					renderPass.end();

  				}

  			}

  		} else if ( renderContextData.currentPass ) {

  		  renderContextData.currentPass.end();

  		}

  		if ( occlusionQueryCount > 0 ) {

  			const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results

  			//

  			let queryResolveBuffer = this.occludedResolveCache.get( bufferSize );

  			if ( queryResolveBuffer === undefined ) {

  				queryResolveBuffer = this.device.createBuffer(
  					{
  						size: bufferSize,
  						usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
  					}
  				);

  				this.occludedResolveCache.set( bufferSize, queryResolveBuffer );

  			}

  			//

  			const readBuffer = this.device.createBuffer(
  				{
  					size: bufferSize,
  					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  				}
  			);

  			// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
  			renderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );
  			renderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );

  			renderContextData.occlusionQueryBuffer = readBuffer;

  			//

  			this.resolveOccludedAsync( renderContext );

  		}

  		this.device.queue.submit( [ renderContextData.encoder.finish() ] );


  		//

  		if ( renderContext.textures !== null ) {

  			const textures = renderContext.textures;

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				if ( texture.generateMipmaps === true ) {

  					this.textureUtils.generateMipmaps( texture );

  				}

  			}

  		}

  	}

  	/**
  	 * Returns `true` if the given 3D object is fully occluded by other
  	 * 3D objects in the scene.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object3D} object - The 3D object to test.
  	 * @return {boolean} Whether the 3D object is fully occluded or not.
  	 */
  	isOccluded( renderContext, object ) {

  		const renderContextData = this.get( renderContext );

  		return renderContextData.occluded && renderContextData.occluded.has( object );

  	}

  	/**
  	 * This method processes the result of occlusion queries and writes it
  	 * into render context data.
  	 *
  	 * @async
  	 * @param {RenderContext} renderContext - The render context.
  	 * @return {Promise} A Promise that resolves when the occlusion query results have been processed.
  	 */
  	async resolveOccludedAsync( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		// handle occlusion query results

  		const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;

  		if ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {

  			const occluded = new WeakSet();

  			renderContextData.currentOcclusionQueryObjects = null;
  			renderContextData.currentOcclusionQueryBuffer = null;

  			await currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );

  			const buffer = currentOcclusionQueryBuffer.getMappedRange();
  			const results = new BigUint64Array( buffer );

  			for ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {

  				if ( results[ i ] === BigInt( 0 ) ) {

  					occluded.add( currentOcclusionQueryObjects[ i ] );

  				}

  			}

  			currentOcclusionQueryBuffer.destroy();

  			renderContextData.occluded = occluded;

  		}

  	}

  	/**
  	 * Updates the viewport with the values from the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	updateViewport( renderContext ) {

  		const { currentPass } = this.get( renderContext );
  		const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;

  		currentPass.setViewport( x, y, width, height, minDepth, maxDepth );

  	}

  	/**
  	 * Returns the clear color and alpha into a single
  	 * color object.
  	 *
  	 * @return {Color4} The clear color.
  	 */
  	getClearColor() {

  		const clearColor = super.getClearColor();

  		// only premultiply alpha when alphaMode is "premultiplied"

  		if ( this.renderer.alpha === true ) {

  			clearColor.r *= clearColor.a;
  			clearColor.g *= clearColor.a;
  			clearColor.b *= clearColor.a;

  		}

  		return clearColor;

  	}

  	/**
  	 * Performs a clear operation.
  	 *
  	 * @param {boolean} color - Whether the color buffer should be cleared or not.
  	 * @param {boolean} depth - Whether the depth buffer should be cleared or not.
  	 * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
  	 * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
  	 */
  	clear( color, depth, stencil, renderTargetContext = null ) {

  		const device = this.device;
  		const renderer = this.renderer;

  		let colorAttachments = [];
  		let depthStencilAttachment;
  		let clearValue;

  		let supportsDepth;
  		let supportsStencil;

  		if ( color ) {

  			const clearColor = this.getClearColor();
  			clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };

  		}

  		if ( renderTargetContext === null ) {

  			supportsDepth = renderer.depth;
  			supportsStencil = renderer.stencil;

  			const descriptor = this._getDefaultRenderPassDescriptor();

  			if ( color ) {

  				colorAttachments = descriptor.colorAttachments;

  				const colorAttachment = colorAttachments[ 0 ];

  				colorAttachment.clearValue = clearValue;
  				colorAttachment.loadOp = GPULoadOp.Clear;
  				colorAttachment.storeOp = GPUStoreOp.Store;

  			}

  			if ( supportsDepth || supportsStencil ) {

  				depthStencilAttachment = descriptor.depthStencilAttachment;

  			}

  		} else {

  			supportsDepth = renderTargetContext.depth;
  			supportsStencil = renderTargetContext.stencil;

  			const clearConfig = {
  				loadOp: color ? GPULoadOp.Clear : GPULoadOp.Load,
  				clearValue: color ? clearValue : undefined
  			};

  			if ( supportsDepth ) {

  				clearConfig.depthLoadOp = depth ? GPULoadOp.Clear : GPULoadOp.Load;
  				clearConfig.depthClearValue = depth ? renderer.getClearDepth() : undefined;
  				clearConfig.depthStoreOp = GPUStoreOp.Store;

  			}

  			if ( supportsStencil ) {

  				clearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;
  				clearConfig.stencilClearValue = stencil ? renderer.getClearStencil() : undefined;
  				clearConfig.stencilStoreOp = GPUStoreOp.Store;

  			}

  			const descriptor = this._getRenderPassDescriptor( renderTargetContext, clearConfig );

  			colorAttachments = descriptor.colorAttachments;
  			depthStencilAttachment = descriptor.depthStencilAttachment;

  		}

  		if ( supportsDepth && depthStencilAttachment && depthStencilAttachment.depthLoadOp === undefined ) {

  			if ( depth ) {

  				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
  				depthStencilAttachment.depthClearValue = renderer.getClearDepth();
  				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  			} else {

  				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
  				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  			}

  		}

  		//

  		if ( supportsStencil && depthStencilAttachment && depthStencilAttachment.stencilLoadOp === undefined ) {

  			if ( stencil ) {

  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
  				depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
  				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  			} else {

  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
  				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  			}

  		}

  		//

  		const encoder = device.createCommandEncoder( { label: 'clear' } );
  		const currentPass = encoder.beginRenderPass( {
  			colorAttachments,
  			depthStencilAttachment
  		} );

  		currentPass.end();

  		device.queue.submit( [ encoder.finish() ] );

  	}

  	// compute

  	/**
  	 * This method is executed at the beginning of a compute call and
  	 * prepares the state for upcoming compute tasks.
  	 *
  	 * @param {Node|Array<Node>} computeGroup - The compute node(s).
  	 */
  	beginCompute( computeGroup ) {

  		const groupGPU = this.get( computeGroup );


  		const descriptor = {
  			label: 'computeGroup_' + computeGroup.id
  		};

  		this.initTimestampQuery( computeGroup, descriptor );

  		groupGPU.cmdEncoderGPU = this.device.createCommandEncoder( { label: 'computeGroup_' + computeGroup.id } );

  		groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );

  	}

  	/**
  	 * Executes a compute command for the given compute node.
  	 *
  	 * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
  	 * @param {Node} computeNode - The compute node.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 * @param {ComputePipeline} pipeline - The compute pipeline.
  	 */
  	compute( computeGroup, computeNode, bindings, pipeline ) {

  		const { passEncoderGPU } = this.get( computeGroup );

  		// pipeline

  		const pipelineGPU = this.get( pipeline ).pipeline;

  		this.pipelineUtils.setPipeline( passEncoderGPU, pipelineGPU );

  		// bind groups

  		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

  			const bindGroup = bindings[ i ];
  			const bindingsData = this.get( bindGroup );

  			passEncoderGPU.setBindGroup( i, bindingsData.group );

  		}

  		const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;

  		const computeNodeData = this.get( computeNode );

  		if ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };

  		const { dispatchSize } = computeNodeData;

  		if ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {

  			dispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );
  			dispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );

  		} else {

  			dispatchSize.x = computeNode.dispatchCount;

  		}

  		passEncoderGPU.dispatchWorkgroups(
  			dispatchSize.x,
  			dispatchSize.y,
  			dispatchSize.z
  		);

  	}

  	/**
  	 * This method is executed at the end of a compute call and
  	 * finalizes work after compute tasks.
  	 *
  	 * @param {Node|Array<Node>} computeGroup - The compute node(s).
  	 */
  	finishCompute( computeGroup ) {

  		const groupData = this.get( computeGroup );

  		groupData.passEncoderGPU.end();

  		this.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );

  	}

  	/**
  	 * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
  	 * the CPU waits for the GPU to complete its operation (e.g. a compute task).
  	 *
  	 * @async
  	 * @return {Promise} A Promise that resolves when synchronization has been finished.
  	 */
  	async waitForGPU() {

  		await this.device.queue.onSubmittedWorkDone();

  	}

  	// render object

  	/**
  	 * Executes a draw command for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object to draw.
  	 * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
  	 */
  	draw( renderObject, info ) {

  		const { object, material, context, pipeline } = renderObject;
  		const bindings = renderObject.getBindings();
  		const renderContextData = this.get( context );
  		const pipelineGPU = this.get( pipeline ).pipeline;

  		const index = renderObject.getIndex();
  		const hasIndex = ( index !== null );


  		const drawParams = renderObject.getDrawParameters();
  		if ( drawParams === null ) return;

  		// pipeline

  		const setPipelineAndBindings = ( passEncoderGPU, currentSets ) => {

  			// pipeline
  			this.pipelineUtils.setPipeline( passEncoderGPU, pipelineGPU );
  			currentSets.pipeline = pipelineGPU;

  			// bind groups
  			const currentBindingGroups = currentSets.bindingGroups;
  			for ( let i = 0, l = bindings.length; i < l; i ++ ) {

  				const bindGroup = bindings[ i ];
  				const bindingsData = this.get( bindGroup );
  				if ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {

  					passEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );
  					currentBindingGroups[ bindGroup.index ] = bindGroup.id;

  				}

  			}

  			// attributes

  			// index

  			if ( hasIndex === true ) {

  				if ( currentSets.index !== index ) {

  					const buffer = this.get( index ).buffer;
  					const indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

  					passEncoderGPU.setIndexBuffer( buffer, indexFormat );

  					currentSets.index = index;

  				}

  			}
  			// vertex buffers

  			const vertexBuffers = renderObject.getVertexBuffers();

  			for ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {

  				const vertexBuffer = vertexBuffers[ i ];

  				if ( currentSets.attributes[ i ] !== vertexBuffer ) {

  					const buffer = this.get( vertexBuffer ).buffer;
  					passEncoderGPU.setVertexBuffer( i, buffer );

  					currentSets.attributes[ i ] = vertexBuffer;

  				}

  			}
  			// stencil

  			if ( context.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef ) {

  				passEncoderGPU.setStencilReference( material.stencilRef );
  				renderContextData.currentStencilRef = material.stencilRef;

  			}


  		};

  		// Define draw function
  		const draw = ( passEncoderGPU, currentSets ) => {

  			setPipelineAndBindings( passEncoderGPU, currentSets );

  			if ( object.isBatchedMesh === true ) {

  				const starts = object._multiDrawStarts;
  				const counts = object._multiDrawCounts;
  				const drawCount = object._multiDrawCount;
  				const drawInstances = object._multiDrawInstances;

  				if ( drawInstances !== null ) {

  					// @deprecated, r174
  					warnOnce( 'THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );

  				}

  				for ( let i = 0; i < drawCount; i ++ ) {

  					const count = drawInstances ? drawInstances[ i ] : 1;
  					const firstInstance = count > 1 ? 0 : i;

  					if ( hasIndex === true ) {

  						passEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / index.array.BYTES_PER_ELEMENT, 0, firstInstance );

  					} else {

  						passEncoderGPU.draw( counts[ i ], count, starts[ i ], firstInstance );

  					}

  					info.update( object, counts[ i ], count );

  				}

  			} else if ( hasIndex === true ) {

  				const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;

  				const indirect = renderObject.getIndirect();

  				if ( indirect !== null ) {

  					const buffer = this.get( indirect ).buffer;

  					passEncoderGPU.drawIndexedIndirect( buffer, 0 );

  				} else {

  					passEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );

  				}

  				info.update( object, indexCount, instanceCount );

  			} else {

  				const { vertexCount, instanceCount, firstVertex } = drawParams;

  				const indirect = renderObject.getIndirect();

  				if ( indirect !== null ) {

  					const buffer = this.get( indirect ).buffer;

  					passEncoderGPU.drawIndirect( buffer, 0 );

  				} else {

  					passEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );

  				}

  				info.update( object, vertexCount, instanceCount );

  			}

  		};

  		if ( renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0 ) {

  			const cameraData = this.get( renderObject.camera );
  			const cameras = renderObject.camera.cameras;
  			const cameraIndex = renderObject.getBindingGroup( 'cameraIndex' );

  			if ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {

  				const bindingsData = this.get( cameraIndex );
  				const indexesGPU = [];

  				const data = new Uint32Array( [ 0, 0, 0, 0 ] );

  				for ( let i = 0, len = cameras.length; i < len; i ++ ) {

  					data[ 0 ] = i;

  					const bindGroupIndex = this.bindingUtils.createBindGroupIndex( data, bindingsData.layout );

  					indexesGPU.push( bindGroupIndex );

  				}

  				cameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this

  			}

  			const pixelRatio = this.renderer.getPixelRatio();

  			for ( let i = 0, len = cameras.length; i < len; i ++ ) {

  				const subCamera = cameras[ i ];

  				if ( object.layers.test( subCamera.layers ) ) {

  					const vp = subCamera.viewport;



  					let pass = renderContextData.currentPass;
  					let sets = renderContextData.currentSets;
  					if ( renderContextData.bundleEncoders ) {

  						const bundleEncoder = renderContextData.bundleEncoders[ i ];
  						const bundleSets = renderContextData.bundleSets[ i ];
  						pass = bundleEncoder;
  						sets = bundleSets;

  					}



  					if ( vp ) {

  						pass.setViewport(
  							Math.floor( vp.x * pixelRatio ),
  							Math.floor( vp.y * pixelRatio ),
  							Math.floor( vp.width * pixelRatio ),
  							Math.floor( vp.height * pixelRatio ),
  							context.viewportValue.minDepth,
  							context.viewportValue.maxDepth
  						);

  					}


  					// Set camera index binding for this layer
  					if ( cameraIndex && cameraData.indexesGPU ) {

  						pass.setBindGroup( cameraIndex.index, cameraData.indexesGPU[ i ] );
  						sets.bindingGroups[ cameraIndex.index ] = cameraIndex.id;

  					}

  					draw( pass, sets );


  				}

  			}

  		} else {

  			// Regular single camera rendering
  			if ( renderContextData.currentPass ) {

  				// Handle occlusion queries
  				if ( renderContextData.occlusionQuerySet !== undefined ) {

  					const lastObject = renderContextData.lastOcclusionObject;
  					if ( lastObject !== object ) {

  						if ( lastObject !== null && lastObject.occlusionTest === true ) {

  							renderContextData.currentPass.endOcclusionQuery();
  							renderContextData.occlusionQueryIndex ++;

  						}

  						if ( object.occlusionTest === true ) {

  							renderContextData.currentPass.beginOcclusionQuery( renderContextData.occlusionQueryIndex );
  							renderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;

  						}

  						renderContextData.lastOcclusionObject = object;

  					}

  				}

  				draw( renderContextData.currentPass, renderContextData.currentSets );

  			}

  		}

  	}

  	// cache key

  	/**
  	 * Returns `true` if the render pipeline requires an update.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {boolean} Whether the render pipeline requires an update or not.
  	 */
  	needsRenderUpdate( renderObject ) {

  		const data = this.get( renderObject );

  		const { object, material } = renderObject;

  		const utils = this.utils;

  		const sampleCount = utils.getSampleCountRenderContext( renderObject.context );
  		const colorSpace = utils.getCurrentColorSpace( renderObject.context );
  		const colorFormat = utils.getCurrentColorFormat( renderObject.context );
  		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
  		const primitiveTopology = utils.getPrimitiveTopology( object, material );

  		let needsUpdate = false;

  		if ( data.material !== material || data.materialVersion !== material.version ||
  			data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
  			data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
  			data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
  			data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
  			data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
  			data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
  			data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
  			data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||
  			data.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||
  			data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||
  			data.primitiveTopology !== primitiveTopology ||
  			data.clippingContextCacheKey !== renderObject.clippingContextCacheKey
  		) {

  			data.material = material; data.materialVersion = material.version;
  			data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
  			data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
  			data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
  			data.colorWrite = material.colorWrite;
  			data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
  			data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
  			data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
  			data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
  			data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;
  			data.sampleCount = sampleCount;
  			data.colorSpace = colorSpace;
  			data.colorFormat = colorFormat;
  			data.depthStencilFormat = depthStencilFormat;
  			data.primitiveTopology = primitiveTopology;
  			data.clippingContextCacheKey = renderObject.clippingContextCacheKey;

  			needsUpdate = true;

  		}

  		return needsUpdate;

  	}

  	/**
  	 * Returns a cache key that is used to identify render pipelines.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @return {string} The cache key.
  	 */
  	getRenderCacheKey( renderObject ) {

  		const { object, material } = renderObject;

  		const utils = this.utils;
  		const renderContext = renderObject.context;

  		return [
  			material.transparent, material.blending, material.premultipliedAlpha,
  			material.blendSrc, material.blendDst, material.blendEquation,
  			material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
  			material.colorWrite,
  			material.depthWrite, material.depthTest, material.depthFunc,
  			material.stencilWrite, material.stencilFunc,
  			material.stencilFail, material.stencilZFail, material.stencilZPass,
  			material.stencilFuncMask, material.stencilWriteMask,
  			material.side,
  			utils.getSampleCountRenderContext( renderContext ),
  			utils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),
  			utils.getPrimitiveTopology( object, material ),
  			renderObject.getGeometryCacheKey(),
  			renderObject.clippingContextCacheKey
  		].join();

  	}

  	// textures

  	/**
  	 * Creates a GPU sampler for the given texture.
  	 *
  	 * @param {Texture} texture - The texture to create the sampler for.
  	 */
  	createSampler( texture ) {

  		this.textureUtils.createSampler( texture );

  	}

  	/**
  	 * Destroys the GPU sampler for the given texture.
  	 *
  	 * @param {Texture} texture - The texture to destroy the sampler for.
  	 */
  	destroySampler( texture ) {

  		this.textureUtils.destroySampler( texture );

  	}

  	/**
  	 * Creates a default texture for the given texture that can be used
  	 * as a placeholder until the actual texture is ready for usage.
  	 *
  	 * @param {Texture} texture - The texture to create a default texture for.
  	 */
  	createDefaultTexture( texture ) {

  		this.textureUtils.createDefaultTexture( texture );

  	}

  	/**
  	 * Defines a texture on the GPU for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	createTexture( texture, options ) {

  		this.textureUtils.createTexture( texture, options );

  	}

  	/**
  	 * Uploads the updated texture data to the GPU.
  	 *
  	 * @param {Texture} texture - The texture.
  	 * @param {Object} [options={}] - Optional configuration parameter.
  	 */
  	updateTexture( texture, options ) {

  		this.textureUtils.updateTexture( texture, options );

  	}

  	/**
  	 * Generates mipmaps for the given texture.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	generateMipmaps( texture ) {

  		this.textureUtils.generateMipmaps( texture );

  	}

  	/**
  	 * Destroys the GPU data for the given texture object.
  	 *
  	 * @param {Texture} texture - The texture.
  	 */
  	destroyTexture( texture ) {

  		this.textureUtils.destroyTexture( texture );

  	}

  	/**
  	 * Returns texture data as a typed array.
  	 *
  	 * @async
  	 * @param {Texture} texture - The texture to copy.
  	 * @param {number} x - The x coordinate of the copy origin.
  	 * @param {number} y - The y coordinate of the copy origin.
  	 * @param {number} width - The width of the copy.
  	 * @param {number} height - The height of the copy.
  	 * @param {number} faceIndex - The face index.
  	 * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
  	 */
  	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

  	}

  	/**
  	 * Inits a time stamp query for the given render context.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Object} descriptor - The query descriptor.
  	 */
  	initTimestampQuery( renderContext, descriptor ) {

  		if ( ! this.trackTimestamp ) return;

  		const type = renderContext.isComputeNode ? 'compute' : 'render';

  		if ( ! this.timestampQueryPool[ type ] ) {

  			// TODO: Variable maxQueries?
  			this.timestampQueryPool[ type ] = new WebGPUTimestampQueryPool( this.device, type, 2048 );

  		}

  		const timestampQueryPool = this.timestampQueryPool[ type ];

  		const baseOffset = timestampQueryPool.allocateQueriesForContext( renderContext );

  		descriptor.timestampWrites = {
  			querySet: timestampQueryPool.querySet,
  			beginningOfPassWriteIndex: baseOffset,
  			endOfPassWriteIndex: baseOffset + 1,
  		  };

  	}


  	// node builder

  	/**
  	 * Returns a node builder for the given render object.
  	 *
  	 * @param {RenderObject} object - The render object.
  	 * @param {Renderer} renderer - The renderer.
  	 * @return {WGSLNodeBuilder} The node builder.
  	 */
  	createNodeBuilder( object, renderer ) {

  		return new WGSLNodeBuilder( object, renderer );

  	}

  	// program

  	/**
  	 * Creates a shader program from the given programmable stage.
  	 *
  	 * @param {ProgrammableStage} program - The programmable stage.
  	 */
  	createProgram( program ) {

  		const programGPU = this.get( program );

  		programGPU.module = {
  			module: this.device.createShaderModule( { code: program.code, label: program.stage + ( program.name !== '' ? `_${ program.name }` : '' ) } ),
  			entryPoint: 'main'
  		};

  	}

  	/**
  	 * Destroys the shader program of the given programmable stage.
  	 *
  	 * @param {ProgrammableStage} program - The programmable stage.
  	 */
  	destroyProgram( program ) {

  		this.delete( program );

  	}

  	// pipelines

  	/**
  	 * Creates a render pipeline for the given render object.
  	 *
  	 * @param {RenderObject} renderObject - The render object.
  	 * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
  	 */
  	createRenderPipeline( renderObject, promises ) {

  		this.pipelineUtils.createRenderPipeline( renderObject, promises );

  	}

  	/**
  	 * Creates a compute pipeline for the given compute node.
  	 *
  	 * @param {ComputePipeline} computePipeline - The compute pipeline.
  	 * @param {Array<BindGroup>} bindings - The bindings.
  	 */
  	createComputePipeline( computePipeline, bindings ) {

  		this.pipelineUtils.createComputePipeline( computePipeline, bindings );

  	}

  	/**
  	 * Prepares the state for encoding render bundles.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 */
  	beginBundle( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		renderContextData._currentPass = renderContextData.currentPass;
  		renderContextData._currentSets = renderContextData.currentSets;

  		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
  		renderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );

  	}

  	/**
  	 * After processing render bundles this method finalizes related work.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {RenderBundle} bundle - The render bundle.
  	 */
  	finishBundle( renderContext, bundle ) {

  		const renderContextData = this.get( renderContext );

  		const bundleEncoder = renderContextData.currentPass;
  		const bundleGPU = bundleEncoder.finish();

  		this.get( bundle ).bundleGPU = bundleGPU;

  		// restore render pass state

  		renderContextData.currentSets = renderContextData._currentSets;
  		renderContextData.currentPass = renderContextData._currentPass;

  	}

  	/**
  	 * Adds a render bundle to the render context data.
  	 *
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {RenderBundle} bundle - The render bundle to add.
  	 */
  	addBundle( renderContext, bundle ) {

  		const renderContextData = this.get( renderContext );

  		renderContextData.renderBundles.push( this.get( bundle ).bundleGPU );

  	}

  	// bindings

  	/**
  	 * Creates bindings from the given bind group definition.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	createBindings( bindGroup, bindings, cacheIndex, version ) {

  		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

  	}

  	/**
  	 * Updates the given bind group definition.
  	 *
  	 * @param {BindGroup} bindGroup - The bind group.
  	 * @param {Array<BindGroup>} bindings - Array of bind groups.
  	 * @param {number} cacheIndex - The cache index.
  	 * @param {number} version - The version.
  	 */
  	updateBindings( bindGroup, bindings, cacheIndex, version ) {

  		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

  	}

  	/**
  	 * Updates a buffer binding.
  	 *
  	 *  @param {Buffer} binding - The buffer binding to update.
  	 */
  	updateBinding( binding ) {

  		this.bindingUtils.updateBinding( binding );

  	}

  	// attributes

  	/**
  	 * Creates the buffer of an indexed shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The indexed buffer attribute.
  	 */
  	createIndexAttribute( attribute ) {

  		let usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;

  		if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

  			usage |= GPUBufferUsage.STORAGE;

  		}

  		this.attributeUtils.createAttribute( attribute, usage );

  	}

  	/**
  	 * Creates the GPU buffer of a shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createAttribute( attribute ) {

  		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

  	}

  	/**
  	 * Creates the GPU buffer of a storage attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createStorageAttribute( attribute ) {

  		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

  	}

  	/**
  	 * Creates the GPU buffer of an indirect storage attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute.
  	 */
  	createIndirectStorageAttribute( attribute ) {

  		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

  	}

  	/**
  	 * Updates the GPU buffer of a shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute to update.
  	 */
  	updateAttribute( attribute ) {

  		this.attributeUtils.updateAttribute( attribute );

  	}

  	/**
  	 * Destroys the GPU buffer of a shader attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute to destroy.
  	 */
  	destroyAttribute( attribute ) {

  		this.attributeUtils.destroyAttribute( attribute );

  	}

  	// canvas

  	/**
  	 * Triggers an update of the default render pass descriptor.
  	 */
  	updateSize() {

  		this.colorBuffer = this.textureUtils.getColorBuffer();
  		this.defaultRenderPassdescriptor = null;

  	}

  	// utils public

  	/**
  	 * Returns the maximum anisotropy texture filtering value.
  	 *
  	 * @return {number} The maximum anisotropy texture filtering value.
  	 */
  	getMaxAnisotropy() {

  		return 16;

  	}

  	/**
  	 * Checks if the given feature is supported  by the backend.
  	 *
  	 * @param {string} name - The feature's name.
  	 * @return {boolean} Whether the feature is supported or not.
  	 */
  	hasFeature( name ) {

  		return this.device.features.has( name );

  	}

  	/**
  	 * Copies data of the given source texture to the given destination texture.
  	 *
  	 * @param {Texture} srcTexture - The source texture.
  	 * @param {Texture} dstTexture - The destination texture.
  	 * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
  	 * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
  	 * @param {number} [srcLevel=0] - The mipmap level to copy.
  	 * @param {number} [dstLevel=0] - The destination mip level to copy to.
  	 */
  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {

  		let dstX = 0;
  		let dstY = 0;
  		let dstZ = 0;

  		let srcX = 0;
  		let srcY = 0;
  		let srcZ = 0;

  		let srcWidth = srcTexture.image.width;
  		let srcHeight = srcTexture.image.height;
  		let srcDepth = 1;


  		if ( srcRegion !== null ) {

  			if ( srcRegion.isBox3 === true ) {

  				srcX = srcRegion.min.x;
  				srcY = srcRegion.min.y;
  				srcZ = srcRegion.min.z;
  				srcWidth = srcRegion.max.x - srcRegion.min.x;
  				srcHeight = srcRegion.max.y - srcRegion.min.y;
  				srcDepth = srcRegion.max.z - srcRegion.min.z;

  			} else {

  				// Assume it's a Box2
  				srcX = srcRegion.min.x;
  				srcY = srcRegion.min.y;
  				srcWidth = srcRegion.max.x - srcRegion.min.x;
  				srcHeight = srcRegion.max.y - srcRegion.min.y;
  				srcDepth = 1;

  			}

  		}


  		if ( dstPosition !== null ) {

  			dstX = dstPosition.x;
  			dstY = dstPosition.y;
  			dstZ = dstPosition.z || 0;

  		}

  		const encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );

  		const sourceGPU = this.get( srcTexture ).texture;
  		const destinationGPU = this.get( dstTexture ).texture;

  		encoder.copyTextureToTexture(
  			{
  				texture: sourceGPU,
  				mipLevel: srcLevel,
  				origin: { x: srcX, y: srcY, z: srcZ }
  			},
  			{
  				texture: destinationGPU,
  				mipLevel: dstLevel,
  				origin: { x: dstX, y: dstY, z: dstZ }
  			},
  			[
  				srcWidth,
  				srcHeight,
  				srcDepth
  			]
  		);

  		this.device.queue.submit( [ encoder.finish() ] );

  		if ( dstLevel === 0 && dstTexture.generateMipmaps ) {

  			this.textureUtils.generateMipmaps( dstTexture );

  		}

  	}

  	/**
  	 * Copies the current bound framebuffer to the given texture.
  	 *
  	 * @param {Texture} texture - The destination texture.
  	 * @param {RenderContext} renderContext - The render context.
  	 * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  	 */
  	copyFramebufferToTexture( texture, renderContext, rectangle ) {

  		const renderContextData = this.get( renderContext );

  		let sourceGPU = null;

  		if ( renderContext.renderTarget ) {

  			if ( texture.isDepthTexture ) {

  				sourceGPU = this.get( renderContext.depthTexture ).texture;

  			} else {

  				sourceGPU = this.get( renderContext.textures[ 0 ] ).texture;

  			}

  		} else {

  			if ( texture.isDepthTexture ) {

  				sourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );

  			} else {

  				sourceGPU = this.context.getCurrentTexture();

  			}

  		}

  		const destinationGPU = this.get( texture ).texture;

  		if ( sourceGPU.format !== destinationGPU.format ) {

  			console.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );

  			return;

  		}

  		let encoder;

  		if ( renderContextData.currentPass ) {

  			renderContextData.currentPass.end();

  			encoder = renderContextData.encoder;

  		} else {

  			encoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );

  		}

  		encoder.copyTextureToTexture(
  			{
  				texture: sourceGPU,
  				origin: [ rectangle.x, rectangle.y, 0 ],
  			},
  			{
  				texture: destinationGPU
  			},
  			[
  				rectangle.z,
  				rectangle.w
  			]
  		);

  		if ( renderContextData.currentPass ) {

  			const { descriptor } = renderContextData;

  			for ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {

  				descriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;

  			}

  			if ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
  			if ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

  			renderContextData.currentPass = encoder.beginRenderPass( descriptor );
  			renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };

  			if ( renderContext.viewport ) {

  				this.updateViewport( renderContext );

  			}

  			if ( renderContext.scissor ) {

  				const { x, y, width, height } = renderContext.scissorValue;

  				renderContextData.currentPass.setScissorRect( x, y, width, height );

  			}

  		} else {

  			this.device.queue.submit( [ encoder.finish() ] );

  		}

  		if ( texture.generateMipmaps ) {

  			this.textureUtils.generateMipmaps( texture );

  		}

  	}

  }

  /**
   * A IES version of {@link SpotLight}. Can only be used with {@link WebGPURenderer}.
   *
   * @augments SpotLight
   */
  class IESSpotLight extends SpotLight {

  	/**
  	 * Constructs a new IES spot light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
  	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
  	 * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
  	 * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
  	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
  	 */
  	constructor( color, intensity, distance, angle, penumbra, decay ) {

  		super( color, intensity, distance, angle, penumbra, decay );

  		/**
  		 * TODO
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.iesMap = null;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.iesMap = source.iesMap;

  		return this;

  	}

  }

  /**
   * A projector light version of {@link SpotLight}. Can only be used with {@link WebGPURenderer}.
   *
   * @augments SpotLight
   */
  class ProjectorLight extends SpotLight {

  	/**
  	 * Constructs a new projector light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
  	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
  	 * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
  	 * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
  	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
  	 */
  	constructor( color, intensity, distance, angle, penumbra, decay ) {

  		super( color, intensity, distance, angle, penumbra, decay );

  		/**
  		 * Aspect ratio of the light. Set to `null` to use the texture aspect ratio.
  		 *
  		 * @type {number}
  		 * @default null
  		 */
  		this.aspect = null;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.aspect = source.aspect;

  		return this;

  	}

  }

  /**
   * This version of a node library represents the standard version
   * used in {@link WebGPURenderer}. It maps lights, tone mapping
   * techniques and materials to node-based implementations.
   *
   * @private
   * @augments NodeLibrary
   */
  class StandardNodeLibrary extends NodeLibrary {

  	/**
  	 * Constructs a new standard node library.
  	 */
  	constructor() {

  		super();

  		this.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );
  		this.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );
  		this.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );
  		this.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );
  		this.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );
  		this.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );
  		this.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );
  		this.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );
  		this.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );
  		this.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );
  		this.addMaterial( PointsNodeMaterial, 'PointsMaterial' );
  		this.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );
  		this.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );

  		this.addLight( PointLightNode, PointLight );
  		this.addLight( DirectionalLightNode, DirectionalLight );
  		this.addLight( RectAreaLightNode, RectAreaLight );
  		this.addLight( SpotLightNode, SpotLight );
  		this.addLight( AmbientLightNode, AmbientLight );
  		this.addLight( HemisphereLightNode, HemisphereLight );
  		this.addLight( LightProbeNode, LightProbe );
  		this.addLight( IESSpotLightNode, IESSpotLight );
  		this.addLight( ProjectorLightNode, ProjectorLight );

  		this.addToneMapping( linearToneMapping, LinearToneMapping );
  		this.addToneMapping( reinhardToneMapping, ReinhardToneMapping );
  		this.addToneMapping( cineonToneMapping, CineonToneMapping );
  		this.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );
  		this.addToneMapping( agxToneMapping, AgXToneMapping );
  		this.addToneMapping( neutralToneMapping, NeutralToneMapping );

  	}

  }

  /*
  const debugHandler = {

  	get: function ( target, name ) {

  		// Add |update
  		if ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );

  		return target[ name ];

  	}

  };
  */

  /**
   * This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability
   * to target different backends. By default, the renderer tries to use a WebGPU backend if the
   * browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.
   *
   * @augments Renderer
   */
  class WebGPURenderer extends Renderer {

  	/**
  	 * WebGPURenderer options.
  	 *
  	 * @typedef {Object} WebGPURenderer~Options
  	 * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
  	 * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
  	 * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
  	 * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
  	 * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
  	 * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
  	 * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
  	 * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
  	 * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
  	 * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
  	 * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
  	 */

  	/**
  	 * Constructs a new WebGPU renderer.
  	 *
  	 * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters = {} ) {

  		let BackendClass;

  		if ( parameters.forceWebGL ) {

  			BackendClass = WebGLBackend;

  		} else {

  			BackendClass = WebGPUBackend;

  			parameters.getFallback = () => {

  				console.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );

  				return new WebGLBackend( parameters );

  			};

  		}

  		const backend = new BackendClass( parameters );

  		//super( new Proxy( backend, debugHandler ) );
  		super( backend, parameters );

  		/**
  		 * The generic default value is overwritten with the
  		 * standard node library for type mapping.
  		 *
  		 * @type {StandardNodeLibrary}
  		 */
  		this.library = new StandardNodeLibrary();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGPURenderer = true;

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  }

  /**
   * Fires when the camera has been transformed by the controls.
   *
   * @event TrackballControls#change
   * @type {Object}
   */
  const _changeEvent$2 = { type: 'change' };

  /**
   * Fires when an interaction was initiated.
   *
   * @event TrackballControls#start
   * @type {Object}
   */
  const _startEvent$1 = { type: 'start' };

  /**
   * Fires when an interaction has finished.
   *
   * @event TrackballControls#end
   * @type {Object}
   */
  const _endEvent$1 = { type: 'end' };

  const _EPS$2 = 0.000001;
  const _STATE$1 = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

  const _v2 = new three$1.Vector2();
  const _mouseChange = new three$1.Vector2();
  const _objectUp = new three$1.Vector3();
  const _pan = new three$1.Vector3();
  const _axis = new three$1.Vector3();
  const _quaternion = new three$1.Quaternion();
  const _eyeDirection = new three$1.Vector3();
  const _objectUpDirection = new three$1.Vector3();
  const _objectSidewaysDirection = new three$1.Vector3();
  const _moveDirection = new three$1.Vector3();

  /**
   * This class is similar to {@link OrbitControls}. However, it does not maintain a constant camera
   * `up` vector. That means if the camera orbits over the “north” and “south” poles, it does not flip
   * to stay "right side up".
   *
   * @augments Controls
   * @three_import import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
   */
  class TrackballControls extends three$1.Controls {

  	/**
  	 * Constructs a new controls instance.
  	 *
  	 * @param {Object3D} object - The object that is managed by the controls.
  	 * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
  	 */
  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		/**
  		 * Represents the properties of the screen. Automatically set when `handleResize()` is called.
  		 *
  		 * @type {Object}
  		 * @readonly
  		 */
  		this.screen = { left: 0, top: 0, width: 0, height: 0 };

  		/**
  		 * The rotation speed.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.rotateSpeed = 1.0;

  		/**
  		 * The zoom speed.
  		 *
  		 * @type {number}
  		 * @default 1.2
  		 */
  		this.zoomSpeed = 1.2;

  		/**
  		 * The pan speed.
  		 *
  		 * @type {number}
  		 * @default 0.3
  		 */
  		this.panSpeed = 0.3;

  		/**
  		 * Whether rotation is disabled or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.noRotate = false;

  		/**
  		 * Whether zooming is disabled or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.noZoom = false;

  		/**
  		 * Whether panning is disabled or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.noPan = false;

  		/**
  		 * Whether damping is disabled or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.staticMoving = false;

  		/**
  		 * Defines the intensity of damping. Only considered if `staticMoving` is set to `false`.
  		 *
  		 * @type {number}
  		 * @default 0.2
  		 */
  		this.dynamicDampingFactor = 0.2;

  		/**
  		 * How far you can dolly in (perspective camera only).
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minDistance = 0;

  		/**
  		 * How far you can dolly out (perspective camera only).
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxDistance = Infinity;

  		/**
  		 * How far you can zoom in (orthographic camera only).
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minZoom = 0;

  		/**
  		 * How far you can zoom out (orthographic camera only).
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxZoom = Infinity;

  		/**
  		 * This array holds keycodes for controlling interactions.
  		 *
  		 * - When the first defined key is pressed, all mouse interactions (left, middle, right) performs orbiting.
  		 * - When the second defined key is pressed, all mouse interactions (left, middle, right) performs zooming.
  		 * - When the third defined key is pressed, all mouse interactions (left, middle, right) performs panning.
  		 *
  		 * Default is *KeyA, KeyS, KeyD* which represents A, S, D.
  		 *
  		 * @type {Array<string>}
  		 */
  		this.keys = [ 'KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/ ];

  		/**
  		 * This object contains references to the mouse actions used by the controls.
  		 *
  		 * ```js
  		 * controls.mouseButtons = {
  		 * 	LEFT: THREE.MOUSE.ROTATE,
  		 * 	MIDDLE: THREE.MOUSE.DOLLY,
  		 * 	RIGHT: THREE.MOUSE.PAN
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.mouseButtons = { LEFT: three$1.MOUSE.ROTATE, MIDDLE: three$1.MOUSE.DOLLY, RIGHT: three$1.MOUSE.PAN };

  		/**
  		 * The focus point of the controls.
  		 *
  		 * @type {Vector3}
  		 */
  		this.target = new three$1.Vector3();

  		// internals

  		this.state = _STATE$1.NONE;
  		this.keyState = _STATE$1.NONE;

  		this._lastPosition = new three$1.Vector3();
  		this._lastZoom = 1;
  		this._touchZoomDistanceStart = 0;
  		this._touchZoomDistanceEnd = 0;
  		this._lastAngle = 0;

  		this._eye = new three$1.Vector3();

  		this._movePrev = new three$1.Vector2();
  		this._moveCurr = new three$1.Vector2();

  		this._lastAxis = new three$1.Vector3();

  		this._zoomStart = new three$1.Vector2();
  		this._zoomEnd = new three$1.Vector2();

  		this._panStart = new three$1.Vector2();
  		this._panEnd = new three$1.Vector2();

  		this._pointers = [];
  		this._pointerPositions = {};

  		// event listeners

  		this._onPointerMove = onPointerMove$2.bind( this );
  		this._onPointerDown = onPointerDown$2.bind( this );
  		this._onPointerUp = onPointerUp$2.bind( this );
  		this._onPointerCancel = onPointerCancel$1.bind( this );
  		this._onContextMenu = onContextMenu$2.bind( this );
  		this._onMouseWheel = onMouseWheel$1.bind( this );
  		this._onKeyDown = onKeyDown$2.bind( this );
  		this._onKeyUp = onKeyUp$1.bind( this );

  		this._onTouchStart = onTouchStart$1.bind( this );
  		this._onTouchMove = onTouchMove$1.bind( this );
  		this._onTouchEnd = onTouchEnd.bind( this );

  		this._onMouseDown = onMouseDown$1.bind( this );
  		this._onMouseMove = onMouseMove$1.bind( this );
  		this._onMouseUp = onMouseUp.bind( this );

  		// for reset

  		this._target0 = this.target.clone();
  		this._position0 = this.object.position.clone();
  		this._up0 = this.object.up.clone();
  		this._zoom0 = this.object.zoom;

  		if ( domElement !== null ) {

  			this.connect( domElement );

  			this.handleResize();

  		}

  		// force an update at start
  		this.update();

  	}

  	connect( element ) {

  		super.connect( element );

  		window.addEventListener( 'keydown', this._onKeyDown );
  		window.addEventListener( 'keyup', this._onKeyUp );

  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );
  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );

  		this.domElement.style.touchAction = 'none'; // disable touch scroll

  	}

  	disconnect() {

  		window.removeEventListener( 'keydown', this._onKeyDown );
  		window.removeEventListener( 'keyup', this._onKeyUp );

  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.removeEventListener( 'wheel', this._onMouseWheel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  		this.domElement.style.touchAction = 'auto'; // disable touch scroll

  	}

  	dispose() {

  		this.disconnect();

  	}

  	/**
  	 * Must be called if the application window is resized.
  	 */
  	handleResize() {

  		const box = this.domElement.getBoundingClientRect();
  		// adjustments come from similar code in the jquery offset() function
  		const d = this.domElement.ownerDocument.documentElement;

  		this.screen.left = box.left + window.pageXOffset - d.clientLeft;
  		this.screen.top = box.top + window.pageYOffset - d.clientTop;
  		this.screen.width = box.width;
  		this.screen.height = box.height;

  	}

  	update() {

  		this._eye.subVectors( this.object.position, this.target );

  		if ( ! this.noRotate ) {

  			this._rotateCamera();

  		}

  		if ( ! this.noZoom ) {

  			this._zoomCamera();

  		}

  		if ( ! this.noPan ) {

  			this._panCamera();

  		}

  		this.object.position.addVectors( this.target, this._eye );

  		if ( this.object.isPerspectiveCamera ) {

  			this._checkDistances();

  			this.object.lookAt( this.target );

  			if ( this._lastPosition.distanceToSquared( this.object.position ) > _EPS$2 ) {

  				this.dispatchEvent( _changeEvent$2 );

  				this._lastPosition.copy( this.object.position );

  			}

  		} else if ( this.object.isOrthographicCamera ) {

  			this.object.lookAt( this.target );

  			if ( this._lastPosition.distanceToSquared( this.object.position ) > _EPS$2 || this._lastZoom !== this.object.zoom ) {

  				this.dispatchEvent( _changeEvent$2 );

  				this._lastPosition.copy( this.object.position );
  				this._lastZoom = this.object.zoom;

  			}

  		} else {

  			console.warn( 'THREE.TrackballControls: Unsupported camera type.' );

  		}

  	}

  	/**
  	 * Resets the controls to its initial state.
  	 */
  	reset() {

  		this.state = _STATE$1.NONE;
  		this.keyState = _STATE$1.NONE;

  		this.target.copy( this._target0 );
  		this.object.position.copy( this._position0 );
  		this.object.up.copy( this._up0 );
  		this.object.zoom = this._zoom0;

  		this.object.updateProjectionMatrix();

  		this._eye.subVectors( this.object.position, this.target );

  		this.object.lookAt( this.target );

  		this.dispatchEvent( _changeEvent$2 );

  		this._lastPosition.copy( this.object.position );
  		this._lastZoom = this.object.zoom;

  	}

  	_panCamera() {

  		_mouseChange.copy( this._panEnd ).sub( this._panStart );

  		if ( _mouseChange.lengthSq() ) {

  			if ( this.object.isOrthographicCamera ) {

  				const scale_x = ( this.object.right - this.object.left ) / this.object.zoom / this.domElement.clientWidth;
  				const scale_y = ( this.object.top - this.object.bottom ) / this.object.zoom / this.domElement.clientWidth;

  				_mouseChange.x *= scale_x;
  				_mouseChange.y *= scale_y;

  			}

  			_mouseChange.multiplyScalar( this._eye.length() * this.panSpeed );

  			_pan.copy( this._eye ).cross( this.object.up ).setLength( _mouseChange.x );
  			_pan.add( _objectUp.copy( this.object.up ).setLength( _mouseChange.y ) );

  			this.object.position.add( _pan );
  			this.target.add( _pan );

  			if ( this.staticMoving ) {

  				this._panStart.copy( this._panEnd );

  			} else {

  				this._panStart.add( _mouseChange.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.dynamicDampingFactor ) );

  			}

  		}

  	}

  	_rotateCamera() {

  		_moveDirection.set( this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0 );
  		let angle = _moveDirection.length();

  		if ( angle ) {

  			this._eye.copy( this.object.position ).sub( this.target );

  			_eyeDirection.copy( this._eye ).normalize();
  			_objectUpDirection.copy( this.object.up ).normalize();
  			_objectSidewaysDirection.crossVectors( _objectUpDirection, _eyeDirection ).normalize();

  			_objectUpDirection.setLength( this._moveCurr.y - this._movePrev.y );
  			_objectSidewaysDirection.setLength( this._moveCurr.x - this._movePrev.x );

  			_moveDirection.copy( _objectUpDirection.add( _objectSidewaysDirection ) );

  			_axis.crossVectors( _moveDirection, this._eye ).normalize();

  			angle *= this.rotateSpeed;
  			_quaternion.setFromAxisAngle( _axis, angle );

  			this._eye.applyQuaternion( _quaternion );
  			this.object.up.applyQuaternion( _quaternion );

  			this._lastAxis.copy( _axis );
  			this._lastAngle = angle;

  		} else if ( ! this.staticMoving && this._lastAngle ) {

  			this._lastAngle *= Math.sqrt( 1.0 - this.dynamicDampingFactor );
  			this._eye.copy( this.object.position ).sub( this.target );
  			_quaternion.setFromAxisAngle( this._lastAxis, this._lastAngle );
  			this._eye.applyQuaternion( _quaternion );
  			this.object.up.applyQuaternion( _quaternion );

  		}

  		this._movePrev.copy( this._moveCurr );

  	}

  	_zoomCamera() {

  		let factor;

  		if ( this.state === _STATE$1.TOUCH_ZOOM_PAN ) {

  			factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
  			this._touchZoomDistanceStart = this._touchZoomDistanceEnd;

  			if ( this.object.isPerspectiveCamera ) {

  				this._eye.multiplyScalar( factor );

  			} else if ( this.object.isOrthographicCamera ) {

  				this.object.zoom = three$1.MathUtils.clamp( this.object.zoom / factor, this.minZoom, this.maxZoom );

  				if ( this._lastZoom !== this.object.zoom ) {

  					this.object.updateProjectionMatrix();

  				}

  			} else {

  				console.warn( 'THREE.TrackballControls: Unsupported camera type' );

  			}

  		} else {

  			factor = 1.0 + ( this._zoomEnd.y - this._zoomStart.y ) * this.zoomSpeed;

  			if ( factor !== 1.0 && factor > 0.0 ) {

  				if ( this.object.isPerspectiveCamera ) {

  					this._eye.multiplyScalar( factor );

  				} else if ( this.object.isOrthographicCamera ) {

  					this.object.zoom = three$1.MathUtils.clamp( this.object.zoom / factor, this.minZoom, this.maxZoom );

  					if ( this._lastZoom !== this.object.zoom ) {

  						this.object.updateProjectionMatrix();

  					}

  				} else {

  					console.warn( 'THREE.TrackballControls: Unsupported camera type' );

  				}

  			}

  			if ( this.staticMoving ) {

  				this._zoomStart.copy( this._zoomEnd );

  			} else {

  				this._zoomStart.y += ( this._zoomEnd.y - this._zoomStart.y ) * this.dynamicDampingFactor;

  			}

  		}

  	}

  	_getMouseOnScreen( pageX, pageY ) {

  		_v2.set(
  			( pageX - this.screen.left ) / this.screen.width,
  			( pageY - this.screen.top ) / this.screen.height
  		);

  		return _v2;

  	}

  	_getMouseOnCircle( pageX, pageY ) {

  		_v2.set(
  			( ( pageX - this.screen.width * 0.5 - this.screen.left ) / ( this.screen.width * 0.5 ) ),
  			( ( this.screen.height + 2 * ( this.screen.top - pageY ) ) / this.screen.width ) // screen.width intentional
  		);

  		return _v2;

  	}

  	_addPointer( event ) {

  		this._pointers.push( event );

  	}

  	_removePointer( event ) {

  		delete this._pointerPositions[ event.pointerId ];

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ].pointerId == event.pointerId ) {

  				this._pointers.splice( i, 1 );
  				return;

  			}

  		}

  	}

  	_trackPointer( event ) {

  		let position = this._pointerPositions[ event.pointerId ];

  		if ( position === undefined ) {

  			position = new three$1.Vector2();
  			this._pointerPositions[ event.pointerId ] = position;

  		}

  		position.set( event.pageX, event.pageY );

  	}

  	_getSecondPointerPosition( event ) {

  		const pointer = ( event.pointerId === this._pointers[ 0 ].pointerId ) ? this._pointers[ 1 ] : this._pointers[ 0 ];

  		return this._pointerPositions[ pointer.pointerId ];

  	}

  	_checkDistances() {

  		if ( ! this.noZoom || ! this.noPan ) {

  			if ( this._eye.lengthSq() > this.maxDistance * this.maxDistance ) {

  				this.object.position.addVectors( this.target, this._eye.setLength( this.maxDistance ) );
  				this._zoomStart.copy( this._zoomEnd );

  			}

  			if ( this._eye.lengthSq() < this.minDistance * this.minDistance ) {

  				this.object.position.addVectors( this.target, this._eye.setLength( this.minDistance ) );
  				this._zoomStart.copy( this._zoomEnd );

  			}

  		}

  	}

  }

  function onPointerDown$2( event ) {

  	if ( this.enabled === false ) return;

  	if ( this._pointers.length === 0 ) {

  		this.domElement.setPointerCapture( event.pointerId );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

  	}

  	//

  	this._addPointer( event );

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchStart( event );

  	} else {

  		this._onMouseDown( event );

  	}

  }

  function onPointerMove$2( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchMove( event );

  	} else {

  		this._onMouseMove( event );

  	}

  }

  function onPointerUp$2( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchEnd( event );

  	} else {

  		this._onMouseUp();

  	}

  	//

  	this._removePointer( event );

  	if ( this._pointers.length === 0 ) {

  		this.domElement.releasePointerCapture( event.pointerId );

  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

  	}

  }

  function onPointerCancel$1( event ) {

  	this._removePointer( event );

  }

  function onKeyUp$1() {

  	if ( this.enabled === false ) return;

  	this.keyState = _STATE$1.NONE;

  	window.addEventListener( 'keydown', this._onKeyDown );

  }

  function onKeyDown$2( event ) {

  	if ( this.enabled === false ) return;

  	window.removeEventListener( 'keydown', this._onKeyDown );

  	if ( this.keyState !== _STATE$1.NONE ) {

  		return;

  	} else if ( event.code === this.keys[ _STATE$1.ROTATE ] && ! this.noRotate ) {

  		this.keyState = _STATE$1.ROTATE;

  	} else if ( event.code === this.keys[ _STATE$1.ZOOM ] && ! this.noZoom ) {

  		this.keyState = _STATE$1.ZOOM;

  	} else if ( event.code === this.keys[ _STATE$1.PAN ] && ! this.noPan ) {

  		this.keyState = _STATE$1.PAN;

  	}

  }

  function onMouseDown$1( event ) {

  	let mouseAction;

  	switch ( event.button ) {

  		case 0:
  			mouseAction = this.mouseButtons.LEFT;
  			break;

  		case 1:
  			mouseAction = this.mouseButtons.MIDDLE;
  			break;

  		case 2:
  			mouseAction = this.mouseButtons.RIGHT;
  			break;

  		default:
  			mouseAction = -1;

  	}

  	switch ( mouseAction ) {

  		case three$1.MOUSE.DOLLY:
  			this.state = _STATE$1.ZOOM;
  			break;

  		case three$1.MOUSE.ROTATE:
  			this.state = _STATE$1.ROTATE;
  			break;

  		case three$1.MOUSE.PAN:
  			this.state = _STATE$1.PAN;
  			break;

  		default:
  			this.state = _STATE$1.NONE;

  	}

  	const state = ( this.keyState !== _STATE$1.NONE ) ? this.keyState : this.state;

  	if ( state === _STATE$1.ROTATE && ! this.noRotate ) {

  		this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );
  		this._movePrev.copy( this._moveCurr );

  	} else if ( state === _STATE$1.ZOOM && ! this.noZoom ) {

  		this._zoomStart.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );
  		this._zoomEnd.copy( this._zoomStart );

  	} else if ( state === _STATE$1.PAN && ! this.noPan ) {

  		this._panStart.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );
  		this._panEnd.copy( this._panStart );

  	}

  	this.dispatchEvent( _startEvent$1 );

  }

  function onMouseMove$1( event ) {

  	const state = ( this.keyState !== _STATE$1.NONE ) ? this.keyState : this.state;

  	if ( state === _STATE$1.ROTATE && ! this.noRotate ) {

  		this._movePrev.copy( this._moveCurr );
  		this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );

  	} else if ( state === _STATE$1.ZOOM && ! this.noZoom ) {

  		this._zoomEnd.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );

  	} else if ( state === _STATE$1.PAN && ! this.noPan ) {

  		this._panEnd.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );

  	}

  }

  function onMouseUp() {

  	this.state = _STATE$1.NONE;

  	this.dispatchEvent( _endEvent$1 );

  }

  function onMouseWheel$1( event ) {

  	if ( this.enabled === false ) return;

  	if ( this.noZoom === true ) return;

  	event.preventDefault();

  	switch ( event.deltaMode ) {

  		case 2:
  			// Zoom in pages
  			this._zoomStart.y -= event.deltaY * 0.025;
  			break;

  		case 1:
  			// Zoom in lines
  			this._zoomStart.y -= event.deltaY * 0.01;
  			break;

  		default:
  			// undefined, 0, assume pixels
  			this._zoomStart.y -= event.deltaY * 0.00025;
  			break;

  	}

  	this.dispatchEvent( _startEvent$1 );
  	this.dispatchEvent( _endEvent$1 );

  }

  function onContextMenu$2( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  function onTouchStart$1( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:
  			this.state = _STATE$1.TOUCH_ROTATE;
  			this._moveCurr.copy( this._getMouseOnCircle( this._pointers[ 0 ].pageX, this._pointers[ 0 ].pageY ) );
  			this._movePrev.copy( this._moveCurr );
  			break;

  		default: // 2 or more
  			this.state = _STATE$1.TOUCH_ZOOM_PAN;
  			const dx = this._pointers[ 0 ].pageX - this._pointers[ 1 ].pageX;
  			const dy = this._pointers[ 0 ].pageY - this._pointers[ 1 ].pageY;
  			this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

  			const x = ( this._pointers[ 0 ].pageX + this._pointers[ 1 ].pageX ) / 2;
  			const y = ( this._pointers[ 0 ].pageY + this._pointers[ 1 ].pageY ) / 2;
  			this._panStart.copy( this._getMouseOnScreen( x, y ) );
  			this._panEnd.copy( this._panStart );
  			break;

  	}

  	this.dispatchEvent( _startEvent$1 );

  }

  function onTouchMove$1( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:
  			this._movePrev.copy( this._moveCurr );
  			this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );
  			break;

  		default: // 2 or more

  			const position = this._getSecondPointerPosition( event );

  			const dx = event.pageX - position.x;
  			const dy = event.pageY - position.y;
  			this._touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

  			const x = ( event.pageX + position.x ) / 2;
  			const y = ( event.pageY + position.y ) / 2;
  			this._panEnd.copy( this._getMouseOnScreen( x, y ) );
  			break;

  	}

  }

  function onTouchEnd( event ) {

  	switch ( this._pointers.length ) {

  		case 0:
  			this.state = _STATE$1.NONE;
  			break;

  		case 1:
  			this.state = _STATE$1.TOUCH_ROTATE;
  			this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );
  			this._movePrev.copy( this._moveCurr );
  			break;

  		case 2:
  			this.state = _STATE$1.TOUCH_ZOOM_PAN;

  			for ( let i = 0; i < this._pointers.length; i ++ ) {

  				if ( this._pointers[ i ].pointerId !== event.pointerId ) {

  					const position = this._pointerPositions[ this._pointers[ i ].pointerId ];
  					this._moveCurr.copy( this._getMouseOnCircle( position.x, position.y ) );
  					this._movePrev.copy( this._moveCurr );
  					break;

  				}

  			}

  			break;

  	}

  	this.dispatchEvent( _endEvent$1 );

  }

  /**
   * Fires when the camera has been transformed by the controls.
   *
   * @event OrbitControls#change
   * @type {Object}
   */
  const _changeEvent$1 = { type: 'change' };

  /**
   * Fires when an interaction was initiated.
   *
   * @event OrbitControls#start
   * @type {Object}
   */
  const _startEvent = { type: 'start' };

  /**
   * Fires when an interaction has finished.
   *
   * @event OrbitControls#end
   * @type {Object}
   */
  const _endEvent = { type: 'end' };

  const _ray = new three$1.Ray();
  const _plane = new three$1.Plane();
  const _TILT_LIMIT = Math.cos( 70 * three$1.MathUtils.DEG2RAD );

  const _v = new three$1.Vector3();
  const _twoPI = 2 * Math.PI;

  const _STATE = {
  	NONE: -1,
  	ROTATE: 0,
  	DOLLY: 1,
  	PAN: 2,
  	TOUCH_ROTATE: 3,
  	TOUCH_PAN: 4,
  	TOUCH_DOLLY_PAN: 5,
  	TOUCH_DOLLY_ROTATE: 6
  };
  const _EPS$1 = 0.000001;


  /**
   * Orbit controls allow the camera to orbit around a target.
   *
   * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},
   * it maintains the "up" direction `object.up` (+Y by default).
   *
   * - Orbit: Left mouse / touch: one-finger move.
   * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
   * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.
   *
   * ```js
   * const controls = new OrbitControls( camera, renderer.domElement );
   *
   * // controls.update() must be called after any manual changes to the camera's transform
   * camera.position.set( 0, 20, 100 );
   * controls.update();
   *
   * function animate() {
   *
   * 	// required if controls.enableDamping or controls.autoRotate are set to true
   * 	controls.update();
   *
   * 	renderer.render( scene, camera );
   *
   * }
   * ```
   *
   * @augments Controls
   * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
   */
  class OrbitControls extends three$1.Controls {

  	/**
  	 * Constructs a new controls instance.
  	 *
  	 * @param {Object3D} object - The object that is managed by the controls.
  	 * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
  	 */
  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		this.state = _STATE.NONE;

  		/**
  		 * The focus point of the controls, the `object` orbits around this.
  		 * It can be updated manually at any point to change the focus of the controls.
  		 *
  		 * @type {Vector3}
  		 */
  		this.target = new three$1.Vector3();

  		/**
  		 * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.
  		 * It can be updated manually at any point to change the center of interest
  		 * for the `target`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.cursor = new three$1.Vector3();

  		/**
  		 * How far you can dolly in (perspective camera only).
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minDistance = 0;

  		/**
  		 * How far you can dolly out (perspective camera only).
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxDistance = Infinity;

  		/**
  		 * How far you can zoom in (orthographic camera only).
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minZoom = 0;

  		/**
  		 * How far you can zoom out (orthographic camera only).
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxZoom = Infinity;

  		/**
  		 * How close you can get the target to the 3D `cursor`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minTargetRadius = 0;

  		/**
  		 * How far you can move the target from the 3D `cursor`.
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxTargetRadius = Infinity;

  		/**
  		 * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minPolarAngle = 0;

  		/**
  		 * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.
  		 *
  		 * @type {number}
  		 * @default Math.PI
  		 */
  		this.maxPolarAngle = Math.PI;

  		/**
  		 * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`
  		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
  		 *
  		 * @type {number}
  		 * @default -Infinity
  		 */
  		this.minAzimuthAngle = - Infinity;

  		/**
  		 * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`
  		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
  		 *
  		 * @type {number}
  		 * @default -Infinity
  		 */
  		this.maxAzimuthAngle = Infinity;

  		/**
  		 * Set to `true` to enable damping (inertia), which can be used to give a sense of weight
  		 * to the controls. Note that if this is enabled, you must call `update()` in your animation
  		 * loop.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.enableDamping = false;

  		/**
  		 * The damping inertia used if `enableDamping` is set to `true`.
  		 *
  		 * Note that for this to work, you must call `update()` in your animation loop.
  		 *
  		 * @type {number}
  		 * @default 0.05
  		 */
  		this.dampingFactor = 0.05;

  		/**
  		 * Enable or disable zooming (dollying) of the camera.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enableZoom = true;

  		/**
  		 * Speed of zooming / dollying.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.zoomSpeed = 1.0;

  		/**
  		 * Enable or disable horizontal and vertical rotation of the camera.
  		 *
  		 * Note that it is possible to disable a single axis by setting the min and max of the
  		 * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical
  		 * or horizontal rotation to be fixed at that value.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enableRotate = true;

  		/**
  		 * Speed of rotation.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.rotateSpeed = 1.0;

  		/**
  		 * How fast to rotate the camera when the keyboard is used.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.keyRotateSpeed = 1.0;

  		/**
  		 * Enable or disable camera panning.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enablePan = true;

  		/**
  		 * Speed of panning.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.panSpeed = 1.0;

  		/**
  		 * Defines how the camera's position is translated when panning. If `true`, the camera pans
  		 * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
  		 * direction.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.screenSpacePanning = true;

  		/**
  		 * How fast to pan the camera when the keyboard is used in
  		 * pixels per keypress.
  		 *
  		 * @type {number}
  		 * @default 7
  		 */
  		this.keyPanSpeed = 7.0;

  		/**
  		 * Setting this property to `true` allows to zoom to the cursor's position.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.zoomToCursor = false;

  		/**
  		 * Set to true to automatically rotate around the target
  		 *
  		 * Note that if this is enabled, you must call `update()` in your animation loop.
  		 * If you want the auto-rotate speed to be independent of the frame rate (the refresh
  		 * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.autoRotate = false;

  		/**
  		 * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds
  		 * per orbit at 60fps.
  		 *
  		 * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.
  		 *
  		 * @type {number}
  		 * @default 2
  		 */
  		this.autoRotateSpeed = 2.0;

  		/**
  		 * This object contains references to the keycodes for controlling camera panning.
  		 *
  		 * ```js
  		 * controls.keys = {
  		 * 	LEFT: 'ArrowLeft', //left arrow
  		 * 	UP: 'ArrowUp', // up arrow
  		 * 	RIGHT: 'ArrowRight', // right arrow
  		 * 	BOTTOM: 'ArrowDown' // down arrow
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

  		/**
  		 * This object contains references to the mouse actions used by the controls.
  		 *
  		 * ```js
  		 * controls.mouseButtons = {
  		 * 	LEFT: THREE.MOUSE.ROTATE,
  		 * 	MIDDLE: THREE.MOUSE.DOLLY,
  		 * 	RIGHT: THREE.MOUSE.PAN
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.mouseButtons = { LEFT: three$1.MOUSE.ROTATE, MIDDLE: three$1.MOUSE.DOLLY, RIGHT: three$1.MOUSE.PAN };

  		/**
  		 * This object contains references to the touch actions used by the controls.
  		 *
  		 * ```js
  		 * controls.mouseButtons = {
  		 * 	ONE: THREE.TOUCH.ROTATE,
  		 * 	TWO: THREE.TOUCH.DOLLY_PAN
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.touches = { ONE: three$1.TOUCH.ROTATE, TWO: three$1.TOUCH.DOLLY_PAN };

  		/**
  		 * Used internally by `saveState()` and `reset()`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.target0 = this.target.clone();

  		/**
  		 * Used internally by `saveState()` and `reset()`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.position0 = this.object.position.clone();

  		/**
  		 * Used internally by `saveState()` and `reset()`.
  		 *
  		 * @type {number}
  		 */
  		this.zoom0 = this.object.zoom;

  		// the target DOM element for key events
  		this._domElementKeyEvents = null;

  		// internals

  		this._lastPosition = new three$1.Vector3();
  		this._lastQuaternion = new three$1.Quaternion();
  		this._lastTargetPosition = new three$1.Vector3();

  		// so camera.up is the orbit axis
  		this._quat = new three$1.Quaternion().setFromUnitVectors( object.up, new three$1.Vector3( 0, 1, 0 ) );
  		this._quatInverse = this._quat.clone().invert();

  		// current position in spherical coordinates
  		this._spherical = new three$1.Spherical();
  		this._sphericalDelta = new three$1.Spherical();

  		this._scale = 1;
  		this._panOffset = new three$1.Vector3();

  		this._rotateStart = new three$1.Vector2();
  		this._rotateEnd = new three$1.Vector2();
  		this._rotateDelta = new three$1.Vector2();

  		this._panStart = new three$1.Vector2();
  		this._panEnd = new three$1.Vector2();
  		this._panDelta = new three$1.Vector2();

  		this._dollyStart = new three$1.Vector2();
  		this._dollyEnd = new three$1.Vector2();
  		this._dollyDelta = new three$1.Vector2();

  		this._dollyDirection = new three$1.Vector3();
  		this._mouse = new three$1.Vector2();
  		this._performCursorZoom = false;

  		this._pointers = [];
  		this._pointerPositions = {};

  		this._controlActive = false;

  		// event listeners

  		this._onPointerMove = onPointerMove$1.bind( this );
  		this._onPointerDown = onPointerDown$1.bind( this );
  		this._onPointerUp = onPointerUp$1.bind( this );
  		this._onContextMenu = onContextMenu$1.bind( this );
  		this._onMouseWheel = onMouseWheel.bind( this );
  		this._onKeyDown = onKeyDown$1.bind( this );

  		this._onTouchStart = onTouchStart.bind( this );
  		this._onTouchMove = onTouchMove.bind( this );

  		this._onMouseDown = onMouseDown.bind( this );
  		this._onMouseMove = onMouseMove.bind( this );

  		this._interceptControlDown = interceptControlDown.bind( this );
  		this._interceptControlUp = interceptControlUp.bind( this );

  		//

  		if ( this.domElement !== null ) {

  			this.connect( this.domElement );

  		}

  		this.update();

  	}

  	connect( element ) {

  		super.connect( element );

  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerUp );

  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );
  		this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
  		document.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );

  		this.domElement.style.touchAction = 'none'; // disable touch scroll

  	}

  	disconnect() {

  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerUp );

  		this.domElement.removeEventListener( 'wheel', this._onMouseWheel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  		this.stopListenToKeyEvents();

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
  		document.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );

  		this.domElement.style.touchAction = 'auto';

  	}

  	dispose() {

  		this.disconnect();

  	}

  	/**
  	 * Get the current vertical rotation, in radians.
  	 *
  	 * @return {number} The current vertical rotation, in radians.
  	 */
  	getPolarAngle() {

  		return this._spherical.phi;

  	}

  	/**
  	 * Get the current horizontal rotation, in radians.
  	 *
  	 * @return {number} The current horizontal rotation, in radians.
  	 */
  	getAzimuthalAngle() {

  		return this._spherical.theta;

  	}

  	/**
  	 * Returns the distance from the camera to the target.
  	 *
  	 * @return {number} The distance from the camera to the target.
  	 */
  	getDistance() {

  		return this.object.position.distanceTo( this.target );

  	}

  	/**
  	 * Adds key event listeners to the given DOM element.
  	 * `window` is a recommended argument for using this method.
  	 *
  	 * @param {HTMLDOMElement} domElement - The DOM element
  	 */
  	listenToKeyEvents( domElement ) {

  		domElement.addEventListener( 'keydown', this._onKeyDown );
  		this._domElementKeyEvents = domElement;

  	}

  	/**
  	 * Removes the key event listener previously defined with `listenToKeyEvents()`.
  	 */
  	stopListenToKeyEvents() {

  		if ( this._domElementKeyEvents !== null ) {

  			this._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );
  			this._domElementKeyEvents = null;

  		}

  	}

  	/**
  	 * Save the current state of the controls. This can later be recovered with `reset()`.
  	 */
  	saveState() {

  		this.target0.copy( this.target );
  		this.position0.copy( this.object.position );
  		this.zoom0 = this.object.zoom;

  	}

  	/**
  	 * Reset the controls to their state from either the last time the `saveState()`
  	 * was called, or the initial state.
  	 */
  	reset() {

  		this.target.copy( this.target0 );
  		this.object.position.copy( this.position0 );
  		this.object.zoom = this.zoom0;

  		this.object.updateProjectionMatrix();
  		this.dispatchEvent( _changeEvent$1 );

  		this.update();

  		this.state = _STATE.NONE;

  	}

  	update( deltaTime = null ) {

  		const position = this.object.position;

  		_v.copy( position ).sub( this.target );

  		// rotate offset to "y-axis-is-up" space
  		_v.applyQuaternion( this._quat );

  		// angle from z-axis around y-axis
  		this._spherical.setFromVector3( _v );

  		if ( this.autoRotate && this.state === _STATE.NONE ) {

  			this._rotateLeft( this._getAutoRotationAngle( deltaTime ) );

  		}

  		if ( this.enableDamping ) {

  			this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
  			this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;

  		} else {

  			this._spherical.theta += this._sphericalDelta.theta;
  			this._spherical.phi += this._sphericalDelta.phi;

  		}

  		// restrict theta to be between desired limits

  		let min = this.minAzimuthAngle;
  		let max = this.maxAzimuthAngle;

  		if ( isFinite( min ) && isFinite( max ) ) {

  			if ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;

  			if ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;

  			if ( min <= max ) {

  				this._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );

  			} else {

  				this._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?
  					Math.max( min, this._spherical.theta ) :
  					Math.min( max, this._spherical.theta );

  			}

  		}

  		// restrict phi to be between desired limits
  		this._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );

  		this._spherical.makeSafe();


  		// move target to panned location

  		if ( this.enableDamping === true ) {

  			this.target.addScaledVector( this._panOffset, this.dampingFactor );

  		} else {

  			this.target.add( this._panOffset );

  		}

  		// Limit the target distance from the cursor to create a sphere around the center of interest
  		this.target.sub( this.cursor );
  		this.target.clampLength( this.minTargetRadius, this.maxTargetRadius );
  		this.target.add( this.cursor );

  		let zoomChanged = false;
  		// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
  		// we adjust zoom later in these cases
  		if ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {

  			this._spherical.radius = this._clampDistance( this._spherical.radius );

  		} else {

  			const prevRadius = this._spherical.radius;
  			this._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );
  			zoomChanged = prevRadius != this._spherical.radius;

  		}

  		_v.setFromSpherical( this._spherical );

  		// rotate offset back to "camera-up-vector-is-up" space
  		_v.applyQuaternion( this._quatInverse );

  		position.copy( this.target ).add( _v );

  		this.object.lookAt( this.target );

  		if ( this.enableDamping === true ) {

  			this._sphericalDelta.theta *= ( 1 - this.dampingFactor );
  			this._sphericalDelta.phi *= ( 1 - this.dampingFactor );

  			this._panOffset.multiplyScalar( 1 - this.dampingFactor );

  		} else {

  			this._sphericalDelta.set( 0, 0, 0 );

  			this._panOffset.set( 0, 0, 0 );

  		}

  		// adjust camera position
  		if ( this.zoomToCursor && this._performCursorZoom ) {

  			let newRadius = null;
  			if ( this.object.isPerspectiveCamera ) {

  				// move the camera down the pointer ray
  				// this method avoids floating point error
  				const prevRadius = _v.length();
  				newRadius = this._clampDistance( prevRadius * this._scale );

  				const radiusDelta = prevRadius - newRadius;
  				this.object.position.addScaledVector( this._dollyDirection, radiusDelta );
  				this.object.updateMatrixWorld();

  				zoomChanged = !! radiusDelta;

  			} else if ( this.object.isOrthographicCamera ) {

  				// adjust the ortho camera position based on zoom changes
  				const mouseBefore = new three$1.Vector3( this._mouse.x, this._mouse.y, 0 );
  				mouseBefore.unproject( this.object );

  				const prevZoom = this.object.zoom;
  				this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );
  				this.object.updateProjectionMatrix();

  				zoomChanged = prevZoom !== this.object.zoom;

  				const mouseAfter = new three$1.Vector3( this._mouse.x, this._mouse.y, 0 );
  				mouseAfter.unproject( this.object );

  				this.object.position.sub( mouseAfter ).add( mouseBefore );
  				this.object.updateMatrixWorld();

  				newRadius = _v.length();

  			} else {

  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
  				this.zoomToCursor = false;

  			}

  			// handle the placement of the target
  			if ( newRadius !== null ) {

  				if ( this.screenSpacePanning ) {

  					// position the orbit target in front of the new camera position
  					this.target.set( 0, 0, -1 )
  						.transformDirection( this.object.matrix )
  						.multiplyScalar( newRadius )
  						.add( this.object.position );

  				} else {

  					// get the ray and translation plane to compute target
  					_ray.origin.copy( this.object.position );
  					_ray.direction.set( 0, 0, -1 ).transformDirection( this.object.matrix );

  					// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
  					// extremely large values
  					if ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {

  						this.object.lookAt( this.target );

  					} else {

  						_plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );
  						_ray.intersectPlane( _plane, this.target );

  					}

  				}

  			}

  		} else if ( this.object.isOrthographicCamera ) {

  			const prevZoom = this.object.zoom;
  			this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );

  			if ( prevZoom !== this.object.zoom ) {

  				this.object.updateProjectionMatrix();
  				zoomChanged = true;

  			}

  		}

  		this._scale = 1;
  		this._performCursorZoom = false;

  		// update condition is:
  		// min(camera displacement, camera rotation in radians)^2 > EPS
  		// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  		if ( zoomChanged ||
  			this._lastPosition.distanceToSquared( this.object.position ) > _EPS$1 ||
  			8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS$1 ||
  			this._lastTargetPosition.distanceToSquared( this.target ) > _EPS$1 ) {

  			this.dispatchEvent( _changeEvent$1 );

  			this._lastPosition.copy( this.object.position );
  			this._lastQuaternion.copy( this.object.quaternion );
  			this._lastTargetPosition.copy( this.target );

  			return true;

  		}

  		return false;

  	}

  	_getAutoRotationAngle( deltaTime ) {

  		if ( deltaTime !== null ) {

  			return ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;

  		} else {

  			return _twoPI / 60 / 60 * this.autoRotateSpeed;

  		}

  	}

  	_getZoomScale( delta ) {

  		const normalizedDelta = Math.abs( delta * 0.01 );
  		return Math.pow( 0.95, this.zoomSpeed * normalizedDelta );

  	}

  	_rotateLeft( angle ) {

  		this._sphericalDelta.theta -= angle;

  	}

  	_rotateUp( angle ) {

  		this._sphericalDelta.phi -= angle;

  	}

  	_panLeft( distance, objectMatrix ) {

  		_v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  		_v.multiplyScalar( - distance );

  		this._panOffset.add( _v );

  	}

  	_panUp( distance, objectMatrix ) {

  		if ( this.screenSpacePanning === true ) {

  			_v.setFromMatrixColumn( objectMatrix, 1 );

  		} else {

  			_v.setFromMatrixColumn( objectMatrix, 0 );
  			_v.crossVectors( this.object.up, _v );

  		}

  		_v.multiplyScalar( distance );

  		this._panOffset.add( _v );

  	}

  	// deltaX and deltaY are in pixels; right and down are positive
  	_pan( deltaX, deltaY ) {

  		const element = this.domElement;

  		if ( this.object.isPerspectiveCamera ) {

  			// perspective
  			const position = this.object.position;
  			_v.copy( position ).sub( this.target );
  			let targetDistance = _v.length();

  			// half of the fov is center to top of screen
  			targetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );

  			// we use only clientHeight here so aspect ratio does not distort speed
  			this._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );
  			this._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );

  		} else if ( this.object.isOrthographicCamera ) {

  			// orthographic
  			this._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );
  			this._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );

  		} else {

  			// camera neither orthographic nor perspective
  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  			this.enablePan = false;

  		}

  	}

  	_dollyOut( dollyScale ) {

  		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

  			this._scale /= dollyScale;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			this.enableZoom = false;

  		}

  	}

  	_dollyIn( dollyScale ) {

  		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

  			this._scale *= dollyScale;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			this.enableZoom = false;

  		}

  	}

  	_updateZoomParameters( x, y ) {

  		if ( ! this.zoomToCursor ) {

  			return;

  		}

  		this._performCursorZoom = true;

  		const rect = this.domElement.getBoundingClientRect();
  		const dx = x - rect.left;
  		const dy = y - rect.top;
  		const w = rect.width;
  		const h = rect.height;

  		this._mouse.x = ( dx / w ) * 2 - 1;
  		this._mouse.y = - ( dy / h ) * 2 + 1;

  		this._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();

  	}

  	_clampDistance( dist ) {

  		return Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );

  	}

  	//
  	// event callbacks - update the object state
  	//

  	_handleMouseDownRotate( event ) {

  		this._rotateStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseDownDolly( event ) {

  		this._updateZoomParameters( event.clientX, event.clientX );
  		this._dollyStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseDownPan( event ) {

  		this._panStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseMoveRotate( event ) {

  		this._rotateEnd.set( event.clientX, event.clientY );

  		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

  		const element = this.domElement;

  		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

  		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

  		this._rotateStart.copy( this._rotateEnd );

  		this.update();

  	}

  	_handleMouseMoveDolly( event ) {

  		this._dollyEnd.set( event.clientX, event.clientY );

  		this._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );

  		if ( this._dollyDelta.y > 0 ) {

  			this._dollyOut( this._getZoomScale( this._dollyDelta.y ) );

  		} else if ( this._dollyDelta.y < 0 ) {

  			this._dollyIn( this._getZoomScale( this._dollyDelta.y ) );

  		}

  		this._dollyStart.copy( this._dollyEnd );

  		this.update();

  	}

  	_handleMouseMovePan( event ) {

  		this._panEnd.set( event.clientX, event.clientY );

  		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

  		this._pan( this._panDelta.x, this._panDelta.y );

  		this._panStart.copy( this._panEnd );

  		this.update();

  	}

  	_handleMouseWheel( event ) {

  		this._updateZoomParameters( event.clientX, event.clientY );

  		if ( event.deltaY < 0 ) {

  			this._dollyIn( this._getZoomScale( event.deltaY ) );

  		} else if ( event.deltaY > 0 ) {

  			this._dollyOut( this._getZoomScale( event.deltaY ) );

  		}

  		this.update();

  	}

  	_handleKeyDown( event ) {

  		let needsUpdate = false;

  		switch ( event.code ) {

  			case this.keys.UP:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateUp( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( 0, this.keyPanSpeed );

  					}

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.BOTTOM:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateUp( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( 0, - this.keyPanSpeed );

  					}

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.LEFT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateLeft( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( this.keyPanSpeed, 0 );

  					}

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.RIGHT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateLeft( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( - this.keyPanSpeed, 0 );

  					}

  				}

  				needsUpdate = true;
  				break;

  		}

  		if ( needsUpdate ) {

  			// prevent the browser from scrolling on cursor keys
  			event.preventDefault();

  			this.update();

  		}


  	}

  	_handleTouchStartRotate( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._rotateStart.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._rotateStart.set( x, y );

  		}

  	}

  	_handleTouchStartPan( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._panStart.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._panStart.set( x, y );

  		}

  	}

  	_handleTouchStartDolly( event ) {

  		const position = this._getSecondPointerPosition( event );

  		const dx = event.pageX - position.x;
  		const dy = event.pageY - position.y;

  		const distance = Math.sqrt( dx * dx + dy * dy );

  		this._dollyStart.set( 0, distance );

  	}

  	_handleTouchStartDollyPan( event ) {

  		if ( this.enableZoom ) this._handleTouchStartDolly( event );

  		if ( this.enablePan ) this._handleTouchStartPan( event );

  	}

  	_handleTouchStartDollyRotate( event ) {

  		if ( this.enableZoom ) this._handleTouchStartDolly( event );

  		if ( this.enableRotate ) this._handleTouchStartRotate( event );

  	}

  	_handleTouchMoveRotate( event ) {

  		if ( this._pointers.length == 1 ) {

  			this._rotateEnd.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._rotateEnd.set( x, y );

  		}

  		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

  		const element = this.domElement;

  		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

  		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

  		this._rotateStart.copy( this._rotateEnd );

  	}

  	_handleTouchMovePan( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._panEnd.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._panEnd.set( x, y );

  		}

  		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

  		this._pan( this._panDelta.x, this._panDelta.y );

  		this._panStart.copy( this._panEnd );

  	}

  	_handleTouchMoveDolly( event ) {

  		const position = this._getSecondPointerPosition( event );

  		const dx = event.pageX - position.x;
  		const dy = event.pageY - position.y;

  		const distance = Math.sqrt( dx * dx + dy * dy );

  		this._dollyEnd.set( 0, distance );

  		this._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );

  		this._dollyOut( this._dollyDelta.y );

  		this._dollyStart.copy( this._dollyEnd );

  		const centerX = ( event.pageX + position.x ) * 0.5;
  		const centerY = ( event.pageY + position.y ) * 0.5;

  		this._updateZoomParameters( centerX, centerY );

  	}

  	_handleTouchMoveDollyPan( event ) {

  		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

  		if ( this.enablePan ) this._handleTouchMovePan( event );

  	}

  	_handleTouchMoveDollyRotate( event ) {

  		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

  		if ( this.enableRotate ) this._handleTouchMoveRotate( event );

  	}

  	// pointers

  	_addPointer( event ) {

  		this._pointers.push( event.pointerId );

  	}

  	_removePointer( event ) {

  		delete this._pointerPositions[ event.pointerId ];

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ] == event.pointerId ) {

  				this._pointers.splice( i, 1 );
  				return;

  			}

  		}

  	}

  	_isTrackingPointer( event ) {

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ] == event.pointerId ) return true;

  		}

  		return false;

  	}

  	_trackPointer( event ) {

  		let position = this._pointerPositions[ event.pointerId ];

  		if ( position === undefined ) {

  			position = new three$1.Vector2();
  			this._pointerPositions[ event.pointerId ] = position;

  		}

  		position.set( event.pageX, event.pageY );

  	}

  	_getSecondPointerPosition( event ) {

  		const pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];

  		return this._pointerPositions[ pointerId ];

  	}

  	//

  	_customWheelEvent( event ) {

  		const mode = event.deltaMode;

  		// minimal wheel event altered to meet delta-zoom demand
  		const newEvent = {
  			clientX: event.clientX,
  			clientY: event.clientY,
  			deltaY: event.deltaY,
  		};

  		switch ( mode ) {

  			case 1: // LINE_MODE
  				newEvent.deltaY *= 16;
  				break;

  			case 2: // PAGE_MODE
  				newEvent.deltaY *= 100;
  				break;

  		}

  		// detect if event was triggered by pinching
  		if ( event.ctrlKey && ! this._controlActive ) {

  			newEvent.deltaY *= 10;

  		}

  		return newEvent;

  	}

  }

  function onPointerDown$1( event ) {

  	if ( this.enabled === false ) return;

  	if ( this._pointers.length === 0 ) {

  		this.domElement.setPointerCapture( event.pointerId );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

  	}

  	//

  	if ( this._isTrackingPointer( event ) ) return;

  	//

  	this._addPointer( event );

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchStart( event );

  	} else {

  		this._onMouseDown( event );

  	}

  }

  function onPointerMove$1( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchMove( event );

  	} else {

  		this._onMouseMove( event );

  	}

  }

  function onPointerUp$1( event ) {

  	this._removePointer( event );

  	switch ( this._pointers.length ) {

  		case 0:

  			this.domElement.releasePointerCapture( event.pointerId );

  			this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  			this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

  			this.dispatchEvent( _endEvent );

  			this.state = _STATE.NONE;

  			break;

  		case 1:

  			const pointerId = this._pointers[ 0 ];
  			const position = this._pointerPositions[ pointerId ];

  			// minimal placeholder event - allows state correction on pointer-up
  			this._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

  			break;

  	}

  }

  function onMouseDown( event ) {

  	let mouseAction;

  	switch ( event.button ) {

  		case 0:

  			mouseAction = this.mouseButtons.LEFT;
  			break;

  		case 1:

  			mouseAction = this.mouseButtons.MIDDLE;
  			break;

  		case 2:

  			mouseAction = this.mouseButtons.RIGHT;
  			break;

  		default:

  			mouseAction = -1;

  	}

  	switch ( mouseAction ) {

  		case three$1.MOUSE.DOLLY:

  			if ( this.enableZoom === false ) return;

  			this._handleMouseDownDolly( event );

  			this.state = _STATE.DOLLY;

  			break;

  		case three$1.MOUSE.ROTATE:

  			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  				if ( this.enablePan === false ) return;

  				this._handleMouseDownPan( event );

  				this.state = _STATE.PAN;

  			} else {

  				if ( this.enableRotate === false ) return;

  				this._handleMouseDownRotate( event );

  				this.state = _STATE.ROTATE;

  			}

  			break;

  		case three$1.MOUSE.PAN:

  			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  				if ( this.enableRotate === false ) return;

  				this._handleMouseDownRotate( event );

  				this.state = _STATE.ROTATE;

  			} else {

  				if ( this.enablePan === false ) return;

  				this._handleMouseDownPan( event );

  				this.state = _STATE.PAN;

  			}

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  	if ( this.state !== _STATE.NONE ) {

  		this.dispatchEvent( _startEvent );

  	}

  }

  function onMouseMove( event ) {

  	switch ( this.state ) {

  		case _STATE.ROTATE:

  			if ( this.enableRotate === false ) return;

  			this._handleMouseMoveRotate( event );

  			break;

  		case _STATE.DOLLY:

  			if ( this.enableZoom === false ) return;

  			this._handleMouseMoveDolly( event );

  			break;

  		case _STATE.PAN:

  			if ( this.enablePan === false ) return;

  			this._handleMouseMovePan( event );

  			break;

  	}

  }

  function onMouseWheel( event ) {

  	if ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;

  	event.preventDefault();

  	this.dispatchEvent( _startEvent );

  	this._handleMouseWheel( this._customWheelEvent( event ) );

  	this.dispatchEvent( _endEvent );

  }

  function onKeyDown$1( event ) {

  	if ( this.enabled === false ) return;

  	this._handleKeyDown( event );

  }

  function onTouchStart( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:

  			switch ( this.touches.ONE ) {

  				case three$1.TOUCH.ROTATE:

  					if ( this.enableRotate === false ) return;

  					this._handleTouchStartRotate( event );

  					this.state = _STATE.TOUCH_ROTATE;

  					break;

  				case three$1.TOUCH.PAN:

  					if ( this.enablePan === false ) return;

  					this._handleTouchStartPan( event );

  					this.state = _STATE.TOUCH_PAN;

  					break;

  				default:

  					this.state = _STATE.NONE;

  			}

  			break;

  		case 2:

  			switch ( this.touches.TWO ) {

  				case three$1.TOUCH.DOLLY_PAN:

  					if ( this.enableZoom === false && this.enablePan === false ) return;

  					this._handleTouchStartDollyPan( event );

  					this.state = _STATE.TOUCH_DOLLY_PAN;

  					break;

  				case three$1.TOUCH.DOLLY_ROTATE:

  					if ( this.enableZoom === false && this.enableRotate === false ) return;

  					this._handleTouchStartDollyRotate( event );

  					this.state = _STATE.TOUCH_DOLLY_ROTATE;

  					break;

  				default:

  					this.state = _STATE.NONE;

  			}

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  	if ( this.state !== _STATE.NONE ) {

  		this.dispatchEvent( _startEvent );

  	}

  }

  function onTouchMove( event ) {

  	this._trackPointer( event );

  	switch ( this.state ) {

  		case _STATE.TOUCH_ROTATE:

  			if ( this.enableRotate === false ) return;

  			this._handleTouchMoveRotate( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_PAN:

  			if ( this.enablePan === false ) return;

  			this._handleTouchMovePan( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_DOLLY_PAN:

  			if ( this.enableZoom === false && this.enablePan === false ) return;

  			this._handleTouchMoveDollyPan( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_DOLLY_ROTATE:

  			if ( this.enableZoom === false && this.enableRotate === false ) return;

  			this._handleTouchMoveDollyRotate( event );

  			this.update();

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  }

  function onContextMenu$1( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  function interceptControlDown( event ) {

  	if ( event.key === 'Control' ) {

  		this._controlActive = true;

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

  		document.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

  	}

  }

  function interceptControlUp( event ) {

  	if ( event.key === 'Control' ) {

  		this._controlActive = false;

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

  		document.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

  	}

  }

  /**
   * Fires when the camera has been transformed by the controls.
   *
   * @event FlyControls#change
   * @type {Object}
   */
  const _changeEvent = { type: 'change' };

  const _EPS = 0.000001;
  const _tmpQuaternion = new three$1.Quaternion();

  /**
   * This class enables a navigation similar to fly modes in DCC tools like Blender.
   * You can arbitrarily transform the camera in 3D space without any limitations
   * (e.g. focus on a specific target).
   *
   * @augments Controls
   * @three_import import { FlyControls } from 'three/addons/controls/FlyControls.js';
   */
  class FlyControls extends three$1.Controls {

  	/**
  	 * Constructs a new controls instance.
  	 *
  	 * @param {Object3D} object - The object that is managed by the controls.
  	 * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
  	 */
  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		/**
  		 * The movement speed.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.movementSpeed = 1.0;

  		/**
  		 * The rotation speed.
  		 *
  		 * @type {number}
  		 * @default 0.005
  		 */
  		this.rollSpeed = 0.005;

  		/**
  		 * If set to `true`, you can only look around by performing a drag interaction.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.dragToLook = false;

  		/**
  		 * If set to `true`, the camera automatically moves forward (and does not stop) when initially translated.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.autoForward = false;

  		// internals

  		this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
  		this._moveVector = new three$1.Vector3( 0, 0, 0 );
  		this._rotationVector = new three$1.Vector3( 0, 0, 0 );
  		this._lastQuaternion = new three$1.Quaternion();
  		this._lastPosition = new three$1.Vector3();
  		this._status = 0;

  		// event listeners

  		this._onKeyDown = onKeyDown.bind( this );
  		this._onKeyUp = onKeyUp.bind( this );
  		this._onPointerMove = onPointerMove.bind( this );
  		this._onPointerDown = onPointerDown.bind( this );
  		this._onPointerUp = onPointerUp.bind( this );
  		this._onPointerCancel = onPointerCancel.bind( this );
  		this._onContextMenu = onContextMenu.bind( this );

  		//

  		if ( domElement !== null ) {

  			this.connect( domElement );

  		}

  	}

  	connect( element ) {

  		super.connect( element );

  		window.addEventListener( 'keydown', this._onKeyDown );
  		window.addEventListener( 'keyup', this._onKeyUp );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );

  	}

  	disconnect() {

  		window.removeEventListener( 'keydown', this._onKeyDown );
  		window.removeEventListener( 'keyup', this._onKeyUp );

  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  	}

  	dispose() {

  		this.disconnect();

  	}

  	update( delta ) {

  		if ( this.enabled === false ) return;

  		const object = this.object;

  		const moveMult = delta * this.movementSpeed;
  		const rotMult = delta * this.rollSpeed;

  		object.translateX( this._moveVector.x * moveMult );
  		object.translateY( this._moveVector.y * moveMult );
  		object.translateZ( this._moveVector.z * moveMult );

  		_tmpQuaternion.set( this._rotationVector.x * rotMult, this._rotationVector.y * rotMult, this._rotationVector.z * rotMult, 1 ).normalize();
  		object.quaternion.multiply( _tmpQuaternion );

  		if (
  			this._lastPosition.distanceToSquared( object.position ) > _EPS ||
  			8 * ( 1 - this._lastQuaternion.dot( object.quaternion ) ) > _EPS
  		) {

  			this.dispatchEvent( _changeEvent );
  			this._lastQuaternion.copy( object.quaternion );
  			this._lastPosition.copy( object.position );

  		}

  	}

  	// private

  	_updateMovementVector() {

  		const forward = ( this._moveState.forward || ( this.autoForward && ! this._moveState.back ) ) ? 1 : 0;

  		this._moveVector.x = ( - this._moveState.left + this._moveState.right );
  		this._moveVector.y = ( - this._moveState.down + this._moveState.up );
  		this._moveVector.z = ( - forward + this._moveState.back );

  		//console.log( 'move:', [ this._moveVector.x, this._moveVector.y, this._moveVector.z ] );

  	}

  	_updateRotationVector() {

  		this._rotationVector.x = ( - this._moveState.pitchDown + this._moveState.pitchUp );
  		this._rotationVector.y = ( - this._moveState.yawRight + this._moveState.yawLeft );
  		this._rotationVector.z = ( - this._moveState.rollRight + this._moveState.rollLeft );

  		//console.log( 'rotate:', [ this._rotationVector.x, this._rotationVector.y, this._rotationVector.z ] );

  	}

  	_getContainerDimensions() {

  		if ( this.domElement != document ) {

  			return {
  				size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
  				offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
  			};

  		} else {

  			return {
  				size: [ window.innerWidth, window.innerHeight ],
  				offset: [ 0, 0 ]
  			};

  		}

  	}

  }

  function onKeyDown( event ) {

  	if ( event.altKey || this.enabled === false ) {

  		return;

  	}

  	switch ( event.code ) {

  		case 'ShiftLeft':
  		case 'ShiftRight': this.movementSpeedMultiplier = .1; break;

  		case 'KeyW': this._moveState.forward = 1; break;
  		case 'KeyS': this._moveState.back = 1; break;

  		case 'KeyA': this._moveState.left = 1; break;
  		case 'KeyD': this._moveState.right = 1; break;

  		case 'KeyR': this._moveState.up = 1; break;
  		case 'KeyF': this._moveState.down = 1; break;

  		case 'ArrowUp': this._moveState.pitchUp = 1; break;
  		case 'ArrowDown': this._moveState.pitchDown = 1; break;

  		case 'ArrowLeft': this._moveState.yawLeft = 1; break;
  		case 'ArrowRight': this._moveState.yawRight = 1; break;

  		case 'KeyQ': this._moveState.rollLeft = 1; break;
  		case 'KeyE': this._moveState.rollRight = 1; break;

  	}

  	this._updateMovementVector();
  	this._updateRotationVector();

  }

  function onKeyUp( event ) {

  	if ( this.enabled === false ) return;

  	switch ( event.code ) {

  		case 'ShiftLeft':
  		case 'ShiftRight': this.movementSpeedMultiplier = 1; break;

  		case 'KeyW': this._moveState.forward = 0; break;
  		case 'KeyS': this._moveState.back = 0; break;

  		case 'KeyA': this._moveState.left = 0; break;
  		case 'KeyD': this._moveState.right = 0; break;

  		case 'KeyR': this._moveState.up = 0; break;
  		case 'KeyF': this._moveState.down = 0; break;

  		case 'ArrowUp': this._moveState.pitchUp = 0; break;
  		case 'ArrowDown': this._moveState.pitchDown = 0; break;

  		case 'ArrowLeft': this._moveState.yawLeft = 0; break;
  		case 'ArrowRight': this._moveState.yawRight = 0; break;

  		case 'KeyQ': this._moveState.rollLeft = 0; break;
  		case 'KeyE': this._moveState.rollRight = 0; break;

  	}

  	this._updateMovementVector();
  	this._updateRotationVector();

  }

  function onPointerDown( event ) {

  	if ( this.enabled === false ) return;

  	if ( this.dragToLook ) {

  		this._status ++;

  	} else {

  		switch ( event.button ) {

  			case 0: this._moveState.forward = 1; break;
  			case 2: this._moveState.back = 1; break;

  		}

  		this._updateMovementVector();

  	}

  }

  function onPointerMove( event ) {

  	if ( this.enabled === false ) return;

  	if ( ! this.dragToLook || this._status > 0 ) {

  		const container = this._getContainerDimensions();
  		const halfWidth = container.size[ 0 ] / 2;
  		const halfHeight = container.size[ 1 ] / 2;

  		this._moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;
  		this._moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

  		this._updateRotationVector();

  	}

  }

  function onPointerUp( event ) {

  	if ( this.enabled === false ) return;

  	if ( this.dragToLook ) {

  		this._status --;

  		this._moveState.yawLeft = this._moveState.pitchDown = 0;

  	} else {

  		switch ( event.button ) {

  			case 0: this._moveState.forward = 0; break;
  			case 2: this._moveState.back = 0; break;

  		}

  		this._updateMovementVector();

  	}

  	this._updateRotationVector();

  }

  function onPointerCancel() {

  	if ( this.enabled === false ) return;

  	if ( this.dragToLook ) {

  		this._status = 0;

  		this._moveState.yawLeft = this._moveState.pitchDown = 0;

  	} else {

  		this._moveState.forward = 0;
  		this._moveState.back = 0;

  		this._updateMovementVector();

  	}

  	this._updateRotationVector();

  }

  function onContextMenu( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  /**
   * @module CopyShader
   * @three_import import { CopyShader } from 'three/addons/shaders/CopyShader.js';
   */

  /**
   * Full-screen copy shader pass.
   *
   * @constant
   * @type {ShaderMaterial~Shader}
   */
  const CopyShader = {

  	name: 'CopyShader',

  	uniforms: {

  		'tDiffuse': { value: null },
  		'opacity': { value: 1.0 }

  	},

  	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

  	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`

  };

  /**
   * Abstract base class for all post processing passes.
   *
   * This module is only relevant for post processing with {@link WebGLRenderer}.
   *
   * @abstract
   * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';
   */
  class Pass {

  	/**
  	 * Constructs a new pass.
  	 */
  	constructor() {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPass = true;

  		/**
  		 * If set to `true`, the pass is processed by the composer.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enabled = true;

  		/**
  		 * If set to `true`, the pass indicates to swap read and write buffer after rendering.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.needsSwap = true;

  		/**
  		 * If set to `true`, the pass clears its buffer before rendering
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clear = false;

  		/**
  		 * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers
  		 * pass chain gets automatically rendered to screen, no matter how this property is configured.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.renderToScreen = false;

  	}

  	/**
  	 * Sets the size of the pass.
  	 *
  	 * @abstract
  	 * @param {number} width - The width to set.
  	 * @param {number} height - The height to set.
  	 */
  	setSize( /* width, height */ ) {}

  	/**
  	 * This method holds the render logic of a pass. It must be implemented in all derived classes.
  	 *
  	 * @abstract
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
  	 * destination for the pass.
  	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
  	 * previous pass from this buffer.
  	 * @param {number} deltaTime - The delta time in seconds.
  	 * @param {boolean} maskActive - Whether masking is active or not.
  	 */
  	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

  		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever the pass is no longer used in your app.
  	 *
  	 * @abstract
  	 */
  	dispose() {}

  }

  // Helper for passes that need to fill the viewport with a single quad.

  const _camera = new three$1.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

  // https://github.com/mrdoob/three.js/pull/21358

  class FullscreenTriangleGeometry extends three$1.BufferGeometry {

  	constructor() {

  		super();

  		this.setAttribute( 'position', new three$1.Float32BufferAttribute( [ -1, 3, 0, -1, -1, 0, 3, -1, 0 ], 3 ) );
  		this.setAttribute( 'uv', new three$1.Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

  	}

  }

  const _geometry = new FullscreenTriangleGeometry();


  /**
   * This module is a helper for passes which need to render a full
   * screen effect which is quite common in context of post processing.
   *
   * The intended usage is to reuse a single full screen quad for rendering
   * subsequent passes by just reassigning the `material` reference.
   *
   * This module can only be used with {@link WebGLRenderer}.
   *
   * @augments Mesh
   * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';
   */
  class FullScreenQuad {

  	/**
  	 * Constructs a new full screen quad.
  	 *
  	 * @param {?Material} material - The material to render te full screen quad with.
  	 */
  	constructor( material ) {

  		this._mesh = new three$1.Mesh( _geometry, material );

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever the instance is no longer used in your app.
  	 */
  	dispose() {

  		this._mesh.geometry.dispose();

  	}

  	/**
  	 * Renders the full screen quad.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 */
  	render( renderer ) {

  		renderer.render( this._mesh, _camera );

  	}

  	/**
  	 * The quad's material.
  	 *
  	 * @type {?Material}
  	 */
  	get material() {

  		return this._mesh.material;

  	}

  	set material( value ) {

  		this._mesh.material = value;

  	}

  }

  /**
   * This pass can be used to create a post processing effect
   * with a raw GLSL shader object. Useful for implementing custom
   * effects.
   *
   * ```js
   * const fxaaPass = new ShaderPass( FXAAShader );
   * composer.addPass( fxaaPass );
   * ```
   *
   * @augments Pass
   * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
   */
  class ShaderPass extends Pass {

  	/**
  	 * Constructs a new shader pass.
  	 *
  	 * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
  	 * defines and uniforms. It's also valid to pass a custom shader material.
  	 * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
  	 * the read buffer.
  	 */
  	constructor( shader, textureID = 'tDiffuse' ) {

  		super();

  		/**
  		 * The name of the texture uniform that should sample the read buffer.
  		 *
  		 * @type {string}
  		 * @default 'tDiffuse'
  		 */
  		this.textureID = textureID;

  		/**
  		 * The pass uniforms.
  		 *
  		 * @type {?Object}
  		 */
  		this.uniforms = null;

  		/**
  		 * The pass material.
  		 *
  		 * @type {?ShaderMaterial}
  		 */
  		this.material = null;

  		if ( shader instanceof three$1.ShaderMaterial ) {

  			this.uniforms = shader.uniforms;

  			this.material = shader;

  		} else if ( shader ) {

  			this.uniforms = three$1.UniformsUtils.clone( shader.uniforms );

  			this.material = new three$1.ShaderMaterial( {

  				name: ( shader.name !== undefined ) ? shader.name : 'unspecified',
  				defines: Object.assign( {}, shader.defines ),
  				uniforms: this.uniforms,
  				vertexShader: shader.vertexShader,
  				fragmentShader: shader.fragmentShader

  			} );

  		}

  		// internals

  		this._fsQuad = new FullScreenQuad( this.material );

  	}

  	/**
  	 * Performs the shader pass.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
  	 * destination for the pass.
  	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
  	 * previous pass from this buffer.
  	 * @param {number} deltaTime - The delta time in seconds.
  	 * @param {boolean} maskActive - Whether masking is active or not.
  	 */
  	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

  		if ( this.uniforms[ this.textureID ] ) {

  			this.uniforms[ this.textureID ].value = readBuffer.texture;

  		}

  		this._fsQuad.material = this.material;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			this._fsQuad.render( renderer );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
  			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
  			this._fsQuad.render( renderer );

  		}

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever the pass is no longer used in your app.
  	 */
  	dispose() {

  		this.material.dispose();

  		this._fsQuad.dispose();

  	}

  }

  /**
   * This pass can be used to define a mask during post processing.
   * Meaning only areas of subsequent post processing are affected
   * which lie in the masking area of this pass. Internally, the masking
   * is implemented with the stencil buffer.
   *
   * ```js
   * const maskPass = new MaskPass( scene, camera );
   * composer.addPass( maskPass );
   * ```
   *
   * @augments Pass
   * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';
   */
  class MaskPass extends Pass {

  	/**
  	 * Constructs a new mask pass.
  	 *
  	 * @param {Scene} scene - The 3D objects in this scene will define the mask.
  	 * @param {Camera} camera - The camera.
  	 */
  	constructor( scene, camera ) {

  		super();

  		/**
  		 * The scene that defines the mask.
  		 *
  		 * @type {Scene}
  		 */
  		this.scene = scene;

  		/**
  		 * The camera.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * Overwritten to perform a clear operation by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.clear = true;

  		/**
  		 * Overwritten to disable the swap.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.needsSwap = false;

  		/**
  		 * Whether to inverse the mask or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.inverse = false;

  	}

  	/**
  	 * Performs a mask pass with the configured scene and camera.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
  	 * destination for the pass.
  	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
  	 * previous pass from this buffer.
  	 * @param {number} deltaTime - The delta time in seconds.
  	 * @param {boolean} maskActive - Whether masking is active or not.
  	 */
  	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

  		const context = renderer.getContext();
  		const state = renderer.state;

  		// don't update color or depth

  		state.buffers.color.setMask( false );
  		state.buffers.depth.setMask( false );

  		// lock buffers

  		state.buffers.color.setLocked( true );
  		state.buffers.depth.setLocked( true );

  		// set up stencil

  		let writeValue, clearValue;

  		if ( this.inverse ) {

  			writeValue = 0;
  			clearValue = 1;

  		} else {

  			writeValue = 1;
  			clearValue = 0;

  		}

  		state.buffers.stencil.setTest( true );
  		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
  		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
  		state.buffers.stencil.setClear( clearValue );
  		state.buffers.stencil.setLocked( true );

  		// draw into the stencil buffer

  		renderer.setRenderTarget( readBuffer );
  		if ( this.clear ) renderer.clear();
  		renderer.render( this.scene, this.camera );

  		renderer.setRenderTarget( writeBuffer );
  		if ( this.clear ) renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// unlock color and depth buffer and make them writable for subsequent rendering/clearing

  		state.buffers.color.setLocked( false );
  		state.buffers.depth.setLocked( false );

  		state.buffers.color.setMask( true );
  		state.buffers.depth.setMask( true );

  		// only render where stencil is set to 1

  		state.buffers.stencil.setLocked( false );
  		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
  		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
  		state.buffers.stencil.setLocked( true );

  	}

  }

  /**
   * This pass can be used to clear a mask previously defined with {@link MaskPass}.
   *
   * ```js
   * const clearPass = new ClearMaskPass();
   * composer.addPass( clearPass );
   * ```
   *
   * @augments Pass
   */
  class ClearMaskPass extends Pass {

  	/**
  	 * Constructs a new clear mask pass.
  	 */
  	constructor() {

  		super();

  		/**
  		 * Overwritten to disable the swap.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.needsSwap = false;

  	}

  	/**
  	 * Performs the clear of the currently defined mask.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
  	 * destination for the pass.
  	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
  	 * previous pass from this buffer.
  	 * @param {number} deltaTime - The delta time in seconds.
  	 * @param {boolean} maskActive - Whether masking is active or not.
  	 */
  	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

  		renderer.state.buffers.stencil.setLocked( false );
  		renderer.state.buffers.stencil.setTest( false );

  	}

  }

  /**
   * Used to implement post-processing effects in three.js.
   * The class manages a chain of post-processing passes to produce the final visual result.
   * Post-processing passes are executed in order of their addition/insertion.
   * The last pass is automatically rendered to screen.
   *
   * This module can only be used with {@link WebGLRenderer}.
   *
   * ```js
   * const composer = new EffectComposer( renderer );
   *
   * // adding some passes
   * const renderPass = new RenderPass( scene, camera );
   * composer.addPass( renderPass );
   *
   * const glitchPass = new GlitchPass();
   * composer.addPass( glitchPass );
   *
   * const outputPass = new OutputPass()
   * composer.addPass( outputPass );
   *
   * function animate() {
   *
   * 	composer.render(); // instead of renderer.render()
   *
   * }
   * ```
   *
   * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
   */
  class EffectComposer {

  	/**
  	 * Constructs a new effect composer.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
  	 * be used as the internal read and write buffers. If not given, the composer creates
  	 * the buffers automatically.
  	 */
  	constructor( renderer, renderTarget ) {

  		/**
  		 * The renderer.
  		 *
  		 * @type {WebGLRenderer}
  		 */
  		this.renderer = renderer;

  		this._pixelRatio = renderer.getPixelRatio();

  		if ( renderTarget === undefined ) {

  			const size = renderer.getSize( new three$1.Vector2() );
  			this._width = size.width;
  			this._height = size.height;

  			renderTarget = new three$1.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: three$1.HalfFloatType } );
  			renderTarget.texture.name = 'EffectComposer.rt1';

  		} else {

  			this._width = renderTarget.width;
  			this._height = renderTarget.height;

  		}

  		this.renderTarget1 = renderTarget;
  		this.renderTarget2 = renderTarget.clone();
  		this.renderTarget2.texture.name = 'EffectComposer.rt2';

  		/**
  		 * A reference to the internal write buffer. Passes usually write
  		 * their result into this buffer.
  		 *
  		 * @type {WebGLRenderTarget}
  		 */
  		this.writeBuffer = this.renderTarget1;

  		/**
  		 * A reference to the internal read buffer. Passes usually read
  		 * the previous render result from this buffer.
  		 *
  		 * @type {WebGLRenderTarget}
  		 */
  		this.readBuffer = this.renderTarget2;

  		/**
  		 * Whether the final pass is rendered to the screen (default framebuffer) or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.renderToScreen = true;

  		/**
  		 * An array representing the (ordered) chain of post-processing passes.
  		 *
  		 * @type {Array<Pass>}
  		 */
  		this.passes = [];

  		/**
  		 * A copy pass used for internal swap operations.
  		 *
  		 * @private
  		 * @type {ShaderPass}
  		 */
  		this.copyPass = new ShaderPass( CopyShader );
  		this.copyPass.material.blending = three$1.NoBlending;

  		/**
  		 * The internal clock for managing time data.
  		 *
  		 * @private
  		 * @type {Clock}
  		 */
  		this.clock = new three$1.Clock();

  	}

  	/**
  	 * Swaps the internal read/write buffers.
  	 */
  	swapBuffers() {

  		const tmp = this.readBuffer;
  		this.readBuffer = this.writeBuffer;
  		this.writeBuffer = tmp;

  	}

  	/**
  	 * Adds the given pass to the pass chain.
  	 *
  	 * @param {Pass} pass - The pass to add.
  	 */
  	addPass( pass ) {

  		this.passes.push( pass );
  		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

  	}

  	/**
  	 * Inserts the given pass at a given index.
  	 *
  	 * @param {Pass} pass - The pass to insert.
  	 * @param {number} index - The index into the pass chain.
  	 */
  	insertPass( pass, index ) {

  		this.passes.splice( index, 0, pass );
  		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

  	}

  	/**
  	 * Removes the given pass from the pass chain.
  	 *
  	 * @param {Pass} pass - The pass to remove.
  	 */
  	removePass( pass ) {

  		const index = this.passes.indexOf( pass );

  		if ( index !== -1 ) {

  			this.passes.splice( index, 1 );

  		}

  	}

  	/**
  	 * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
  	 *
  	 * @param {number} passIndex - The pass index.
  	 * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.
  	 */
  	isLastEnabledPass( passIndex ) {

  		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

  			if ( this.passes[ i ].enabled ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Executes all enabled post-processing passes in order to produce the final frame.
  	 *
  	 * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
  	 * its own time delta value.
  	 */
  	render( deltaTime ) {

  		// deltaTime value is in seconds

  		if ( deltaTime === undefined ) {

  			deltaTime = this.clock.getDelta();

  		}

  		const currentRenderTarget = this.renderer.getRenderTarget();

  		let maskActive = false;

  		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

  			const pass = this.passes[ i ];

  			if ( pass.enabled === false ) continue;

  			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
  			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

  			if ( pass.needsSwap ) {

  				if ( maskActive ) {

  					const context = this.renderer.getContext();
  					const stencil = this.renderer.state.buffers.stencil;

  					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
  					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

  					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

  					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
  					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

  				}

  				this.swapBuffers();

  			}

  			if ( MaskPass !== undefined ) {

  				if ( pass instanceof MaskPass ) {

  					maskActive = true;

  				} else if ( pass instanceof ClearMaskPass ) {

  					maskActive = false;

  				}

  			}

  		}

  		this.renderer.setRenderTarget( currentRenderTarget );

  	}

  	/**
  	 * Resets the internal state of the EffectComposer.
  	 *
  	 * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
  	 * the one from the constructor. If set, it is used to setup the read and write buffers.
  	 */
  	reset( renderTarget ) {

  		if ( renderTarget === undefined ) {

  			const size = this.renderer.getSize( new three$1.Vector2() );
  			this._pixelRatio = this.renderer.getPixelRatio();
  			this._width = size.width;
  			this._height = size.height;

  			renderTarget = this.renderTarget1.clone();
  			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

  		}

  		this.renderTarget1.dispose();
  		this.renderTarget2.dispose();
  		this.renderTarget1 = renderTarget;
  		this.renderTarget2 = renderTarget.clone();

  		this.writeBuffer = this.renderTarget1;
  		this.readBuffer = this.renderTarget2;

  	}

  	/**
  	 * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
  	 * this method honors the current pixel ration.
  	 *
  	 * @param {number} width - The width in logical pixels.
  	 * @param {number} height - The height in logical pixels.
  	 */
  	setSize( width, height ) {

  		this._width = width;
  		this._height = height;

  		const effectiveWidth = this._width * this._pixelRatio;
  		const effectiveHeight = this._height * this._pixelRatio;

  		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
  		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

  		for ( let i = 0; i < this.passes.length; i ++ ) {

  			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

  		}

  	}

  	/**
  	 * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
  	 * Setting the pixel ratio will automatically resize the composer.
  	 *
  	 * @param {number} pixelRatio - The pixel ratio to set.
  	 */
  	setPixelRatio( pixelRatio ) {

  		this._pixelRatio = pixelRatio;

  		this.setSize( this._width, this._height );

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever the composer is no longer used in your app.
  	 */
  	dispose() {

  		this.renderTarget1.dispose();
  		this.renderTarget2.dispose();

  		this.copyPass.dispose();

  	}

  }

  /**
   * This class represents a render pass. It takes a camera and a scene and produces
   * a beauty pass for subsequent post processing effects.
   *
   * ```js
   * const renderPass = new RenderPass( scene, camera );
   * composer.addPass( renderPass );
   * ```
   *
   * @augments Pass
   * @three_import import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
   */
  class RenderPass extends Pass {

  	/**
  	 * Constructs a new render pass.
  	 *
  	 * @param {Scene} scene - The scene to render.
  	 * @param {Camera} camera - The camera.
  	 * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
  	 * for all objects in the scene.
  	 * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
  	 * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
  	 */
  	constructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {

  		super();

  		/**
  		 * The scene to render.
  		 *
  		 * @type {Scene}
  		 */
  		this.scene = scene;

  		/**
  		 * The camera.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * The override material. If set, this material is used
  		 * for all objects in the scene.
  		 *
  		 * @type {?Material}
  		 * @default null
  		 */
  		this.overrideMaterial = overrideMaterial;

  		/**
  		 * The clear color of the render pass.
  		 *
  		 * @type {?(number|Color|string)}
  		 * @default null
  		 */
  		this.clearColor = clearColor;

  		/**
  		 * The clear alpha of the render pass.
  		 *
  		 * @type {?number}
  		 * @default null
  		 */
  		this.clearAlpha = clearAlpha;

  		/**
  		 * Overwritten to perform a clear operation by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.clear = true;

  		/**
  		 * If set to `true`, only the depth can be cleared when `clear` is to `false`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clearDepth = false;

  		/**
  		 * Overwritten to disable the swap.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.needsSwap = false;
  		this._oldClearColor = new three$1.Color();

  	}

  	/**
  	 * Performs a beauty pass with the configured scene and camera.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
  	 * destination for the pass.
  	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
  	 * previous pass from this buffer.
  	 * @param {number} deltaTime - The delta time in seconds.
  	 * @param {boolean} maskActive - Whether masking is active or not.
  	 */
  	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

  		const oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		let oldClearAlpha, oldOverrideMaterial;

  		if ( this.overrideMaterial !== null ) {

  			oldOverrideMaterial = this.scene.overrideMaterial;

  			this.scene.overrideMaterial = this.overrideMaterial;

  		}

  		if ( this.clearColor !== null ) {

  			renderer.getClearColor( this._oldClearColor );
  			renderer.setClearColor( this.clearColor, renderer.getClearAlpha() );

  		}

  		if ( this.clearAlpha !== null ) {

  			oldClearAlpha = renderer.getClearAlpha();
  			renderer.setClearAlpha( this.clearAlpha );

  		}

  		if ( this.clearDepth == true ) {

  			renderer.clearDepth();

  		}

  		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

  		if ( this.clear === true ) {

  			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  		renderer.render( this.scene, this.camera );

  		// restore

  		if ( this.clearColor !== null ) {

  			renderer.setClearColor( this._oldClearColor );

  		}

  		if ( this.clearAlpha !== null ) {

  			renderer.setClearAlpha( oldClearAlpha );

  		}

  		if ( this.overrideMaterial !== null ) {

  			this.scene.overrideMaterial = oldOverrideMaterial;

  		}

  		renderer.autoClear = oldAutoClear;

  	}

  }

  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }

  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }

  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }

  function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
  }

  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }

  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }

  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }

  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }

  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function _wrapNativeSuper(t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  // based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js
  /**
   * Parse errors.md and turn it into a simple hash of code: message
   * @private
   */
  var ERRORS = {
    "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
    "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
    "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
    "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
    "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
    "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
    "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
    "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
    "9": "Please provide a number of steps to the modularScale helper.\n\n",
    "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
    "11": "Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\n\n",
    "12": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\n\n",
    "13": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\n\n",
    "14": "Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
    "15": "Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
    "16": "You must provide a template to this method.\n\n",
    "17": "You passed an unsupported selector state to this method.\n\n",
    "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
    "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
    "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
    "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    "23": "fontFace expects a name of a font-family.\n\n",
    "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
    "25": "fontFace expects localFonts to be an array.\n\n",
    "26": "fontFace expects fileFormats to be an array.\n\n",
    "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
    "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
    "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
    "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
    "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
    "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
    "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
    "35": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
    "36": "Property must be a string value.\n\n",
    "37": "Syntax Error at %s.\n\n",
    "38": "Formula contains a function that needs parentheses at %s.\n\n",
    "39": "Formula is missing closing parenthesis at %s.\n\n",
    "40": "Formula has too many closing parentheses at %s.\n\n",
    "41": "All values in a formula must have the same unit or be unitless.\n\n",
    "42": "Please provide a number of steps to the modularScale helper.\n\n",
    "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
    "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
    "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
    "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
    "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
    "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
    "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
    "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
    "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
    "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
    "53": "fontFace expects localFonts to be an array.\n\n",
    "54": "fontFace expects fileFormats to be an array.\n\n",
    "55": "fontFace expects a name of a font-family.\n\n",
    "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
    "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
    "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
    "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
    "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    "61": "Property must be a string value.\n\n",
    "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
    "63": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
    "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
    "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
    "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
    "67": "You must provide a template to this method.\n\n",
    "68": "You passed an unsupported selector state to this method.\n\n",
    "69": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\n\n",
    "70": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\n\n",
    "71": "Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
    "72": "Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
    "73": "Please provide a valid CSS variable.\n\n",
    "74": "CSS variable not found and no default was provided.\n\n",
    "75": "important requires a valid style object, got a %s instead.\n\n",
    "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
    "77": "remToPx expects a value in \"rem\" but you provided it in \"%s\".\n\n",
    "78": "base must be set in \"px\" or \"%\" but you set it in \"%s\".\n"
  };

  /**
   * super basic version of sprintf
   * @private
   */
  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var a = args[0];
    var b = [];
    var c;
    for (c = 1; c < args.length; c += 1) {
      b.push(args[c]);
    }
    b.forEach(function (d) {
      a = a.replace(/%[a-z]/, d);
    });
    return a;
  }

  /**
   * Create an error file out of errors.md for development and a simple web link to the full errors
   * in production mode.
   * @private
   */
  var PolishedError = /*#__PURE__*/function (_Error) {
    _inheritsLoose(PolishedError, _Error);
    function PolishedError(code) {
      var _this;
      if (process.env.NODE_ENV === 'production') {
        _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
      } else {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
      }
      return _assertThisInitialized(_this);
    }
    return PolishedError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function colorToInt(color) {
    return Math.round(color * 255);
  }
  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }
  function hslToRgb(hue, saturation, lightness, convert) {
    if (convert === void 0) {
      convert = convertToInt;
    }
    if (saturation === 0) {
      // achromatic
      return convert(lightness, lightness, lightness);
    }

    // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV
    var huePrime = (hue % 360 + 360) % 360 / 60;
    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    var red = 0;
    var green = 0;
    var blue = 0;
    if (huePrime >= 0 && huePrime < 1) {
      red = chroma;
      green = secondComponent;
    } else if (huePrime >= 1 && huePrime < 2) {
      red = secondComponent;
      green = chroma;
    } else if (huePrime >= 2 && huePrime < 3) {
      green = chroma;
      blue = secondComponent;
    } else if (huePrime >= 3 && huePrime < 4) {
      green = secondComponent;
      blue = chroma;
    } else if (huePrime >= 4 && huePrime < 5) {
      red = secondComponent;
      blue = chroma;
    } else if (huePrime >= 5 && huePrime < 6) {
      red = chroma;
      blue = secondComponent;
    }
    var lightnessModification = lightness - chroma / 2;
    var finalRed = red + lightnessModification;
    var finalGreen = green + lightnessModification;
    var finalBlue = blue + lightnessModification;
    return convert(finalRed, finalGreen, finalBlue);
  }

  var namedColorMap = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '0f0',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'f0f',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    rebeccapurple: '639',
    red: 'f00',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'fff',
    whitesmoke: 'f5f5f5',
    yellow: 'ff0',
    yellowgreen: '9acd32'
  };

  /**
   * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
   * @private
   */
  function nameToHex(color) {
    if (typeof color !== 'string') return color;
    var normalizedColorName = color.toLowerCase();
    return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
  }

  var hexRegex = /^#[a-fA-F0-9]{6}$/;
  var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
  var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
  var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
  var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
  var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
  var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
  var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;

  /**
   * Returns an RgbColor or RgbaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a RgbColor or RgbaColor object back to a string.
   *
   * @example
   * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
   * const color1 = parseToRgb('rgb(255, 0, 0)');
   * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
   * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
   */
  function parseToRgb(color) {
    if (typeof color !== 'string') {
      throw new PolishedError(3);
    }
    var normalizedColor = nameToHex(color);
    if (normalizedColor.match(hexRegex)) {
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
      };
    }
    if (normalizedColor.match(hexRgbaRegex)) {
      var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
        alpha: alpha
      };
    }
    if (normalizedColor.match(reducedHexRegex)) {
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
      };
    }
    if (normalizedColor.match(reducedRgbaHexRegex)) {
      var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
        alpha: _alpha
      };
    }
    var rgbMatched = rgbRegex.exec(normalizedColor);
    if (rgbMatched) {
      return {
        red: parseInt("" + rgbMatched[1], 10),
        green: parseInt("" + rgbMatched[2], 10),
        blue: parseInt("" + rgbMatched[3], 10)
      };
    }
    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
    if (rgbaMatched) {
      return {
        red: parseInt("" + rgbaMatched[1], 10),
        green: parseInt("" + rgbaMatched[2], 10),
        blue: parseInt("" + rgbaMatched[3], 10),
        alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
      };
    }
    var hslMatched = hslRegex.exec(normalizedColor);
    if (hslMatched) {
      var hue = parseInt("" + hslMatched[1], 10);
      var saturation = parseInt("" + hslMatched[2], 10) / 100;
      var lightness = parseInt("" + hslMatched[3], 10) / 100;
      var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
      var hslRgbMatched = rgbRegex.exec(rgbColorString);
      if (!hslRgbMatched) {
        throw new PolishedError(4, normalizedColor, rgbColorString);
      }
      return {
        red: parseInt("" + hslRgbMatched[1], 10),
        green: parseInt("" + hslRgbMatched[2], 10),
        blue: parseInt("" + hslRgbMatched[3], 10)
      };
    }
    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
    if (hslaMatched) {
      var _hue = parseInt("" + hslaMatched[1], 10);
      var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
      var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
      var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
      var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
      if (!_hslRgbMatched) {
        throw new PolishedError(4, normalizedColor, _rgbColorString);
      }
      return {
        red: parseInt("" + _hslRgbMatched[1], 10),
        green: parseInt("" + _hslRgbMatched[2], 10),
        blue: parseInt("" + _hslRgbMatched[3], 10),
        alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
      };
    }
    throw new PolishedError(5);
  }

  function rgbToHsl(color) {
    // make sure rgb are contained in a set of [0, 255]
    var red = color.red / 255;
    var green = color.green / 255;
    var blue = color.blue / 255;
    var max = Math.max(red, green, blue);
    var min = Math.min(red, green, blue);
    var lightness = (max + min) / 2;
    if (max === min) {
      // achromatic
      if (color.alpha !== undefined) {
        return {
          hue: 0,
          saturation: 0,
          lightness: lightness,
          alpha: color.alpha
        };
      } else {
        return {
          hue: 0,
          saturation: 0,
          lightness: lightness
        };
      }
    }
    var hue;
    var delta = max - min;
    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    switch (max) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      default:
        // blue case
        hue = (red - green) / delta + 4;
        break;
    }
    hue *= 60;
    if (color.alpha !== undefined) {
      return {
        hue: hue,
        saturation: saturation,
        lightness: lightness,
        alpha: color.alpha
      };
    }
    return {
      hue: hue,
      saturation: saturation,
      lightness: lightness
    };
  }

  /**
   * Returns an HslColor or HslaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a HslColor or HslaColor object back to a string.
   *
   * @example
   * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1
   * const color1 = parseToHsl('rgb(255, 0, 0)');
   * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2
   * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');
   */
  function parseToHsl(color) {
    // Note: At a later stage we can optimize this function as right now a hsl
    // color would be parsed converted to rgb values and converted back to hsl.
    return rgbToHsl(parseToRgb(color));
  }

  /**
   * Reduces hex values if possible e.g. #ff8866 to #f86
   * @private
   */
  var reduceHexValue = function reduceHexValue(value) {
    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
      return "#" + value[1] + value[3] + value[5];
    }
    return value;
  };
  var reduceHexValue$1 = reduceHexValue;

  function numberToHex(value) {
    var hex = value.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }

  function colorToHex(color) {
    return numberToHex(Math.round(color * 255));
  }
  function convertToHex(red, green, blue) {
    return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
  }
  function hslToHex(hue, saturation, lightness) {
    return hslToRgb(hue, saturation, lightness, convertToHex);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: hsl(359, 0.75, 0.4),
   *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${hsl(359, 0.75, 0.4)};
   *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#b3191c";
   *   background: "#b3191c";
   * }
   */
  function hsl(value, saturation, lightness) {
    if (typeof value === 'object' && saturation === undefined && lightness === undefined) {
      return hslToHex(value.hue, value.saturation, value.lightness);
    }
    throw new PolishedError(1);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: hsla(359, 0.75, 0.4, 0.7),
   *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
   *   background: hsla(359, 0.75, 0.4, 1),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${hsla(359, 0.75, 0.4, 0.7)};
   *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
   *   background: ${hsla(359, 0.75, 0.4, 1)};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(179,25,28,0.7)";
   *   background: "rgba(179,25,28,0.7)";
   *   background: "#b3191c";
   * }
   */
  function hsla(value, saturation, lightness, alpha) {
    if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
      return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
    }
    throw new PolishedError(2);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: rgb(255, 205, 100),
   *   background: rgb({ red: 255, green: 205, blue: 100 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${rgb(255, 205, 100)};
   *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#ffcd64";
   *   background: "#ffcd64";
   * }
   */
  function rgb(value, green, blue) {
    if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
      return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
    } else if (typeof value === 'object' && green === undefined && blue === undefined) {
      return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
    }
    throw new PolishedError(6);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
   *
   * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: rgba(255, 205, 100, 0.7),
   *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
   *   background: rgba(255, 205, 100, 1),
   *   background: rgba('#ffffff', 0.4),
   *   background: rgba('black', 0.7),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${rgba(255, 205, 100, 0.7)};
   *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
   *   background: ${rgba(255, 205, 100, 1)};
   *   background: ${rgba('#ffffff', 0.4)};
   *   background: ${rgba('black', 0.7)};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(255,205,100,0.7)";
   *   background: "rgba(255,205,100,0.7)";
   *   background: "#ffcd64";
   *   background: "rgba(255,255,255,0.4)";
   *   background: "rgba(0,0,0,0.7)";
   * }
   */
  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
      return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
    }
    throw new PolishedError(7);
  }

  var isRgb = function isRgb(color) {
    return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
  };
  var isRgba = function isRgba(color) {
    return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
  };
  var isHsl = function isHsl(color) {
    return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
  };
  var isHsla = function isHsla(color) {
    return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
  };

  /**
   * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
   * This util is useful in case you only know on runtime which color object is
   * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: toColorString({ red: 255, green: 205, blue: 100 }),
   *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
   *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
   *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
   *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
   *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
   *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#ffcd64";
   *   background: "rgba(255,205,100,0.72)";
   *   background: "#00f";
   *   background: "rgba(179,25,25,0.72)";
   * }
   */

  function toColorString(color) {
    if (typeof color !== 'object') throw new PolishedError(8);
    if (isRgba(color)) return rgba(color);
    if (isRgb(color)) return rgb(color);
    if (isHsla(color)) return hsla(color);
    if (isHsl(color)) return hsl(color);
    throw new PolishedError(8);
  }

  // Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
  // eslint-disable-next-line no-unused-vars
  // eslint-disable-next-line no-unused-vars
  // eslint-disable-next-line no-redeclare
  function curried(f, length, acc) {
    return function fn() {
      // eslint-disable-next-line prefer-rest-params
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
    };
  }

  // eslint-disable-next-line no-redeclare
  function curry(f) {
    // eslint-disable-line no-redeclare
    return curried(f, f.length, []);
  }

  /**
   * Changes the hue of the color. Hue is a number between 0 to 360. The first
   * argument for adjustHue is the amount of degrees the color is rotated around
   * the color wheel, always producing a positive hue value.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: adjustHue(180, '#448'),
   *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${adjustHue(180, '#448')};
   *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#888844";
   *   background: "rgba(136,136,68,0.7)";
   * }
   */
  function adjustHue(degree, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      hue: hslColor.hue + parseFloat(degree)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(adjustHue);

  function guard(lowerBoundary, upperBoundary, value) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value));
  }

  /**
   * Returns a string value for the darkened color.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: darken(0.2, '#FFCD64'),
   *   background: darken('0.2', 'rgba(255,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${darken(0.2, '#FFCD64')};
   *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#ffbd31";
   *   background: "rgba(255,189,49,0.7)";
   * }
   */
  function darken(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(darken);

  /**
   * Decreases the intensity of a color. Its range is between 0 to 1. The first
   * argument of the desaturate function is the amount by how much the color
   * intensity should be decreased.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: desaturate(0.2, '#CCCD64'),
   *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${desaturate(0.2, '#CCCD64')};
   *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#b8b979";
   *   background: "rgba(184,185,121,0.7)";
   * }
   */
  function desaturate(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(desaturate);

  /**
   * Returns a string value for the lightened color.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: lighten(0.2, '#CCCD64'),
   *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${lighten(0.2, '#FFCD64')};
   *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#e5e6b1";
   *   background: "rgba(229,230,177,0.7)";
   * }
   */
  function lighten(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(lighten);

  /**
   * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: mix(0.5, '#f00', '#00f')
   *   background: mix(0.25, '#f00', '#00f')
   *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${mix(0.5, '#f00', '#00f')};
   *   background: ${mix(0.25, '#f00', '#00f')};
   *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#7f007f";
   *   background: "#3f00bf";
   *   background: "rgba(63, 0, 191, 0.75)";
   * }
   */
  function mix(weight, color, otherColor) {
    if (color === 'transparent') return otherColor;
    if (otherColor === 'transparent') return color;
    if (weight === 0) return otherColor;
    var parsedColor1 = parseToRgb(color);
    var color1 = _extends({}, parsedColor1, {
      alpha: typeof parsedColor1.alpha === 'number' ? parsedColor1.alpha : 1
    });
    var parsedColor2 = parseToRgb(otherColor);
    var color2 = _extends({}, parsedColor2, {
      alpha: typeof parsedColor2.alpha === 'number' ? parsedColor2.alpha : 1
    });

    // The formula is copied from the original Sass implementation:
    // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method
    var alphaDelta = color1.alpha - color2.alpha;
    var x = parseFloat(weight) * 2 - 1;
    var y = x * alphaDelta === -1 ? x : x + alphaDelta;
    var z = 1 + x * alphaDelta;
    var weight1 = (y / z + 1) / 2.0;
    var weight2 = 1 - weight1;
    var mixedColor = {
      red: Math.floor(color1.red * weight1 + color2.red * weight2),
      green: Math.floor(color1.green * weight1 + color2.green * weight2),
      blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
      alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))
    };
    return rgba(mixedColor);
  }

  // prettier-ignore
  var curriedMix = curry /* ::<number | string, string, string, string> */(mix);
  var mix$1 = curriedMix;

  /**
   * Increases the opacity of a color. Its range for the amount is between 0 to 1.
   *
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');
   *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),
   *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};
   *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},
   *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#fff";
   *   background: "rgba(255,255,255,0.7)";
   *   background: "rgba(255,0,0,0.7)";
   * }
   */
  function opacify(amount, color) {
    if (color === 'transparent') return color;
    var parsedColor = parseToRgb(color);
    var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;
    var colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
    });
    return rgba(colorWithAlpha);
  }

  // prettier-ignore
  var curriedOpacify = curry /* ::<number | string, string, string> */(opacify);
  var curriedOpacify$1 = curriedOpacify;

  /**
   * Increases the intensity of a color. Its range is between 0 to 1. The first
   * argument of the saturate function is the amount by how much the color
   * intensity should be increased.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: saturate(0.2, '#CCCD64'),
   *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${saturate(0.2, '#FFCD64')};
   *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#e0e250";
   *   background: "rgba(224,226,80,0.7)";
   * }
   */
  function saturate(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(saturate);

  /**
   * Sets the hue of a color to the provided value. The hue range can be
   * from 0 and 359.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: setHue(42, '#CCCD64'),
   *   background: setHue('244', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${setHue(42, '#CCCD64')};
   *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#cdae64";
   *   background: "rgba(107,100,205,0.7)";
   * }
   */
  function setHue(hue, color) {
    if (color === 'transparent') return color;
    return toColorString(_extends({}, parseToHsl(color), {
      hue: parseFloat(hue)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(setHue);

  /**
   * Sets the lightness of a color to the provided value. The lightness range can be
   * from 0 and 1.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: setLightness(0.2, '#CCCD64'),
   *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${setLightness(0.2, '#CCCD64')};
   *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#4d4d19";
   *   background: "rgba(223,224,159,0.7)";
   * }
   */
  function setLightness(lightness, color) {
    if (color === 'transparent') return color;
    return toColorString(_extends({}, parseToHsl(color), {
      lightness: parseFloat(lightness)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(setLightness);

  /**
   * Sets the saturation of a color to the provided value. The saturation range can be
   * from 0 and 1.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: setSaturation(0.2, '#CCCD64'),
   *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${setSaturation(0.2, '#CCCD64')};
   *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#adad84";
   *   background: "rgba(228,229,76,0.7)";
   * }
   */
  function setSaturation(saturation, color) {
    if (color === 'transparent') return color;
    return toColorString(_extends({}, parseToHsl(color), {
      saturation: parseFloat(saturation)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(setSaturation);

  /**
   * Shades a color by mixing it with black. `shade` can produce
   * hue shifts, where as `darken` manipulates the luminance channel and therefore
   * doesn't produce hue shifts.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: shade(0.25, '#00f')
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${shade(0.25, '#00f')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#00003f";
   * }
   */

  function shade(percentage, color) {
    if (color === 'transparent') return color;
    return mix$1(parseFloat(percentage), 'rgb(0, 0, 0)', color);
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(shade);

  /**
   * Tints a color by mixing it with white. `tint` can produce
   * hue shifts, where as `lighten` manipulates the luminance channel and therefore
   * doesn't produce hue shifts.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: tint(0.25, '#00f')
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${tint(0.25, '#00f')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#bfbfff";
   * }
   */

  function tint(percentage, color) {
    if (color === 'transparent') return color;
    return mix$1(parseFloat(percentage), 'rgb(255, 255, 255)', color);
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(tint);

  /**
   * Decreases the opacity of a color. Its range for the amount is between 0 to 1.
   *
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: transparentize(0.1, '#fff'),
   *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),
   *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${transparentize(0.1, '#fff')};
   *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};
   *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(255,255,255,0.9)";
   *   background: "rgba(255,255,255,0.8)";
   *   background: "rgba(255,0,0,0.3)";
   * }
   */
  function transparentize(amount, color) {
    if (color === 'transparent') return color;
    var parsedColor = parseToRgb(color);
    var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;
    var colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
    });
    return rgba(colorWithAlpha);
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(transparentize);

  /**
   * The Ease class provides a collection of easing functions for use with tween.js.
   */
  var Easing = Object.freeze({
      Linear: Object.freeze({
          None: function (amount) {
              return amount;
          },
          In: function (amount) {
              return amount;
          },
          Out: function (amount) {
              return amount;
          },
          InOut: function (amount) {
              return amount;
          },
      }),
      Quadratic: Object.freeze({
          In: function (amount) {
              return amount * amount;
          },
          Out: function (amount) {
              return amount * (2 - amount);
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount;
              }
              return -0.5 * (--amount * (amount - 2) - 1);
          },
      }),
      Cubic: Object.freeze({
          In: function (amount) {
              return amount * amount * amount;
          },
          Out: function (amount) {
              return --amount * amount * amount + 1;
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount * amount;
              }
              return 0.5 * ((amount -= 2) * amount * amount + 2);
          },
      }),
      Quartic: Object.freeze({
          In: function (amount) {
              return amount * amount * amount * amount;
          },
          Out: function (amount) {
              return 1 - --amount * amount * amount * amount;
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount * amount * amount;
              }
              return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
          },
      }),
      Quintic: Object.freeze({
          In: function (amount) {
              return amount * amount * amount * amount * amount;
          },
          Out: function (amount) {
              return --amount * amount * amount * amount * amount + 1;
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount * amount * amount * amount;
              }
              return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
          },
      }),
      Sinusoidal: Object.freeze({
          In: function (amount) {
              return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);
          },
          Out: function (amount) {
              return Math.sin((amount * Math.PI) / 2);
          },
          InOut: function (amount) {
              return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
          },
      }),
      Exponential: Object.freeze({
          In: function (amount) {
              return amount === 0 ? 0 : Math.pow(1024, amount - 1);
          },
          Out: function (amount) {
              return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
          },
          InOut: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              if ((amount *= 2) < 1) {
                  return 0.5 * Math.pow(1024, amount - 1);
              }
              return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
          },
      }),
      Circular: Object.freeze({
          In: function (amount) {
              return 1 - Math.sqrt(1 - amount * amount);
          },
          Out: function (amount) {
              return Math.sqrt(1 - --amount * amount);
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
              }
              return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
          },
      }),
      Elastic: Object.freeze({
          In: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
          },
          Out: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
          },
          InOut: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              amount *= 2;
              if (amount < 1) {
                  return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
              }
              return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
          },
      }),
      Back: Object.freeze({
          In: function (amount) {
              var s = 1.70158;
              return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);
          },
          Out: function (amount) {
              var s = 1.70158;
              return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;
          },
          InOut: function (amount) {
              var s = 1.70158 * 1.525;
              if ((amount *= 2) < 1) {
                  return 0.5 * (amount * amount * ((s + 1) * amount - s));
              }
              return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
          },
      }),
      Bounce: Object.freeze({
          In: function (amount) {
              return 1 - Easing.Bounce.Out(1 - amount);
          },
          Out: function (amount) {
              if (amount < 1 / 2.75) {
                  return 7.5625 * amount * amount;
              }
              else if (amount < 2 / 2.75) {
                  return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
              }
              else if (amount < 2.5 / 2.75) {
                  return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
              }
              else {
                  return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
              }
          },
          InOut: function (amount) {
              if (amount < 0.5) {
                  return Easing.Bounce.In(amount * 2) * 0.5;
              }
              return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
          },
      }),
      generatePow: function (power) {
          if (power === void 0) { power = 4; }
          power = power < Number.EPSILON ? Number.EPSILON : power;
          power = power > 10000 ? 10000 : power;
          return {
              In: function (amount) {
                  return Math.pow(amount, power);
              },
              Out: function (amount) {
                  return 1 - Math.pow((1 - amount), power);
              },
              InOut: function (amount) {
                  if (amount < 0.5) {
                      return Math.pow((amount * 2), power) / 2;
                  }
                  return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;
              },
          };
      },
  });

  var now$1 = function () { return performance.now(); };

  /**
   * Controlling groups of tweens
   *
   * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
   * In these cases, you may want to create your own smaller groups of tween
   */
  var Group = /** @class */ (function () {
      function Group() {
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          this._tweens = {};
          this._tweensAddedDuringUpdate = {};
          this.add.apply(this, tweens);
      }
      Group.prototype.getAll = function () {
          var _this = this;
          return Object.keys(this._tweens).map(function (tweenId) { return _this._tweens[tweenId]; });
      };
      Group.prototype.removeAll = function () {
          this._tweens = {};
      };
      Group.prototype.add = function () {
          var _a;
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {
              var tween = tweens_1[_b];
              // Remove from any other group first, a tween can only be in one group at a time.
              // @ts-expect-error library internal access
              (_a = tween._group) === null || _a === void 0 ? void 0 : _a.remove(tween);
              // @ts-expect-error library internal access
              tween._group = this;
              this._tweens[tween.getId()] = tween;
              this._tweensAddedDuringUpdate[tween.getId()] = tween;
          }
      };
      Group.prototype.remove = function () {
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {
              var tween = tweens_2[_a];
              // @ts-expect-error library internal access
              tween._group = undefined;
              delete this._tweens[tween.getId()];
              delete this._tweensAddedDuringUpdate[tween.getId()];
          }
      };
      /** Return true if all tweens in the group are not paused or playing. */
      Group.prototype.allStopped = function () {
          return this.getAll().every(function (tween) { return !tween.isPlaying(); });
      };
      Group.prototype.update = function (time, preserve) {
          if (time === void 0) { time = now$1(); }
          if (preserve === void 0) { preserve = true; }
          var tweenIds = Object.keys(this._tweens);
          if (tweenIds.length === 0)
              return;
          // Tweens are updated in "batches". If you add a new tween during an
          // update, then the new tween will be updated in the next batch.
          // If you remove a tween during an update, it may or may not be updated.
          // However, if the removed tween was added during the current batch,
          // then it will not be updated.
          while (tweenIds.length > 0) {
              this._tweensAddedDuringUpdate = {};
              for (var i = 0; i < tweenIds.length; i++) {
                  var tween = this._tweens[tweenIds[i]];
                  var autoStart = !preserve;
                  if (tween && tween.update(time, autoStart) === false && !preserve)
                      this.remove(tween);
              }
              tweenIds = Object.keys(this._tweensAddedDuringUpdate);
          }
      };
      return Group;
  }());

  /**
   *
   */
  var Interpolation = {
      Linear: function (v, k) {
          var m = v.length - 1;
          var f = m * k;
          var i = Math.floor(f);
          var fn = Interpolation.Utils.Linear;
          if (k < 0) {
              return fn(v[0], v[1], f);
          }
          if (k > 1) {
              return fn(v[m], v[m - 1], m - f);
          }
          return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
      },
      Utils: {
          Linear: function (p0, p1, t) {
              return (p1 - p0) * t + p0;
          }},
  };

  /**
   * Utils
   */
  var Sequence = /** @class */ (function () {
      function Sequence() {
      }
      Sequence.nextId = function () {
          return Sequence._nextId++;
      };
      Sequence._nextId = 0;
      return Sequence;
  }());

  var mainGroup = new Group();

  /**
   * Tween.js - Licensed under the MIT license
   * https://github.com/tweenjs/tween.js
   * ----------------------------------------------
   *
   * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
   * Thank you all, you're awesome!
   */
  var Tween = /** @class */ (function () {
      function Tween(object, group) {
          this._isPaused = false;
          this._pauseStart = 0;
          this._valuesStart = {};
          this._valuesEnd = {};
          this._valuesStartRepeat = {};
          this._duration = 1000;
          this._isDynamic = false;
          this._initialRepeat = 0;
          this._repeat = 0;
          this._yoyo = false;
          this._isPlaying = false;
          this._reversed = false;
          this._delayTime = 0;
          this._startTime = 0;
          this._easingFunction = Easing.Linear.None;
          this._interpolationFunction = Interpolation.Linear;
          // eslint-disable-next-line
          this._chainedTweens = [];
          this._onStartCallbackFired = false;
          this._onEveryStartCallbackFired = false;
          this._id = Sequence.nextId();
          this._isChainStopped = false;
          this._propertiesAreSetUp = false;
          this._goToEnd = false;
          this._object = object;
          if (typeof group === 'object') {
              this._group = group;
              group.add(this);
          }
          // Use "true" to restore old behavior (will be removed in future release).
          else if (group === true) {
              this._group = mainGroup;
              mainGroup.add(this);
          }
      }
      Tween.prototype.getId = function () {
          return this._id;
      };
      Tween.prototype.isPlaying = function () {
          return this._isPlaying;
      };
      Tween.prototype.isPaused = function () {
          return this._isPaused;
      };
      Tween.prototype.getDuration = function () {
          return this._duration;
      };
      Tween.prototype.to = function (target, duration) {
          if (duration === void 0) { duration = 1000; }
          if (this._isPlaying)
              throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');
          this._valuesEnd = target;
          this._propertiesAreSetUp = false;
          this._duration = duration < 0 ? 0 : duration;
          return this;
      };
      Tween.prototype.duration = function (duration) {
          if (duration === void 0) { duration = 1000; }
          this._duration = duration < 0 ? 0 : duration;
          return this;
      };
      Tween.prototype.dynamic = function (dynamic) {
          if (dynamic === void 0) { dynamic = false; }
          this._isDynamic = dynamic;
          return this;
      };
      Tween.prototype.start = function (time, overrideStartingValues) {
          if (time === void 0) { time = now$1(); }
          if (overrideStartingValues === void 0) { overrideStartingValues = false; }
          if (this._isPlaying) {
              return this;
          }
          this._repeat = this._initialRepeat;
          if (this._reversed) {
              // If we were reversed (f.e. using the yoyo feature) then we need to
              // flip the tween direction back to forward.
              this._reversed = false;
              for (var property in this._valuesStartRepeat) {
                  this._swapEndStartRepeatValues(property);
                  this._valuesStart[property] = this._valuesStartRepeat[property];
              }
          }
          this._isPlaying = true;
          this._isPaused = false;
          this._onStartCallbackFired = false;
          this._onEveryStartCallbackFired = false;
          this._isChainStopped = false;
          this._startTime = time;
          this._startTime += this._delayTime;
          if (!this._propertiesAreSetUp || overrideStartingValues) {
              this._propertiesAreSetUp = true;
              // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
              if (!this._isDynamic) {
                  var tmp = {};
                  for (var prop in this._valuesEnd)
                      tmp[prop] = this._valuesEnd[prop];
                  this._valuesEnd = tmp;
              }
              this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
          }
          return this;
      };
      Tween.prototype.startFromCurrentValues = function (time) {
          return this.start(time, true);
      };
      Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
          for (var property in _valuesEnd) {
              var startValue = _object[property];
              var startValueIsArray = Array.isArray(startValue);
              var propType = startValueIsArray ? 'array' : typeof startValue;
              var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
              // If `to()` specifies a property that doesn't exist in the source object,
              // we should not set that property in the object
              if (propType === 'undefined' || propType === 'function') {
                  continue;
              }
              // Check if an Array was provided as property value
              if (isInterpolationList) {
                  var endValues = _valuesEnd[property];
                  if (endValues.length === 0) {
                      continue;
                  }
                  // Handle an array of relative values.
                  // Creates a local copy of the Array with the start value at the front
                  var temp = [startValue];
                  for (var i = 0, l = endValues.length; i < l; i += 1) {
                      var value = this._handleRelativeValue(startValue, endValues[i]);
                      if (isNaN(value)) {
                          isInterpolationList = false;
                          console.warn('Found invalid interpolation list. Skipping.');
                          break;
                      }
                      temp.push(value);
                  }
                  if (isInterpolationList) {
                      // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.
                      _valuesEnd[property] = temp;
                      // }
                  }
              }
              // handle the deepness of the values
              if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                  _valuesStart[property] = startValueIsArray ? [] : {};
                  var nestedObject = startValue;
                  for (var prop in nestedObject) {
                      _valuesStart[property][prop] = nestedObject[prop];
                  }
                  // TODO? repeat nested values? And yoyo? And array values?
                  _valuesStartRepeat[property] = startValueIsArray ? [] : {};
                  var endValues = _valuesEnd[property];
                  // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
                  if (!this._isDynamic) {
                      var tmp = {};
                      for (var prop in endValues)
                          tmp[prop] = endValues[prop];
                      _valuesEnd[property] = endValues = tmp;
                  }
                  this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);
              }
              else {
                  // Save the starting value, but only once unless override is requested.
                  if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {
                      _valuesStart[property] = startValue;
                  }
                  if (!startValueIsArray) {
                      // eslint-disable-next-line
                      // @ts-ignore FIXME?
                      _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                  }
                  if (isInterpolationList) {
                      // eslint-disable-next-line
                      // @ts-ignore FIXME?
                      _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                  }
                  else {
                      _valuesStartRepeat[property] = _valuesStart[property] || 0;
                  }
              }
          }
      };
      Tween.prototype.stop = function () {
          if (!this._isChainStopped) {
              this._isChainStopped = true;
              this.stopChainedTweens();
          }
          if (!this._isPlaying) {
              return this;
          }
          this._isPlaying = false;
          this._isPaused = false;
          if (this._onStopCallback) {
              this._onStopCallback(this._object);
          }
          return this;
      };
      Tween.prototype.end = function () {
          this._goToEnd = true;
          this.update(this._startTime + this._duration);
          return this;
      };
      Tween.prototype.pause = function (time) {
          if (time === void 0) { time = now$1(); }
          if (this._isPaused || !this._isPlaying) {
              return this;
          }
          this._isPaused = true;
          this._pauseStart = time;
          return this;
      };
      Tween.prototype.resume = function (time) {
          if (time === void 0) { time = now$1(); }
          if (!this._isPaused || !this._isPlaying) {
              return this;
          }
          this._isPaused = false;
          this._startTime += time - this._pauseStart;
          this._pauseStart = 0;
          return this;
      };
      Tween.prototype.stopChainedTweens = function () {
          for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
              this._chainedTweens[i].stop();
          }
          return this;
      };
      Tween.prototype.group = function (group) {
          if (!group) {
              console.warn('tween.group() without args has been removed, use group.add(tween) instead.');
              return this;
          }
          group.add(this);
          return this;
      };
      /**
       * Removes the tween from whichever group it is in.
       */
      Tween.prototype.remove = function () {
          var _a;
          (_a = this._group) === null || _a === void 0 ? void 0 : _a.remove(this);
          return this;
      };
      Tween.prototype.delay = function (amount) {
          if (amount === void 0) { amount = 0; }
          this._delayTime = amount;
          return this;
      };
      Tween.prototype.repeat = function (times) {
          if (times === void 0) { times = 0; }
          this._initialRepeat = times;
          this._repeat = times;
          return this;
      };
      Tween.prototype.repeatDelay = function (amount) {
          this._repeatDelayTime = amount;
          return this;
      };
      Tween.prototype.yoyo = function (yoyo) {
          if (yoyo === void 0) { yoyo = false; }
          this._yoyo = yoyo;
          return this;
      };
      Tween.prototype.easing = function (easingFunction) {
          if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }
          this._easingFunction = easingFunction;
          return this;
      };
      Tween.prototype.interpolation = function (interpolationFunction) {
          if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }
          this._interpolationFunction = interpolationFunction;
          return this;
      };
      // eslint-disable-next-line
      Tween.prototype.chain = function () {
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          this._chainedTweens = tweens;
          return this;
      };
      Tween.prototype.onStart = function (callback) {
          this._onStartCallback = callback;
          return this;
      };
      Tween.prototype.onEveryStart = function (callback) {
          this._onEveryStartCallback = callback;
          return this;
      };
      Tween.prototype.onUpdate = function (callback) {
          this._onUpdateCallback = callback;
          return this;
      };
      Tween.prototype.onRepeat = function (callback) {
          this._onRepeatCallback = callback;
          return this;
      };
      Tween.prototype.onComplete = function (callback) {
          this._onCompleteCallback = callback;
          return this;
      };
      Tween.prototype.onStop = function (callback) {
          this._onStopCallback = callback;
          return this;
      };
      /**
       * @returns true if the tween is still playing after the update, false
       * otherwise (calling update on a paused tween still returns true because
       * it is still playing, just paused).
       *
       * @param autoStart - When true, calling update will implicitly call start()
       * as well. Note, if you stop() or end() the tween, but are still calling
       * update(), it will start again!
       */
      Tween.prototype.update = function (time, autoStart) {
          var _this = this;
          var _a;
          if (time === void 0) { time = now$1(); }
          if (autoStart === void 0) { autoStart = Tween.autoStartOnUpdate; }
          if (this._isPaused)
              return true;
          var property;
          if (!this._goToEnd && !this._isPlaying) {
              if (autoStart)
                  this.start(time, true);
              else
                  return false;
          }
          this._goToEnd = false;
          if (time < this._startTime) {
              return true;
          }
          if (this._onStartCallbackFired === false) {
              if (this._onStartCallback) {
                  this._onStartCallback(this._object);
              }
              this._onStartCallbackFired = true;
          }
          if (this._onEveryStartCallbackFired === false) {
              if (this._onEveryStartCallback) {
                  this._onEveryStartCallback(this._object);
              }
              this._onEveryStartCallbackFired = true;
          }
          var elapsedTime = time - this._startTime;
          var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
          var totalTime = this._duration + this._repeat * durationAndDelay;
          var calculateElapsedPortion = function () {
              if (_this._duration === 0)
                  return 1;
              if (elapsedTime > totalTime) {
                  return 1;
              }
              var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);
              var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;
              // TODO use %?
              // const timeIntoCurrentRepeat = elapsedTime % durationAndDelay
              var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
              if (portion === 0 && elapsedTime === _this._duration) {
                  return 1;
              }
              return portion;
          };
          var elapsed = calculateElapsedPortion();
          var value = this._easingFunction(elapsed);
          // properties transformations
          this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
          if (this._onUpdateCallback) {
              this._onUpdateCallback(this._object, elapsed);
          }
          if (this._duration === 0 || elapsedTime >= this._duration) {
              if (this._repeat > 0) {
                  var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
                  if (isFinite(this._repeat)) {
                      this._repeat -= completeCount;
                  }
                  // Reassign starting values, restart by making startTime = now
                  for (property in this._valuesStartRepeat) {
                      if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                          this._valuesStartRepeat[property] =
                              // eslint-disable-next-line
                              // @ts-ignore FIXME?
                              this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                      }
                      if (this._yoyo) {
                          this._swapEndStartRepeatValues(property);
                      }
                      this._valuesStart[property] = this._valuesStartRepeat[property];
                  }
                  if (this._yoyo) {
                      this._reversed = !this._reversed;
                  }
                  this._startTime += durationAndDelay * completeCount;
                  if (this._onRepeatCallback) {
                      this._onRepeatCallback(this._object);
                  }
                  this._onEveryStartCallbackFired = false;
                  return true;
              }
              else {
                  if (this._onCompleteCallback) {
                      this._onCompleteCallback(this._object);
                  }
                  for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                      // Make the chained tweens start exactly at the time they should,
                      // even if the `update()` method was called way past the duration of the tween
                      this._chainedTweens[i].start(this._startTime + this._duration, false);
                  }
                  this._isPlaying = false;
                  return false;
              }
          }
          return true;
      };
      Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
          for (var property in _valuesEnd) {
              // Don't update properties that do not exist in the source object
              if (_valuesStart[property] === undefined) {
                  continue;
              }
              var start = _valuesStart[property] || 0;
              var end = _valuesEnd[property];
              var startIsArray = Array.isArray(_object[property]);
              var endIsArray = Array.isArray(end);
              var isInterpolationList = !startIsArray && endIsArray;
              if (isInterpolationList) {
                  _object[property] = this._interpolationFunction(end, value);
              }
              else if (typeof end === 'object' && end) {
                  // eslint-disable-next-line
                  // @ts-ignore FIXME?
                  this._updateProperties(_object[property], start, end, value);
              }
              else {
                  // Parses relative end values with start as base (e.g.: +10, -3)
                  end = this._handleRelativeValue(start, end);
                  // Protect against non numeric properties.
                  if (typeof end === 'number') {
                      // eslint-disable-next-line
                      // @ts-ignore FIXME?
                      _object[property] = start + (end - start) * value;
                  }
              }
          }
      };
      Tween.prototype._handleRelativeValue = function (start, end) {
          if (typeof end !== 'string') {
              return end;
          }
          if (end.charAt(0) === '+' || end.charAt(0) === '-') {
              return start + parseFloat(end);
          }
          return parseFloat(end);
      };
      Tween.prototype._swapEndStartRepeatValues = function (property) {
          var tmp = this._valuesStartRepeat[property];
          var endValue = this._valuesEnd[property];
          if (typeof endValue === 'string') {
              this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
          }
          else {
              this._valuesStartRepeat[property] = this._valuesEnd[property];
          }
          this._valuesEnd[property] = tmp;
      };
      Tween.autoStartOnUpdate = false;
      return Tween;
  }());

  /**
   * Tween.js - Licensed under the MIT license
   * https://github.com/tweenjs/tween.js
   * ----------------------------------------------
   *
   * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
   * Thank you all, you're awesome!
   */
  Sequence.nextId;
  /**
   * Controlling groups of tweens
   *
   * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
   * In these cases, you may want to create your own smaller groups of tweens.
   */
  var TWEEN = mainGroup;
  // This is the best way to export things in a way that's compatible with both ES
  // Modules and CommonJS, without build hacks, and so as not to break the
  // existing API.
  // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.getAll.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.removeAll.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.add.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.remove.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.update.bind(TWEEN);

  var index$2 = (function (p) {
    return typeof p === 'function' ? p // fn
    : typeof p === 'string' ? function (obj) {
      return obj[p];
    } // property name
    : function (obj) {
      return p;
    };
  }); // constant

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal || freeSelf || Function('return this')();

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root$1.Date.now();
  };

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto$1.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  function _arrayLikeToArray$1(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles$1(r) {
    if (Array.isArray(r)) return r;
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _createClass(e, r, t) {
    return Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  function _iterableToArrayLimit$1(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = true,
        o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = true, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray$1(r, e) {
    return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest$1();
  }
  function _unsupportedIterableToArray$1(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
    }
  }

  var Prop = /*#__PURE__*/_createClass(function Prop(name, _ref) {
    var _ref$default = _ref["default"],
      defaultVal = _ref$default === void 0 ? null : _ref$default,
      _ref$triggerUpdate = _ref.triggerUpdate,
      triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function (newVal, state) {} : _ref$onChange;
    _classCallCheck(this, Prop);
    this.name = name;
    this.defaultVal = defaultVal;
    this.triggerUpdate = triggerUpdate;
    this.onChange = onChange;
  });
  function index$1 (_ref2) {
    var _ref2$stateInit = _ref2.stateInit,
      stateInit = _ref2$stateInit === void 0 ? function () {
        return {};
      } : _ref2$stateInit,
      _ref2$props = _ref2.props,
      rawProps = _ref2$props === void 0 ? {} : _ref2$props,
      _ref2$methods = _ref2.methods,
      methods = _ref2$methods === void 0 ? {} : _ref2$methods,
      _ref2$aliases = _ref2.aliases,
      aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases,
      _ref2$init = _ref2.init,
      initFn = _ref2$init === void 0 ? function () {} : _ref2$init,
      _ref2$update = _ref2.update,
      updateFn = _ref2$update === void 0 ? function () {} : _ref2$update;
    // Parse props into Prop instances
    var props = Object.keys(rawProps).map(function (propName) {
      return new Prop(propName, rawProps[propName]);
    });
    return function KapsuleComp() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var classMode = !!(this instanceof KapsuleComp ? this.constructor : void 0);
      var nodeElement = classMode ? args.shift() : undefined;
      var _args$ = args[0],
        options = _args$ === void 0 ? {} : _args$;

      // Holds component state
      var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit,
      // Support plain objects for backwards compatibility
      {
        initialised: false
      });

      // keeps track of which props triggered an update
      var changedProps = {};

      // Component constructor
      function comp(nodeElement) {
        initStatic(nodeElement, options);
        digest();
        return comp;
      }
      var initStatic = function initStatic(nodeElement, options) {
        initFn.call(comp, nodeElement, state, options);
        state.initialised = true;
      };
      var digest = debounce(function () {
        if (!state.initialised) {
          return;
        }
        updateFn.call(comp, state, changedProps);
        changedProps = {};
      }, 1);

      // Getter/setter methods
      props.forEach(function (prop) {
        comp[prop.name] = getSetProp(prop);
        function getSetProp(_ref3) {
          var prop = _ref3.name,
            _ref3$triggerUpdate = _ref3.triggerUpdate,
            redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate,
            _ref3$onChange = _ref3.onChange,
            onChange = _ref3$onChange === void 0 ? function (newVal, state) {} : _ref3$onChange,
            _ref3$defaultVal = _ref3.defaultVal,
            defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
          return function (_) {
            var curVal = state[prop];
            if (!arguments.length) {
              return curVal;
            } // Getter mode

            var val = _ === undefined ? defaultVal : _; // pick default if value passed is undefined
            state[prop] = val;
            onChange.call(comp, val, state, curVal);

            // track changed props
            !changedProps.hasOwnProperty(prop) && (changedProps[prop] = curVal);
            if (redigest) {
              digest();
            }
            return comp;
          };
        }
      });

      // Other methods
      Object.keys(methods).forEach(function (methodName) {
        comp[methodName] = function () {
          var _methods$methodName;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args));
        };
      });

      // Link aliases
      Object.entries(aliases).forEach(function (_ref4) {
        var _ref5 = _slicedToArray$1(_ref4, 2),
          alias = _ref5[0],
          target = _ref5[1];
        return comp[alias] = comp[target];
      });

      // Reset all component props to their default value
      comp.resetProps = function () {
        props.forEach(function (prop) {
          comp[prop.name](prop.defaultVal);
        });
        return comp;
      };

      //

      comp.resetProps(); // Apply all prop defaults
      state._rerender = digest; // Expose digest method

      classMode && nodeElement && comp(nodeElement);
      return comp;
    };
  }

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  // Given something array like (or null), returns something that is strictly an
  // array. This is used to ensure that array-like objects passed to d3.selectAll
  // or selection.selectAll are converted into proper arrays when creating a
  // selection; we don’t ever want to create a selection backed by a live
  // HTMLCollection or NodeList. However, note that selection.selectAll will use a
  // static NodeList as a group, since it safely derived from querySelectorAll.
  function array(x) {
    return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }

  function selection_selectAll(select) {
    if (typeof select === "function") select = arrayAll(select);
    else select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  var find = Array.prototype.find;

  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }

  function childFirst() {
    return this.firstElementChild;
  }

  function selection_selectChild(match) {
    return this.select(match == null ? childFirst
        : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  var filter = Array.prototype.filter;

  function children() {
    return Array.from(this.children);
  }

  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }

  function selection_selectChildren(match) {
    return this.selectAll(match == null ? children
        : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = new Map,
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
        exit[i] = node;
      }
    }
  }

  function datum(node) {
    return node.__data__;
  }

  function selection_data(value, key) {
    if (!arguments.length) return Array.from(this, datum);

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  // Given some data, this returns an array-like view of it: an object that
  // exposes a length property and allows numeric indexing. Note that unlike
  // selectAll, this isn’t worried about “live” collections because the resulting
  // array will only be used briefly while data is being bound. (It is possible to
  // cause the data to change while iterating by using a key function, but please
  // don’t; we’d rather avoid a gratuitous copy.)
  function arraylike(data) {
    return typeof data === "object" && "length" in data
      ? data // Array, TypedArray, NodeList, array-like
      : Array.from(data); // Map, Set, iterable, string, or anything else
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update) update = update.selection();
    }
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(context) {
    var selection = context.selection ? context.selection() : context;

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    return Array.from(this);
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    let size = 0;
    for (const node of this) ++size; // eslint-disable-line no-unused-vars
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, options) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
    return this;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  function* selection_iterator() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) yield node;
      }
    }
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection_selection() {
    return this;
  }

  Selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    selectChild: selection_selectChild,
    selectChildren: selection_selectChildren,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    selection: selection_selection,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch,
    [Symbol.iterator]: selection_iterator
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function sourceEvent(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent) event = sourceEvent;
    return event;
  }

  function pointer(event, node) {
    event = sourceEvent(event);
    if (node === undefined) node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  var n,l,u,t,i,r,o,e,f,c,s,a,p={},v=[],y=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,w=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function g(n){n&&n.parentNode&&n.parentNode.removeChild(n);}function _(l,u,t){var i,r,o,e={};for(o in u)"key"==o?i=u[o]:"ref"==o?r=u[o]:e[o]=u[o];if(arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps) void 0===e[o]&&(e[o]=l.defaultProps[o]);return m(l,e,i,r,null)}function m(n,t,i,r,o){var e={type:n,props:t,key:i,ref:r,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:null==o?++u:o,__i:-1,__u:0};return null==o&&null!=l.vnode&&l.vnode(e),e}function k(n){return n.children}function x(n,l){this.props=n,this.context=l;}function S(n,l){if(null==l)return n.__?S(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?S(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=true)&&i.push(n)&&!$.__r++||r!=l.debounceRendering)&&((r=l.debounceRendering)||o)($);}function $(){for(var n,u,t,r,o,f,c,s=1;i.length;)i.length>s&&i.sort(e),n=i.shift(),s=i.length,n.__d&&(t=void 0,o=(r=(u=n).__v).__e,f=[],c=[],u.__P&&((t=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(t),O(u.__P,t,r,u.__n,u.__P.namespaceURI,32&r.__u?[o]:null,f,null==o?S(r):o,!!(32&r.__u),c),t.__v=r.__v,t.__.__k[t.__i]=t,z(f,t,c),t.__e!=o&&C(t)));$.__r=0;}function I(n,l,u,t,i,r,o,e,f,c,s){var a,h,y,w,d,g,_=t&&t.__k||v,m=l.length;for(f=P(u,l,_,f,m),a=0;a<m;a++)null!=(y=u.__k[a])&&(h=-1==y.__i?p:_[y.__i]||p,y.__i=a,g=O(n,y,h,i,r,o,e,f,c,s),w=y.__e,y.ref&&h.ref!=y.ref&&(h.ref&&q(h.ref,null,y),s.push(y.ref,y.__c||w,y)),null==d&&null!=w&&(d=w),4&y.__u||h.__k===y.__k?f=A(y,f,n):"function"==typeof y.type&&void 0!==g?f=g:w&&(f=w.nextSibling),y.__u&=-7);return u.__e=d,f}function P(n,l,u,t,i){var r,o,e,f,c,s=u.length,a=s,h=0;for(n.__k=new Array(i),r=0;r<i;r++)null!=(o=l[r])&&"boolean"!=typeof o&&"function"!=typeof o?(f=r+h,(o=n.__k[r]="string"==typeof o||"number"==typeof o||"bigint"==typeof o||o.constructor==String?m(null,o,null,null,null):w(o)?m(k,{children:o},null,null,null):null==o.constructor&&o.__b>0?m(o.type,o.props,o.key,o.ref?o.ref:null,o.__v):o).__=n,o.__b=n.__b+1,e=null,-1!=(c=o.__i=L(o,u,f,a))&&(a--,(e=u[c])&&(e.__u|=2)),null==e||null==e.__v?(-1==c&&(i>s?h--:i<s&&h++),"function"!=typeof o.type&&(o.__u|=4)):c!=f&&(c==f-1?h--:c==f+1?h++:(c>f?h--:h++,o.__u|=4))):n.__k[r]=null;if(a)for(r=0;r<s;r++)null!=(e=u[r])&&0==(2&e.__u)&&(e.__e==t&&(t=S(e)),B(e,e));return t}function A(n,l,u){var t,i;if("function"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=A(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=S(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling;}while(null!=l&&8==l.nodeType);return l}function L(n,l,u,t){var i,r,o=n.key,e=n.type,f=l[u];if(null===f&&null==n.key||f&&o==f.key&&e==f.type&&0==(2&f.__u))return u;if(t>(null!=f&&0==(2&f.__u)?1:0))for(i=u-1,r=u+1;i>=0||r<l.length;){if(i>=0){if((f=l[i])&&0==(2&f.__u)&&o==f.key&&e==f.type)return i;i--;}if(r<l.length){if((f=l[r])&&0==(2&f.__u)&&o==f.key&&e==f.type)return r;r++;}}return  -1}function T(n,l,u){"-"==l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||y.test(l)?u:u+"px";}function j(n,l,u,t,i){var r,o;n:if("style"==l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||T(n.style,l,"");if(u)for(l in u)t&&u[l]==t[l]||T(n.style,l,u[l]);}else if("o"==l[0]&&"n"==l[1])r=l!=(l=l.replace(f,"$1")),o=l.toLowerCase(),l=o in n||"onFocusOut"==l||"onFocusIn"==l?o.slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?t?u.u=t.u:(u.u=c,n.addEventListener(l,r?a:s,r)):n.removeEventListener(l,r?a:s,r);else {if("http://www.w3.org/2000/svg"==i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!=l&&"height"!=l&&"href"!=l&&"list"!=l&&"form"!=l&&"tabIndex"!=l&&"download"!=l&&"rowSpan"!=l&&"colSpan"!=l&&"role"!=l&&"popover"!=l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||false===u&&"-"!=l[4]?n.removeAttribute(l):n.setAttribute(l,"popover"==l&&1==u?"":u));}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=c++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,r,o,e,f,c,s){var a,h,p,v,y,_,m,b,S,C,M,$,P,A,H,L,T,j=u.type;if(null!=u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),o=[f=u.__e=t.__e]),(a=l.__b)&&a(u);n:if("function"==typeof j)try{if(b=u.props,S="prototype"in j&&j.prototype.render,C=(a=j.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?m=(h=u.__c=t.__c).__=h.__E:(S?u.__c=h=new j(b,M):(u.__c=h=new x(b,M),h.constructor=j,h.render=D),C&&C.sub(h),h.props=b,h.state||(h.state={}),h.context=M,h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),S&&null==h.__s&&(h.__s=h.state),S&&null!=j.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,j.getDerivedStateFromProps(b,h.__s))),v=h.props,y=h.state,h.__v=u,p)S&&null==j.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),S&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(S&&null==j.getDerivedStateFromProps&&b!==v&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(b,M),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(b,h.__s,M)||u.__v==t.__v){for(u.__v!=t.__v&&(h.props=b,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.some(function(n){n&&(n.__=u);}),$=0;$<h._sb.length;$++)h.__h.push(h._sb[$]);h._sb=[],h.__h.length&&e.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(b,h.__s,M),S&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(v,y,_);});}if(h.context=M,h.props=b,h.__P=n,h.__e=!1,P=l.__r,A=0,S){for(h.state=h.__s,h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[];}else do{h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++A<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),S&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(v,y)),L=a,null!=a&&a.type===k&&null==a.key&&(L=N(a.props.children)),f=I(n,w(L)?L:[L],u,t,i,r,o,e,f,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&e.push(h),m&&(h.__E=h.__=null);}catch(n){if(u.__v=null,c||null!=o)if(n.then){for(u.__u|=c?160:128;f&&8==f.nodeType&&f.nextSibling;)f=f.nextSibling;o[o.indexOf(f)]=null,u.__e=f;}else for(T=o.length;T--;)g(o[T]);else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t);}else null==o&&u.__v==t.__v?(u.__k=t.__k,u.__e=t.__e):f=u.__e=V(t.__e,u,t,i,r,o,e,c,s);return (a=l.diffed)&&a(u),128&u.__u?void 0:f}function z(n,u,t){for(var i=0;i<t.length;i++)q(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l.__e(n,u.__v);}});}function N(n){return "object"!=typeof n||null==n||n.__b&&n.__b>0?n:w(n)?n.map(N):d({},n)}function V(u,t,i,r,o,e,f,c,s){var a,h,v,y,d,_,m,b=i.props,k=t.props,x=t.type;if("svg"==x?o="http://www.w3.org/2000/svg":"math"==x?o="http://www.w3.org/1998/Math/MathML":o||(o="http://www.w3.org/1999/xhtml"),null!=e)for(a=0;a<e.length;a++)if((d=e[a])&&"setAttribute"in d==!!x&&(x?d.localName==x:3==d.nodeType)){u=d,e[a]=null;break}if(null==u){if(null==x)return document.createTextNode(k);u=document.createElementNS(o,x,k.is&&k),c&&(l.__m&&l.__m(t,e),c=false),e=null;}if(null==x)b===k||c&&u.data==k||(u.data=k);else {if(e=e&&n.call(u.childNodes),b=i.props||p,!c&&null!=e)for(b={},a=0;a<u.attributes.length;a++)b[(d=u.attributes[a]).name]=d.value;for(a in b)if(d=b[a],"children"==a);else if("dangerouslySetInnerHTML"==a)v=d;else if(!(a in k)){if("value"==a&&"defaultValue"in k||"checked"==a&&"defaultChecked"in k)continue;j(u,a,null,d,o);}for(a in k)d=k[a],"children"==a?y=d:"dangerouslySetInnerHTML"==a?h=d:"value"==a?_=d:"checked"==a?m=d:c&&"function"!=typeof d||b[a]===d||j(u,a,d,b[a],o);if(h)c||v&&(h.__html==v.__html||h.__html==u.innerHTML)||(u.innerHTML=h.__html),t.__k=[];else if(v&&(u.innerHTML=""),I("template"==t.type?u.content:u,w(y)?y:[y],t,i,r,"foreignObject"==x?"http://www.w3.org/1999/xhtml":o,e,f,e?e[0]:i.__k&&S(i,0),c,s),null!=e)for(a=e.length;a--;)g(e[a]);c||(a="value","progress"==x&&null==_?u.removeAttribute("value"):null!=_&&(_!==u[a]||"progress"==x&&!_||"option"==x&&_!=b[a])&&j(u,a,_,b[a],o),a="checked",null!=m&&m!=u[a]&&j(u,a,m,b[a],o));}return u}function q(n,u,t){try{if("function"==typeof n){var i="function"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u));}else n.current=u;}catch(n){l.__e(n,t);}}function B(n,u,t){var i,r;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!=n.__e||q(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount();}catch(n){l.__e(n,u);}i.base=i.__P=null;}if(i=n.__k)for(r=0;r<i.length;r++)i[r]&&B(i[r],u,t||"function"!=typeof n.type);t||g(n.__e),n.__c=n.__=n.__e=void 0;}function D(n,l,u){return this.constructor(n,u)}function E(u,t,i){var r,o,e,f;t==document&&(t=document.documentElement),l.__&&l.__(u,t),o=(r="function"=="undefined")?null:t.__k,e=[],f=[],O(t,u=(t).__k=_(k,null,[u]),o||p,p,t.namespaceURI,o?null:t.firstChild?n.call(t.childNodes):null,e,o?o.__e:t.firstChild,r,f),z(e,u,f);}function J(l,u,t){var i,r,o,e,f=d({},l.props);for(o in l.type&&l.type.defaultProps&&(e=l.type.defaultProps),u)"key"==o?i=u[o]:"ref"==o?r=u[o]:f[o]=void 0===u[o]&&null!=e?e[o]:u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),m(l.type,f,i||l.key,r||l.ref,null)}n=v.slice,l={__e:function(n,l,u,t){for(var i,r,o;l=l.__;)if((i=l.__c)&&!i.__)try{if((r=i.constructor)&&null!=r.getDerivedStateFromError&&(i.setState(r.getDerivedStateFromError(n)),o=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),o=i.__d),o)return i.__E=i}catch(l){n=l;}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},x.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!=this.state?this.__s:this.__s=d({},this.state),"function"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this));},x.prototype.forceUpdate=function(n){this.__v&&(this.__e=true,n&&this.__h.push(n),M(this));},x.prototype.render=k,i=[],o="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,e=function(n,l){return n.__v.__b-l.__v.__b},$.__r=0,f=/(PointerCapture)$|Capture$/i,c=0,s=F(false),a=F(true);

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = true,
        o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = true, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  var _reactElement2VNode = function reactElement2VNode(el) {
    // Among other things, react VNodes (and all its children) need to have constructor: undefined attributes in order to be recognised, cloneElement (applied recursively) does the necessary conversion
    if (!(_typeof(el) === 'object')) return el;
    var res = J(el);
    if (res.props) {
      var _res$props;
      res.props = _objectSpread2({}, res.props);
      if (res !== null && res !== void 0 && (_res$props = res.props) !== null && _res$props !== void 0 && _res$props.children) {
        res.props.children = Array.isArray(res.props.children) ? res.props.children.map(_reactElement2VNode) : _reactElement2VNode(res.props.children);
      }
    }
    return res;
  };
  var isReactRenderable = function isReactRenderable(o) {
    return t(J(o));
  };
  var render = function render(jsx, domEl) {
    delete domEl.__k; // Wipe traces of previous preact renders
    E(_reactElement2VNode(jsx), domEl);
  };

  function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (typeof document === 'undefined') {
      return;
    }
    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';
    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = ".float-tooltip-kap {\n  position: absolute;\n  width: max-content; /* prevent shrinking near right edge */\n  max-width: max(50%, 150px);\n  padding: 3px 5px;\n  border-radius: 3px;\n  font: 12px sans-serif;\n  color: #eee;\n  background: rgba(0,0,0,0.6);\n  pointer-events: none;\n}\n";
  styleInject(css_248z);

  var index = index$1({
    props: {
      content: {
        "default": false
      },
      offsetX: {
        triggerUpdate: false
      },
      // null or number
      offsetY: {
        triggerUpdate: false
      } // null or number
    },
    init: function init(domNode, state) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$style = _ref.style,
        style = _ref$style === void 0 ? {} : _ref$style;
      var isD3Selection = !!domNode && _typeof(domNode) === 'object' && !!domNode.node && typeof domNode.node === 'function';
      var el = select(isD3Selection ? domNode.node() : domNode);

      // make sure container is positioned, to provide anchor for tooltip
      el.style('position') === 'static' && el.style('position', 'relative');
      state.tooltipEl = el.append('div').attr('class', 'float-tooltip-kap');
      Object.entries(style).forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          k = _ref3[0],
          v = _ref3[1];
        return state.tooltipEl.style(k, v);
      });
      state.tooltipEl // start off-screen
      .style('left', '-10000px').style('display', 'none');
      var evSuffix = "tooltip-".concat(Math.round(Math.random() * 1e12));
      state.mouseInside = false;
      el.on("mousemove.".concat(evSuffix), function (ev) {
        state.mouseInside = true;
        var mousePos = pointer(ev);
        var domNode = el.node();
        var canvasWidth = domNode.offsetWidth;
        var canvasHeight = domNode.offsetHeight;
        var translate = [state.offsetX === null || state.offsetX === undefined
        // auto: adjust horizontal position to not exceed canvas boundaries
        ? "-".concat(mousePos[0] / canvasWidth * 100, "%") : typeof state.offsetX === 'number' ? "calc(-50% + ".concat(state.offsetX, "px)") : state.offsetX, state.offsetY === null || state.offsetY === undefined
        // auto: flip to above if near bottom
        ? canvasHeight > 130 && canvasHeight - mousePos[1] < 100 ? 'calc(-100% - 6px)' : '21px' : typeof state.offsetY === 'number' ? state.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(state.offsetY), "px)") : "".concat(state.offsetY, "px") : state.offsetY];
        state.tooltipEl.style('left', mousePos[0] + 'px').style('top', mousePos[1] + 'px').style('transform', "translate(".concat(translate.join(','), ")"));
        state.content && state.tooltipEl.style('display', 'inline');
      });
      el.on("mouseover.".concat(evSuffix), function () {
        state.mouseInside = true;
        state.content && state.tooltipEl.style('display', 'inline');
      });
      el.on("mouseout.".concat(evSuffix), function () {
        state.mouseInside = false;
        state.tooltipEl.style('display', 'none');
      });
    },
    update: function update(state) {
      state.tooltipEl.style('display', !!state.content && state.mouseInside ? 'inline' : 'none');
      if (!state.content) {
        state.tooltipEl.text('');
      } else if (state.content instanceof HTMLElement) {
        state.tooltipEl.text(''); // empty it
        state.tooltipEl.append(function () {
          return state.content;
        });
      } else if (typeof state.content === 'string') {
        state.tooltipEl.html(state.content);
      } else if (isReactRenderable(state.content)) {
        state.tooltipEl.text(''); // empty it
        render(state.content, state.tooltipEl.node());
      } else {
        state.tooltipEl.style('display', 'none');
        console.warn('Tooltip content is invalid, skipping.', state.content, state.content.toString());
      }
    }
  });

  var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
  : {
    WebGLRenderer: three$1.WebGLRenderer,
    Scene: three$1.Scene,
    PerspectiveCamera: three$1.PerspectiveCamera,
    Raycaster: three$1.Raycaster,
    SRGBColorSpace: three$1.SRGBColorSpace,
    TextureLoader: three$1.TextureLoader,
    Vector2: three$1.Vector2,
    Vector3: three$1.Vector3,
    Box3: three$1.Box3,
    Color: three$1.Color,
    Mesh: three$1.Mesh,
    SphereGeometry: three$1.SphereGeometry,
    MeshBasicMaterial: three$1.MeshBasicMaterial,
    BackSide: three$1.BackSide,
    Clock: three$1.Clock
  };
  var threeRenderObjects = index$1({
    props: {
      width: {
        "default": window.innerWidth,
        onChange: function onChange(width, state, prevWidth) {
          isNaN(width) && (state.width = prevWidth);
        }
      },
      height: {
        "default": window.innerHeight,
        onChange: function onChange(height, state, prevHeight) {
          isNaN(height) && (state.height = prevHeight);
        }
      },
      viewOffset: {
        "default": [0, 0]
      },
      backgroundColor: {
        "default": '#000011'
      },
      backgroundImageUrl: {},
      onBackgroundImageLoaded: {},
      showNavInfo: {
        "default": true
      },
      skyRadius: {
        "default": 50000
      },
      objects: {
        "default": []
      },
      lights: {
        "default": []
      },
      enablePointerInteraction: {
        "default": true,
        onChange: function onChange(_, state) {
          // Reset hover state
          state.hoverObj = null;
          state.tooltip && state.tooltip.content(null);
        },
        triggerUpdate: false
      },
      pointerRaycasterThrottleMs: {
        "default": 50,
        triggerUpdate: false
      },
      lineHoverPrecision: {
        "default": 1,
        triggerUpdate: false
      },
      pointsHoverPrecision: {
        "default": 1,
        triggerUpdate: false
      },
      hoverOrderComparator: {
        triggerUpdate: false
      },
      // keep existing order by default
      hoverFilter: {
        "default": function _default() {
          return true;
        },
        triggerUpdate: false
      },
      // exclude objects from interaction
      tooltipContent: {
        triggerUpdate: false
      },
      hoverDuringDrag: {
        "default": false,
        triggerUpdate: false
      },
      clickAfterDrag: {
        "default": false,
        triggerUpdate: false
      },
      onHover: {
        "default": function _default() {},
        triggerUpdate: false
      },
      onClick: {
        "default": function _default() {},
        triggerUpdate: false
      },
      onRightClick: {
        triggerUpdate: false
      }
    },
    methods: {
      tick: function tick(state) {
        if (state.initialised) {
          state.controls.enabled && state.controls.update && state.controls.update(Math.min(1, state.clock.getDelta())); // timedelta is required for fly controls

          state.postProcessingComposer ? state.postProcessingComposer.render() // if using postprocessing, switch the output to it
          : state.renderer.render(state.scene, state.camera);
          state.extraRenderers.forEach(function (r) {
            return r.render(state.scene, state.camera);
          });
          var now = +new Date();
          if (state.enablePointerInteraction && now - state.lastRaycasterCheck >= state.pointerRaycasterThrottleMs) {
            state.lastRaycasterCheck = now;
            // Update tooltip and trigger onHover events
            var topObject = null;
            if (state.hoverDuringDrag || !state.isPointerDragging) {
              var intersects = this.intersectingObjects(state.pointerPos.x, state.pointerPos.y);
              state.hoverOrderComparator && intersects.sort(function (a, b) {
                return state.hoverOrderComparator(a.object, b.object);
              });
              var topIntersect = intersects.find(function (d) {
                return state.hoverFilter(d.object);
              }) || null;
              topObject = topIntersect ? topIntersect.object : null;
              state.intersection = topIntersect || null;
            }
            if (topObject !== state.hoverObj) {
              state.onHover(topObject, state.hoverObj, state.intersection);
              state.tooltip.content(topObject ? index$2(state.tooltipContent)(topObject, state.intersection) || null : null);
              state.hoverObj = topObject;
            }
          }
          state.tweenGroup.update(); // update camera animation tweens
        }
        return this;
      },
      getPointerPos: function getPointerPos(state) {
        var _state$pointerPos = state.pointerPos,
          x = _state$pointerPos.x,
          y = _state$pointerPos.y;
        return {
          x: x,
          y: y
        };
      },
      cameraPosition: function cameraPosition(state, position, lookAt, transitionDuration) {
        var camera = state.camera;

        // Setter
        if (position && state.initialised) {
          var finalPos = position;
          var finalLookAt = lookAt || {
            x: 0,
            y: 0,
            z: 0
          };
          if (!transitionDuration) {
            // no animation
            setCameraPos(finalPos);
            setLookAt(finalLookAt);
          } else {
            var camPos = Object.assign({}, camera.position);
            var camLookAt = getLookAt();
            state.tweenGroup.add(new Tween(camPos).to(finalPos, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCameraPos).start());

            // Face direction in 1/3rd of time
            state.tweenGroup.add(new Tween(camLookAt).to(finalLookAt, transitionDuration / 3).easing(Easing.Quadratic.Out).onUpdate(setLookAt).start());
          }
          return this;
        }

        // Getter
        return Object.assign({}, camera.position, {
          lookAt: getLookAt()
        });

        //

        function setCameraPos(pos) {
          var x = pos.x,
            y = pos.y,
            z = pos.z;
          if (x !== undefined) camera.position.x = x;
          if (y !== undefined) camera.position.y = y;
          if (z !== undefined) camera.position.z = z;
        }
        function setLookAt(lookAt) {
          var lookAtVect = new three.Vector3(lookAt.x, lookAt.y, lookAt.z);
          if (state.controls.enabled && state.controls.target) {
            state.controls.target = lookAtVect;
          } else {
            // Fly controls doesn't have target attribute
            camera.lookAt(lookAtVect); // note: lookAt may be overridden by other controls in some cases
          }
        }
        function getLookAt() {
          return Object.assign(new three.Vector3(0, 0, -1e3).applyQuaternion(camera.quaternion).add(camera.position));
        }
      },
      zoomToFit: function zoomToFit(state) {
        var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
        for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          bboxArgs[_key - 3] = arguments[_key];
        }
        return this.fitToBbox(this.getBbox.apply(this, bboxArgs), transitionDuration, padding);
      },
      fitToBbox: function fitToBbox(state, bbox) {
        var transitionDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
        // based on https://discourse.threejs.org/t/camera-zoom-to-fit-object/936/24
        var camera = state.camera;
        if (bbox) {
          var center = new three.Vector3(0, 0, 0); // reset camera aim to center
          var maxBoxSide = Math.max.apply(Math, _toConsumableArray(Object.entries(bbox).map(function (_ref) {
            var _ref2 = _slicedToArray$2(_ref, 2),
              coordType = _ref2[0],
              coords = _ref2[1];
            return Math.max.apply(Math, _toConsumableArray(coords.map(function (c) {
              return Math.abs(center[coordType] - c);
            })));
          }))) * 2;

          // find distance that fits whole bbox within padded fov
          var paddedFov = (1 - padding * 2 / state.height) * camera.fov;
          var fitHeightDistance = maxBoxSide / Math.atan(paddedFov * Math.PI / 180);
          var fitWidthDistance = fitHeightDistance / camera.aspect;
          var distance = Math.max(fitHeightDistance, fitWidthDistance);
          if (distance > 0) {
            var newCameraPosition = center.clone().sub(camera.position).normalize().multiplyScalar(-distance);
            this.cameraPosition(newCameraPosition, center, transitionDuration);
          }
        }
        return this;
      },
      getBbox: function getBbox(state) {
        var objFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
          return true;
        };
        var box = new three.Box3(new three.Vector3(0, 0, 0), new three.Vector3(0, 0, 0));
        var objs = state.objects.filter(objFilter);
        if (!objs.length) return null;
        objs.forEach(function (obj) {
          return box.expandByObject(obj);
        });

        // extract global x,y,z min/max
        return Object.assign.apply(Object, _toConsumableArray(['x', 'y', 'z'].map(function (c) {
          return _defineProperty$1({}, c, [box.min[c], box.max[c]]);
        })));
      },
      getScreenCoords: function getScreenCoords(state, x, y, z) {
        var vec = new three.Vector3(x, y, z);
        vec.project(this.camera()); // project to the camera plane
        return {
          // align relative pos to canvas dimensions
          x: (vec.x + 1) * state.width / 2,
          y: -(vec.y - 1) * state.height / 2
        };
      },
      getSceneCoords: function getSceneCoords(state, screenX, screenY) {
        var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var relCoords = new three.Vector2(screenX / state.width * 2 - 1, -(screenY / state.height) * 2 + 1);
        var raycaster = new three.Raycaster();
        raycaster.setFromCamera(relCoords, state.camera);
        return Object.assign({}, raycaster.ray.at(distance, new three.Vector3()));
      },
      intersectingObjects: function intersectingObjects(state, x, y) {
        var relCoords = new three.Vector2(x / state.width * 2 - 1, -(y / state.height) * 2 + 1);
        var raycaster = new three.Raycaster();
        raycaster.params.Line.threshold = state.lineHoverPrecision; // set linePrecision
        raycaster.params.Points.threshold = state.pointsHoverPrecision; // set pointsPrecision
        raycaster.setFromCamera(relCoords, state.camera);
        return raycaster.intersectObjects(state.objects, true);
      },
      renderer: function renderer(state) {
        return state.renderer;
      },
      scene: function scene(state) {
        return state.scene;
      },
      camera: function camera(state) {
        return state.camera;
      },
      postProcessingComposer: function postProcessingComposer(state) {
        return state.postProcessingComposer;
      },
      controls: function controls(state) {
        return state.controls;
      },
      tbControls: function tbControls(state) {
        return state.controls;
      } // to be deprecated
    },
    stateInit: function stateInit() {
      return {
        scene: new three.Scene(),
        camera: new three.PerspectiveCamera(),
        clock: new three.Clock(),
        tweenGroup: new Group(),
        lastRaycasterCheck: 0
      };
    },
    init: function init(domNode, state) {
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref4$controlType = _ref4.controlType,
        controlType = _ref4$controlType === void 0 ? 'trackball' : _ref4$controlType,
        _ref4$useWebGPU = _ref4.useWebGPU,
        useWebGPU = _ref4$useWebGPU === void 0 ? false : _ref4$useWebGPU,
        _ref4$rendererConfig = _ref4.rendererConfig,
        rendererConfig = _ref4$rendererConfig === void 0 ? {} : _ref4$rendererConfig,
        _ref4$extraRenderers = _ref4.extraRenderers,
        extraRenderers = _ref4$extraRenderers === void 0 ? [] : _ref4$extraRenderers,
        _ref4$waitForLoadComp = _ref4.waitForLoadComplete,
        waitForLoadComplete = _ref4$waitForLoadComp === void 0 ? true : _ref4$waitForLoadComp;
      // Wipe DOM
      domNode.innerHTML = '';

      // Add relative container
      domNode.appendChild(state.container = document.createElement('div'));
      state.container.className = 'scene-container';
      state.container.style.position = 'relative';

      // Add nav info section
      state.container.appendChild(state.navInfo = document.createElement('div'));
      state.navInfo.className = 'scene-nav-info';
      state.navInfo.textContent = {
        orbit: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
        trackball: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
        fly: 'WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw'
      }[controlType] || '';
      state.navInfo.style.display = state.showNavInfo ? null : 'none';

      // Setup tooltip
      state.tooltip = new index(state.container);

      // Capture pointer coords on move or touchstart
      state.pointerPos = new three.Vector2();
      state.pointerPos.x = -2; // Initialize off canvas
      state.pointerPos.y = -2;
      ['pointermove', 'pointerdown'].forEach(function (evType) {
        return state.container.addEventListener(evType, function (ev) {
          // track click state
          evType === 'pointerdown' && (state.isPointerPressed = true);

          // detect point drag
          !state.isPointerDragging && ev.type === 'pointermove' && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we used the isPointerPressed tracker
          && (ev.pointerType === 'mouse' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {
            return Math.abs(m) > 1;
          })) // relax drag trigger sensitivity on non-mouse (touch/pen) events
          && (state.isPointerDragging = true);
          if (state.enablePointerInteraction) {
            // update the pointer pos
            var offset = getOffset(state.container);
            state.pointerPos.x = ev.pageX - offset.left;
            state.pointerPos.y = ev.pageY - offset.top;
          }
          function getOffset(el) {
            var rect = el.getBoundingClientRect(),
              scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
              scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            return {
              top: rect.top + scrollTop,
              left: rect.left + scrollLeft
            };
          }
        }, {
          passive: true
        });
      });

      // Handle click events on objs
      state.container.addEventListener('pointerup', function (ev) {
        if (!state.isPointerPressed) return; // don't trigger click events if pointer is not pressed on the canvas

        state.isPointerPressed = false;
        if (state.isPointerDragging) {
          state.isPointerDragging = false;
          if (!state.clickAfterDrag) return; // don't trigger onClick after pointer drag (camera motion via controls)
        }
        requestAnimationFrame(function () {
          // trigger click events asynchronously, to allow hoverObj to be set (on frame)
          if (ev.button === 0) {
            // left-click
            state.onClick(state.hoverObj || null, ev, state.intersection); // trigger background clicks with null
          }
          if (ev.button === 2 && state.onRightClick) {
            // right-click
            state.onRightClick(state.hoverObj || null, ev, state.intersection);
          }
        });
      }, {
        passive: true,
        capture: true
      }); // use capture phase to prevent propagation blocking from controls (specifically for fly)

      state.container.addEventListener('contextmenu', function (ev) {
        if (state.onRightClick) ev.preventDefault(); // prevent default contextmenu behavior and allow pointerup to fire instead
      });

      // Setup renderer, camera and controls
      state.renderer = new (useWebGPU ? WebGPURenderer : three.WebGLRenderer)(Object.assign({
        antialias: true,
        alpha: true
      }, rendererConfig));
      state.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)); // clamp device pixel ratio
      state.container.appendChild(state.renderer.domElement);

      // Setup extra renderers
      state.extraRenderers = extraRenderers;
      state.extraRenderers.forEach(function (r) {
        // overlay them on top of main renderer
        r.domElement.style.position = 'absolute';
        r.domElement.style.top = '0px';
        r.domElement.style.pointerEvents = 'none';
        state.container.appendChild(r.domElement);
      });

      // configure post-processing composer
      state.postProcessingComposer = new EffectComposer(state.renderer);
      state.postProcessingComposer.addPass(new RenderPass(state.scene, state.camera)); // render scene as first pass

      // configure controls
      state.controls = new {
        trackball: TrackballControls,
        orbit: OrbitControls,
        fly: FlyControls
      }[controlType](state.camera, state.renderer.domElement);
      if (controlType === 'fly') {
        state.controls.movementSpeed = 300;
        state.controls.rollSpeed = Math.PI / 6;
        state.controls.dragToLook = true;
      }
      if (controlType === 'trackball' || controlType === 'orbit') {
        state.controls.minDistance = 0.1;
        state.controls.maxDistance = state.skyRadius;
        state.controls.addEventListener('start', function () {
          state.controlsEngaged = true;
        });
        state.controls.addEventListener('change', function () {
          if (state.controlsEngaged) {
            state.controlsDragging = true;
          }
        });
        state.controls.addEventListener('end', function () {
          state.controlsEngaged = false;
          state.controlsDragging = false;
        });
      }
      [state.renderer, state.postProcessingComposer].concat(_toConsumableArray(state.extraRenderers)).forEach(function (r) {
        return r.setSize(state.width, state.height);
      });
      state.camera.aspect = state.width / state.height;
      state.camera.updateProjectionMatrix();
      state.camera.position.z = 1000;

      // add sky
      state.scene.add(state.skysphere = new three.Mesh());
      state.skysphere.visible = false;
      state.loadComplete = state.scene.visible = !waitForLoadComplete;
      window.scene = state.scene;
    },
    update: function update(state, changedProps) {
      // resize canvas
      if (state.width && state.height && (changedProps.hasOwnProperty('width') || changedProps.hasOwnProperty('height'))) {
        var _state$camera;
        var w = state.width;
        var h = state.height;
        state.container.style.width = "".concat(w, "px");
        state.container.style.height = "".concat(h, "px");
        [state.renderer, state.postProcessingComposer].concat(_toConsumableArray(state.extraRenderers)).forEach(function (r) {
          return r.setSize(w, h);
        });
        state.camera.aspect = w / h;
        var o = state.viewOffset.slice(0, 2);
        o.some(function (n) {
          return n;
        }) && (_state$camera = state.camera).setViewOffset.apply(_state$camera, [w, h].concat(_toConsumableArray(o), [w, h]));
        state.camera.updateProjectionMatrix();
      }
      if (changedProps.hasOwnProperty('viewOffset')) {
        var _state$camera2;
        var _w = state.width;
        var _h = state.height;
        var _o = state.viewOffset.slice(0, 2);
        _o.some(function (n) {
          return n;
        }) ? (_state$camera2 = state.camera).setViewOffset.apply(_state$camera2, [_w, _h].concat(_toConsumableArray(_o), [_w, _h])) : state.camera.clearViewOffset();
      }
      if (changedProps.hasOwnProperty('skyRadius') && state.skyRadius) {
        state.controls.hasOwnProperty('maxDistance') && changedProps.skyRadius && (state.controls.maxDistance = Math.min(state.controls.maxDistance, state.skyRadius));
        state.camera.far = state.skyRadius * 2.5;
        state.camera.updateProjectionMatrix();
        state.skysphere.geometry = new three.SphereGeometry(state.skyRadius);
      }
      if (changedProps.hasOwnProperty('backgroundColor')) {
        var alpha = parseToRgb(state.backgroundColor).alpha;
        if (alpha === undefined) alpha = 1;
        state.renderer.setClearColor(new three.Color(curriedOpacify$1(1, state.backgroundColor)), alpha);
      }
      if (changedProps.hasOwnProperty('backgroundImageUrl')) {
        if (!state.backgroundImageUrl) {
          state.skysphere.visible = false;
          state.skysphere.material.map = null;
          !state.loadComplete && finishLoad();
        } else {
          new three.TextureLoader().load(state.backgroundImageUrl, function (texture) {
            texture.colorSpace = three.SRGBColorSpace;
            state.skysphere.material = new three.MeshBasicMaterial({
              map: texture,
              side: three.BackSide
            });
            state.skysphere.visible = true;

            // triggered when background image finishes loading (asynchronously to allow 1 frame to load texture)
            state.onBackgroundImageLoaded && setTimeout(state.onBackgroundImageLoaded);
            !state.loadComplete && finishLoad();
          });
        }
      }
      changedProps.hasOwnProperty('showNavInfo') && (state.navInfo.style.display = state.showNavInfo ? null : 'none');
      if (changedProps.hasOwnProperty('lights')) {
        (changedProps.lights || []).forEach(function (light) {
          return state.scene.remove(light);
        }); // Clear the place
        state.lights.forEach(function (light) {
          return state.scene.add(light);
        }); // Add to scene
      }
      if (changedProps.hasOwnProperty('objects')) {
        (changedProps.objects || []).forEach(function (obj) {
          return state.scene.remove(obj);
        }); // Clear the place
        state.objects.forEach(function (obj) {
          return state.scene.add(obj);
        }); // Add to scene
      }

      //

      function finishLoad() {
        state.loadComplete = state.scene.visible = true;
      }
    }
  });

  return threeRenderObjects;

}));
//# sourceMappingURL=three-render-objects.js.map
