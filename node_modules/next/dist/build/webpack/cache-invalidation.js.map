{"version":3,"sources":["../../../src/build/webpack/cache-invalidation.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\n\nconst INVALIDATION_MARKER = '__nextjs_invalidated_cache'\n\n/**\n * Atomically write an invalidation marker.\n *\n * Because attempting to delete currently open cache files could cause issues,\n * actual deletion of files is deferred until the next start-up (in\n * `checkPersistentCacheInvalidationAndCleanup`).\n *\n * In the case that no database is currently open (e.g. via a separate CLI\n * subcommand), you should call `cleanupPersistentCache` *after* this to eagerly\n * remove the cache files.\n */\nexport async function invalidatePersistentCache(cacheDirectory: string) {\n  let file\n  try {\n    // We're just opening it so that `open()` creates the file.\n    file = await fs.open(path.join(cacheDirectory, INVALIDATION_MARKER), 'w')\n    // We don't currently write anything to the file, but we could choose to\n    // later, e.g. a reason for the invalidation.\n  } catch (err: any) {\n    // it's valid for the cache to not exist at all\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n  } finally {\n    file?.close()\n  }\n}\n\n/**\n * Called during startup. See if the cache is in a partially-completed\n * invalidation state. Finds and delete any invalidated cache files.\n */\nexport async function checkPersistentCacheInvalidationAndCleanup(\n  cacheDirectory: string\n) {\n  const invalidated = await fs\n    .access(path.join(cacheDirectory, INVALIDATION_MARKER))\n    .then(\n      () => true,\n      () => false\n    )\n  if (invalidated) {\n    await cleanupPersistentCache(cacheDirectory)\n  }\n}\n\n/**\n * Helper for `checkPersistentCacheInvalidationAndCleanup`. You can call this to\n * explicitly clean up a database after running `invalidatePersistentCache` when\n * webpack is not running.\n *\n * You should not run this if the cache has not yet been invalidated, as this\n * operation is not atomic and could result in a partially-deleted and corrupted\n * database.\n */\nasync function cleanupPersistentCache(cacheDirectory: string) {\n  try {\n    await cleanupPersistentCacheInner(cacheDirectory)\n  } catch (e) {\n    // generate a user-friendly error message\n    throw new Error(\n      `Unable to remove an invalidated webpack cache. If this issue persists ` +\n        `you can work around it by deleting ${cacheDirectory}`,\n      { cause: e }\n    )\n  }\n}\n\nasync function cleanupPersistentCacheInner(cacheDirectory: string) {\n  const files = await fs.readdir(cacheDirectory)\n\n  // delete everything except the invalidation marker\n  await Promise.all(\n    files.map((name) =>\n      name !== INVALIDATION_MARKER\n        ? fs.rm(path.join(cacheDirectory, name), {\n            force: true, // ignore errors if path does not exist\n            recursive: true,\n            maxRetries: 2, // windows prevents deletion of open files\n          })\n        : null\n    )\n  )\n\n  // delete the invalidation marker last, once we're sure everything is cleaned\n  // up\n  await fs.rm(path.join(cacheDirectory, INVALIDATION_MARKER), {\n    force: true,\n    maxRetries: 2,\n  })\n}\n"],"names":["checkPersistentCacheInvalidationAndCleanup","invalidatePersistentCache","INVALIDATION_MARKER","cacheDirectory","file","fs","open","path","join","err","code","close","invalidated","access","then","cleanupPersistentCache","cleanupPersistentCacheInner","e","Error","cause","files","readdir","Promise","all","map","name","rm","force","recursive","maxRetries"],"mappings":";;;;;;;;;;;;;;;IAqCsBA,0CAA0C;eAA1CA;;IArBAC,yBAAyB;eAAzBA;;;iEAhBP;iEACE;;;;;;AAEjB,MAAMC,sBAAsB;AAarB,eAAeD,0BAA0BE,cAAsB;IACpE,IAAIC;IACJ,IAAI;QACF,2DAA2D;QAC3DA,OAAO,MAAMC,iBAAE,CAACC,IAAI,CAACC,iBAAI,CAACC,IAAI,CAACL,gBAAgBD,sBAAsB;IACrE,wEAAwE;IACxE,6CAA6C;IAC/C,EAAE,OAAOO,KAAU;QACjB,+CAA+C;QAC/C,IAAIA,IAAIC,IAAI,KAAK,UAAU;YACzB,MAAMD;QACR;IACF,SAAU;QACRL,wBAAAA,KAAMO,KAAK;IACb;AACF;AAMO,eAAeX,2CACpBG,cAAsB;IAEtB,MAAMS,cAAc,MAAMP,iBAAE,CACzBQ,MAAM,CAACN,iBAAI,CAACC,IAAI,CAACL,gBAAgBD,sBACjCY,IAAI,CACH,IAAM,MACN,IAAM;IAEV,IAAIF,aAAa;QACf,MAAMG,uBAAuBZ;IAC/B;AACF;AAEA;;;;;;;;CAQC,GACD,eAAeY,uBAAuBZ,cAAsB;IAC1D,IAAI;QACF,MAAMa,4BAA4Bb;IACpC,EAAE,OAAOc,GAAG;QACV,yCAAyC;QACzC,MAAM,qBAIL,CAJK,IAAIC,MACR,CAAC,sEAAsE,CAAC,GACtE,CAAC,mCAAmC,EAAEf,gBAAgB,EACxD;YAAEgB,OAAOF;QAAE,IAHP,qBAAA;mBAAA;wBAAA;0BAAA;QAIN;IACF;AACF;AAEA,eAAeD,4BAA4Bb,cAAsB;IAC/D,MAAMiB,QAAQ,MAAMf,iBAAE,CAACgB,OAAO,CAAClB;IAE/B,mDAAmD;IACnD,MAAMmB,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,CAACC,OACTA,SAASvB,sBACLG,iBAAE,CAACqB,EAAE,CAACnB,iBAAI,CAACC,IAAI,CAACL,gBAAgBsB,OAAO;YACrCE,OAAO;YACPC,WAAW;YACXC,YAAY;QACd,KACA;IAIR,6EAA6E;IAC7E,KAAK;IACL,MAAMxB,iBAAE,CAACqB,EAAE,CAACnB,iBAAI,CAACC,IAAI,CAACL,gBAAgBD,sBAAsB;QAC1DyB,OAAO;QACPE,YAAY;IACd;AACF","ignoreList":[0]}