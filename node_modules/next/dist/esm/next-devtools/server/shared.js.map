{"version":3,"sources":["../../../src/next-devtools/server/shared.ts"],"sourcesContent":["import type { StackFrame } from 'stacktrace-parser'\nimport { codeFrameColumns } from 'next/dist/compiled/babel/code-frame'\nimport isInternal from '../../shared/lib/is-internal'\nimport { ignoreListAnonymousStackFramesIfSandwiched as ignoreListAnonymousStackFramesIfSandwichedGeneric } from '../../server/lib/source-maps'\n\nexport interface OriginalStackFramesRequest {\n  frames: StackFrame[]\n  isServer: boolean\n  isEdgeServer: boolean\n  isAppDirectory: boolean\n}\n\nexport type OriginalStackFramesResponse = OriginalStackFrameResponseResult[]\n\nexport type OriginalStackFrameResponseResult =\n  PromiseSettledResult<OriginalStackFrameResponse>\n\nexport interface OriginalStackFrameResponse {\n  originalStackFrame: (StackFrame & { ignored: boolean }) | null\n  originalCodeFrame: string | null\n}\n\nexport function ignoreListAnonymousStackFramesIfSandwiched(\n  responses: OriginalStackFramesResponse\n): void {\n  ignoreListAnonymousStackFramesIfSandwichedGeneric(\n    responses,\n    (response) => {\n      return (\n        response.status === 'fulfilled' &&\n        response.value.originalStackFrame !== null &&\n        response.value.originalStackFrame.file === '<anonymous>'\n      )\n    },\n    (response) => {\n      return (\n        response.status === 'fulfilled' &&\n        response.value.originalStackFrame !== null &&\n        response.value.originalStackFrame.ignored === true\n      )\n    },\n    (response) => {\n      return response.status === 'fulfilled' &&\n        response.value.originalStackFrame !== null\n        ? response.value.originalStackFrame.methodName\n        : ''\n    },\n    (response) => {\n      ;(\n        response as PromiseFulfilledResult<OriginalStackFrameResponse>\n      ).value.originalStackFrame!.ignored = true\n    }\n  )\n}\n\n/**\n * It looks up the code frame of the traced source.\n * @note It ignores Next.js/React internals, as these can often be huge bundled files.\n */\nexport function getOriginalCodeFrame(\n  frame: StackFrame,\n  source: string | null,\n  colors: boolean = process.stdout.isTTY\n): string | null {\n  if (!source || isInternal(frame.file)) {\n    return null\n  }\n\n  return codeFrameColumns(\n    source,\n    {\n      start: {\n        // 1-based, but -1 means start line without highlighting\n        line: frame.lineNumber ?? -1,\n        // 1-based, but 0 means whole line without column highlighting\n        column: frame.column ?? 0,\n      },\n    },\n    { forceColor: colors }\n  )\n}\n"],"names":["codeFrameColumns","isInternal","ignoreListAnonymousStackFramesIfSandwiched","ignoreListAnonymousStackFramesIfSandwichedGeneric","responses","response","status","value","originalStackFrame","file","ignored","methodName","getOriginalCodeFrame","frame","source","colors","process","stdout","isTTY","start","line","lineNumber","column","forceColor"],"mappings":"AACA,SAASA,gBAAgB,QAAQ,sCAAqC;AACtE,OAAOC,gBAAgB,+BAA8B;AACrD,SAASC,8CAA8CC,iDAAiD,QAAQ,+BAA8B;AAmB9I,OAAO,SAASD,2CACdE,SAAsC;IAEtCD,kDACEC,WACA,CAACC;QACC,OACEA,SAASC,MAAM,KAAK,eACpBD,SAASE,KAAK,CAACC,kBAAkB,KAAK,QACtCH,SAASE,KAAK,CAACC,kBAAkB,CAACC,IAAI,KAAK;IAE/C,GACA,CAACJ;QACC,OACEA,SAASC,MAAM,KAAK,eACpBD,SAASE,KAAK,CAACC,kBAAkB,KAAK,QACtCH,SAASE,KAAK,CAACC,kBAAkB,CAACE,OAAO,KAAK;IAElD,GACA,CAACL;QACC,OAAOA,SAASC,MAAM,KAAK,eACzBD,SAASE,KAAK,CAACC,kBAAkB,KAAK,OACpCH,SAASE,KAAK,CAACC,kBAAkB,CAACG,UAAU,GAC5C;IACN,GACA,CAACN;;QAEGA,SACAE,KAAK,CAACC,kBAAkB,CAAEE,OAAO,GAAG;IACxC;AAEJ;AAEA;;;CAGC,GACD,OAAO,SAASE,qBACdC,KAAiB,EACjBC,MAAqB,EACrBC,MAAsC;IAAtCA,IAAAA,mBAAAA,SAAkBC,QAAQC,MAAM,CAACC,KAAK;IAEtC,IAAI,CAACJ,UAAUb,WAAWY,MAAMJ,IAAI,GAAG;QACrC,OAAO;IACT;QAOYI,mBAEEA;IAPd,OAAOb,iBACLc,QACA;QACEK,OAAO;YACL,wDAAwD;YACxDC,MAAMP,CAAAA,oBAAAA,MAAMQ,UAAU,YAAhBR,oBAAoB,CAAC;YAC3B,8DAA8D;YAC9DS,QAAQT,CAAAA,gBAAAA,MAAMS,MAAM,YAAZT,gBAAgB;QAC1B;IACF,GACA;QAAEU,YAAYR;IAAO;AAEzB","ignoreList":[0]}