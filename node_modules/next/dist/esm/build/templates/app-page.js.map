{"version":3,"sources":["../../../src/build/templates/app-page.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport {\n  AppPageRouteModule,\n  type AppPageRouteHandlerContext,\n} from '../../server/route-modules/app-page/module.compiled' with { 'turbopack-transition': 'next-ssr' }\n\nimport { RouteKind } from '../../server/route-kind' with { 'turbopack-transition': 'next-server-utility' }\n\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\nimport { getRequestMeta } from '../../server/request-meta'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { interopDefault } from '../../server/app-render/interop-default'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\nimport {\n  getFallbackRouteParams,\n  type FallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport {\n  isHtmlBotRequest,\n  shouldServeStreamingMetadata,\n} from '../../server/lib/streaming-metadata'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n} from '../../client/components/app-router-headers'\nimport { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\nimport {\n  CachedRouteKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\nimport { FallbackMode, parseFallbackField } from '../../lib/fallback'\nimport RenderResult from '../../server/render-result'\nimport { CACHE_ONE_YEAR, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport type { CacheControl } from '../../server/lib/cache-control'\nimport { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\nimport { sendRenderResult } from '../../server/send-payload'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n\n// These are injected by the loader afterwards.\n\n/**\n * The tree created in next-app-loader that holds component segments and modules\n * and I've updated it.\n */\ndeclare const tree: LoaderTree\ndeclare const pages: any\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\n// INJECT:tree\n// INJECT:pages\n\nexport { tree, pages }\n\nimport GlobalError from 'VAR_MODULE_GLOBAL_ERROR' with { 'turbopack-transition': 'next-server-utility' }\n\nexport { GlobalError }\n\n// These are injected by the loader afterwards.\ndeclare const __next_app_require__: (id: string | number) => unknown\ndeclare const __next_app_load_chunk__: (id: string | number) => Promise<unknown>\n\n// INJECT:__next_app_require__\n// INJECT:__next_app_load_chunk__\n\nexport const __next_app__ = {\n  require: __next_app_require__,\n  loadChunk: __next_app_load_chunk__,\n}\n\nimport * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\n\nexport * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n  definition: {\n    kind: RouteKind.APP_PAGE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n    appPaths: [],\n  },\n  userland: {\n    loaderTree: tree,\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const initialPostponed = getRequestMeta(req, 'postponed')\n  // TODO: replace with more specific flags\n  const minimalMode = getRequestMeta(req, 'minimalMode')\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    query,\n    params,\n    parsedUrl,\n    pageIsDynamic,\n    buildManifest,\n    nextFontManifest,\n    reactLoadableManifest,\n    serverActionsManifest,\n    clientReferenceManifest,\n    subresourceIntegrityManifest,\n    prerenderManifest,\n    isDraftMode,\n    resolvedPathname,\n    revalidateOnlyGenerated,\n    routerServerContext,\n    nextConfig,\n  } = prepareResult\n\n  const pathname = parsedUrl.pathname || '/'\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let { isOnDemandRevalidate } = prepareResult\n\n  const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n  const isPrerendered = prerenderManifest.routes[resolvedPathname]\n\n  let isSSG = Boolean(\n    prerenderInfo ||\n      isPrerendered ||\n      prerenderManifest.routes[normalizedSrcPage]\n  )\n\n  const userAgent = req.headers['user-agent'] || ''\n  const botType = getBotType(userAgent)\n  const isHtmlBot = isHtmlBotRequest(req)\n\n  /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */\n  const isPrefetchRSCRequest =\n    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n    Boolean(req.headers[NEXT_ROUTER_PREFETCH_HEADER])\n\n  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n  const isRSCRequest =\n    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n\n  const isPossibleServerAction = getIsPossibleServerAction(req)\n\n  /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */\n  const couldSupportPPR: boolean = checkIsAppPPREnabled(\n    nextConfig.experimental.ppr\n  )\n\n  // When enabled, this will allow the use of the `?__nextppronly` query to\n  // enable debugging of the static shell.\n  const hasDebugStaticShellQuery =\n    process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n    typeof query.__nextppronly !== 'undefined' &&\n    couldSupportPPR\n\n  // When enabled, this will allow the use of the `?__nextppronly` query\n  // to enable debugging of the fallback shell.\n  const hasDebugFallbackShellQuery =\n    hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n  // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n  // prerender manifest and this is an app page.\n  const isRoutePPREnabled: boolean =\n    couldSupportPPR &&\n    ((\n      prerenderManifest.routes[normalizedSrcPage] ??\n      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n    )?.renderingMode === 'PARTIALLY_STATIC' ||\n      // Ideally we'd want to check the appConfig to see if this page has PPR\n      // enabled or not, but that would require plumbing the appConfig through\n      // to the server during development. We assume that the page supports it\n      // but only during development.\n      (hasDebugStaticShellQuery &&\n        (routeModule.isDev === true ||\n          routerServerContext?.experimentalTestProxy === true)))\n\n  const isDebugStaticShell: boolean =\n    hasDebugStaticShellQuery && isRoutePPREnabled\n\n  // We should enable debugging dynamic accesses when the static shell\n  // debugging has been enabled and we're also in development mode.\n  const isDebugDynamicAccesses =\n    isDebugStaticShell && routeModule.isDev === true\n\n  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n  // If we're in minimal mode, then try to get the postponed information from\n  // the request metadata. If available, use it for resuming the postponed\n  // render.\n  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n\n  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n  // we can use this fact to only generate the flight data for the request\n  // because we can't cache the HTML (as it's also dynamic).\n  const isDynamicRSCRequest =\n    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n  // Need to read this before it's stripped by stripFlightHeaders. We don't\n  // need to transfer it to the request meta because it's only read\n  // within this function; the static segment data should have already been\n  // generated, so we will always either return a static response or a 404.\n  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n  // being true for a revalidate due to modifying the base-server this.renderOpts\n  // when fixing this to correct logic it causes hydration issue since we set\n  // serveStreamingMetadata to true during export\n  let serveStreamingMetadata = !userAgent\n    ? true\n    : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n\n  if (isHtmlBot && isRoutePPREnabled) {\n    isSSG = false\n    serveStreamingMetadata = false\n  }\n\n  // In development, we always want to generate dynamic HTML.\n  let supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG ||\n    // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof initialPostponed === 'string' ||\n    // If this is a dynamic RSC request, then this render supports dynamic\n    // HTML (it's dynamic).\n    isDynamicRSCRequest\n\n  // When html bots request PPR page, perform the full dynamic rendering.\n  const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n\n  let ssgCacheKey: string | null = null\n  if (\n    !isDraftMode &&\n    isSSG &&\n    !supportsDynamicResponse &&\n    !isPossibleServerAction &&\n    !minimalPostponed &&\n    !isDynamicRSCRequest\n  ) {\n    ssgCacheKey = resolvedPathname\n  }\n\n  // the staticPathKey differs from ssgCacheKey since\n  // ssgCacheKey is null in dev since we're always in \"dynamic\"\n  // mode in dev to bypass the cache, but we still need to honor\n  // dynamicParams = false in dev mode\n  let staticPathKey = ssgCacheKey\n  if (!staticPathKey && routeModule.isDev) {\n    staticPathKey = resolvedPathname\n  }\n\n  const ComponentMod = {\n    ...entryBase,\n    tree,\n    pages,\n    GlobalError,\n    handler,\n    routeModule,\n    __next_app__,\n  }\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  try {\n    const invokeRouteModule = async (\n      span: Span | undefined,\n      context: AppPageRouteHandlerContext\n    ) => {\n      const nextReq = new NodeNextRequest(req)\n      const nextRes = new NodeNextResponse(res)\n\n      // TODO: adapt for putting the RDC inside the postponed data\n      // If we're in dev, and this isn't a prefetch or a server action,\n      // we should seed the resume data cache.\n      if (process.env.NODE_ENV === 'development') {\n        if (\n          nextConfig.experimental.dynamicIO &&\n          !isPrefetchRSCRequest &&\n          !context.renderOpts.isPossibleServerAction\n        ) {\n          const warmup = await routeModule.warmup(nextReq, nextRes, context)\n\n          // If the warmup is successful, we should use the resume data\n          // cache from the warmup.\n          if (warmup.metadata.renderResumeDataCache) {\n            context.renderOpts.renderResumeDataCache =\n              warmup.metadata.renderResumeDataCache\n          }\n        }\n      }\n\n      return routeModule.render(nextReq, nextRes, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${req.url}`)\n        }\n      })\n    }\n\n    const doRender = async ({\n      span,\n      postponed,\n      fallbackRouteParams,\n    }: {\n      span?: Span\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: FallbackRouteParams | null\n    }): Promise<ResponseCacheEntry> => {\n      const context: AppPageRouteHandlerContext = {\n        query,\n        params,\n        page: normalizedSrcPage,\n        sharedContext: {\n          buildId,\n        },\n        serverComponentsHmrCache: getRequestMeta(\n          req,\n          'serverComponentsHmrCache'\n        ),\n        fallbackRouteParams,\n        renderOpts: {\n          App: () => null,\n          Document: () => null,\n          pageConfig: {},\n          ComponentMod,\n          Component: interopDefault(ComponentMod),\n\n          params,\n          routeModule,\n          page: srcPage,\n          postponed,\n          shouldWaitOnAllReady,\n          serveStreamingMetadata,\n          supportsDynamicResponse:\n            typeof postponed === 'string' || supportsDynamicResponse,\n          buildManifest,\n          nextFontManifest,\n          reactLoadableManifest,\n          subresourceIntegrityManifest,\n          serverActionsManifest,\n          clientReferenceManifest,\n          setIsrStatus: routerServerContext?.setIsrStatus,\n\n          dir: routeModule.projectDir,\n          isDraftMode,\n          isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n          botType,\n          isOnDemandRevalidate,\n          isPossibleServerAction,\n          assetPrefix: nextConfig.assetPrefix,\n          nextConfigOutput: nextConfig.output,\n          crossOrigin: nextConfig.crossOrigin,\n          trailingSlash: nextConfig.trailingSlash,\n          previewProps: prerenderManifest.preview,\n          deploymentId: nextConfig.deploymentId,\n          enableTainting: nextConfig.experimental.taint,\n          htmlLimitedBots: nextConfig.htmlLimitedBots,\n          devtoolSegmentExplorer:\n            nextConfig.experimental.devtoolSegmentExplorer,\n          reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n\n          multiZoneDraftMode,\n          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n          cacheLifeProfiles: nextConfig.experimental.cacheLife,\n          basePath: nextConfig.basePath,\n          serverActions: nextConfig.experimental.serverActions,\n\n          ...(isDebugStaticShell || isDebugDynamicAccesses\n            ? {\n                nextExport: true,\n                supportsDynamicResponse: false,\n                isStaticGeneration: true,\n                isRevalidate: true,\n                isDebugDynamicAccesses: isDebugDynamicAccesses,\n              }\n            : {}),\n\n          experimental: {\n            isRoutePPREnabled,\n            expireTime: nextConfig.expireTime,\n            staleTimes: nextConfig.experimental.staleTimes,\n            dynamicIO: Boolean(nextConfig.experimental.dynamicIO),\n            clientSegmentCache: Boolean(\n              nextConfig.experimental.clientSegmentCache\n            ),\n            dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n            inlineCss: Boolean(nextConfig.experimental.inlineCss),\n            authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n            clientTraceMetadata:\n              nextConfig.experimental.clientTraceMetadata || ([] as any),\n          },\n\n          waitUntil: ctx.waitUntil,\n          onClose: (cb) => {\n            res.on('close', cb)\n          },\n          onAfterTaskError: () => {},\n\n          onInstrumentationRequestError: (error, _request, errorContext) =>\n            routeModule.onRequestError(\n              req,\n              error,\n              errorContext,\n              routerServerContext\n            ),\n          err: getRequestMeta(req, 'invokeError'),\n          dev: routeModule.isDev,\n        },\n      }\n\n      const result = await invokeRouteModule(span, context)\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = metadata.fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !routeModule.isDev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.APP_PAGE,\n          html: result,\n          headers,\n          rscData: metadata.flightData,\n          postponed: metadata.postponed,\n          status: metadata.statusCode,\n          segmentData: metadata.segmentData,\n        } satisfies CachedAppPageValue,\n        cacheControl,\n      } satisfies ResponseCacheEntry\n    }\n\n    const responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry,\n      isRevalidating,\n      span,\n    }) => {\n      const isProduction = routeModule.isDev === false\n      const didRespond = hasResolved || res.writableEnded\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousCacheEntry &&\n        !minimalMode\n      ) {\n        if (routerServerContext?.render404) {\n          await routerServerContext.render404(req, res)\n        } else {\n          res.statusCode = 404\n          res.end('This page could not be found')\n        }\n        return null\n      }\n\n      let fallbackMode: FallbackMode | undefined\n\n      if (prerenderInfo) {\n        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n      }\n\n      // When serving a bot request, we want to serve a blocking render and not\n      // the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (previousCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (\n        !minimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        staticPathKey &&\n        !didRespond &&\n        !isDraftMode &&\n        pageIsDynamic &&\n        (isProduction || !isPrerendered)\n      ) {\n        // if the page has dynamicParams: false and this pathname wasn't\n        // prerendered trigger the no fallback handling\n        if (\n          // In development, fall through to render to handle missing\n          // getStaticPaths.\n          (isProduction || prerenderInfo) &&\n          // When fallback isn't present, abort this render so we 404\n          fallbackMode === FallbackMode.NOT_FOUND\n        ) {\n          throw new NoFallbackError()\n        }\n\n        let fallbackResponse: ResponseCacheEntry | null | undefined\n\n        if (isRoutePPREnabled && !isRSCRequest) {\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          fallbackResponse = await routeModule.handleResponse({\n            cacheKey: isProduction ? normalizedSrcPage : null,\n            req,\n            nextConfig,\n            routeKind: RouteKind.APP_PAGE,\n            isFallback: true,\n            prerenderManifest,\n            isRoutePPREnabled,\n            responseGenerator: async () =>\n              doRender({\n                span,\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                fallbackRouteParams:\n                  // If we're in production or we're debugging the fallback\n                  // shell then we should postpone when dynamic params are\n                  // accessed.\n                  isProduction || isDebugFallbackShell\n                    ? getFallbackRouteParams(normalizedSrcPage)\n                    : null,\n              }),\n            waitUntil: ctx.waitUntil,\n          })\n\n          // If the fallback response was set to null, then we should return null.\n          if (fallbackResponse === null) return null\n\n          // Otherwise, if we did get a fallback response, we should return it.\n          if (fallbackResponse) {\n            // Remove the cache control from the response to prevent it from being\n            // used in the surrounding cache.\n            delete fallbackResponse.cacheControl\n\n            return fallbackResponse\n          }\n        }\n      }\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      const postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(''),\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      // If this is a dynamic route with PPR enabled and the default route\n      // matches were set, then we should pass the fallback route params to\n      // the renderer as this is a fallback revalidation request.\n      const fallbackRouteParams =\n        pageIsDynamic &&\n        isRoutePPREnabled &&\n        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n          ? getFallbackRouteParams(pathname)\n          : null\n\n      // Perform the render.\n      return doRender({\n        span,\n        postponed,\n        fallbackRouteParams,\n      })\n    }\n\n    const handleResponse = async (span?: Span): Promise<null | void> => {\n      const cacheEntry = await routeModule.handleResponse({\n        cacheKey: ssgCacheKey,\n        responseGenerator: (c) =>\n          responseGenerator({\n            span,\n            ...c,\n          }),\n        routeKind: RouteKind.APP_PAGE,\n        isOnDemandRevalidate,\n        isRoutePPREnabled,\n        req,\n        nextConfig,\n        prerenderManifest,\n        waitUntil: ctx.waitUntil,\n      })\n\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      // In dev, we should not cache pages for any reason.\n      if (routeModule.isDev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n\n      if (!cacheEntry) {\n        if (ssgCacheKey) {\n          // A cache entry might not be generated if a response is written\n          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n          // have a cache key. If we do have a cache key but we don't end up\n          // with a cache entry, then either Next.js or the application has a\n          // bug that needs fixing.\n          throw new Error('invariant: cache entry required but not generated')\n        }\n        return null\n      }\n\n      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n        throw new Error(\n          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n        )\n      }\n\n      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n\n      if (\n        isSSG &&\n        // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest &&\n        (!didPostpone || isPrefetchRSCRequest)\n      ) {\n        if (!minimalMode) {\n          // set x-nextjs-cache header to match the header\n          // we set for the image-optimizer\n          res.setHeader(\n            'x-nextjs-cache',\n            isOnDemandRevalidate\n              ? 'REVALIDATED'\n              : cacheEntry.isMiss\n                ? 'MISS'\n                : cacheEntry.isStale\n                  ? 'STALE'\n                  : 'HIT'\n          )\n        }\n        // Set a header used by the client router to signal the response is static\n        // and should respect the `static` cache staleTime value.\n        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n      }\n      const { value: cachedData } = cacheEntry\n\n      // Coerce the cache control parameter from the render.\n      let cacheControl: CacheControl | undefined\n\n      // If this is a resume request in minimal mode it is streamed with dynamic\n      // content and should not be cached.\n      if (minimalPostponed) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this is in minimal mode and this is a flight request that isn't a\n      // prefetch request while PPR is enabled, it cannot be cached as it contains\n      // dynamic content.\n      else if (\n        minimalMode &&\n        isRSCRequest &&\n        !isPrefetchRSCRequest &&\n        isRoutePPREnabled\n      ) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (!routeModule.isDev) {\n        // If this is a preview mode request, we shouldn't cache it\n        if (isDraftMode) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n\n        // If this isn't SSG, then we should set change the header only if it is\n        // not set already.\n        else if (!isSSG) {\n          if (!res.getHeader('Cache-Control')) {\n            cacheControl = { revalidate: 0, expire: undefined }\n          }\n        } else if (cacheEntry.cacheControl) {\n          // If the cache entry has a cache control with a revalidate value that's\n          // a number, use it.\n          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n            if (cacheEntry.cacheControl.revalidate < 1) {\n              throw new Error(\n                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n              )\n            }\n\n            cacheControl = {\n              revalidate: cacheEntry.cacheControl.revalidate,\n              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n            }\n          }\n          // Otherwise if the revalidate value is false, then we should use the\n          // cache time of one year.\n          else {\n            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n          }\n        }\n      }\n\n      cacheEntry.cacheControl = cacheControl\n\n      if (\n        typeof segmentPrefetchHeader === 'string' &&\n        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n        cachedData.segmentData\n      ) {\n        // This is a prefetch request issued by the client Segment Cache. These\n        // should never reach the application layer (lambda). We should either\n        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n        // Set a header to indicate that PPR is enabled for this route. This\n        // lets the client distinguish between a regular cache miss and a cache\n        // miss due to PPR being disabled. In other contexts this header is used\n        // to indicate that the response contains dynamic data, but here we're\n        // only using it to indicate that the feature is enabled â€” the segment\n        // response itself contains whether the data is dynamic.\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n        // Add the cache tags header to the response if it exists and we're in\n        // minimal mode while rendering a static page.\n        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n        if (minimalMode && isSSG && tags && typeof tags === 'string') {\n          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n        }\n\n        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n        if (matchedSegment !== undefined) {\n          // Cache hit\n          return sendRenderResult({\n            req,\n            res,\n            type: 'rsc',\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: RenderResult.fromStatic(matchedSegment),\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // Cache miss. Either a cache entry for this route has not been generated\n        // (which technically should not be possible when PPR is enabled, because\n        // at a minimum there should always be a fallback entry) or there's no\n        // match for the requested segment. Respond with a 204 No Content. We\n        // don't bother to respond with 404, because these requests are only\n        // issued as part of a prefetch.\n        res.statusCode = 204\n        return sendRenderResult({\n          req,\n          res,\n          type: 'rsc',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(''),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If there's a callback for `onCacheEntry`, call it with the cache entry\n      // and the revalidate options.\n      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n      if (onCacheEntry) {\n        const finished = await onCacheEntry(\n          {\n            ...cacheEntry,\n            // TODO: remove this when upstream doesn't\n            // always expect this value to be \"PAGE\"\n            value: {\n              ...cacheEntry.value,\n              kind: 'PAGE',\n            },\n          },\n          {\n            url: getRequestMeta(req, 'initURL'),\n          }\n        )\n        if (finished) {\n          // TODO: maybe we have to end the request?\n          return null\n        }\n      }\n\n      // If the request has a postponed state and it's a resume request we\n      // should error.\n      if (didPostpone && minimalPostponed) {\n        throw new Error(\n          'Invariant: postponed state should not be present on a resume request'\n        )\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!minimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (minimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n      if (\n        !minimalMode &&\n        cachedData.status &&\n        RedirectStatusCode[cachedData.status] &&\n        isRSCRequest\n      ) {\n        res.statusCode = 200\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isDraftMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          if (cachedData.postponed) {\n            throw new Error('Invariant: Expected postponed to be undefined')\n          }\n\n          return sendRenderResult({\n            req,\n            res,\n            type: 'rsc',\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: cachedData.html,\n            // Dynamic RSC responses cannot be cached, even if they're\n            // configured with `force-static` because we have no way of\n            // distinguishing between `force-static` and pages that have no\n            // postponed state.\n            // TODO: distinguish `force-static` from pages with no postponed state (static)\n            cacheControl: isDynamicRSCRequest\n              ? { revalidate: 0, expire: undefined }\n              : cacheEntry.cacheControl,\n          })\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return sendRenderResult({\n          req,\n          res,\n          type: 'rsc',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(cachedData.rscData),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // This is a request for HTML data.\n      let body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || minimalMode) {\n        return sendRenderResult({\n          req,\n          res,\n          type: 'html',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.chain(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return sendRenderResult({\n          req,\n          res,\n          type: 'html',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        })\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.chain(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        span,\n        postponed: cachedData.postponed,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return sendRenderResult({\n        req,\n        res,\n        type: 'html',\n        generateEtags: nextConfig.generateEtags,\n        poweredByHeader: nextConfig.poweredByHeader,\n        result: body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      })\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      return await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${req.url}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    // if we aren't wrapped by base-server handle here\n    if (!activeSpan && !(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: srcPage,\n          routeType: 'render',\n          revalidateReason: getRevalidateReason({\n            isRevalidate: isSSG,\n            isOnDemandRevalidate,\n          }),\n        },\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n    throw err\n  }\n}\n"],"names":["AppPageRouteModule","RouteKind","getRevalidateReason","getTracer","SpanKind","getRequestMeta","BaseServerSpan","interopDefault","NodeNextRequest","NodeNextResponse","checkIsAppPPREnabled","getFallbackRouteParams","setReferenceManifestsSingleton","isHtmlBotRequest","shouldServeStreamingMetadata","createServerModuleMap","normalizeAppPath","getIsPossibleServerAction","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_DID_POSTPONE_HEADER","getBotType","isBot","CachedRouteKind","FallbackMode","parseFallbackField","RenderResult","CACHE_ONE_YEAR","NEXT_CACHE_TAGS_HEADER","ENCODED_TAGS","sendRenderResult","NoFallbackError","tree","pages","GlobalError","__next_app__","require","__next_app_require__","loadChunk","__next_app_load_chunk__","entryBase","RedirectStatusCode","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","projectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","prerenderManifest","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","initialPostponed","minimalMode","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","query","params","parsedUrl","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","isDraftMode","resolvedPathname","revalidateOnlyGenerated","routerServerContext","nextConfig","normalizedSrcPage","isOnDemandRevalidate","prerenderInfo","dynamicRoutes","isPrerendered","routes","isSSG","Boolean","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","experimental","ppr","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","renderingMode","isDev","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","undefined","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","staticPathKey","ComponentMod","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","invokeRouteModule","span","context","nextReq","nextRes","NODE_ENV","dynamicIO","renderOpts","warmup","metadata","renderResumeDataCache","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","url","doRender","postponed","fallbackRouteParams","sharedContext","serverComponentsHmrCache","App","Document","pageConfig","Component","setIsrStatus","dir","isRevalidate","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","previewProps","preview","deploymentId","enableTainting","taint","devtoolSegmentExplorer","reactMaxHeadersLength","incrementalCache","cacheLifeProfiles","cacheLife","basePath","serverActions","nextExport","isStaticGeneration","expireTime","staleTimes","clientSegmentCache","dynamicOnHover","inlineCss","authInterrupts","clientTraceMetadata","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","onRequestError","err","dev","result","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","Error","description","stack","message","substring","indexOf","value","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","render404","fallbackMode","fallback","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","fallbackResponse","handleResponse","cacheKey","routeKind","isFallback","expire","PAGES","fromStatic","pageData","cacheEntry","cachedData","c","setHeader","didPostpone","isMiss","getHeader","tags","matchedSegment","type","generateEtags","poweredByHeader","onCacheEntry","finished","key","Object","entries","Array","isArray","v","appendHeader","toString","body","chain","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason"],"mappings":"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","ignoreList":[0]}