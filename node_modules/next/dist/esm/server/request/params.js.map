{"version":3,"sources":["../../../src/server/request/params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (\n    prerenderStore &&\n    (prerenderStore.type === 'prerender' ||\n      prerenderStore.type === 'prerender-client')\n  ) {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise(prerenderStore.renderSignal, '`params`')\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      switch (prerenderStore.type) {\n        case 'prerender':\n        case 'prerender-client':\n          // We are in a dynamicIO prerender\n          return makeHangingParams(underlyingParams, prerenderStore)\n        default:\n          return makeErroringExoticParams(\n            underlyingParams,\n            fallbackParams,\n            workStore,\n            prerenderStore\n          )\n      }\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    if (process.env.__NEXT_DYNAMIC_IO) {\n      return makeDynamicallyTrackedParamsWithDevWarnings(\n        underlyingParams,\n        workStore\n      )\n    }\n\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    if (process.env.__NEXT_DYNAMIC_IO) {\n      return makeUntrackedParams(underlyingParams)\n    }\n\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(prerenderStore.renderSignal, '`params`'),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise<Params>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingParams))\n  )\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\n// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n// logging the sync access without actually defining the params on the promise.\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise<Params>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingParams))\n  )\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","trackSynchronousRequestDataAccessInDev","workUnitAsyncStorage","InvariantError","describeStringPropertyAccess","wellKnownProperties","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","scheduleImmediate","dynamicAccessAsyncStorage","createParamsFromClient","underlyingParams","workStore","workUnitStore","getStore","type","createPrerenderParams","createRenderParams","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","createPrerenderParamsForClientSegment","prerenderStore","fallbackParams","fallbackRouteParams","key","has","renderSignal","Promise","resolve","hasSomeFallbackParams","makeHangingParams","makeErroringExoticParams","makeUntrackedExoticParams","process","env","NODE_ENV","isPrefetchRequest","__NEXT_DYNAMIC_IO","makeDynamicallyTrackedParamsWithDevWarnings","makeDynamicallyTrackedExoticParamsWithDevWarnings","makeUntrackedParams","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","args","store","abortController","abort","Error","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","Object","keys","forEach","defineProperty","expression","route","dynamicTracking","enumerable","newValue","value","writable","configurable","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","syncIODev","delete","ownKeys","Reflect","warnForSyncAccess","warnForIncompleteEnumeration","missingProperties","prerenderPhase","requestStore","length","createParamsAccessError","createIncompleteEnumerationError","prefix","describeListOfPropertyNames","properties","description","i"],"mappings":"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","ignoreList":[0]}