{"version":3,"sources":["../../../../src/server/dev/browser-logs/source-map.ts"],"sourcesContent":["import type { StackFrame } from 'stacktrace-parser'\nimport { getOriginalStackFrames as getOriginalStackFramesWebpack } from '../middleware-webpack'\nimport { getOriginalStackFrames as getOriginalStackFramesTurbopack } from '../middleware-turbopack'\nimport type { Project } from '../../../build/swc/types'\nimport { dim } from '../../../lib/picocolors'\nimport { parseStack } from '../../lib/parse-stack'\nimport path from 'path'\nimport { LRUCache } from '../../lib/lru-cache'\n\ntype WebpackMappingContext = {\n  bundler: 'webpack'\n  isServer: boolean\n  isEdgeServer: boolean\n  isAppDirectory: boolean\n  clientStats: () => any\n  serverStats: () => any\n  edgeServerStats: () => any\n  rootDirectory: string\n}\n\ntype TurbopackMappingContext = {\n  bundler: 'turbopack'\n  isServer: boolean\n  isEdgeServer: boolean\n  isAppDirectory: boolean\n  project: Project\n  projectPath: string\n}\n\nexport type MappingContext = WebpackMappingContext | TurbopackMappingContext\n\n// TODO: handle server vs browser error source mapping correctly\nexport async function mapFramesUsingBundler(\n  frames: StackFrame[],\n  ctx: MappingContext\n) {\n  switch (ctx.bundler) {\n    case 'webpack': {\n      const {\n        isServer,\n        isEdgeServer,\n        isAppDirectory,\n        clientStats,\n        serverStats,\n        edgeServerStats,\n        rootDirectory,\n      } = ctx\n      const res = await getOriginalStackFramesWebpack({\n        isServer,\n        isEdgeServer,\n        isAppDirectory,\n        frames,\n        clientStats,\n        serverStats,\n        edgeServerStats,\n        rootDirectory,\n      })\n      return res\n    }\n    case 'turbopack': {\n      const { project, projectPath, isServer, isEdgeServer, isAppDirectory } =\n        ctx\n      const res = await getOriginalStackFramesTurbopack({\n        project,\n        projectPath,\n        frames,\n        isServer,\n        isEdgeServer,\n        isAppDirectory,\n      })\n\n      return res\n    }\n    default: {\n      return null!\n    }\n  }\n}\n\n// converts _next/static/chunks/... to file:///.next/static/chunks/... for parseStack\n// todo: where does next dev overlay handle this case and re-use that logic\nfunction preprocessStackTrace(stackTrace: string, distDir?: string): string {\n  return stackTrace\n    .split('\\n')\n    .map((line) => {\n      const match = line.match(/^(\\s*at\\s+.*?)\\s+\\(([^)]+)\\)$/)\n      if (match) {\n        const [, prefix, location] = match\n\n        if (location.startsWith('_next/static/') && distDir) {\n          const normalizedDistDir = distDir\n            .replace(/\\\\/g, '/')\n            .replace(/\\/$/, '')\n\n          const absolutePath =\n            normalizedDistDir + '/' + location.slice('_next/'.length)\n          const fileUrl = `file://${path.resolve(absolutePath)}`\n\n          return `${prefix} (${fileUrl})`\n        }\n      }\n\n      return line\n    })\n    .join('\\n')\n}\n\nconst cache = new LRUCache<\n  Awaited<ReturnType<typeof getSourceMappedStackFramesInternal>>\n>(25)\nasync function getSourceMappedStackFramesInternal(\n  stackTrace: string,\n  ctx: MappingContext,\n  distDir: string,\n  ignore = true\n) {\n  try {\n    const normalizedStack = preprocessStackTrace(stackTrace, distDir)\n    const frames = parseStack(normalizedStack, distDir)\n\n    if (frames.length === 0) {\n      return {\n        kind: 'stack' as const,\n        stack: stackTrace,\n      }\n    }\n\n    const mappingResults = await mapFramesUsingBundler(frames, ctx)\n\n    const processedFrames = mappingResults\n      .map((result, index) => ({\n        result,\n        originalFrame: frames[index],\n      }))\n      .map(({ result, originalFrame }) => {\n        if (result.status === 'rejected') {\n          return {\n            kind: 'rejected' as const,\n            frameText: formatStackFrame(originalFrame),\n            codeFrame: null,\n          }\n        }\n\n        const { originalStackFrame, originalCodeFrame } = result.value\n        if (originalStackFrame?.ignored && ignore) {\n          return {\n            kind: 'ignored' as const,\n          }\n        }\n\n        // should we apply this generally to dev overlay (dev overlay does not ignore chrome-extension://)\n        if (originalStackFrame?.file?.startsWith('chrome-extension://')) {\n          return {\n            kind: 'ignored' as const,\n          }\n        }\n\n        return {\n          kind: 'success' as const,\n          // invariant: if result is not rejected and not ignored, then original stack frame exists\n          // verifiable by tracing `getOriginalStackFrame`. The invariant exists because of bad types\n          frameText: formatStackFrame(originalStackFrame!),\n          codeFrame: originalCodeFrame,\n        }\n      })\n\n    const allIgnored = processedFrames.every(\n      (frame) => frame.kind === 'ignored'\n    )\n\n    // we want to handle **all** ignored vs all/some rejected differently\n    // if all are ignored we should show no frames\n    // if all are rejected, we want to fallback to showing original stack frames\n    if (allIgnored) {\n      return {\n        kind: 'all-ignored' as const,\n      }\n    }\n\n    const filteredFrames = processedFrames.filter(\n      (frame) => frame.kind !== 'ignored'\n    )\n\n    if (filteredFrames.length === 0) {\n      return {\n        kind: 'stack' as const,\n        stack: stackTrace,\n      }\n    }\n\n    const stackOutput = filteredFrames\n      .map((frame) => frame.frameText)\n      .join('\\n')\n    const firstFrameCode = filteredFrames.find(\n      (frame) => frame.codeFrame\n    )?.codeFrame\n\n    if (firstFrameCode) {\n      return {\n        kind: 'with-frame-code' as const,\n        frameCode: firstFrameCode,\n        stack: stackOutput,\n        frames: filteredFrames,\n      }\n    }\n    // i don't think this a real case, but good for exhaustion\n    return {\n      kind: 'mapped-stack' as const,\n      stack: stackOutput,\n      frames: filteredFrames,\n    }\n  } catch (error) {\n    return {\n      kind: 'stack' as const,\n      stack: stackTrace,\n    }\n  }\n}\n\n// todo: cache the actual async call, not the wrapper with post processing\nexport async function getSourceMappedStackFrames(\n  stackTrace: string,\n  ctx: MappingContext,\n  distDir: string,\n  ignore = true\n) {\n  const cacheKey = `sm_${stackTrace}-${ctx.bundler}-${ctx.isAppDirectory}-${ctx.isEdgeServer}-${ctx.isServer}-${distDir}-${ignore}`\n\n  const cacheItem = cache.get(cacheKey)\n  if (cacheItem) {\n    return cacheItem\n  }\n\n  const result = await getSourceMappedStackFramesInternal(\n    stackTrace,\n    ctx,\n    distDir,\n    ignore\n  )\n  cache.set(cacheKey, result)\n  return result\n}\n\nfunction formatStackFrame(frame: StackFrame): string {\n  const functionName = frame.methodName || '<anonymous>'\n  const location =\n    frame.file && frame.lineNumber\n      ? `${frame.file}:${frame.lineNumber}${frame.column ? `:${frame.column}` : ''}`\n      : frame.file || '<unknown>'\n\n  return `    at ${functionName} (${location})`\n}\n\n// appends the source mapped location of the console method\nexport const withLocation = async (\n  {\n    original,\n    stack,\n  }: {\n    original: Array<any>\n    stack: string | null\n  },\n  ctx: MappingContext,\n  distDir: string,\n  config: boolean | { logDepth?: number; showSourceLocation?: boolean }\n) => {\n  if (typeof config === 'object' && config.showSourceLocation === false) {\n    return original\n  }\n  if (!stack) {\n    return original\n  }\n\n  const res = await getSourceMappedStackFrames(stack, ctx, distDir)\n  const location = getConsoleLocation(res)\n\n  if (!location) {\n    return original\n  }\n\n  return [...original, dim(`(${location})`)]\n}\n\nexport const getConsoleLocation = (\n  mapped: Awaited<ReturnType<typeof getSourceMappedStackFrames>>\n) => {\n  if (mapped.kind !== 'mapped-stack' && mapped.kind !== 'with-frame-code') {\n    return null\n  }\n\n  const first = mapped.frames.at(0)\n\n  if (!first) {\n    return null\n  }\n\n  // we don't want to show the name of parent function (at <fn> thing in stack), just source location for minimal noise\n  const match = first.frameText.match(/\\(([^)]+)\\)/)\n  const locationText = match ? match[1] : first.frameText\n  return locationText\n}\n"],"names":["getConsoleLocation","getSourceMappedStackFrames","mapFramesUsingBundler","withLocation","frames","ctx","bundler","isServer","isEdgeServer","isAppDirectory","clientStats","serverStats","edgeServerStats","rootDirectory","res","getOriginalStackFramesWebpack","project","projectPath","getOriginalStackFramesTurbopack","preprocessStackTrace","stackTrace","distDir","split","map","line","match","prefix","location","startsWith","normalizedDistDir","replace","absolutePath","slice","length","fileUrl","path","resolve","join","cache","LRUCache","getSourceMappedStackFramesInternal","ignore","filteredFrames","normalizedStack","parseStack","kind","stack","mappingResults","processedFrames","result","index","originalFrame","originalStackFrame","status","frameText","formatStackFrame","codeFrame","originalCodeFrame","value","ignored","file","allIgnored","every","frame","filter","stackOutput","firstFrameCode","find","frameCode","error","cacheKey","cacheItem","get","set","functionName","methodName","lineNumber","column","original","config","showSourceLocation","dim","mapped","first","at","locationText"],"mappings":"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","ignoreList":[0]}