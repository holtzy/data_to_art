{"version":3,"sources":["../../../../src/server/typescript/rules/metadata.ts"],"sourcesContent":["import { NEXT_TS_ERRORS } from '../constant'\nimport { getSource, getTs, getTypeChecker } from '../utils'\n\nimport type tsModule from 'typescript/lib/tsserverlibrary'\n\nconst metadata = {\n  client: {\n    getSemanticDiagnosticsForExportVariableStatement(\n      fileName: string,\n      node: tsModule.VariableStatement | tsModule.FunctionDeclaration\n    ): tsModule.Diagnostic[] {\n      const source = getSource(fileName)\n      const ts = getTs()\n\n      // It is not allowed to export `metadata` or `generateMetadata` in client entry\n      if (ts.isFunctionDeclaration(node)) {\n        if (node.name?.getText() === 'generateMetadata') {\n          return [\n            {\n              file: source,\n              category: ts.DiagnosticCategory.Error,\n              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n              messageText: `The Next.js 'generateMetadata' API is not allowed in a Client Component.`,\n              start: node.name.getStart(),\n              length: node.name.getWidth(),\n            },\n          ]\n        }\n      } else {\n        for (const declaration of node.declarationList.declarations) {\n          const name = declaration.name.getText()\n          if (name === 'metadata') {\n            return [\n              {\n                file: source,\n                category: ts.DiagnosticCategory.Error,\n                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                messageText: `The Next.js 'metadata' API is not allowed in a Client Component.`,\n                start: declaration.name.getStart(),\n                length: declaration.name.getWidth(),\n              },\n            ]\n          }\n        }\n      }\n      return []\n    },\n    getSemanticDiagnosticsForExportDeclaration(\n      fileName: string,\n      node: tsModule.ExportDeclaration\n    ): tsModule.Diagnostic[] {\n      const ts = getTs()\n      const source = getSource(fileName)\n      const diagnostics: tsModule.Diagnostic[] = []\n\n      const exportClause = node.exportClause\n      if (exportClause && ts.isNamedExports(exportClause)) {\n        for (const e of exportClause.elements) {\n          if (['generateMetadata', 'metadata'].includes(e.name.getText())) {\n            diagnostics.push({\n              file: source,\n              category: ts.DiagnosticCategory.Error,\n              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n              messageText: `The Next.js '${e.name.getText()}' API is not allowed in a Client Component.`,\n              start: e.name.getStart(),\n              length: e.name.getWidth(),\n            })\n          }\n        }\n      }\n\n      return diagnostics\n    },\n  },\n  server: {\n    getSemanticDiagnosticsForExportVariableStatement(\n      fileName: string,\n      node: tsModule.VariableStatement | tsModule.FunctionDeclaration\n    ): tsModule.Diagnostic[] {\n      const source = getSource(fileName)\n      const ts = getTs()\n\n      if (ts.isFunctionDeclaration(node)) {\n        if (node.name?.getText() === 'generateMetadata') {\n          if (hasType(node)) {\n            return []\n          }\n\n          const isAsync = node.modifiers?.some(\n            (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n          )\n\n          return [\n            {\n              file: source,\n              category: ts.DiagnosticCategory.Warning,\n              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n              messageText: `The Next.js \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n              start: node.name.getStart(),\n              length: node.name.getWidth(),\n            },\n          ]\n        }\n      } else {\n        for (const declaration of node.declarationList.declarations) {\n          if (hasType(declaration)) {\n            return []\n          }\n\n          const name = declaration.name.getText()\n          if (name === 'metadata') {\n            return [\n              {\n                file: source,\n                category: ts.DiagnosticCategory.Warning,\n                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                messageText: `The Next.js \"metadata\" export should be type of \"Metadata\" from \"next\".`,\n                start: declaration.name.getStart(),\n                length: declaration.name.getWidth(),\n              },\n            ]\n          }\n          if (name === 'generateMetadata') {\n            // Check if it's a function expression or arrow function\n            if (\n              declaration.initializer &&\n              (ts.isFunctionExpression(declaration.initializer) ||\n                ts.isArrowFunction(declaration.initializer))\n            ) {\n              const isAsync = declaration.initializer.modifiers?.some(\n                (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n              )\n              return [\n                {\n                  file: source,\n                  category: ts.DiagnosticCategory.Warning,\n                  code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                  messageText: `The Next.js \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n                  start: declaration.name.getStart(),\n                  length: declaration.name.getWidth(),\n                },\n              ]\n            }\n          }\n        }\n      }\n      return []\n    },\n    getSemanticDiagnosticsForExportDeclaration(\n      fileName: string,\n      node: tsModule.ExportDeclaration\n    ) {\n      const typeChecker = getTypeChecker()\n      if (!typeChecker) {\n        return []\n      }\n\n      const ts = getTs()\n      const source = getSource(fileName)\n      const diagnostics: tsModule.Diagnostic[] = []\n\n      const exportClause = node.exportClause\n      if (!node.isTypeOnly && exportClause && ts.isNamedExports(exportClause)) {\n        for (const e of exportClause.elements) {\n          if (e.isTypeOnly) {\n            continue\n          }\n          const exportName = e.name.getText()\n          if (exportName !== 'metadata' && exportName !== 'generateMetadata') {\n            continue\n          }\n\n          const symbol = typeChecker.getSymbolAtLocation(e.name)\n          if (!symbol) {\n            continue\n          }\n\n          const originalSymbol = typeChecker.getAliasedSymbol(symbol)\n          const declarations = originalSymbol.getDeclarations()\n          if (!declarations) {\n            continue\n          }\n\n          const declaration = declarations[0]\n          if (hasType(declaration)) {\n            continue\n          }\n\n          if (exportName === 'generateMetadata') {\n            let isAsync = false\n\n            // async function() {}\n            if (ts.isFunctionDeclaration(declaration)) {\n              isAsync =\n                declaration.modifiers?.some(\n                  (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n                ) ?? false\n            }\n\n            // foo = async function() {}\n            // foo = async () => {}\n            if (\n              ts.isVariableDeclaration(declaration) &&\n              declaration.initializer\n            ) {\n              const initializer = declaration.initializer\n              const isFunction =\n                ts.isArrowFunction(initializer) ||\n                ts.isFunctionExpression(initializer)\n\n              if (isFunction) {\n                isAsync =\n                  initializer.modifiers?.some(\n                    (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n                  ) ?? false\n              }\n            }\n\n            diagnostics.push({\n              file: source,\n              category: ts.DiagnosticCategory.Warning,\n              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n              messageText: `The Next.js \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n              start: e.name.getStart(),\n              length: e.name.getWidth(),\n            })\n          } else {\n            diagnostics.push({\n              file: source,\n              category: ts.DiagnosticCategory.Warning,\n              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n              messageText: `The Next.js \"metadata\" export should be type of \"Metadata\" from \"next\".`,\n              start: e.name.getStart(),\n              length: e.name.getWidth(),\n            })\n          }\n        }\n      }\n      return diagnostics\n    },\n  },\n}\n\nfunction hasType(node: tsModule.Declaration): boolean {\n  const ts = getTs()\n\n  if (\n    !ts.isVariableDeclaration(node) &&\n    !ts.isFunctionDeclaration(node) &&\n    !ts.isArrowFunction(node) &&\n    !ts.isFunctionExpression(node)\n  ) {\n    return false\n  }\n\n  // For function declarations, expressions, and arrow functions, check if they have return type\n  if (\n    ts.isFunctionDeclaration(node) ||\n    ts.isFunctionExpression(node) ||\n    ts.isArrowFunction(node)\n  ) {\n    return !!node.type\n  }\n\n  // For variable declarations\n  if (!node.name) return false\n  const name = node.name.getText()\n  if (name === 'generateMetadata') {\n    // If it's a function expression or arrow function, check if it has return type\n    if (\n      node.initializer &&\n      (ts.isFunctionExpression(node.initializer) ||\n        ts.isArrowFunction(node.initializer))\n    ) {\n      return !!node.initializer.type\n    }\n  }\n\n  // For all other cases, check if the node has a type annotation\n  return !!node.type\n}\n\nexport default metadata\n"],"names":["metadata","client","getSemanticDiagnosticsForExportVariableStatement","fileName","node","source","getSource","ts","getTs","isFunctionDeclaration","name","getText","file","category","DiagnosticCategory","Error","code","NEXT_TS_ERRORS","INVALID_METADATA_EXPORT","messageText","start","getStart","length","getWidth","declaration","declarationList","declarations","getSemanticDiagnosticsForExportDeclaration","diagnostics","exportClause","isNamedExports","e","elements","includes","push","server","hasType","isAsync","modifiers","some","m","kind","SyntaxKind","AsyncKeyword","Warning","initializer","isFunctionExpression","isArrowFunction","typeChecker","getTypeChecker","isTypeOnly","exportName","symbol","getSymbolAtLocation","originalSymbol","getAliasedSymbol","getDeclarations","isVariableDeclaration","isFunction","type"],"mappings":"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","ignoreList":[0]}