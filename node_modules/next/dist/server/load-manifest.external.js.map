{"version":3,"sources":["../../src/server/load-manifest.external.ts"],"sourcesContent":["import type { DeepReadonly } from '../shared/lib/deep-readonly'\n\nimport { join } from 'path'\nimport { readFileSync } from 'fs'\nimport { runInNewContext } from 'vm'\nimport { deepFreeze } from '../shared/lib/deep-freeze'\n\nconst sharedCache = new Map<string, unknown>()\n\n/**\n * Load a manifest file from the file system. Optionally cache the manifest in\n * memory to avoid reading the file multiple times using the provided cache or\n * defaulting to a shared module cache. The manifest is frozen to prevent\n * modifications if it is cached.\n *\n * @param path the path to the manifest file\n * @param shouldCache whether to cache the manifest in memory\n * @param cache the cache to use for storing the manifest\n * @returns the manifest object\n */\nexport function loadManifest<T extends object>(\n  path: string,\n  shouldCache: false\n): T\nexport function loadManifest<T extends object>(\n  path: string,\n  shouldCache?: boolean,\n  cache?: Map<string, unknown>,\n  skipParse?: boolean\n): DeepReadonly<T>\nexport function loadManifest<T extends object>(\n  path: string,\n  shouldCache?: true,\n  cache?: Map<string, unknown>,\n  skipParse?: boolean\n): DeepReadonly<T>\nexport function loadManifest<T extends object>(\n  path: string,\n  shouldCache: boolean = true,\n  cache = sharedCache,\n  skipParse = false\n): T {\n  const cached = shouldCache && cache.get(path)\n  if (cached) {\n    return cached as T\n  }\n\n  let manifest: any = readFileSync(/* turbopackIgnore: true */ path, 'utf8')\n\n  if (!skipParse) {\n    manifest = JSON.parse(manifest)\n\n    // Freeze the manifest so it cannot be modified if we're caching it.\n    if (shouldCache) {\n      manifest = deepFreeze(manifest)\n    }\n  }\n\n  if (shouldCache) {\n    cache.set(path, manifest)\n  }\n\n  return manifest\n}\n\nexport function evalManifest<T extends object>(\n  path: string,\n  shouldCache: false\n): T\nexport function evalManifest<T extends object>(\n  path: string,\n  shouldCache?: boolean,\n  cache?: Map<string, unknown>\n): DeepReadonly<T>\nexport function evalManifest<T extends object>(\n  path: string,\n  shouldCache?: true,\n  cache?: Map<string, unknown>\n): DeepReadonly<T>\nexport function evalManifest<T extends object>(\n  path: string,\n  shouldCache: boolean = true,\n  cache = sharedCache\n): T {\n  const cached = shouldCache && cache.get(path)\n  if (cached) {\n    return cached as T\n  }\n\n  const content = readFileSync(/* turbopackIgnore: true */ path, 'utf8')\n  if (content.length === 0) {\n    throw new Error('Manifest file is empty')\n  }\n\n  let contextObject = {}\n  runInNewContext(content, contextObject)\n\n  // Freeze the context object so it cannot be modified if we're caching it.\n  if (shouldCache) {\n    contextObject = deepFreeze(contextObject)\n  }\n\n  if (shouldCache) {\n    cache.set(path, contextObject)\n  }\n\n  return contextObject as T\n}\n\nexport function loadManifestFromRelativePath<T extends object>({\n  projectDir,\n  distDir,\n  manifest,\n  shouldCache,\n  cache,\n  skipParse,\n  handleMissing,\n  useEval,\n}: {\n  projectDir: string\n  distDir: string\n  manifest: string\n  shouldCache?: boolean\n  cache?: Map<string, unknown>\n  skipParse?: boolean\n  handleMissing?: boolean\n  useEval?: boolean\n}): DeepReadonly<T> {\n  try {\n    const manifestPath = join(\n      /* turbopackIgnore: true */ projectDir,\n      distDir,\n      manifest\n    )\n\n    if (useEval) {\n      return evalManifest<T>(manifestPath, shouldCache, cache)\n    }\n    return loadManifest<T>(manifestPath, shouldCache, cache, skipParse)\n  } catch (err) {\n    if (handleMissing) {\n      // TODO: should this be undefined\n      return {} as DeepReadonly<T>\n    }\n    throw err\n  }\n}\n\nexport function clearManifestCache(path: string, cache = sharedCache): boolean {\n  return cache.delete(path)\n}\n"],"names":["clearManifestCache","evalManifest","loadManifest","loadManifestFromRelativePath","sharedCache","Map","path","shouldCache","cache","skipParse","cached","get","manifest","readFileSync","JSON","parse","deepFreeze","set","content","length","Error","contextObject","runInNewContext","projectDir","distDir","handleMissing","useEval","manifestPath","join","err","delete"],"mappings":";;;;;;;;;;;;;;;;;IAoJgBA,kBAAkB;eAAlBA;;IArEAC,YAAY;eAAZA;;IA3CAC,YAAY;eAAZA;;IAyEAC,4BAA4B;eAA5BA;;;sBA3GK;oBACQ;oBACG;4BACL;AAE3B,MAAMC,cAAc,IAAIC;AA6BjB,SAASH,aACdI,IAAY,EACZC,cAAuB,IAAI,EAC3BC,QAAQJ,WAAW,EACnBK,YAAY,KAAK;IAEjB,MAAMC,SAASH,eAAeC,MAAMG,GAAG,CAACL;IACxC,IAAII,QAAQ;QACV,OAAOA;IACT;IAEA,IAAIE,WAAgBC,IAAAA,gBAAY,EAAC,yBAAyB,GAAGP,MAAM;IAEnE,IAAI,CAACG,WAAW;QACdG,WAAWE,KAAKC,KAAK,CAACH;QAEtB,oEAAoE;QACpE,IAAIL,aAAa;YACfK,WAAWI,IAAAA,sBAAU,EAACJ;QACxB;IACF;IAEA,IAAIL,aAAa;QACfC,MAAMS,GAAG,CAACX,MAAMM;IAClB;IAEA,OAAOA;AACT;AAgBO,SAASX,aACdK,IAAY,EACZC,cAAuB,IAAI,EAC3BC,QAAQJ,WAAW;IAEnB,MAAMM,SAASH,eAAeC,MAAMG,GAAG,CAACL;IACxC,IAAII,QAAQ;QACV,OAAOA;IACT;IAEA,MAAMQ,UAAUL,IAAAA,gBAAY,EAAC,yBAAyB,GAAGP,MAAM;IAC/D,IAAIY,QAAQC,MAAM,KAAK,GAAG;QACxB,MAAM,qBAAmC,CAAnC,IAAIC,MAAM,2BAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAkC;IAC1C;IAEA,IAAIC,gBAAgB,CAAC;IACrBC,IAAAA,mBAAe,EAACJ,SAASG;IAEzB,0EAA0E;IAC1E,IAAId,aAAa;QACfc,gBAAgBL,IAAAA,sBAAU,EAACK;IAC7B;IAEA,IAAId,aAAa;QACfC,MAAMS,GAAG,CAACX,MAAMe;IAClB;IAEA,OAAOA;AACT;AAEO,SAASlB,6BAA+C,EAC7DoB,UAAU,EACVC,OAAO,EACPZ,QAAQ,EACRL,WAAW,EACXC,KAAK,EACLC,SAAS,EACTgB,aAAa,EACbC,OAAO,EAUR;IACC,IAAI;QACF,MAAMC,eAAeC,IAAAA,UAAI,EACvB,yBAAyB,GAAGL,YAC5BC,SACAZ;QAGF,IAAIc,SAAS;YACX,OAAOzB,aAAgB0B,cAAcpB,aAAaC;QACpD;QACA,OAAON,aAAgByB,cAAcpB,aAAaC,OAAOC;IAC3D,EAAE,OAAOoB,KAAK;QACZ,IAAIJ,eAAe;YACjB,iCAAiC;YACjC,OAAO,CAAC;QACV;QACA,MAAMI;IACR;AACF;AAEO,SAAS7B,mBAAmBM,IAAY,EAAEE,QAAQJ,WAAW;IAClE,OAAOI,MAAMsB,MAAM,CAACxB;AACtB","ignoreList":[0]}